# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/performance/using_multimesh.rst:6
msgid "Optimization using MultiMeshes"
msgstr ""

#: ../../docs/tutorials/performance/using_multimesh.rst:8
msgid "For large amount of instances (in the thousands), that need to be constantly processed (and certain amount of control needs to be retained), :ref:`using servers directly <doc_using_servers>` is the recommended optimization."
msgstr ""

#: ../../docs/tutorials/performance/using_multimesh.rst:12
msgid "When the amount of objects reach the hundreds of thousands or millions, none of these approaches are efficient anymore. Still, depending on the requirements, there is one more optimization possible."
msgstr ""

#: ../../docs/tutorials/performance/using_multimesh.rst:17
msgid "MultiMeshes"
msgstr ""

#: ../../docs/tutorials/performance/using_multimesh.rst:19
msgid "A :ref:`MultiMesh<class_MultiMesh>` is a single draw primitive that can draw up to millions of objects in one go. It's extremely efficient because it uses the GPU hardware to do this (in OpenGL ES 2.0, it's less efficient because there is no hardware support for it, though)."
msgstr ""

#: ../../docs/tutorials/performance/using_multimesh.rst:23
msgid "The only drawback is that there is no *screen* or *frustum* culling possible for individual instances. This means, that millions of objects will be *always* or *never* drawn, depending on the visibility of the whole MultiMesh. It is possible to provide a custom visibility rect for them, but it will always be *all-or-none* visibility."
msgstr ""

#: ../../docs/tutorials/performance/using_multimesh.rst:28
msgid "If the objects are simple enough (just a couple of vertices), this is generally not much of a problem as most modern GPUs are optimized for this use case. A workaround is to create several MultiMeshes for different areas of the world."
msgstr ""

#: ../../docs/tutorials/performance/using_multimesh.rst:32
msgid "It is also possible to execute some logic inside the vertex shader (using the ``INSTANCE_ID`` or ``INSTANCE_CUSTOM`` built-in constants). For an example of animating thousands of objects in a MultiMesh, see the :ref:`Animating thousands of fish <doc_animating_thousands_of_fish>` tutorial. Information to the shader can be provided via textures (there are floating-point :ref:`Image<class_Image>` formats which are ideal for this)."
msgstr ""

#: ../../docs/tutorials/performance/using_multimesh.rst:38
msgid "Another alternative is to use a GDExtension and C++, which should be extremely efficient (it's possible to set the entire state for all objects using linear memory via the :ref:`RenderingServer.multimesh_set_buffer() <class_RenderingServer_method_multimesh_set_buffer>` function). This way, the array can be created with multiple threads, then set in one call, providing high cache efficiency."
msgstr ""

#: ../../docs/tutorials/performance/using_multimesh.rst:44
msgid "Finally, it's not required to have all MultiMesh instances visible. The amount of visible ones can be controlled with the :ref:`MultiMesh.visible_instance_count <class_MultiMesh_property_visible_instance_count>` property. The typical workflow is to allocate the maximum amount of instances that will be used, then change the amount visible depending on how many are currently needed."
msgstr ""

#: ../../docs/tutorials/performance/using_multimesh.rst:50
msgid "Multimesh example"
msgstr ""

#: ../../docs/tutorials/performance/using_multimesh.rst:52
msgid "Here is an example of using a MultiMesh from code. Languages other than GDScript may be more efficient for millions of objects, but for a few thousands, GDScript should be fine."
msgstr ""

#: ../../docs/<rst_epilog>:0
msgid "Translation status"
msgstr ""
