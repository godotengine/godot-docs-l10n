# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-06-22 14:46+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:4
msgid "Screen-reading shaders"
msgstr "Shaders de lecture d'écran"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:7
msgid "Introduction"
msgstr "Introduction"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:9
msgid ""
"Very often, it is desired to make a shader that reads from the same screen "
"to which it's writing. 3D APIs, such as OpenGL or DirectX, make this very "
"difficult because of internal hardware limitations. GPUs are extremely "
"parallel, so reading and writing causes all sorts of cache and coherency "
"problems. As a result, not even the most modern hardware supports this "
"properly."
msgstr ""
"Très souvent, on souhaite faire un shader qui lit à partir du même écran que "
"celui sur lequel il écrit. Les API 3D, telles que OpenGL ou DirectX, rendent "
"la tâche très difficile en raison de limitations matérielles internes. Les "
"GPU sont extrêmement parallèles, de sorte que la lecture et l'écriture "
"causent toutes sortes de problèmes de cache et de cohérence. Par conséquent, "
"même le matériel le plus moderne ne le supporte pas correctement."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:16
msgid ""
"The workaround is to make a copy of the screen, or a part of the screen, to "
"a back-buffer and then read from it while drawing. Godot provides a few "
"tools that make this process easy!"
msgstr ""
"La solution consiste à faire une copie de l'écran, ou d'une partie de "
"l'écran, dans une mémoire tampon, puis à la lire pendant le dessin. Godot "
"fournit quelques outils qui rendent ce processus facile !"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:21
msgid "SCREEN_TEXTURE built-in texture"
msgstr "SCREEN_TEXTURE texture intégrée"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:23
#, fuzzy
msgid ""
"Godot :ref:`doc_shading_language` has a special texture, ``SCREEN_TEXTURE`` "
"(and ``DEPTH_TEXTURE`` for depth, in the case of 3D). It takes as argument "
"the UV of the screen and returns a vec3 RGB with the color. A special built-"
"in varying: SCREEN_UV can be used to obtain the UV for the current fragment. "
"As a result, this simple canvas_item fragment shader:"
msgstr ""
"Godot :ref:`doc_shading_language` a une texture spéciale, \"SCREEN_TEXTURE"
"\" (et \"DEPTH_TEXTURE\" pour la profondeur, dans le cas de la 3D). Il prend "
"comme argument l'UV de l'écran et renvoie un vec3 RGB avec la couleur. Une "
"varying spéciale intégrée : SCREEN_UV peut être utilisé pour obtenir l'UV du "
"fragment actuel. Le résultat est ce simple shader de fragments en 2D :"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:34
msgid "results in an invisible object, because it just shows what lies behind."
msgstr ""
"résulte en un objet invisible, car il ne fait que montrer ce qui se cache "
"derrière."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:36
msgid ""
"The reason why textureLod must be used is because, when Godot copies back a "
"chunk of the screen, it also does an efficient separatable gaussian blur to "
"its mipmaps."
msgstr ""
"La raison pour laquelle textureLod doit être utilisé est que, lorsque Godot "
"copie une partie de l'écran, il effectue également un flou gaussien "
"séparable efficace sur ses mipmaps."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:39
msgid ""
"This allows for not only reading from the screen, but reading from it with "
"different amounts of blur at no cost."
msgstr ""
"Cela permet non seulement de lire depuis l'écran, mais aussi de lire depuis "
"celui-ci avec différentes quantités de flou sans frais."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:44
msgid ""
"Mipmaps are not generated in GLES2 due to poor performance and compatibility "
"with older devices."
msgstr ""

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:48
msgid "SCREEN_TEXTURE example"
msgstr "Exemple SCREEN_TEXTURE"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:50
#, fuzzy
msgid ""
"``SCREEN_TEXTURE`` can be used for many things. There is a special demo for "
"*Screen Space Shaders*, that you can download to see and learn. One example "
"is a simple shader to adjust brightness, contrast and saturation:"
msgstr ""
"SCREEN_TEXTURE peut être utilisé pour beaucoup de choses. Il existe une démo "
"spéciale pour *Screen Space Shaders*, que vous pouvez télécharger pour voir "
"et apprendre. Un exemple est un simple shader pour ajuster la luminosité, le "
"contraste et la saturation :"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:74
msgid "Behind the scenes"
msgstr "Dans les coulisses"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:76
#, fuzzy
msgid ""
"While this seems magical, it's not. In 2D, the ``SCREEN_TEXTURE`` built-in, "
"when first found in a node that is about to be drawn, does a full-screen "
"copy to a back-buffer. Subsequent nodes that use it in shaders will not have "
"the screen copied for them, because this ends up being inefficient. In 3D, "
"the screen is copied after the opaque geometry pass, but before the "
"transparent geometry pass, so transparent objects will not be captured in "
"the ``SCREEN_TEXTURE``."
msgstr ""
"Bien que cela semble magique, ce n'est pas le cas. La fonction "
"SCREEN_TEXTURE intégrée, lorsqu'elle est trouvée pour la première fois dans "
"un nœud sur le point d'être dessiné, effectue une copie plein écran vers une "
"mémoire tampon. Les nœuds ultérieurs qui l'utilisent dans les shaders "
"n'auront pas l'écran copié pour eux, car cela finit par être inefficace."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:84
#, fuzzy
msgid ""
"As a result, in 2D, if shaders that use ``SCREEN_TEXTURE`` overlap, the "
"second one will not use the result of the first one, resulting in unexpected "
"visuals:"
msgstr ""
"Par conséquent, si les shaders qui utilisent SCREEN_TEXTURE se chevauchent, "
"le second n'utilisera pas le résultat du premier, ce qui entraînera des "
"visuels inattendus :"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:90
#, fuzzy
msgid ""
"In the above image, the second sphere (top right) is using the same source "
"for ``SCREEN_TEXTURE`` as the first one below, so the first one \"disappears"
"\", or is not visible."
msgstr ""
"Dans l'image ci-dessus, la deuxième sphère (en haut à droite) utilise la "
"même source pour SCREEN_TEXTURE que la première en dessous, donc la première "
"\"disparaît\", ou n'est pas visible."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:94
msgid ""
"In 2D, this can be corrected via the :ref:`BackBufferCopy "
"<class_BackBufferCopy>` node, which can be instantiated between both "
"spheres. BackBufferCopy can work by either specifying a screen region or the "
"whole screen:"
msgstr ""
"En 2D, cela peut être corrigé via le nœud :ref:`BackBufferCopy "
"<class_BackBufferCopy>`, qui peut être instancié entre les deux sphères. "
"BackBufferCopy peut fonctionner en spécifiant soit une région de l'écran, "
"soit l'écran entier :"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:100
msgid "With correct back-buffer copying, the two spheres blend correctly:"
msgstr ""
"Avec une copie correcte du back-buffer, les deux sphères se mélangent "
"correctement :"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:104
msgid ""
"In 3D, there is less flexibility to solve this particular issue because the "
"``SCREEN_TEXTURE`` is only captured once. Be careful when using "
"``SCREEN_TEXTURE`` in 3D as it won't capture transparent objects and may "
"capture some opaque objects that are in front of the object."
msgstr ""

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:109
msgid ""
"You can reproduce the back-buffer logic in 3D by creating a :ref:`Viewport "
"<class_Viewport>` with a camera in the same position as your object, and "
"then use the :ref:`Viewport's <class_Viewport>` texture instead of "
"``SCREEN_TEXTURE``."
msgstr ""

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:114
msgid "Back-buffer logic"
msgstr "Logique du back-buffer"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:116
msgid ""
"So, to make it clearer, here's how the backbuffer copying logic works in "
"Godot:"
msgstr ""
"Donc, pour être plus clair, voici comment fonctionne la logique de copie du "
"backbuffer dans Godot :"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:119
#, fuzzy
msgid ""
"If a node uses the ``SCREEN_TEXTURE``, the entire screen is copied to the "
"back buffer before drawing that node. This only happens the first time; "
"subsequent nodes do not trigger this."
msgstr ""
"Si un nœud utilise la SCREEN_TEXTURE, l'écran entier est copié dans le back "
"buffer avant de dessiner ce nœud. Cela ne se produit que la première fois ; "
"les nœuds suivants ne déclenchent pas cette situation."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:122
#, fuzzy
msgid ""
"If a BackBufferCopy node was processed before the situation in the point "
"above (even if ``SCREEN_TEXTURE`` was not used), the behavior described in "
"the point above does not happen. In other words, automatic copying of the "
"entire screen only happens if ``SCREEN_TEXTURE`` is used in a node for the "
"first time and no BackBufferCopy node (not disabled) was found before in "
"tree-order."
msgstr ""
"Si un nœud BackBufferCopy a été traité avant la situation décrite au point "
"ci-dessus (même si SCREEN_TEXTURE n'a pas été utilisé), le comportement "
"décrit au point ci-dessus ne se produit pas. En d'autres termes, la copie "
"automatique de l'écran entier ne se produit que si SCREEN_TEXTURE est "
"utilisé dans un nœud pour la première fois et qu'aucun nœud BackBufferCopy "
"(non désactivé) n'a été trouvé auparavant dans l'ordre de l'arbre."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:128
#, fuzzy
msgid ""
"BackBufferCopy can copy either the entire screen or a region. If set to only "
"a region (not the whole screen) and your shader uses pixels not in the "
"region copied, the result of that read is undefined (most likely garbage "
"from previous frames). In other words, it's possible to use BackBufferCopy "
"to copy back a region of the screen and then use ``SCREEN_TEXTURE`` on a "
"different region. Avoid this behavior!"
msgstr ""
"BackBufferCopy peut copier soit l'écran entier, soit une région. S'il est "
"réglé sur une seule région (et non sur l'ensemble de l'écran) et que votre "
"shader utilise des pixels qui ne se trouvent pas dans la région copiée, le "
"résultat de cette lecture est indéfini (très probablement les déchets des "
"images précédentes). En d'autres termes, il est possible d'utiliser "
"BackBufferCopy pour recopier une région de l'écran et d'utiliser ensuite "
"SCREEN_TEXTURE sur une autre région. Évitez ce comportement !"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:137
msgid "DEPTH_TEXTURE"
msgstr "DEPTH_TEXTURE"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:139
#, fuzzy
msgid ""
"For 3D Shaders, it's also possible to access the screen depth buffer. For "
"this, the ``DEPTH_TEXTURE`` built-in is used. This texture is not linear; it "
"must be converted via the inverse projection matrix."
msgstr ""
"Pour les shaders 3D, il est également possible d'accéder au buffer de "
"profondeur de l'écran. Pour cela, on utilise la DEPTH_TEXTURE intégrée. "
"Cette texture n'est pas linéaire, elle doit être convertie via la matrice de "
"projection inverse."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:143
msgid ""
"The following code retrieves the 3D position below the pixel being drawn:"
msgstr "Le code suivant récupère la position 3D sous le pixel dessiné :"
