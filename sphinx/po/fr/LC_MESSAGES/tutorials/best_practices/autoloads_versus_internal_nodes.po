# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Autoloads versus regular nodes"
msgstr "Chargements automatiques contre nœuds normaux"

msgid ""
"Godot offers a feature to automatically load nodes at the root of your "
"project, allowing you to access them globally, that can fulfill the role of "
"a Singleton: :ref:`doc_singletons_autoload`. These auto-loaded nodes are not "
"freed when you change the scene from code with :ref:`SceneTree.change_scene "
"<class_SceneTree_method_change_scene>`."
msgstr ""
"Godot offre une fonctionnalité pour charger automatiquement les nœuds à la "
"racine de votre projet, vous permettant d'y accéder globalement, ce qui peut "
"remplir le rôle d'un Singleton : :ref:`doc_singletons_autoload`. Ces nœuds "
"auto-chargés ne sont pas libérés lorsque vous changez de scène à partir du "
"code avec :ref:`SceneTree.change_scene "
"<class_SceneTree_method_change_scene>`."

msgid ""
"In this guide, you will learn when to use the Autoload feature, and "
"techniques you can use to avoid it."
msgstr ""
"Dans ce guide, vous apprendrez quand utiliser la fonction de Chargement "
"Automatique et les techniques que vous pouvez utiliser pour l'éviter."

msgid "The cutting audio issue"
msgstr "Le problème du son qui coupe"

msgid ""
"Other engines can encourage the use of creating manager classes, singletons "
"that organize a lot of functionality into a globally accessible object. "
"Godot offers many ways to avoid global state thanks to the node tree and "
"signals."
msgstr ""
"D'autres moteurs pourraient encourager l'utilisation de la création de "
"classes \"manager\" qui organisent un grand nombre de fonctionnalités en une "
"entité globalement accessible. Godot fournit de nombreux moyens d'éviter "
"d'utiliser un état global grâce à l'arbre des nœuds et aux signaux."

msgid ""
"For example, let's say we are building a platformer and want to collect "
"coins that play a sound effect. There's a node for that: the :ref:"
"`AudioStreamPlayer <class_AudioStreamPlayer>`. But if we call the "
"``AudioStreamPlayer`` while it is already playing a sound, the new sound "
"interrupts the first."
msgstr ""
"Par exemple, que se passe-t-il si un développeur construit un platformer et "
"qu'il veut collectionner des pièces qui jouent un effet sonore ? Eh bien, il "
"y a un nœud pour cela : le :ref:`AudioStreamPlayer "
"<class_AudioStreamPlayer>`. Mais si on appelle un ``AudioStreamPlayer`` "
"alors qu'il joue déjà un son, alors le nouveau son interrompt le précédent."

msgid ""
"A solution is to code a global, auto-loaded sound manager class. It "
"generates a pool of ``AudioStreamPlayer`` nodes that cycle through as each "
"new request for sound effects comes in. Say we call that class ``Sound``, "
"you can use it from anywhere in your project by calling ``Sound."
"play(\"coin_pickup.ogg\")``. This solves the problem in the short term but "
"causes more problems:"
msgstr ""
"Une solution possible est de coder une classe globale de gestionnaire de son "
"chargée automatiquement. Elle génère un pool de nœuds ``AudioStreamPlayer`` "
"qui passe d'un lecteur à l'autre à chaque nouvelle demande d'effet sonore. "
"Disons que nous appelons cette classe ``Sound``, elle peut être utilisée "
"n'importe où dans le projet en appelant ``Sound.play(\"coin_pickup.ogg\")``. "
"Cela résout le problème à court terme mais cause de nouveaux problèmes :"

msgid ""
"**Global state**: one object is now responsible for all objects' data. If "
"the ``Sound`` class has errors or doesn't have an AudioStreamPlayer "
"available, all the nodes calling it can break."
msgstr ""
"**État global** : un seul objet est maintenant responsable des données de "
"tous les objets. Si la classe ``Sound`` a des erreurs ou n'a pas "
"d'AudioStreamPlayer disponible, tous les nœuds qui l'appellent vont "
"dysfonctionner."

msgid ""
"**Global access**: now that any object can call ``Sound.play(sound_path)`` "
"from anywhere, there's no longer an easy way to find the source of a bug."
msgstr ""
"**Accès global** : maintenant que n'importe quel objet peut appeler ``Sound."
"play(sound_path)``de n'importe où, il n'y a plus de moyen facile de trouver "
"la source d'un bug."

msgid ""
"**Global resource allocation**: with a pool of ``AudioStreamPlayer`` nodes "
"stored from the start, you can either have too few and face bugs, or too "
"many and use more memory than you need."
msgstr ""
"**Allocation globale des ressources** : avec un pool de nœuds "
"``AudioStreamPlayer`` stockés dès le départ, vous pouvez en avoir trop peu "
"et rencontrer des bugs, ou en avoir trop et utiliser plus de mémoire que "
"nécessaire."

msgid ""
"About global access, the problem is that Any code anywhere could pass wrong "
"data to the ``Sound`` autoload in our example. As a result, the domain to "
"explore to fix the bug spans the entire project."
msgstr ""
"En ce qui concerne l'accès global, le problème est que n'importe quel code "
"n'importe où pourrait transmettre des données erronées à la classe chargée "
"automatiquement ``Sound`` dans notre exemple. Par conséquent, le domaine à "
"explorer pour corriger des bugs s'étend sur l'ensemble du projet."

msgid ""
"When you keep code inside a scene, only one or two scripts may be involved "
"in audio."
msgstr ""
"Lorsque vous gardez le code à l'intérieur d'une scène, un ou deux scripts "
"seulement peuvent être impliqués dans l'audio."

msgid ""
"Contrast this with each scene keeping as many ``AudioStreamPlayer`` nodes as "
"it needs within itself and all these problems go away:"
msgstr ""
"Comparez cela avec chaque scène qui garde autant de nœuds "
"``AudioStreamPlayer`` qu'il lui faut et tous ces problèmes disparaissent :"

msgid ""
"Each scene manages its own state information. If there is a problem with the "
"data, it will only cause issues in that one scene."
msgstr ""
"Chaque scène gère ses propres informations d'état. S'il y a un problème avec "
"les données, cela ne causera des problèmes que dans une seule scène."

msgid ""
"Each scene accesses only its own nodes. Now, if there is a bug, it's easy to "
"find which node is at fault."
msgstr ""
"Chaque scène accède uniquement à ses propres nœuds. Ainsi, si il y a un bug, "
"il est facile de trouver quel nœud pose problème."

msgid "Each scene allocates exactly the amount of resources it needs."
msgstr ""
"Chaque scène alloue exactement la quantité de ressources dont elle a besoin."

msgid "Managing shared functionality or data"
msgstr "Gérer des données ou des fonctionnalités partagées"

msgid ""
"Another reason to use an Autoload can be that you want to reuse the same "
"method or data across many scenes."
msgstr ""
"Une autre raison d'utiliser un Chargement Automatique peut être que vous "
"souhaitez réutiliser la même méthode ou les mêmes données à travers "
"plusieurs scènes."

msgid ""
"In the case of functions, you can create a new type of ``Node`` that "
"provides that feature for an individual scene using the :ref:`class_name "
"<doc_gdscript_basics_class_name>` keyword in GDScript."
msgstr ""
"Dans le cas des fonctions, vous pouvez créer un nouveau type de ``Node`` qui "
"fournit cette fonctionnalité pour une scène individuelle en utilisant le mot-"
"clé :ref:`class_name <doc_gdscript_basics_class_name>` dans GDScript."

msgid "When it comes to data, you can either:"
msgstr "En ce qui concerne les données, vous pouvez :"

msgid ""
"Create a new type of :ref:`Resource <class_Resource>` to share the data."
msgstr ""
"Créez un nouveau type de :ref:`Resource <class_Resource>` pour partager les "
"données."

msgid ""
"Store the data in an object to which each node has access, for example using "
"the ``owner`` property to access the scene's root node."
msgstr ""
"Stocker les données dans un objet auquel chaque nœud a accès, par exemple en "
"utilisant la propriété ``owner`` pour accéder au nœud racine de la scène."

msgid "When you should use an Autoload"
msgstr "Quand utiliser un Chargement Automatique"

msgid "Auto-loaded nodes can simplify your code in some cases:"
msgstr ""
"Les nœuds chargés automatiquement peuvent simplifier votre code dans "
"certains cas :"

msgid ""
"**Static Data**: if you need data that is exclusive to one class, like a "
"database, then an autoload can be a good tool. There is no scripting API in "
"Godot to create and manage static data otherwise."
msgstr ""
"**Données statiques** : si vous avez besoin de données exclusives à une "
"classe, comme une base de données, un chargement automatique peut être un "
"bon outil. Sinon, il n'y a pas d'API de script dans Godot pour créer et "
"gérer des données statiques."

msgid ""
"**Static functions**: creating a library of functions that only return "
"values."
msgstr ""
"**Fonctions statiques** : création d'une bibliothèque de fonctions qui ne "
"font que retourner des valeurs."

msgid ""
"**Systems with a wide scope**: If the singleton is managing its own "
"information and not invading the data of other objects, then it's a great "
"way to create systems that handle broad-scoped tasks. For example, a quest "
"or a dialogue system."
msgstr ""
"**Systèmes avec une large portée** : Si le singleton gère ses propres "
"informations et n'envahit pas avec les données d'autres objets, alors c'est "
"un excellent moyen de créer des systèmes qui gèrent des tâches à grande "
"portée. Par exemple, une quête ou un système de dialogue."

msgid ""
"Until Godot 3.1, another use was just for convenience: autoloads have a "
"global variable for their name generated in GDScript, allowing you to call "
"them from any script file in your project. But now, you can use the "
"``class_name`` keyword instead to get auto-completion for a type in your "
"entire project."
msgstr ""
"Jusqu'à Godot 3.1, une autre utilisation était juste pour plus de "
"commodité : les chargements automatiques ont une variable globale pour leur "
"nom générée dans GDScript, vous permettant de les appeler à partir de "
"n'importe quel fichier de script de votre projet. Mais maintenant, vous "
"pouvez utiliser le mot-clé ``class_name`` à la place pour obtenir l'auto-"
"complétion pour un type dans l'ensemble de votre projet."

msgid ""
"Autoload is not exactly a Singleton. Nothing prevents you from instantiating "
"copies of an auto-loaded node. It is only a tool that makes a node load "
"automatically as a child of the root of your scene tree, regardless of your "
"game's node structure or which scene you run, e.g. by pressing :kbd:`F6` key."
msgstr ""
"Un Chargement Automatique n'est pas exactement un Singleton. Rien ne vous "
"empêche d'instancier des copies d'un nœud chargé automatiquement. Il s'agit "
"seulement d'un outil permettant à un nœud de se charger automatiquement en "
"tant qu'enfant de la racine de votre arbre des scènes, indépendamment de la "
"structure des nœuds de votre jeu ou de la scène que vous exécutez, par "
"exemple en appuyant sur la touche :kbd:`F6`."

msgid ""
"As a result, you can get the auto-loaded node, for example an autoload "
"called ``Sound``, by calling ``get_node(\"/root/Sound\")``."
msgstr ""
"Par conséquent, vous pouvez obtenir le nœud chargé automatiquement, par "
"exemple un chargement automatique appelé ``Sound``, en appelant "
"``get_node(\"/root/Sound\")``."

msgid "Translation status"
msgstr "État de la traduction"
