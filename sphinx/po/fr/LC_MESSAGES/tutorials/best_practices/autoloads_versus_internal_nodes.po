# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Autoloads versus regular nodes"
msgstr "Chargements automatiques contre nœuds normaux"

#, fuzzy
msgid ""
"Godot offers a feature to automatically load nodes at the root of your "
"project, allowing you to access them globally, that can fulfill the role of "
"a Singleton: :ref:`doc_singletons_autoload`. These autoloaded nodes are not "
"freed when you change the scene from code with :ref:`SceneTree."
"change_scene_to_file <class_SceneTree_method_change_scene_to_file>`."
msgstr ""
"Godot offre une fonctionnalité pour charger automatiquement les nœuds à la "
"racine de votre projet, vous permettant d'y accéder globalement, ce qui peut "
"remplir le rôle d'un Singleton : :ref:`doc_singletons_autoload`. Ces nœuds "
"auto-chargés ne sont pas libérés lorsque vous changez de scène à partir du "
"code avec :ref:`SceneTree.change_scene "
"<class_SceneTree_method_change_scene>`."

msgid ""
"In this guide, you will learn when to use the Autoload feature, and "
"techniques you can use to avoid it."
msgstr ""
"Dans ce guide, vous apprendrez quand utiliser la fonction de Chargement "
"Automatique et les techniques que vous pouvez utiliser pour l'éviter."

msgid "The cutting audio issue"
msgstr "Le problème du son qui coupe"

msgid ""
"Other engines can encourage the use of creating manager classes, singletons "
"that organize a lot of functionality into a globally accessible object. "
"Godot offers many ways to avoid global state thanks to the node tree and "
"signals."
msgstr ""
"D'autres moteurs pourraient encourager l'utilisation de la création de "
"classes \"manager\" qui organisent un grand nombre de fonctionnalités en une "
"entité globalement accessible. Godot fournit de nombreux moyens d'éviter "
"d'utiliser un état global grâce à l'arbre des nœuds et aux signaux."

msgid ""
"For example, let's say we are building a platformer and want to collect "
"coins that play a sound effect. There's a node for that: the :ref:"
"`AudioStreamPlayer <class_AudioStreamPlayer>`. But if we call the "
"``AudioStreamPlayer`` while it is already playing a sound, the new sound "
"interrupts the first."
msgstr ""
"Par exemple, que se passe-t-il si un développeur construit un platformer et "
"qu'il veut collectionner des pièces qui jouent un effet sonore ? Eh bien, il "
"y a un nœud pour cela : le :ref:`AudioStreamPlayer "
"<class_AudioStreamPlayer>`. Mais si on appelle un ``AudioStreamPlayer`` "
"alors qu'il joue déjà un son, alors le nouveau son interrompt le précédent."

#, fuzzy
msgid ""
"A solution is to code a global, autoloaded sound manager class. It generates "
"a pool of ``AudioStreamPlayer`` nodes that cycle through as each new request "
"for sound effects comes in. Say we call that class ``Sound``, you can use it "
"from anywhere in your project by calling ``Sound.play(\"coin_pickup."
"ogg\")``. This solves the problem in the short term but causes more problems:"
msgstr ""
"Une solution possible est de coder une classe globale de gestionnaire de son "
"chargée automatiquement. Elle génère un pool de nœuds ``AudioStreamPlayer`` "
"qui passe d'un lecteur à l'autre à chaque nouvelle demande d'effet sonore. "
"Disons que nous appelons cette classe ``Sound``, elle peut être utilisée "
"n'importe où dans le projet en appelant ``Sound.play(\"coin_pickup.ogg\")``. "
"Cela résout le problème à court terme mais cause de nouveaux problèmes :"

msgid ""
"**Global state**: one object is now responsible for all objects' data. If "
"the ``Sound`` class has errors or doesn't have an AudioStreamPlayer "
"available, all the nodes calling it can break."
msgstr ""
"**État global** : un seul objet est maintenant responsable des données de "
"tous les objets. Si la classe ``Sound`` a des erreurs ou n'a pas "
"d'AudioStreamPlayer disponible, tous les nœuds qui l'appellent vont "
"dysfonctionner."

msgid ""
"**Global access**: now that any object can call ``Sound.play(sound_path)`` "
"from anywhere, there's no longer an easy way to find the source of a bug."
msgstr ""
"**Accès global** : maintenant que n'importe quel objet peut appeler ``Sound."
"play(sound_path)``de n'importe où, il n'y a plus de moyen facile de trouver "
"la source d'un bug."

msgid ""
"**Global resource allocation**: with a pool of ``AudioStreamPlayer`` nodes "
"stored from the start, you can either have too few and face bugs, or too "
"many and use more memory than you need."
msgstr ""
"**Allocation globale des ressources** : avec un pool de nœuds "
"``AudioStreamPlayer`` stockés dès le départ, vous pouvez en avoir trop peu "
"et rencontrer des bugs, ou en avoir trop et utiliser plus de mémoire que "
"nécessaire."

#, fuzzy
msgid ""
"About global access, the problem is that any code anywhere could pass wrong "
"data to the ``Sound`` autoload in our example. As a result, the domain to "
"explore to fix the bug spans the entire project."
msgstr ""
"En ce qui concerne l'accès global, le problème est que n'importe quel code "
"n'importe où pourrait transmettre des données erronées à la classe chargée "
"automatiquement ``Sound`` dans notre exemple. Par conséquent, le domaine à "
"explorer pour corriger des bugs s'étend sur l'ensemble du projet."

msgid ""
"When you keep code inside a scene, only one or two scripts may be involved "
"in audio."
msgstr ""
"Lorsque vous gardez le code à l'intérieur d'une scène, un ou deux scripts "
"seulement peuvent être impliqués dans l'audio."

msgid ""
"Contrast this with each scene keeping as many ``AudioStreamPlayer`` nodes as "
"it needs within itself and all these problems go away:"
msgstr ""
"Comparez cela avec chaque scène qui garde autant de nœuds "
"``AudioStreamPlayer`` qu'il lui faut et tous ces problèmes disparaissent :"

msgid ""
"Each scene manages its own state information. If there is a problem with the "
"data, it will only cause issues in that one scene."
msgstr ""
"Chaque scène gère ses propres informations d'état. S'il y a un problème avec "
"les données, cela ne causera des problèmes que dans une seule scène."

msgid ""
"Each scene accesses only its own nodes. Now, if there is a bug, it's easy to "
"find which node is at fault."
msgstr ""
"Chaque scène accède uniquement à ses propres nœuds. Ainsi, si il y a un bug, "
"il est facile de trouver quel nœud pose problème."

msgid "Each scene allocates exactly the amount of resources it needs."
msgstr ""
"Chaque scène alloue exactement la quantité de ressources dont elle a besoin."

msgid "Managing shared functionality or data"
msgstr "Gérer des données ou des fonctionnalités partagées"

msgid ""
"Another reason to use an Autoload can be that you want to reuse the same "
"method or data across many scenes."
msgstr ""
"Une autre raison d'utiliser un Chargement Automatique peut être que vous "
"souhaitez réutiliser la même méthode ou les mêmes données à travers "
"plusieurs scènes."

msgid ""
"In the case of functions, you can create a new type of ``Node`` that "
"provides that feature for an individual scene using the :ref:`class_name "
"<doc_gdscript_basics_class_name>` keyword in GDScript."
msgstr ""
"Dans le cas des fonctions, vous pouvez créer un nouveau type de ``Node`` qui "
"fournit cette fonctionnalité pour une scène individuelle en utilisant le mot-"
"clé :ref:`class_name <doc_gdscript_basics_class_name>` dans GDScript."

msgid "When it comes to data, you can either:"
msgstr "En ce qui concerne les données, vous pouvez :"

msgid ""
"Create a new type of :ref:`Resource <class_Resource>` to share the data."
msgstr ""
"Créez un nouveau type de :ref:`Resource <class_Resource>` pour partager les "
"données."

msgid ""
"Store the data in an object to which each node has access, for example using "
"the ``owner`` property to access the scene's root node."
msgstr ""
"Stocker les données dans un objet auquel chaque nœud a accès, par exemple en "
"utilisant la propriété ``owner`` pour accéder au nœud racine de la scène."

msgid "When you should use an Autoload"
msgstr "Quand utiliser un Chargement Automatique"

msgid ""
"GDScript supports the creation of ``static`` functions using ``static "
"func``. When combined with ``class_name``, this makes it possible to create "
"libraries of helper functions without having to create an instance to call "
"them. The limitation of static functions is that they can't reference member "
"variables, non-static functions or ``self``."
msgstr ""

msgid ""
"Since Godot 4.1, GDScript also supports ``static`` variables using ``static "
"var``. This means you can now share a variables across instances of a class "
"without having to create a separate autoload."
msgstr ""

#, fuzzy
msgid ""
"Still, autoloaded nodes can simplify your code for systems with a wide "
"scope. If the autoload is managing its own information and not invading the "
"data of other objects, then it's a great way to create systems that handle "
"broad-scoped tasks. For example, a quest or a dialogue system."
msgstr ""
"**Systèmes avec une large portée** : Si le singleton gère ses propres "
"informations et n'envahit pas avec les données d'autres objets, alors c'est "
"un excellent moyen de créer des systèmes qui gèrent des tâches à grande "
"portée. Par exemple, une quête ou un système de dialogue."

#, fuzzy
msgid ""
"An autoload is *not* necessarily a singleton. Nothing prevents you from "
"instantiating copies of an autoloaded node. An autoload is only a tool that "
"makes a node load automatically as a child of the root of your scene tree, "
"regardless of your game's node structure or which scene you run, e.g. by "
"pressing the :kbd:`F6` key."
msgstr ""
"Un Chargement Automatique n'est pas exactement un Singleton. Rien ne vous "
"empêche d'instancier des copies d'un nœud chargé automatiquement. Il s'agit "
"seulement d'un outil permettant à un nœud de se charger automatiquement en "
"tant qu'enfant de la racine de votre arbre des scènes, indépendamment de la "
"structure des nœuds de votre jeu ou de la scène que vous exécutez, par "
"exemple en appuyant sur la touche :kbd:`F6`."

#, fuzzy
msgid ""
"As a result, you can get the autoloaded node, for example an autoload called "
"``Sound``, by calling ``get_node(\"/root/Sound\")``."
msgstr ""
"Par conséquent, vous pouvez obtenir le nœud chargé automatiquement, par "
"exemple un chargement automatique appelé ``Sound``, en appelant "
"``get_node(\"/root/Sound\")``."

msgid "Translation status"
msgstr "État de la traduction"
