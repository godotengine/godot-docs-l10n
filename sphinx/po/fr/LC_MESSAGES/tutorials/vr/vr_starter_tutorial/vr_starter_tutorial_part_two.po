# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-16 15:51+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "VR starter tutorial part 2"
msgstr "Tutoriel pour commencer en VR partie 2"

msgid "Introduction"
msgstr "Introduction"

msgid ""
"In this part of the VR starter tutorial series, we will be adding a number "
"of special :ref:`RigidBody <class_RigidBody>`-based nodes that can be used "
"in VR."
msgstr ""
"Dans cette partie de la série de tutoriels pour débuter en VR, nous allons "
"ajouter un certain nombre de nœuds spéciaux basés sur :ref:`RigidBody "
"<class_RigidBody>` qui peuvent être utilisés dans la VR."

msgid ""
"This continues from where we left on in the last tutorial part, where we "
"just finished getting the VR controllers working and defined a custom class "
"called ``VR_Interactable_Rigidbody``."
msgstr ""
"Ceci continue là où nous nous sommes arrêtés dans la dernière partie du "
"tutoriel, où nous venons de terminer de faire fonctionner les contrôleurs VR "
"et de définir une classe personnalisée appelée ``VR_Interactable_Rigidbody``."

#, fuzzy
msgid ""
"You can find the finished project on the `OpenVR GitHub repository <https://"
"github.com/GodotVR/godot_openvr_fps>`__."
msgstr ""
"Vous pouvez trouver le projet fini sur le dépôt `OpenVR GitHub <https://"
"github.com/GodotVR/godot_openvr_fps>`_."

msgid "Adding destroyable targets"
msgstr "Ajout de cibles destructibles"

msgid ""
"Before we make any of the special :ref:`RigidBody <class_RigidBody>`-based "
"nodes, we need something for them to do. Let's make a simple sphere target "
"that will break into a bunch of pieces when destroyed."
msgstr ""
"Avant de créer des nœuds spéciaux basés sur :ref:`RigidBody "
"<class_RigidBody>`, nous avons besoin de leur faire faire quelque chose. "
"Faisons une simple sphère cible qui se brisera en mille morceaux lorsqu'elle "
"sera détruite."

msgid ""
"Open up ``Sphere_Target.tscn``, which is in the ``Scenes`` folder. The scene "
"is fairly simple, with just a :ref:`StaticBody <class_StaticBody>` with a "
"sphere shaped :ref:`CollisionShape <class_CollisionShape>`, a :ref:"
"`MeshInstance <class_MeshInstance>` node displaying a sphere mesh, and an :"
"ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node."
msgstr ""
"Ouvrez le fichier ``Sphere_Target.tscn``, qui se trouve dans le dossier "
"``Scenes``. La scène est assez simple, avec juste un nœud :ref:`StaticBody "
"<class_StaticBody>` avec une sphère en forme de :ref:`CollisionShape "
"<class_CollisionShape>`, un nœud :ref:`MeshInstance <class_MeshInstance>` "
"affichant un maillage de sphère, et un nœud :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>`."

msgid ""
"The special :ref:`RigidBody <class_RigidBody>` nodes will handle damaging "
"the sphere, which is why we are using a :ref:`StaticBody <class_StaticBody>` "
"node instead of something like an :ref:`Area <class_Area>` or :ref:"
"`RigidBody <class_RigidBody>` node. Outside of that, there isn't really a "
"lot to talk about, so let's move straight into writing the code."
msgstr ""
"Les nœuds spéciaux :ref:`RigidBody <class_RigidBody>` vont gérer les "
"dommages causés à la sphère, c'est pourquoi nous utilisons un nœud :ref:"
"`StaticBody <class_StaticBody>` au lieu de quelque chose comme un nœud :ref:"
"`Area <class_Area>` ou :ref:`RigidBody <class_RigidBody>`. En dehors de "
"cela, il n'y a pas vraiment grand-chose à dire, alors passons directement à "
"l'écriture du code."

msgid ""
"Select the ``Sphere_Target_Root`` node and make a new script called "
"``Sphere_Target.gd``. Add the following code:"
msgstr ""
"Sélectionnez le nœud ``Sphere_Target_Root`` et créez un nouveau script "
"appelé ``Sphere_Target.gd```. Ajouter le code suivant :"

msgid "Let's go over how this script works."
msgstr "Voyons comment fonctionne le script."

msgid "Explaining the Sphere Target code"
msgstr "Explication du code de Sphere Target"

msgid "First, let's go through all the class variables in the script:"
msgstr ""
"Tout d'abord, passons en revue toutes les variables de classe dans le "
"script :"

msgid ""
"``destroyed``: A variable to track whether the sphere target has been "
"destroyed."
msgstr ""
"``destroyed`` : Variable permettant de savoir si la cible de la sphère a été "
"détruite."

msgid ""
"``destroyed_timer``: A variable to track how long the sphere target has been "
"destroyed."
msgstr ""
"``destroyed_timer`` : Variable permettant de savoir depuis combien de temps "
"la sphère cible a été détruite."

msgid ""
"``DESTROY_WAIT_TIME``: A constant to define the length of time the target "
"can be destroyed for before it frees/deletes itself."
msgstr ""
"``DESTROY_WAIT_TIME`` : une constante pour définir la durée pendant laquelle "
"la cible peut être détruite avant de se libérer/se supprimer."

msgid ""
"``health``: A variable to store the amount of health the sphere target has."
msgstr ""
"``health`` : Une variable pour stocker la quantité de santé de la sphère "
"cible."

msgid ""
"``RIGID_BODY_TARGET``: A constant to hold the scene of the destroyed sphere "
"target."
msgstr ""
"``RIGID_BODY_TARGET`` : Une constante pour contenir la scène de la cible "
"sphère détruite."

msgid ""
"Feel free to check out the ``RIGID_BODY_TARGET`` scene. It is just a bunch "
"of :ref:`RigidBody <class_RigidBody>` nodes and a broken sphere model."
msgstr ""
"N'hésitez pas à jeter un coup d’œil à la scène ``RIGID_BODY_TARGET``. Il "
"s'agit juste d'un tas de nœuds :ref:`RigidBody <class_RigidBody>` et d'un "
"modèle de sphère brisée."

msgid ""
"We'll be instancing this scene so when the target is destroyed, it looks "
"like it broke into a bunch of pieces."
msgstr ""
"Nous allons instancier cette scène pour que, lorsque la cible sera détruite, "
"on ait l'impression qu'elle s'est brisée en mille morceaux."

msgid "``_ready`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``_ready``"

msgid ""
"All the ``_ready`` function does is that it stops the ``_physics_process`` "
"from being called by calling ``set_physics_process`` and passing ``false``. "
"The reason we do this is because all the code in ``_physics_process`` is for "
"destroying this node when enough time has passed, which we only want to do "
"when the target has been destroyed."
msgstr ""
"Tout ce que fait la fonction ``_ready``, c'est qu'elle empêche le "
"``_physics_process`` d'être appelé en appelant ``set_physics_process`` avec "
"``false`` comme argument. La raison pour laquelle nous faisons cela est que "
"tout le code dans ``physics_process`` est destiné à détruire ce nœud lorsque "
"suffisamment de temps s'est écoulé, ce que nous ne voulons faire que lorsque "
"la cible a été détruite."

msgid "``_physics_process`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``_physics_process``"

msgid ""
"First this function adds time, ``delta``, to the ``destroyed_timer`` "
"variable. It then checks to see if ``destroyed_timer`` is greater than or "
"equal to ``DESTROY_WAIT_TIME``. If ``destroyed_timer`` is greater than or "
"equal to ``DESTROY_WAIT_TIME``, then the sphere target frees/deletes itself "
"by calling the ``queue_free`` function."
msgstr ""
"D'abord, cette fonction ajoute le temps, ``delta``, à la variable "
"``destroyed_timer``. Il vérifie ensuite si ``destroyed_timer`` est supérieur "
"ou égal à ``DESTROY_WAIT_TIME``. Si ``destroyed_timer`` est supérieur ou "
"égal à ``DESTROY_WAIT_TIME``, alors la cible sphère se libère/se supprime en "
"appelant la fonction ``queue_free``."

msgid "``damage`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``damage``"

msgid ""
"The ``damage`` function will be called by the special :ref:`RigidBody "
"<class_RigidBody>` nodes, which will pass the amount of damage done to the "
"target, which is a function argument variable called ``damage``. The "
"``damage`` variable will hold the amount of damage the special :ref:"
"`RigidBody <class_RigidBody>` node did to the sphere target."
msgstr ""
"La fonction ``damage`` sera appelée par les nœuds spéciaux :ref:`RigidBody "
"<class_RigidBody>`, qui transmettront la quantité de dommages faits à la "
"cible, qui est une variable d'argument de fonction appelée ``damage``. La "
"variable ``damage`` contiendra la quantité de dommages que le nœud spécial :"
"ref:`RigidBody <class_RigidBody>` a fait à la sphère cible."

msgid ""
"First this function checks to make sure the target is not already destroyed "
"by checking if the ``destroyed`` variable is equal to ``true``. If "
"``destroyed`` is equal to ``true``, then the function calls ``return`` so "
"none of the other code is called. This is just a safety check so that if two "
"things damage the target at exactly the same time, the target cannot be "
"destroyed twice."
msgstr ""
"Cette fonction vérifie d'abord que la cible n'est pas déjà détruite en "
"vérifiant si la variable ``destroyed`` est égale à ``true``. Si "
"``destroyed`` est égal à ``true``, alors la fonction appelle ``return``, "
"donc aucun autre code n'est appelé. Il s'agit simplement d'un contrôle de "
"sécurité, de sorte que si deux choses endommagent la cible exactement au "
"même moment, la cible ne peut pas être détruite deux fois."

msgid ""
"Next the function removes the amount of damage taken, ``damage``, from the "
"target's health, ``health``. If then checks to see if ``health`` is equal to "
"zero or less, meaning that the target has just been destroyed."
msgstr ""
"Ensuite, la fonction enlève la quantité de dégâts subis, ``damage``, de la "
"santé de la cible, ``health``. Il vérifie ensuite si la ``health`` est égale "
"à zéro ou moins, ce qui signifie que la cible vient d'être détruite."

msgid ""
"If the target has just been destroyed, then we disable the :ref:"
"`CollisionShape <class_CollisionShape>` by setting it's ``disabled`` "
"property to ``true``. We then make the ``Sphere_Target`` :ref:`MeshInstance "
"<class_MeshInstance>` invisible by setting the ``visible`` property to "
"``false``. We do this so the target can no longer effect the physics world "
"and so the non-broken target mesh is not visible."
msgstr ""
"Si la cible vient d'être détruite, alors nous désactivons la propriété :ref:"
"`CollisionShape <class_CollisionShape>` en mettant sa propriété ``disabled`` "
"à ``true``. Nous rendons alors la ``Sphere_Target`` :ref:`MeshInstance "
"<class_MeshInstance>` invisible en réglant la propriété ``visible`` à "
"``false``. Nous faisons cela pour que la cible ne puisse plus affecter le "
"monde physique et pour que le maillage de la cible non brisé ne soit pas "
"visible."

msgid ""
"After this the function then instances the ``RIGID_BODY_TARGET`` scene and "
"adds it as a child of the target. It then sets the ``global_transform`` of "
"the newly instanced scene, called ``clone``, to the ``global_transform`` of "
"the non-broken target. This makes it where the broken target starts at the "
"same position as the non-broken target with the same rotation and scale."
msgstr ""
"Ensuite, la fonction instance la scène ``RIGID_BODY_TARGET`` et l'ajoute "
"comme enfant de la cible. Il fixe ensuite la ``global_transform`` de la "
"nouvelle scène instanciée, appelée ``clone``, à la ``global_transform`` de "
"la cible non brisée. La cible brisée commence donc à la même position que la "
"cible non brisée, avec la même rotation et la même échelle."

msgid ""
"Then the function sets the ``destroyed`` variable to ``true`` so the target "
"knows it has been destroyed and calls the ``set_physics_process`` function "
"and passes ``true``. This will start executing the code in "
"``_physics_process`` so that after ``DESTROY_WAIT_TIME`` seconds have "
"passed, the sphere target will free/destroy itself."
msgstr ""
"Ensuite, la fonction met la variable ``destroyed`` à ``true`` pour que la "
"cible sache qu'elle a été détruite et appelle la fonction "
"``set_physics_process`` avec l'argument ``true``. Cela lancera l'exécution "
"du code dans ``_physics_process`` de sorte qu'après que "
"``DESTROY_WAIT_TIME`` secondes se soient écoulées, la cible de la sphère se "
"libèrera/se détruira elle-même."

msgid ""
"The function then gets the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node and calls the ``play`` function so it "
"plays its sound."
msgstr ""
"La fonction obtient alors le nœud :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` et appelle la fonction ``play`` pour qu'il joue "
"son son."

msgid ""
"Finally, the ``remove_sphere`` function is called in ``Game.gd``. To get "
"``Game.gd``, the code uses the scene tree and works its way from the root of "
"the scene tree to the root of the ``Game.tscn`` scene."
msgstr ""
"Enfin, la fonction ``remove_sphere`` est appelée dans ``Game.gd``. Pour "
"obtenir ``Game.gd``, le code utilise l'arbre des scènes et se fraye un "
"chemin de la racine de l'arbre des scènes à la racine de la scène ``Game."
"tscn``."

msgid "Adding the ``remove_sphere`` function to ``Game.gd``"
msgstr "Ajout de la fonction ``remove_sphere`` à ``Game.gd``"

msgid ""
"You may have noticed we are calling a function in ``Game.gd``, called "
"``remove_sphere``, that we have not defined yet. Open up ``Game.gd`` and add "
"the following additional class variables:"
msgstr ""
"Vous avez peut-être remarqué que nous appelons une fonction dans ``Game."
"gd``, appelée ``remove_sphere``, que nous n'avons pas encore définie. Ouvrez "
"``Game.gd`` et ajoutez les variables de classe supplémentaires suivantes :"

msgid ""
"``spheres_left``: The amount of sphere targets left in the world. In the "
"provided ``Game`` scene, there are ``10`` spheres, so that is the initial "
"value."
msgstr ""
"``spheres_left`` : La quantité de sphères cibles restantes dans le monde. "
"Dans la scène ``Game`` fournie, il y a ``10`` sphères, ce qui correspond à "
"la valeur initiale."

msgid ""
"``sphere_ui``: A reference to the sphere UI. We will use this later in the "
"tutorial to display the amount of spheres left in the world."
msgstr ""
"``sphere_ui`` : Une référence à la sphère UI. Nous l'utiliserons plus tard "
"dans le tutoriel pour afficher la quantité de sphères restantes dans le "
"monde."

msgid ""
"With these variables defined, we can now add the ``remove_sphere`` function. "
"Add the following code to ``Game.gd``:"
msgstr ""
"Avec ces variables définies, nous pouvons maintenant ajouter la fonction "
"``remove_sphere``. Ajoutez le code suivant à ``Game.gd`` :"

msgid "Let's go through what this function does real quick:"
msgstr "Passons rapidement en revue ce que fait cette fonction :"

msgid ""
"First, it removes one from the ``spheres_left`` variable. It then checks to "
"see if the ``sphere_ui`` variable is not equal to ``null``, and if it is not "
"equal to ``null`` it calls the ``update_ui`` function on ``sphere_ui``, "
"passing in the number of spheres as an argument to the function."
msgstr ""
"Tout d'abord, il retire un de la variable ``spheres_left``. Il vérifie "
"ensuite si la variable ``sphere_ui`` n'est pas égale à ``null``, et si elle "
"n'est pas égale à ``null``, il appelle la fonction ``update_ui`` sur "
"``sphere_ui``, en passant le nombre de sphères en argument de la fonction."

msgid "We will add the code for ``sphere_ui`` later in this tutorial!"
msgstr ""
"Nous ajouterons le code pour ``sphere_ui`` plus tard dans ce tutoriel !"

msgid ""
"Now the ``Sphere_Target`` is ready to be used, but we don't have any way to "
"destroy it. Let's fix that by adding some special :ref:`RigidBody "
"<class_RigidBody>`-based nodes that can damage the targets."
msgstr ""
"Maintenant, ``Sphere_Target`` est prête à être utilisée, mais nous n'avons "
"aucun moyen de la détruire. Corrigeons cela en ajoutant des nœuds spéciaux "
"basés sur :ref:`RigidBody <class_RigidBody>` qui peuvent endommager les "
"cibles."

msgid "Adding a pistol"
msgstr "Ajouter un pistolet"

msgid ""
"Let's add a pistol as the first interactable :ref:`RigidBody "
"<class_RigidBody>` node. Open up ``Pistol.tscn``, which you can find in the "
"``Scenes`` folder."
msgstr ""
"Ajoutons un pistolet comme premier nœud interactif :ref:`RigidBody "
"<class_RigidBody>`. Ouvrez le fichier ``Pistol.tscn``, que vous trouverez "
"dans le dossier ``Scenes``."

msgid ""
"Let's quickly go over a few things of note in ``Pistol.tscn`` real quick "
"before we add the code."
msgstr ""
"Passons rapidement en revue quelques points importants de ``Pistol.tscn`` "
"avant d'ajouter le code."

msgid ""
"All of the nodes in ``Pistol.tscn`` expect the root node are rotated. This "
"is so the pistol is in the correct rotation relative to the VR controller "
"when it is picked up. The root node is a :ref:`RigidBody <class_RigidBody>` "
"node, which we need because we're going to use the "
"``VR_Interactable_Rigidbody`` class we created in the last part of this "
"tutorial series."
msgstr ""
"Tous les nœuds du fichier ``Pistol.tscn`` s'attendent à ce que le nœud "
"racine soit tourné. Cela permet au pistolet de tourner correctement par "
"rapport au contrôleur VR lorsqu'il est ramassé. Le nœud racine est un nœud :"
"ref:`RigidBody <class_RigidBody>`, dont nous avons besoin parce que nous "
"allons utiliser la classe ``VR_Interactable_Rigidbody`` que nous avons créée "
"dans la dernière partie de cette série de tutoriels."

msgid ""
"There is a :ref:`MeshInstance <class_MeshInstance>` node called "
"``Pistol_Flash``, which is a simple mesh that we will be using to simulate "
"the muzzle flash on the end of the pistol's barrel. A :ref:`MeshInstance "
"<class_MeshInstance>` node called ``LaserSight`` is used to as a guide for "
"aiming the pistol, and it follows the direction of the :ref:`Raycast "
"<class_Raycast>` node, called ``Raycast``, that the pistol uses to detect if "
"its 'bullet' hit something. Finally, there is an :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node at the end of the pistol that we will use "
"to play the sound of the pistol firing."
msgstr ""
"Il y a un nœud :ref:`MeshInstance <class_MeshInstance>` appelé "
"``Pistol_Flash``, qui est un simple maillage que nous utiliserons pour "
"simuler l'éclair de bouche au bout du canon du pistolet. Un nœud :ref:"
"`MeshInstance <class_MeshInstance>` appelé ``LaserSight`` est utilisé comme "
"guide pour viser avec le pistolet, et il suit la direction du nœud :ref:"
"`Raycast <class_Raycast>`, appelé ``Raycast``, que le pistolet utilise pour "
"détecter si sa 'balle' a touché quelque chose. Enfin, il y a un nœud :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` à l'extrémité du pistolet "
"que nous utiliserons pour jouer le son du tir du pistolet."

msgid ""
"Feel free to look at the other parts of the scene if you want. Most of the "
"scene is fairly straightforward, with the major changes mentioned above. "
"Select the :ref:`RigidBody <class_RigidBody>` node called ``Pistol`` and "
"make a new script called ``Pistol.gd``. Add the following code:"
msgstr ""
"N'hésitez pas à regarder les autres parties de la scène si vous le "
"souhaitez. La plupart des scènes sont assez simples, avec les changements "
"majeurs mentionnés ci-dessus. Sélectionnez le nœud :ref:`RigidBody "
"<class_RigidBody>` appelé ``Pistol`` et faites un nouveau script appelé "
"``Pistol.gd``. Ajouter le code suivant :"

msgid "Explaining the pistol code"
msgstr "Explication du code du pistolet"

msgid ""
"First, notice how instead of ``extends RigidBody``, we instead have "
"``extends VR_Interactable_Rigidbody``. This makes it where the pistol script "
"extends the ``VR_Interactable_Rigidbody`` class so the VR controllers know "
"this object can be interacted with and that the functions defined in "
"``VR_Interactable_Rigidbody`` can be called when this object is held by a VR "
"controller."
msgstr ""
"Tout d'abord, remarquez comment, au lieu de ``extends RigidBody``, nous "
"avons ``extends VR_Interactable_Rigidbody``. Cela fait que le script du "
"pistolet étend la classe ``VR_Interactable_Rigidbody`` de sorte que les "
"contrôleurs VR savent qu'il peuvent interagir avec cet objet et que les "
"fonctions définies dans ``VR_Interactable_Rigidbody`` peuvent être appelées "
"lorsque cet objet est tenu par un contrôleur VR."

msgid "Next, let's look at the class variables:"
msgstr "Ensuite, regardons les variables de classe :"

msgid ""
"``flash_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that is used to simulate muzzle flash on the "
"pistol."
msgstr ""
"``flash_mesh`` : Une variable pour tenir le nœud :ref:`MeshInstance "
"<class_MeshInstance>` qui est utilisé pour simuler le flash de la bouche du "
"canon du pistolet."

msgid ""
"``FLASH_TIME``: A constant to define how long the muzzle flash will be "
"visible. This will also define how fast the pistol can fire."
msgstr ""
"``FLASH_TIME`` : Une constante pour définir la durée de visibilité de "
"l'éclair de bouche du canon. Cela permettra également de définir la vitesse "
"à laquelle le pistolet peut tirer."

msgid ""
"``flash_timer``: A variable to hold the amount of time the muzzle flash has "
"been visible for."
msgstr ""
"``flash_timer`` : Variable permettant de contenir la durée pendant laquelle "
"le flash de la bouche du canon a été visible."

msgid ""
"``laser_sight_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that acts as the pistol's 'laser sight'."
msgstr ""
"``laser_sight_mesh`` : Une variable pour contenir le nœud :ref:`MeshInstance "
"<class_MeshInstance>` qui agit comme la 'visée laser' du pistolet."

msgid ""
"``pistol_fire_sound``: A variable to hold the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node used for the pistol's firing sound."
msgstr ""
"``pistol_fire_sound`` : Une variable pour contenir le nœud :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` utilisé pour le son de tir "
"du pistolet."

msgid ""
"``raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` node that "
"is used for calculating the bullet's position and normal when the pistol is "
"fired."
msgstr ""
"``raycast`` : Une variable pour contenir le nœud :ref:`Raycast "
"<class_Raycast>` qui est utilisé pour calculer la position de la balle et "
"normale lorsque le pistolet est tiré."

msgid ""
"``BULLET_DAMAGE``: A constant to define the amount of damage a single bullet "
"from the pistol does."
msgstr ""
"``BULLET_DAMAGE`` : Une constante pour définir la quantité de dommages "
"causés par une seule balle du pistolet."

msgid ""
"``COLLISION_FORCE``: A constant that defines the amount of force that is "
"applied to :ref:`RigidBody <class_RigidBody>` nodes when the pistol's bullet "
"collides."
msgstr ""
"``COLLISION_FORCE`` : Une constante qui définit la quantité de force qui est "
"appliquée aux nœuds :ref:`RigidBody <class_RigidBody>` lorsque la balle du "
"pistolet entre en collision."

msgid ""
"This function gets the nodes and assigns them to their proper variables. For "
"the ``flash_mesh`` and ``laser_sight_mesh`` nodes, both have their "
"``visible`` property set to ``false`` so they are not visible initially."
msgstr ""
"Cette fonction récupère les nœuds et les assigne à leurs propres variables. "
"Pour les nœuds ``flash_mesh`` et ``laser_sight_mesh``, les deux ont leur "
"propriété ``visible`` fixée à ``false``, donc ils ne sont pas visibles au "
"départ."

msgid ""
"The ``_physics_process`` function first checks to see if the pistol's muzzle "
"flash is visible by checking if ``flash_timer`` is more than zero. If "
"``flash_timer`` is more than zero, then we remove time, ``delta`` from it. "
"Next we check if the ``flash_timer`` variable is zero or less now that we "
"removed ``delta`` from it. If it is, then the pistol muzzle flash timer just "
"finished and so we need to make ``flash_mesh`` invisible by setting it's "
"``visible`` property to ``false``."
msgstr ""
"La fonction ``_physics_process`` vérifie d'abord si le flash de la bouche du "
"canon du pistolet est visible en vérifiant si ``flash_timer`` est supérieur "
"à zéro. Si ``flash_timer`` est supérieur à zéro, alors nous en retirons le "
"temps, ``delta``. Ensuite, nous vérifions si la variable ``flash_timer`` est "
"zéro ou inférieure maintenant que nous en avons retiré ``delta``. Si c'est "
"le cas, le timer du flash de la bouche du canon du pistolet vient de se "
"terminer et nous devons donc rendre ``flash_mesh`` invisible en définissant "
"sa propriété ``visible`` à ``false``."

msgid "``interact`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``interact``"

msgid ""
"The interact function first checks to see if the pistol's muzzle flash is "
"invisible by checking to see if ``flash_timer`` is less than or equal to "
"zero. We do this so we can limit the rate of fire of the pistol to the "
"length of time the muzzle flash is visible, which is a simple solution for "
"limiting how fast the player can fire."
msgstr ""
"La fonction interact vérifie d'abord si le flash de la bouche du canon du "
"pistolet est invisible en vérifiant si le ``flash_timer`` est inférieur ou "
"égal à zéro. Nous faisons cela pour pouvoir limiter la cadence de tir du "
"pistolet à la durée pendant laquelle l'éclair de la bouche est visible, ce "
"qui est une solution simple pour limiter la vitesse à laquelle le joueur "
"peut tirer."

msgid ""
"If ``flash_timer`` is zero or less, we then set ``flash_timer`` to "
"``FLASH_TIME`` so there is a delay before the pistol can fire again. After "
"that we set ``flash_mesh.visible`` to ``true`` so the muzzle flash at the "
"end of the pistol is visible while ``flash_timer`` is more than zero."
msgstr ""
"Si ``flash_timer`` est égal ou inférieur à zéro, nous réglons alors "
"``flash_timer`` sur ``FLASH_TIME`` afin qu'il y ait un délai avant que le "
"pistolet puisse tirer à nouveau. Après cela, nous avons réglé ``flash_mesh."
"visible`` sur ``true`` pour que le flash de bouche du canon du pistolet soit "
"visible tandis que ``flash_timer`` est supérieur à zéro."

msgid ""
"Next we call the ``force_raycast_update`` function on the :ref:`Raycast "
"<class_Raycast>` node in ``raycast`` so that it gets the latest collision "
"info from the physics world. We then check if the ``raycast`` hit something "
"by checking if the ``is_colliding`` function is equal to ``true``."
msgstr ""
"Ensuite, nous appelons la fonction ``force_raycast_update`` sur le nœud :ref:"
"`Raycast <class_Raycast>` dans ``raycast`` afin qu'il obtienne les dernières "
"informations de collision du monde physique. Nous vérifions ensuite si le "
"``raycast`` a frappé quelque chose en vérifiant si la fonction "
"``is_colliding`` est égale à ``true``."

msgid ""
"If the ``raycast`` hit something, then we get the :ref:`PhysicsBody "
"<class_PhysicsBody>` it collided with through the ``get_collider`` function. "
"We assign the hit :ref:`PhysicsBody <class_PhysicsBody>` to a variable "
"called ``body``."
msgstr ""
"Si le ``raycast`` frappe quelque chose, alors nous obtenons le :ref:"
"`PhysicsBody <class_PhysicsBody>` avec lequel il est entré en collision via "
"la fonction ``get_collider``. Nous affectons le :ref:`PhysicsBody "
"<class_PhysicsBody>` touché à une variable appelée ``body``."

msgid ""
"We then get the direction of the :ref:`Raycast <class_Raycast>` by getting "
"it's positive ``Z`` directional axis from the :ref:`Basis <class_Basis>` on "
"the ``raycast`` node's ``global_transform``. This will give us the direction "
"the raycast is pointing on the Z axis, which is the same direction as the "
"blue arrow on the :ref:`Spatial <class_Spatial>` gizmo when ``Local space "
"mode`` is enabled in the Godot editor. We store this direction in a variable "
"called ``direction_vector``."
msgstr ""
"Nous obtenons alors la direction du :ref:`Raycast <class_Raycast>` en "
"obtenant son axe directionnel positif ``Z`` à partir de la :ref:`Basis "
"<class_Basis>` sur la ``global_transform`` du nœud ``raycast``. Cela nous "
"donnera la direction dans laquelle le raycast pointe sur l'axe Z, qui est la "
"même direction que la flèche bleue sur le gizmo :ref:`Spatial "
"<class_Spatial>` lorsque le ``Local space mode`` est activé dans l'éditeur "
"Godot. Nous stockons cette direction dans une variable appelée "
"``direction_vector``."

msgid ""
"Next we get the distance from the :ref:`Raycast <class_Raycast>` origin to "
"the :ref:`Raycast <class_Raycast>` collision point by getting the distance "
"from the global position, ``global_transform.origin`` of the ``raycast`` "
"node to the collision point of the :ref:`Raycast <class_Raycast>`, ``raycast."
"get_collision_point``, using the ``distance_to`` function. This will give us "
"the distance the :ref:`Raycast <class_Raycast>` traveled before it collided, "
"which we store in a variable called ``raycast_distance``."
msgstr ""
"Ensuite, nous obtenons la distance entre l'origine du :ref:`Raycast "
"<class_Raycast>` et le point de collision du :ref:`Raycast <class_Raycast>` "
"en obtenant la distance de la position globale, ``global_transform.origin`` "
"du nœud ``raycast`` au point de collision de la :ref:`Raycast "
"<class_Raycast>`, ``raycast.get_collision_point``, en utilisant la fonction "
"``distance_to``. Cela nous donnera la distance que le :ref:`Raycast "
"<class_Raycast>` a parcourue avant sa collision, que nous stockons dans une "
"variable appelée ``raycast_distance``."

msgid ""
"Then the code checks if the :ref:`PhysicsBody <class_PhysicsBody>`, "
"``body``, has a function/method called ``damage`` using the ``has_method`` "
"function. If the :ref:`PhysicsBody <class_PhysicsBody>` has a function/"
"method called ``damage``, then we call the ``damage`` function and pass "
"``BULLET_DAMAGE`` so it takes damage from the bullet colliding into it."
msgstr ""
"Ensuite, le code vérifie si le :ref:`PhysicsBody <class_PhysicsBody>`, "
"``body``, a une fonction/méthode appelée ``damage`` en utilisant la fonction "
"``has_method``. Si le :ref:`PhysicsBody <class_PhysicsBody>` a une fonction/"
"méthode appelée ``dommage``, alors nous appelons la fonction ``dommage`` et "
"nous passons ``BULLET_DAMAGE`` pour qu'elle subisse les dommages de la balle "
"qui entre en collision avec elle."

msgid ""
"Regardless of whether the :ref:`PhysicsBody <class_PhysicsBody>` has a "
"``damage`` function, we then check to see if ``body`` is a :ref:`RigidBody "
"<class_RigidBody>`-based node. If ``body`` is a :ref:`RigidBody "
"<class_RigidBody>`-based node, then we want to push it when the bullet "
"collides."
msgstr ""
"Que le nœud :ref:`PhysicsBody <class_PhysicsBody>` ait une fonction "
"``dommage`` ou non, nous vérifions ensuite si ``body`` est un nœud basé sur :"
"ref:`RigidBody <class_RigidBody>`. Si ``body`` est un nœud basé sur :ref:"
"`RigidBody <class_RigidBody>`, alors nous voulons le pousser lorsque la "
"balle entre en collision avec lui."

msgid ""
"To calculate the amount of force applied, we simply take ``COLLISION_FORCE`` "
"and divide it by ``raycast_distance``, then we multiply the whole thing by "
"``body.mass``. We store this calculation in a variable called "
"``collision_force``. This will make collisions over a shorter distance apply "
"move force than those over longer distances, giving a *slightly* more "
"realistic collision response."
msgstr ""
"Pour calculer la quantité de force appliquée, nous prenons simplement "
"``COLLISION_FORCE`` et la divisons par ``raycast_distance``, puis nous "
"multiplions le tout par ``body.mass``. Nous stockons ce calcul dans une "
"variable appelée ``collision_force``. Cela fera que les collisions sur une "
"distance plus courte appliquent plus de force que celles sur de plus longues "
"distances, donnant une réponse de collision *légèrement* plus réaliste."

msgid ""
"We then push the :ref:`RigidBody <class_RigidBody>` using the "
"``apply_impulse`` function, where the position is a zero Vector3 so the "
"force is applied from the center, and the collision force is the "
"``collision_force`` variable we calculated."
msgstr ""
"Nous poussons ensuite le :ref:`RigidBody <class_RigidBody>` en utilisant la "
"fonction ``apply_impulse``, où la position est un Vector3 zéro de sorte que "
"la force est appliquée à partir du centre, et la force de collision est la "
"variable ``collision_force`` que nous avons calculée."

msgid ""
"Regardless of whether the ``raycast`` variable hit something or not, we then "
"play the pistol shot sound by calling the ``play`` function on the "
"``pistol_fire_sound`` variable."
msgstr ""
"Que la variable ``raycast`` ait touché quelque chose ou non, nous jouons "
"alors le son du coup de pistolet en appelant la fonction ``play`` sur la "
"variable ``pistol_fire_sound``."

msgid ""
"Finally, we check to see if the pistol is being held by a VR controller by "
"checking to see if the ``controller`` variable is not equal to ``null``. If "
"it is not equal to ``null``, we then set the ``rumble`` property of the VR "
"controller to ``0.25``, so there is a slight rumble when the pistol fires."
msgstr ""
"Enfin, nous vérifions si le pistolet est tenu par un contrôleur VR en "
"vérifiant si la variable ``controller`` n'est pas égale à ``null``. S'il "
"n'est pas égal à ``null``, nous réglons alors la propriété de ``rumble`` du "
"contrôleur VR sur ``0.25``, de sorte qu'il y ait un léger grondement lorsque "
"le pistolet fait feu."

msgid "``picked_up`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``picked_up``"

msgid ""
"This function simply makes the ``laser_sight_mesh`` :ref:`MeshInstance "
"<class_MeshInstance>` visible by setting the ``visible`` property to "
"``true``."
msgstr ""
"Cette fonction rend simplement visible le ``laser_sight_mesh`` :ref:"
"`MeshInstance <class_MeshInstance>` en mettant la propriété ``visible`` à "
"``true``."

msgid "``dropped`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``dropped``"

msgid ""
"This function simply makes the ``laser_sight_mesh`` :ref:`MeshInstance "
"<class_MeshInstance>` invisible by setting the ``visible`` property to "
"``false``."
msgstr ""
"Cette fonction rend simplement le ``laser_sight_mesh`` :ref:`MeshInstance "
"<class_MeshInstance>` invisible en réglant la propriété ``visible`` sur "
"``false``."

msgid "Pistol finished"
msgstr "Pistolet fini"

msgid ""
"That is all we need to do to have working pistols in the project! Go ahead "
"and run the project. If you climb up the stairs and grab the pistols, you "
"can fire them at the sphere targets in the scene using the trigger button on "
"the VR controller! If you fire at the targets long enough, they will break "
"into pieces."
msgstr ""
"C'est tout ce qu'il nous faut pour avoir des pistolets en état de marche "
"dans le projet ! Allez-y et lancez le projet. Si vous montez les escaliers "
"et attrapez les pistolets, vous pouvez tirer sur les sphères cibles dans la "
"scène en utilisant le bouton de déclenchement du contrôleur VR ! Si vous "
"tirez sur les cibles assez longtemps, elles se briseront en morceaux."

msgid "Adding a shotgun"
msgstr "Ajouter un fusil à pompe"

msgid "Next let's add a shotgun to the VR project."
msgstr "Ensuite, ajoutons un fusil de chasse au projet VR."

msgid ""
"Adding a special shotgun :ref:`RigidBody <class_RigidBody>` should be fairly "
"straightforward, as almost everything with the shotgun is the same as the "
"pistol."
msgstr ""
"Ajout d'un fusil de chasse spécial  :ref:`RigidBody <class_RigidBody>` "
"devrait être assez simple, car presque tout avec le fusil de chasse est "
"pareil qu'avec le pistolet."

msgid ""
"Open up ``Shotgun.tscn``, which you can find in the ``Scenes`` folder and "
"take a look at the scene. Almost everything is the same as in ``Pistol."
"tscn``. The only thing that is different, beyond name changes, is that "
"instead of a single :ref:`Raycast <class_Raycast>`, there are five :ref:"
"`Raycast <class_Raycast>` nodes. This is because a shotgun generally fires "
"in a cone shape, so we are going to emulate that effect by having several :"
"ref:`Raycast <class_Raycast>` nodes that will rotate randomly in a cone "
"shape when the shotgun fires."
msgstr ""
"Ouvrez le fichier ``Shotgun.tscn``, que vous trouverez dans le dossier "
"``Scenes``, et jetez un coup d’œil à la scène. Presque tout est comme dans "
"``Pistol.tscn``. La seule chose qui est différente, au-delà des changements "
"de noms, est qu'au lieu d'un seul :ref:`Raycast <class_Raycast>`, il y a "
"cinq nœuds :ref:`Raycast <class_Raycast>`. C'est parce qu'un fusil de chasse "
"tire généralement en forme de cône, nous allons donc émuler cet effet en "
"ayant plusieurs nœuds :ref:`Raycast <class_Raycast>` qui tourneront "
"aléatoirement en forme de cône lorsque le fusil de chasse tire."

msgid ""
"Outside of that, everything is more or less the same as ``Pistol.tscn``."
msgstr "En dehors de cela, tout est plus ou moins comme ``Pistol.tscn``."

msgid ""
"Let's write the code for the shotgun. Select the :ref:`RigidBody "
"<class_RigidBody>` node called ``Shotgun`` and make a new script called "
"``Shotgun.gd``. Add the following code:"
msgstr ""
"Écrivons le code du fusil de chasse. Sélectionnez le nœud :ref:`RigidBody "
"<class_RigidBody>` appelé ``Shotgun`` et faites un nouveau script appelé "
"``Shotgun.gd``. Ajouter le code suivant :"

msgid ""
"The majority of this code is exactly the same as the code for the pistol "
"with just a few *minor* changes that are primarily just different names. Due "
"to how similar these scripts are, let's just focus on the changes."
msgstr ""
"La majorité de ce code est exactement le même que celui du pistolet, avec "
"seulement quelques changements *minuscules* qui sont principalement juste "
"des noms différents. Étant donné la similitude de ces scripts, concentrons-"
"nous sur les changements."

msgid "Explaining the shotgun code"
msgstr "Explication du code du fusil de chasse"

msgid ""
"Like with the pistol, the shotgun extends ``VR_Interactable_Rigidbody`` so "
"the VR controllers know that this object can be interacted with and what "
"functions are available."
msgstr ""
"Comme pour le pistolet, le fusil de chasse étend "
"``VR_Interactable_Rigidbody``, de sorte que les contrôleurs de la VR savent "
"qu'ils peuvent interagir avec cet objet et quelles sont les fonctions "
"disponibles."

msgid "There is only one new class variable:"
msgstr "Il n'y a qu'une seule nouvelle variable de classe :"

msgid ""
"``raycasts``: A variable to hold the node that has all of the :ref:`Raycast "
"<class_Raycast>` nodes as its children."
msgstr ""
"``raycasts`` : Une variable pour contenir le nœud qui a tous les nœuds :ref:"
"`Raycast <class_Raycast>` comme ses enfants."

msgid ""
"The new class variable replaces the ``raycast`` variable from ``Pistol.gd``, "
"because with the shotgun we need to process multiple :ref:`Raycast "
"<class_Raycast>` nodes instead of just one. All of the other class variables "
"are the same as ``Pistol.gd`` and function the same way, some just are "
"renamed to be non-pistol specific."
msgstr ""
"La nouvelle variable de classe remplace la variable ``raycast`` de ``Pistol."
"gd``, car avec le fusil de chasse nous devons traiter plusieurs nœuds :ref:"
"`Raycast <class_Raycast>` au lieu d'un seul. Toutes les autres variables de "
"classe sont identiques à ``Pistol.gd`` et fonctionnent de la même manière, "
"certaines sont juste renommées pour être non spécifiques au pistolet."

msgid ""
"The interact function first checks to see if the shotgun's muzzle flash is "
"invisible by checking to see if ``flash_timer`` is less than or equal to "
"zero. We do this so we can limit the rate of fire of the shotgun to the "
"length of time the muzzle flash is visible, which is a simple solution for "
"limiting how fast the player can fire."
msgstr ""
"La fonction interact vérifie d'abord si le flash de la bouche du canon du "
"fusil est invisible en vérifiant si le ``flash_timer`` est inférieur ou égal "
"à zéro. Nous le faisons pour pouvoir limiter la cadence de tir du fusil à la "
"durée pendant laquelle l'éclair de la bouche du canon est visible, ce qui "
"est une solution simple pour limiter la vitesse à laquelle le joueur peut "
"tirer."

msgid ""
"If ``flash_timer`` is zero or less, we then set ``flash_timer`` to "
"``FLASH_TIME`` so there is a delay before the shotgun can fire again. After "
"that we set ``flash_mesh.visible`` to ``true`` so the muzzle flash at the "
"end of the shotgun is visible while ``flash_timer`` is more than zero."
msgstr ""
"Si ``flash_timer`` est égal ou inférieur à zéro, nous mettons alors "
"``flash_timer`` à ``FLASH_TIME`` afin qu'il y ait un délai avant que le "
"fusil ne puisse tirer à nouveau. Après cela, nous avons réglé ``flash_mesh."
"visible`` à ``true``, de sorte que le flash de la bouche à l'extrémité du "
"fusil soit visible tandis que ``flash_timer`` est supérieur à zéro."

msgid ""
"Next we go through each of the child nodes of the ``raycasts`` variable "
"using a for loop. This way the code will go through each of the :ref:"
"`Raycast <class_Raycast>` nodes that are children of the ``raycasts`` "
"variable."
msgstr ""
"Ensuite, nous passons par chacun des nœuds enfants de la variable "
"``raycasts`` en utilisant une boucle for. De cette façon, le code passera "
"par chacun des nœuds :ref:`Raycast <class_Raycast>` qui sont les enfants de "
"la variable ``raycasts``."

msgid ""
"For each node, we check to see if ``raycast`` is *not* a :ref:`Raycast "
"<class_Raycast>` node. If the node is not a :ref:`Raycast <class_Raycast>` "
"node, we simply use ``continue`` to skip it."
msgstr ""
"Pour chaque nœud, nous vérifions si ``raycast`` n'est *pas* un nœud :ref:"
"`Raycast <class_Raycast>`. Si le nœud n'est pas un nœud :ref:`Raycast "
"<class_Raycast>`, nous utilisons simplement ``continue`` pour le sauter."

msgid ""
"Next we rotate the ``raycast`` node randomly around a small ``10`` degrees "
"cone by settings the ``rotation_degrees`` variable of the ``raycast`` to a "
"Vector3 where the X and Z axis are a random number from ``-10`` to ``10``. "
"This random number is selected using the ``rand_range`` function."
msgstr ""
"Ensuite, nous faisons tourner le nœud ``raycast`` de façon aléatoire autour "
"d'un petit cône de ``10`` degrés en réglant la variable ``rotation_degrees`` "
"du ``raycast`` sur un Vector3 où les axes X et Z sont un nombre aléatoire "
"compris entre ``-10`` à ``10``. Ce nombre aléatoire est sélectionné à l'aide "
"de la fonction ``rand_range``."

msgid ""
"Then we call the ``force_raycast_update`` function on the :ref:`Raycast "
"<class_Raycast>` node in ``raycast`` so that it gets the latest collision "
"info from the physics world. We then check if the ``raycast`` hit something "
"by checking if the ``is_colliding`` function is equal to ``true``."
msgstr ""
"Ensuite, nous appelons la fonction ``force_raycast_update`` sur le nœud :ref:"
"`Raycast <class_Raycast>` dans ``raycast`` afin qu'elle obtienne les "
"dernières informations de collision du monde physique. Nous vérifions "
"ensuite si le ``raycast`` a touché quelque chose en vérifiant si la fonction "
"``is_colliding`` est égale à ``true``."

msgid ""
"The rest of the code is exactly the same, but this process is repeated for "
"each :ref:`Raycast <class_Raycast>` node that is a child of the ``raycasts`` "
"variable."
msgstr ""
"Le reste du code est exactement le même, mais ce processus est répété pour "
"chaque nœud :ref:`Raycast <class_Raycast>` qui est un enfant de la variable "
"``raycasts``."

msgid ""
"We then get the direction of the raycast by getting it's positive ``Z`` "
"directional axis from the :ref:`Basis <class_Basis>` on the ``raycast`` "
"node's ``global_transform``. This will give us the direction the raycast is "
"pointing on the Z axis, which is the same direction as the blue arrow on "
"the :ref:`Spatial <class_Spatial>` gizmo when ``Local space mode`` is "
"enabled in the Godot editor. We store this direction in a variable called "
"``direction_vector``."
msgstr ""
"Nous obtenons alors la direction du raycast en obtenant son axe directionnel "
"``Z`` positif à partir de la :ref:`Basis <class_Basis>` sur la "
"``global_transform`` du nœud ``raycast``. Cela nous donnera la direction "
"dans laquelle le raycast pointe sur l'axe Z, qui est la même direction que "
"la flèche bleue sur le gizmo :ref:`Spatial <class_Spatial>` lorsque le mode "
"``Local space mode`` est activé dans l'éditeur Godot. Nous stockons cette "
"direction dans une variable appelée ``direction_vector``."

msgid ""
"Next we get the distance from the raycast origin to the raycast collision "
"point by getting the distance from the global position, ``global_transform."
"origin`` of the ``raycast`` node to the collision point of the raycast, "
"``raycast.get_collision_point``, using the ``distance_to`` function. This "
"will give us the distance the :ref:`Raycast <class_Raycast>` traveled before "
"it collided, which we store in a variable called ``raycast_distance``."
msgstr ""
"Ensuite, nous obtenons la distance entre l'origine du raycast et le point de "
"collision du raycast en obtenant la distancede la position globale, "
"``global_transform.origin`` du nœud ``raycast`` et le point de collision du "
"raycast, ``raycast.get_collision_point``, en utilisant la fonction "
"``distance_to``. Cela nous donnera la distance que le :ref:`Raycast "
"<class_Raycast>` a parcourue avant sa collision, que nous stockons dans une "
"variable appelée ``raycast_distance``."

msgid ""
"Once all of the :ref:`Raycast <class_Raycast>`\\s in the ``raycast`` "
"variable have been iterated over, we then play the shotgun shot sound by "
"calling the ``play`` function on the ``shotgun_fire_sound`` variable."
msgstr ""
"Une fois que toutes les variables :ref:`Raycast <class_Raycast>`\\s de la "
"variable ``raycast`` ont été itérées, nous jouons alors le son du coup de "
"fusil en appelant la fonction ``play`` avec la variable "
"``shotgun_fire_sound``."

msgid ""
"Finally, we check to see if the shotgun is being held by a VR controller by "
"checking to see if the ``controller`` variable is not equal to ``null``. If "
"it is not equal to ``null``, we then set the ``rumble`` property of the VR "
"controller to ``0.25``, so there is a slight rumble when the shotgun fires."
msgstr ""
"Enfin, nous vérifions si le fusil est tenu par un contrôleur VR en vérifiant "
"si la variable ``controller`` n'est pas égale à ``null``. Si elle n'est pas "
"égal à ``null``, nous réglons alors la propriété de ``rumble`` du contrôleur "
"VR sur ``0.25``, de sorte qu'il y ait un léger grondement lorsque le fusil "
"tire."

msgid "Shotgun finished"
msgstr "Fusil de chasse terminé"

msgid ""
"Everything else is exactly the same as the pistol, with at most just some "
"simple name changes."
msgstr ""
"Tout le reste est exactement le même que le pistolet, avec tout au plus "
"quelques simples changements de nom."

msgid ""
"Now the shotgun is finished! You can find the shotgun in the sample scene by "
"looking around the back of one of the walls (not in the building though!)."
msgstr ""
"Maintenant, le fusil de chasse est terminé ! Vous pouvez trouver le fusil de "
"chasse dans la scène exemple en regardant derrière l'un des murs (mais pas "
"dans le bâtiment !)."

msgid "Adding a bomb"
msgstr "Ajouter une bombe"

msgid ""
"Okay, let's add a different special :ref:`RigidBody <class_RigidBody>`. "
"Instead of adding something that shoots, let's add something we can throw - "
"a bomb!"
msgstr ""
"Ok, ajoutons un autre :ref:`RigidBody <class_RigidBody>` spécial. Au lieu "
"d'ajouter quelque chose qui tire, ajoutons quelque chose que nous pouvons "
"lancer - une bombe !"

msgid "Open up ``Bomb.tscn``, which is in the ``Scenes`` folder."
msgstr "Ouvrez ``Bomb.tscn``, qui se trouve dans le dossier ``Scenes``."

msgid ""
"The root node is a :ref:`RigidBody <class_RigidBody>` node that we'll be "
"extending to use ``VR_Interactable_Rigidbody``, which has a :ref:"
"`CollisionShape <class_CollisionShape>` like the other special :ref:"
"`RigidBody <class_RigidBody>` nodes we've made so far. Likewise, there is a :"
"ref:`MeshInstance <class_MeshInstance>` called ``Bomb`` that is used to "
"display the mesh for the bomb."
msgstr ""
"Le nœud racine est un nœud :ref:`RigidBody <class_RigidBody>` que nous "
"allons étendre pour utiliser ``VR_Interactable_Rigidbody``, qui a un nœud :"
"ref:`CollisionShape <class_CollisionShape>` comme les autres nœuds :ref:"
"`RigidBody <class_RigidBody>` spéciaux que nous avons créés jusqu'à présent. "
"De même, il y a un :ref:`MeshInstance <class_MeshInstance>` appelé ``Bomb`` "
"qui est utilisé pour afficher le maillage de la bombe."

msgid ""
"Then we have an :ref:`Area <class_Area>` node simply called ``Area`` that "
"has a large :ref:`CollisionShape <class_CollisionShape>` as its child. We'll "
"use this :ref:`Area <class_Area>` node to effect anything within it when the "
"bomb explodes. Essentially, this :ref:`Area <class_Area>` node will be the "
"blast radius for the bomb."
msgstr ""
"Ensuite, nous avons un nœud :ref:`Area <class_Area>` simplement appelé "
"``Area`` qui a un grand :ref:`CollisionShape <class_CollisionShape>` comme "
"enfant. Nous utiliserons ce nœud :ref:`Area <class_Area>` pour affecter tout "
"ce qui s'y trouve lorsque la bombe explosera. Essentiellement, ce nœud :ref:"
"`Area <class_Area>` sera le rayon d'explosion de la bombe."

msgid ""
"There is also a couple :ref:`Particles <class_Particles>` nodes. One of the :"
"ref:`Particles <class_Particles>` nodes are for the smoke coming out of the "
"bomb's fuse, while another is for the explosion. You can take a look at the :"
"ref:`ParticlesMaterial <class_ParticlesMaterial>` resources, which define "
"how the particles work, if you want. We will not be covering how the "
"particles work in this tutorial due to it being outside of the scope of this "
"tutorial."
msgstr ""
"Il y a aussi quelques nœuds :ref:`Particules <classe_Particules>`. L'un des "
"nœuds :ref:`Particules <classe_Particules>` est destiné à la fumée qui sort "
"du détonateur de la bombe, tandis qu'un autre est destiné à l'explosion. "
"Vous pouvez jeter un œil aux ressources :ref:`ParticlesMaterial "
"<class_ParticlesMaterial>`, qui définissent le fonctionnement des "
"particules, si vous le souhaitez. Nous ne couvrirons pas le fonctionnement "
"des particules dans ce tutoriel car il ne fait pas partie du sujet."

msgid ""
"There is one thing with the :ref:`Particles <class_Particles>` nodes that we "
"need to make note of. If you select the ``Explosion_Particles`` node, you'll "
"find that its ``lifetime`` property is set to ``0.75`` and that the ``one "
"shot`` checkbox is enabled. This means that the particles will only play "
"once, and the particles will last for ``0.75`` seconds. We'll need to know "
"this so we can time the removal of the bomb with the end of the explosion :"
"ref:`Particles <class_Particles>`."
msgstr ""
"Il y a une chose avec les nœuds :ref:`Particles <class_Particles>` que nous "
"devons noter. Si vous sélectionnez le nœud ``Explosion_Particles``, vous "
"verrez que sa propriété ``lifetime`` est fixée à ``0.75`` et que la case "
"``one shot`` est activée. Cela signifie que les particules ne seront jouer "
"qu'une fois, et que les particules dureront 0,75 seconde. Nous aurons besoin "
"de savoir cela pour pouvoir chronométrer le retrait de la bombe à la fin de "
"l'explosion :ref:`Particules <classe_Particules>`."

msgid ""
"Let's write the code for the bomb. Select the ``Bomb`` :ref:`RigidBody "
"<class_RigidBody>` node and make a new script called ``Bomb.gd``. Add the "
"following code:"
msgstr ""
"Écrivons le code de la bombe. Sélectionnez le nœud ``Bomb``` :ref:`RigidBody "
"<class_RigidBody>` et créez un nouveau script appelé ``Bomb.gd``. Ajouter le "
"code suivant :"

msgid "Explaining the bomb code"
msgstr "Explication du code de la bombe"

msgid ""
"Like with the other special :ref:`RigidBody <class_RigidBody>` nodes, the "
"bomb extends ``VR_Interactable_Rigidbody`` so the VR controllers know this "
"object can be interacted with and that the functions defined defined in "
"``VR_Interactable_Rigidbody`` can be called when this object is held by a VR "
"controller."
msgstr ""
"Comme avec les autres nœuds spéciaux :ref:`RigidBody <class_RigidBody>`, la "
"bombe étend ``VR_Interactable_Rigidbody`` de sorte que les contrôleurs VR "
"savent qu'ils peuvent interagir avec cet objet et que les fonctions définies "
"dans ``VR_Interactable_Rigidbody`` peuvent être appelées lorsque cet objet "
"est tenu par un contrôleur VR."

msgid ""
"``bomb_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that is used for the non-exploded bomb."
msgstr ""
"``bomb_mesh`` : Une variable pour tenir le nœud :ref:`MeshInstance "
"<class_MeshInstance>` qui est utilisé pour la bombe non explosée."

msgid ""
"``FUSE_TIME``: A constant to define how long the fuse will 'burn' before the "
"bomb explodes"
msgstr ""
"``FUSE_TIME`` : Une constante pour définir combien de temps le fusible va "
"'brûler' avant que la bombe n'explose"

msgid ""
"``fuse_timer``: A variable to hold the length of time that has passed since "
"the bomb's fuse has started to burn."
msgstr ""
"``fuse_timer`` : Une variable pour contenir le temps qui s'est écoulé depuis "
"que l'amorce de la bombe a commencé à brûler."

msgid ""
"``explosion_area``: A variable to hold the :ref:`Area <class_Area>` node "
"used to detect objects within the bomb's explosion."
msgstr ""
"``explosion_area`` : Une variable pour contenir le nœud :ref:`Area "
"<class_Area>` utilisé pour détecter les objets dans l'explosion de la bombe."

msgid ""
"``EXPLOSION_DAMAGE``: A constant to define how much damage is applied with "
"the bomb explodes."
msgstr ""
"``EXPLOSION_DAMAGE`` : Une constante permettant de définir la quantité de "
"dégâts causés par l'explosion de la bombe."

msgid ""
"``EXPLOSION_TIME``: A constant to define how long the bomb will last in the "
"scene after it explodes. This value should be the same as the ``lifetime`` "
"property of the explosion :ref:`Particles <class_Particles>` node."
msgstr ""
"``EXPLOSION_TIME`` : Une constante pour définir la durée de vie de la bombe "
"après son explosion. Cette valeur doit être la même que la propriété "
"``lifetime`` du nœud :ref:`Particles <class_Particles>` de l'explosion."

msgid ""
"``explosion_timer`` A variable to hold the length of time that has passed "
"since the bomb exploded."
msgstr ""
"``explosion_timer`` une variable qui indique le temps écoulé depuis "
"l'explosion de la bombe."

msgid "``exploded``: A variable to hold whether the bomb has exploded or not."
msgstr "``exploded`` : Une variable pour savoir si la bombe a explosé ou non."

msgid ""
"``COLLISION_FORCE``: A constant that defines the amount of force that is "
"applied to :ref:`RigidBody <class_RigidBody>` nodes when the bomb explodes."
msgstr ""
"``COLLISION_FORCE`` : Une constante qui définit la quantité de force qui est "
"appliquée aux nœuds :ref:`RigidBody <class_RigidBody>` lorsque la bombe "
"explose."

msgid ""
"``fuse_particles``: A variable to hold a reference to the :ref:`Particles "
"<class_Particles>` node used for the bomb's fuse."
msgstr ""
"``fuse_particles`` : Une variable pour contenir une référence au nœud :ref:"
"`Particles <class_Particles>` utilisé pour l'amorce de la bombe."

msgid ""
"``explosion_particles``: A variable to hold a reference to the :ref:"
"`Particles <class_Particles>` node used for the bomb's explosion."
msgstr ""
"``explosion_particles`` : Une variable pour contenir une référence au nœud :"
"ref:`Particles <class_Particles>` utilisé pour l'explosion de la bombe."

msgid ""
"``explosion_sound``: A variable to hold a reference to the :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node used for the "
"explosion sound."
msgstr ""
"``explosion_sound`` : Une variable pour contenir une référence au nœud :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` utilisé pour le son de "
"l'explosion."

msgid ""
"The ``_ready`` function first gets all of the nodes from the bomb scene and "
"assigns them to their respective class variables for later use."
msgstr ""
"La fonction ``_ready`` récupère d'abord tous les nœuds de la scène de la "
"bombe et les affecte à leurs variables de classe respectives pour une "
"utilisation ultérieure."

msgid ""
"Then we call ``set_physics_process`` and pass ``false`` so "
"``_physics_process`` is not executed. We do this because the code in "
"``_physics_process`` will start burning the fuse and exploding the bomb, "
"which we only want to do when the user interacts with the bomb. If we did "
"not disable ``_physics_process``, the bomb's fuse would start before the "
"user has a chance to get to the bomb."
msgstr ""
"Ensuite, nous appelons ``set_physics_process`` et nous passons ``false`` "
"pour que ``_physics_process`` ne soit pas exécuté. Nous faisons cela parce "
"que le code dans ``_physics_process`` va commencer à brûler le fusible et à "
"faire exploser la bombe, ce que nous ne voulons faire que lorsque "
"l'utilisateur interagit avec la bombe. Si nous ne désactivons pas le "
"``_physics_process``, le fusible de la bombe se déclenchera avant que "
"l'utilisateur n'ait la possibilité d'obtenir la bombe."

msgid ""
"The ``_physics_process`` function first checks to see if ``fuse_timer`` is "
"less than ``FUSE_TIME``. If it is, then the bomb's fuse is still burning."
msgstr ""
"La fonction ``_physics_process`` vérifie d'abord si ``fuse_timer`` est "
"inférieur à ``FUSE_TIME``. Si c'est le cas, alors le détonateur de la bombe "
"brûle toujours."

msgid ""
"If the bomb's fuse is still burning, we then add time, ``delta``, to the "
"``fuse_timer`` variable. We then check to see if ``fuse_timer`` is more than "
"or equal to ``FUSE_TIME`` now that we have added ``delta`` to it. If "
"``fuse_timer`` is more than or equal to ``FUSE_TIME``, then the fuse has "
"just finished and we need to explode the bomb."
msgstr ""
"Si le fusible de la bombe brûle toujours, nous ajoutons alors le temps, "
"``delta``, à la variable ``fuse_timer``. Nous vérifions ensuite si "
"``fuse_timer`` est supérieur ou égal à ``FUSE_TIME``, maintenant que nous y "
"avons ajouté ``delta``. Si ``fuse_timer`` est supérieur ou égal à "
"``FUSE_TIME``, alors le fusible vient de se terminer et nous devons faire "
"exploser la bombe."

msgid ""
"To explode the bomb, we first stop emitting particles for the fuse by "
"setting ``emitting`` to ``false`` on ``fuse_particles``. We then tell the "
"explosion :ref:`Particles <class_Particles>` node, ``explosion_particles``, "
"to emit all of its particle in a single shot by setting ``one_shot`` to "
"``true``. After that, we set ``emitting`` to ``true`` on "
"``explosion_particles`` so it looks like the bomb has exploded. To help make "
"it look like the bomb exploded, we hide the bomb :ref:`MeshInstance "
"<class_MeshInstance>` node by setting ``bomb_mesh.visible`` to ``false``."
msgstr ""
"Pour faire exploser la bombe, nous arrêtons d'abord d'émettre des particules "
"pour le fusible en réglant ``emitting`` à ``false`` sur ``fuse_particles``. "
"On dit alors au nœud explosion :ref:`Particules <classe_Particules>`, "
"``explosion_particules``, d'émettre toutes ses particule en un seul coup en "
"mettant ``one_shot`` à ``true``. Après cela, nous réglons ``emitting`` à "
"``true`` sur ``explosion_particles`` pour que la bombe ait l'air d'avoir "
"explosé. Pour faire croire que la bombe a explosé, nous cachons le nœud :ref:"
"`MeshInstance <class_MeshInstance>` en réglant ``bomb_mesh.visible`` sur "
"``false``."

msgid ""
"To keep the bomb from colliding with other objects in the physics world, we "
"set the ``collision_layer`` and ``collision_mask`` properties of the bomb to "
"``0``. We also change the :ref:`RigidBody <class_RigidBody>` mode to "
"``MODE_STATIC`` so the bomb :ref:`RigidBody <class_RigidBody>` does not move."
msgstr ""
"Pour éviter que la bombe n'entre en collision avec d'autres objets du monde "
"de la physique, nous avons réglé les propriétés ``collision_layer`` et "
"``collision_mask`` de la bombe sur ``0``. Nous changeons également le mode :"
"ref:`RigidBody <class_RigidBody>` en ``MODE_STATIC`` pour que le :ref:"
"`RigidBody <class_RigidBody>` de la bombe ne bouge pas."

msgid ""
"Then we need to get all of the :ref:`PhysicsBody <class_PhysicsBody>` nodes "
"within the ``explosion_area`` node. To do this, we use the "
"``get_overlapping_bodies`` in a for loop. The ``get_overlapping_bodies`` "
"function will return an array of :ref:`PhysicsBody <class_PhysicsBody>` "
"nodes within the :ref:`Area <class_Area>` node, which is exactly what we are "
"looking for."
msgstr ""
"Ensuite, nous devons récupérer tous les nœuds :ref:`PhysicsBody "
"<class_PhysicsBody>` dans le nœud ``explosion_area``. Pour ce faire, nous "
"utilisons les ``get_overlapping_bodies`` dans une boucle for. La fonction "
"``get_overlapping_bodies`` retournera un tableau des nœuds :ref:`PhysicsBody "
"<class_PhysicsBody>` dans le nœud :ref:`Area <class_Area>`, ce qui est "
"exactement ce que nous recherchons."

msgid ""
"For each :ref:`PhysicsBody <class_PhysicsBody>` node, which we store in a "
"variable called ``body``, we check to see if it is equal to ``self``. We do "
"this so the bomb does not accidentally explode itself, as the "
"``explosion_area`` could potentially detect the ``Bomb`` :ref:`RigidBody "
"<class_RigidBody>` as a PhysicsBody within the explosion area."
msgstr ""
"Pour chaque nœud :ref:`PhysicsBody <class_PhysicsBody>`, que nous stockons "
"dans une variable appelée ``body``, nous vérifions s'il est égal à ``self``. "
"Nous faisons cela pour que la bombe ne s'explose elle-même pas "
"accidentellement, car l'``explosion_area`` pourrait potentiellement détecter "
"la ``Bomb`` :ref:`RigidBody <class_RigidBody>` comme un corps physique dans "
"la zone d'explosion."

msgid ""
"If the :ref:`PhysicsBody <class_PhysicsBody>` node, ``body``, is not the "
"bomb, then we first check to see if the :ref:`PhysicsBody "
"<class_PhysicsBody>` node has a function called ``damage``. If the :ref:"
"`PhysicsBody <class_PhysicsBody>` node has a function called ``damage``, we "
"call it and pass ``EXPLOSION_DAMAGE`` to it so it takes damage from the "
"explosion."
msgstr ""
"Si le nœud :ref:`PhysicsBody <class_PhysicsBody>`, ``body``, n'est pas la "
"bombe, alors nous vérifions d'abord si le nœud :ref:`PhysicsBody "
"<class_PhysicsBody>` a une fonction appelée ``damage``. Si le nœud :ref:"
"`PhysicsBody <class_PhysicsBody>` a une fonction appelée ``damage``, nous "
"l'appelons et lui passons ``EXPLOSION_DAMAGE`` pour qu'il prenne les "
"dommages de l'explosion."

msgid ""
"Next we check to see if the :ref:`PhysicsBody <class_PhysicsBody>` node is "
"a :ref:`RigidBody <class_RigidBody>`. If ``body`` is a :ref:`RigidBody "
"<class_RigidBody>`, we want to move it when the bomb explodes."
msgstr ""
"Ensuite, nous vérifions si le nœud :ref:`PhysicsBody <class_PhysicsBody>` "
"est un nœud :ref:`RigidBody <class_RigidBody>`. Si ``body`` est un :ref:"
"`RigidBody <class_RigidBody>`, nous voulons le déplacer quand la bombe "
"explose."

msgid ""
"To move the :ref:`RigidBody <class_RigidBody>` node when the bomb explodes, "
"we first need to calculate the direction from the bomb to the :ref:"
"`RigidBody <class_RigidBody>` node. To do this we subtract the global "
"position of the bomb, ``global_transform.origin`` from the global position "
"of the :ref:`RigidBody <class_RigidBody>`. This will give us a :ref:`Vector3 "
"<class_Vector3>` that points from the bomb to the :ref:`RigidBody "
"<class_RigidBody>` node. We store this :ref:`Vector3 <class_Vector3>` in a "
"variable called ``direction_vector``."
msgstr ""
"Pour déplacer le nœud :ref:`RigidBody <class_RigidBody>` lorsque la bombe "
"explose, nous devons d'abord calculer la direction de la bombe vers le nœud :"
"ref:`RigidBody <class_RigidBody>`. Pour ce faire, nous soustrayons la "
"position globale de la bombe, ``global_transform.origin`` de la position "
"globale du :ref:`RigidBody <class_RigidBody>`. Cela nous donnera un :ref:"
"`Vecteur3 <classe_Vecteur3>` qui pointe de la bombe vers le nœud :ref:"
"`RigidBody <class_RigidBody>`. Nous stockons ceci :ref:`Vecteur3 "
"<classe_Vecteur3>` dans une variable appelée ``direction_vector``."

msgid ""
"We then calculate the distance the :ref:`RigidBody <class_RigidBody>` is "
"from the bomb by using the ``length`` function on ``direction_vector``. We "
"store the distance in a variable called ``bomb_distance``."
msgstr ""
"Nous calculons ensuite à quelle distance le :ref:`RigidBody "
"<class_RigidBody>` est de la bombe en utilisant la fonction ``length`` sur "
"le ``direction_vector``. Nous stockons la distance dans une variable appelée "
"``bomb_distance``."

msgid ""
"We then calculate the amount of force the bomb will be applied to the :ref:"
"`RigidBody <class_RigidBody>` node when the bomb explodes by dividing "
"``COLLISION_FORCE`` by ``bomb_distance``, and multiplying that by "
"``collision_force``. This will make it so if the :ref:`RigidBody "
"<class_RigidBody>` node is closer to the bomb, it will be pushed farther."
msgstr ""
"Nous calculons ensuite la force qui sera appliquée au nœud :ref:`RigidBody "
"<class_RigidBody>` lorsque la bombe explosera en divisant "
"``COLLISION_FORCE`` par ``bomb_distance``, et en multipliant le résultat par "
"``collision_force``. Ainsi, si le nœud :ref:`RigidBody <class_RigidBody>` "
"est plus proche de la bombe, il sera poussé plus loin."

msgid ""
"Finally, we push the :ref:`RigidBody <class_RigidBody>` node using the "
"``apply_impulse`` function, with a :ref:`Vector3 <class_Vector3>` position "
"of zero and ``collision_force`` multiplied by ``direction_vector."
"normalized`` as the force. This will send the :ref:`RigidBody "
"<class_RigidBody>` node flying when the bomb explodes."
msgstr ""
"Enfin, nous poussons le nœud :ref:`RigidBody <class_RigidBody>` en utilisant "
"la fonction ``apply_impulse``, avec une position :ref:`Vector3 "
"<class_Vector3>` de zéro et la force de collision multipliée par le vecteur "
"de direction normalisé comme force. Cela enverra le nœud :ref:`RigidBody "
"<class_RigidBody>` voler lorsque la bombe explosera."

msgid ""
"After we have looped through all of the :ref:`PhysicsBody "
"<class_PhysicsBody>` nodes within the ``explosion_area``, we set the "
"``exploded`` variable to ``true`` so the code knows the bomb exploded and "
"call ``play`` on ``explosion_sound`` so the sound of an explosion is played."
msgstr ""
"Après avoir parcouru tous les nœuds :ref:`PhysicsBody <class_PhysicsBody>` "
"dans la ``explosion_area``, nous mettons la variable ``exploded`` à ``true`` "
"pour que le code sache que la bombe a explosé et nous appelons ``play`` avec "
"l'argument ``explosion_sound`` pour que le son d'explosion soit joué."

msgid ""
"Alright, the next section of code starts by first checking if ``exploded`` "
"is equal to ``true``."
msgstr ""
"D'accord, la section suivante du code commence par vérifier si ``exploded`` "
"est égal à ``true``."

msgid ""
"If ``exploded`` is equal to ``true``, then that means the bomb is waiting "
"for the explosion particles to finish before it frees/destroys itself. We "
"add time, ``delta``, to ``explosion_timer`` so we can track how long it has "
"been since the bomb has exploded."
msgstr ""
"Si ``exploded`` est égal à ``true``, alors cela signifie que la bombe attend "
"que les particules de l'explosion se terminent avant de se libérer/se "
"détruire. Nous ajoutons le temps, ``delta``, à ``explosion_timer`` afin de "
"pouvoir suivre le temps écoulé depuis l'explosion de la bombe."

msgid ""
"If ``explosion_timer`` is greater than or equal to ``EXPLOSION_TIME`` after "
"we added ``delta``, then the explosion timer just finished."
msgstr ""
"Si ``explosion_timer`` est supérieur ou égal à ``EXPLOSION_TIME`` après "
"avoir ajouté ``delta``, alors le minuteur d'explosion vient de se terminer."

msgid ""
"If the explosion timer just finished, we set ``explosion_area.monitoring`` "
"to ``false``. The reason we do this is because there was a bug that would "
"print an error when you freed/deleted an :ref:`Area <class_Area>` node when "
"the ``monitoring`` property was true. To make sure this doesn't happen, we "
"simply set ``monitoring`` to false on ``explosion_area``."
msgstr ""
"Si le timer d'explosion vient de se terminer, nous mettons ``explosion_area."
"monitoring`` à ``false``. La raison pour laquelle nous faisons cela est "
"qu'il y avait un bug qui affichait une erreur lorsque vous libériez/"
"supprimiez un nœud :ref:`Area <class_Area>` lorsque la propriété "
"``monitoring`` était vraie. Pour s'assurer que cela ne se produise pas, nous "
"avons simplement mis ``monitoring`` à faux sur ``explosion_area``."

msgid ""
"Next we check to see if the bomb is being held by a VR controller by "
"checking to see if the ``controller`` variable is not equal to ``null``. If "
"the bomb is being held by a VR controller, we set the ``held_object`` "
"property of the VR controller, ``controller``, to ``null``. Because the VR "
"controller is no longer holding anything, we make the VR controller's hand "
"mesh visible by setting ``controller.hand_mesh.visible`` to ``true``. Then "
"we check to see if the VR controller grab mode is ``RAYCAST``, and if it is "
"we set ``controller.grab_raycast.visible`` to ``true`` so the 'laser sight' "
"for the grab raycast is visible."
msgstr ""
"Ensuite, nous vérifions si la bombe est tenue par un contrôleur VR en "
"vérifiant si la variable ``controller`` n'est pas égale à ``null``. Si la "
"bombe est détenue par un contrôleur VR, nous mettons la propriété "
"``held_object`` du contrôleur VR, ``controller``, à ``null``. Comme le "
"contrôleur VR ne tient plus rien, nous rendons visible le maillage de la "
"main du contrôleur VR en réglant ``controller.hand_mesh.visible`` à "
"``true``. Ensuite, nous vérifions si le mode de capture du contrôleur VR est "
"``RAYCAST``, et si c'est le cas, nous mettons ``controller.grab_raycast."
"visible`` à ``true`` pour que le 'laser sight' du raycast soit visible."

msgid ""
"Finally, regardless if the bomb is being held by a VR controller or not, we "
"call ``queue_free`` so the bomb scene is freed/removed from the scene."
msgstr ""
"Enfin, que la bombe soit tenue par un contrôleur VR ou non, nous appelons "
"``queue_free`` pour que la scène de la bombe soit libérée/supprimée de la "
"scène."

msgid ""
"First the ``interact`` function calls ``set_physics_process`` and passes "
"``true`` so the code in ``_physics_process`` starts executing. This will "
"start the bomb's fuse and eventually lead to the bomb exploding."
msgstr ""
"D'abord, la fonction ``interact`` appelle ``set_physics_process`` avec "
"l'argument ``true`` pour que le code dans ``_physics_process`` commence à "
"s'exécuter. Cela allumera l'amorce de la bombe et conduira finalement à "
"l'explosion de la bombe."

msgid ""
"Finally, we start the fuse particles by setting ``fuse_particles.visible`` "
"to ``true``."
msgstr ""
"Enfin, nous commençons les particules de l'amorce en réglant "
"``fuse_particles.visible`` à ``true``."

msgid "Bomb finished"
msgstr "Bombe terminée"

msgid ""
"Now the bomb is ready to go! You can find the bombs in the orange building."
msgstr ""
"La bombe est prête ! Vous pouvez trouver les bombes dans le bâtiment orange."

msgid ""
"Because of how we are calculating the VR controller's velocity, it is "
"easiest to throw the bombs using a thrusting-like motion instead of a more "
"natural throwing-like motion. The smooth curve of a throwing-like motion is "
"harder to track with the code we are using for calculating the velocity of "
"the VR controllers, so it does not always work correctly and can lead "
"inaccurately calculated velocities."
msgstr ""
"En raison de la façon dont nous calculons la vitesse du contrôleur VR, il "
"est plus facile de lancer les bombes en utilisant un mouvement de poussée "
"plutôt qu'un mouvement de lancer plus naturel. La courbe lisse d'un "
"mouvement de type lancer est plus difficile à suivre avec le code que nous "
"utilisons pour calculer la vitesse des contrôleurs VR, donc ça ne fonctionne "
"pas toujours correctement et peut conduire à des vitesses calculées de "
"manière imprécise."

msgid "Adding a sword"
msgstr "Ajouter une épée"

msgid ""
"Let's add one last special :ref:`RigidBody <class_RigidBody>`-based node "
"that can destroy targets. Let's add a sword so we can slice through the "
"targets!"
msgstr ""
"Ajoutons un dernier nœud spécial basé sur :ref:`RigidBody <class_RigidBody>` "
"de qui peut détruire des cibles. Ajoutons une épée pour pouvoir couper les "
"cibles !"

msgid "Open up ``Sword.tscn``, which you can find in the ``Scenes`` folder."
msgstr ""
"Ouvrez le fichier ``Sword.tscn``, que vous trouverez dans le dossier "
"``Scenes``."

msgid ""
"There is not a whole lot going on here. All of the child nodes of the root "
"``Sword`` :ref:`RigidBody <class_RigidBody>` node are rotated to they are "
"positioned correctly when the VR controller picks them up, there is a :ref:"
"`MeshInstance <class_MeshInstance>` node for displaying the sword, and there "
"is an :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node that holds "
"a sound for the sword colliding with something."
msgstr ""
"Il n'y a pas grand-chose qui se passe ici. Tous les nœuds enfants du nœud "
"racine ``Sword`` :ref:`RigidBody <class_RigidBody>` sont tournés pour qu'ils "
"soient positionnés correctement quand le contrôleur VR les prend, il y a un :"
"ref:`MeshInstance <class_MeshInstance>` nœud pour afficher l'épée, et il y a "
"un nœud :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` qui contient "
"un son pour l'épée entrant en collision avec quelque chose."

msgid ""
"There is one thing that is slightly different though. There is a :ref:"
"`KinematicBody <class_KinematicBody>` node called ``Damage_Body``. If you "
"take a look at it, you'll find that it is not on any collision layers, and "
"is instead only on a single collision mask. This is so the :ref:"
"`KinematicBody <class_KinematicBody>` will not effect other :ref:"
"`PhysicsBody <class_PhysicsBody>` nodes in the scene, but it will still be "
"effected by :ref:`PhysicsBody <class_PhysicsBody>` nodes."
msgstr ""
"Il y a cependant une chose qui est légèrement différente. Il y a un nœud :"
"ref:`KinematicBody <class_KinematicBody>` appelé ``Damage_Body``. Si vous le "
"regardez, vous verrez qu'il ne se trouve sur aucune couche de collision, et "
"qu'il ne se trouve au contraire que sur un seul masque de collision. Ainsi, "
"le :ref:`KinematicBody <class_KinematicBody>` n'affectera pas les autres "
"nœuds :ref:`PhysicsBody <class_PhysicsBody>` de la scène, mais il sera "
"toujours affecté par les nœuds :ref:`PhysicsBody <class_PhysicsBody>`."

msgid ""
"We are going to use the ``Damage_Body`` :ref:`KinematicBody "
"<class_KinematicBody>` node to detect the collision point and normal when "
"the sword collides with something in the scene."
msgstr ""
"Nous allons utiliser le nœud ``Damage_Body`` :ref:`KinematicBody "
"<class_KinematicBody>` pour détecter le point de collision et la normale "
"lorsque l'épée entre en collision avec quelque chose dans la scène."

msgid ""
"While this is perhaps not the best way of getting the collision information "
"from a performance point of view, it does give us a lot of information we "
"can use for post-processing! Using a :ref:`KinematicBody "
"<class_KinematicBody>` this way means we can detect exactly where the sword "
"collided with other :ref:`PhysicsBody <class_PhysicsBody>` nodes."
msgstr ""
"Bien que ce ne soit peut-être pas la meilleure façon d'obtenir les "
"informations sur les collisions du point de vue des performances, cela nous "
"donne beaucoup d'informations que nous pouvons utiliser pour le post-"
"traitement ! En utilisant un :ref:`KinematicBody <class_KinematicBody>` de "
"cette façon, nous pouvons détecter exactement où cette épée est entrée en "
"collision avec d'autres nœuds :ref:`PhysicsBody <class_PhysicsBody>`."

msgid ""
"That is really the only thing note worthy about the sword scene. Select the "
"``Sword`` :ref:`RigidBody <class_RigidBody>` node and make a new script "
"called ``Sword.gd``. Add the following code:"
msgstr ""
"C'est vraiment la seule chose digne d'intérêt sur la scène de l'épée. "
"Sélectionnez le nœud ``Sword``:ref:`RigidBody <class_RigidBody>` et créez un "
"nouveau script appelé ``Sword.gd``. Ajouter le code suivant :"

msgid "Let's go over how this script works!"
msgstr "Voyons comment fonctionne ce script !"

msgid "Explaining the sword code"
msgstr "Explication du code de l'épée"

msgid ""
"Like with the other special :ref:`RigidBody <class_RigidBody>` nodes, the "
"sword extends ``VR_Interactable_Rigidbody`` so the VR controllers know this "
"object can be interacted with and that the functions defined defined in "
"``VR_Interactable_Rigidbody`` can be called when this object is held by a VR "
"controller."
msgstr ""
"Comme pour les autres nœuds spéciaux :ref:`RigidBody <class_RigidBody>`, "
"l'épée étend ``VR_Interactable_Rigidbody`` de sorte que les contrôleurs VR "
"savent qu'ils peuvent interagir avec cet objet et que les fonctions définies "
"dans ``VR_Interactable_Rigidbody`` peuvent être appelées lorsque cet objet "
"est tenu par un contrôleur VR."

msgid ""
"``SWORD_DAMAGE``: A constant to define the amount of damage the sword does. "
"This damage is applied to every object in the sword on every "
"``_physics_process`` call"
msgstr ""
"``SWORD_DAMAGE`` : Une constante pour définir la quantité des dégâts causés "
"par l'épée. Ce dommage est appliqué à tous les objets de l'épée à chaque "
"appel de ``_physics_process``"

msgid ""
"``COLLISION_FORCE``: A constant that defines the amount of force applied to :"
"ref:`RigidBody <class_RigidBody>` nodes when the sword collides with a :ref:"
"`PhysicsBody <class_PhysicsBody>`."
msgstr ""
"``COLLISION_FORCE`` : Une constante qui définit la quantité de force "
"appliquée aux nœuds :ref:`RigidBody <class_RigidBody>` lorsque l'épée entre "
"en collision avec un :ref:`PhysicsBody <class_PhysicsBody>`."

msgid ""
"``damage_body``: A variable to hold the :ref:`KinematicBody "
"<class_KinematicBody>` node used to detect whether the sword is stabbing a :"
"ref:`PhysicsBody <class_PhysicsBody>` node or not."
msgstr ""
"``damage_body`` : Une variable pour contenir le nœud :ref:`KinematicBody "
"<class_KinematicBody>` utilisé pour détecter si l'épée blesse ou non un "
"nœud :ref:`PhysicsBody <class_PhysicsBody>`."

msgid ""
"``sword_noise``: A variable to hold the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node used to play a sound when the sword "
"collides with something."
msgstr ""
"``sword_noise`` : Une variable pour contenir le nœud :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` utilisé pour jouer un son "
"lorsque l'épée entre en collision avec quelque chose."

msgid ""
"All we are doing in the ``_ready`` function is getting the ``Damage_Body`` :"
"ref:`KinematicBody <class_KinematicBody>` node and assigning it to "
"``damage_body``. Because we do not want the sword to detect a collision with "
"the root :ref:`RigidBody <class_RigidBody>` node of the sword, we call "
"``add_collision_exception_with`` on ``damage_body`` and pass ``self`` so the "
"sword will not be detected."
msgstr ""
"Tout ce que nous faisons dans la fonction ``_ready`` est d'obtenir le nœud "
"``Damage_Body`` :ref:`KinematicBody <class_KinematicBody>` et de l'assigner "
"à ``damage_body``. Parce que nous ne voulons pas que l'épée détecte une "
"collision avec la racine :ref:`RigidBody <class_RigidBody>` du nœud de "
"l'épée, nous appelons ``add_collision_exception_with`` sur ``damage_body`` "
"et passons ``self`` pour que l'épée ne soit pas détectée."

msgid ""
"Finally, we get the :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` "
"node for the sword collision sound and apply it to the ``sword_noise`` "
"variable."
msgstr ""
"Enfin, on obtient le nœud :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` pour le son de collision d'épée et on "
"l'applique à la variable ``sword_noise``."

msgid ""
"First we need to determine whether the sword is colliding with something or "
"not. To do this, we use the ``move_and_collide`` function of the "
"``damage_body`` node. Unlike how ``move_and_collide`` is normally used, we "
"are not passing a velocity and instead are passing an empty :ref:`Vector3 "
"<class_Vector3>`. Because we do not want the ``damage_body`` node to move, "
"we set the ``test_only`` argument (the fourth argument) as ``true`` so the :"
"ref:`KinematicBody <class_KinematicBody>` generates collision info without "
"actually causing any collisions within the collision world."
msgstr ""
"Nous devons d'abord déterminer si l'épée entre en collision avec quelque "
"chose ou non. Pour ce faire, nous utilisons la fonction ``move_and_collide`` "
"du nœud ``damage_body``. Contrairement à la façon dont on utilise "
"normalement ``move_and_collide``, nous ne passons pas une vitesse et nous "
"passons plutôt un :ref:`Vecteur3 <classe_Vecteur3>` vide. Parce que nous ne "
"voulons pas que le nœud ``damage_body`` se déplace, nous avons défini "
"l'argument ``test_only`` (le quatrième argument) comme ``true`` donc le :ref:"
"`KinematicBody <class_KinematicBody>` génère des informations sur les "
"collisions sans provoquer réellement de collisions dans le monde des "
"collisions."

msgid ""
"The ``move_and_collide`` function will return a :ref:`KinematicCollision "
"<class_KinematicCollision>` class that has all of the information we need "
"for detecting collisions on the sword. We assign the return value of "
"``move_and_collide`` to a variable called ``collision_results``."
msgstr ""
"La fonction ``move_and_collide`` renverra un :ref:`KinematicCollision "
"<class_KinematicCollision>` qui contient toutes les informations dont nous "
"avons besoin pour détecter les collisions sur l'épée. Nous assignons la "
"valeur de retour de ``move_and_collide`` à une variable appelée "
"``collision_results``."

msgid ""
"Next we check to see if ``collision_results`` is not equal to ``null``. If "
"``collision_results`` is not equal to ``null``, then we know that the sword "
"has collided with something."
msgstr ""
"Ensuite, nous vérifions si ``collision_results`` n'est pas égal à ``null``. "
"Si ``collision_results`` n'est pas égal à ``null``, alors nous savons que "
"l'épée a heurté quelque chose."

msgid ""
"We then check to see if the :ref:`PhysicsBody <class_PhysicsBody>` the sword "
"collided with has a function/method called ``damage`` using the "
"``has_method`` function. If the :ref:`PhysicsBody <class_PhysicsBody>` has a "
"function called ``damage_body``, we call it and pass the amount of damage "
"the sword does, ``SWORD_DAMAGE``, to it."
msgstr ""
"Nous vérifions ensuite si le :ref:`PhysicsBody <class_PhysicsBody>` avec "
"lequel l'épée est entrée en collision a une fonction/méthode appelée "
"``dommage`` en utilisant la fonction ``has_method``. Si le :ref:`PhysicsBody "
"<class_PhysicsBody>` a une fonction appelée ``damage_body``, nous l'appelons "
"et lui transmettons la quantité de dégâts que l'épée fait, ``SWORD_DAMAGE``."

msgid ""
"Next we check to see if the :ref:`PhysicsBody <class_PhysicsBody>` the sword "
"collided with is a :ref:`RigidBody <class_RigidBody>`. If what the sword "
"collided with is a :ref:`RigidBody <class_RigidBody>` node, we then check to "
"see if the sword is being held by a VR controller or not by checking to see "
"if ``controller`` is equal to ``null``."
msgstr ""
"Ensuite, nous vérifions si le :ref:`PhysicsBody <class_PhysicsBody>` avec "
"lequel l'épée est entrée en collision est un :ref:`RigidBody "
"<class_RigidBody>`. Si l'épée est entrée en collision avec un nœud :ref:"
"`RigidBody <class_RigidBody>`, nous vérifions alors si l'épée est tenue par "
"un contrôleur VR ou non en vérifiant si ``contrôleur`` est égal à ``null``."

msgid ""
"If the sword is not being held by a VR controller, ``controller`` is equal "
"to ``null``, then we move the :ref:`RigidBody <class_RigidBody>` node the "
"sword collided with using the ``apply_impulse`` function. For the "
"``position`` of the ``apply_impulse`` function, we use "
"``collision_position`` variable stored within the :ref:`KinematicCollision "
"<class_KinematicCollision>` class in ``collision_results``. For the "
"``velocity`` of the ``apply_impulse`` function, we use the "
"``collision_normal`` multiplied by the ``linear_velocity`` of the sword's :"
"ref:`RigidBody <class_RigidBody>` node multiplied by ``COLLISION_FORCE``."
msgstr ""
"Si l'épée n'est pas tenue par un contrôleur VR, ``controller`` est égal à "
"``null``, alors nous déplaçons le nœud :ref:`RigidBody <class_RigidBody>` "
"avec lequel l'épée est entrée en collision en utilisant la fonction "
"``apply_impulse``. Pour la ``position`` de la fonction ``apply_impulse``, "
"nous utilisons la variable ``collision_position`` stockée dans la classe :"
"ref:`KinematicCollision <class_KinematicCollision>` dans "
"``collision_results``. Pour la ``velocity`` de la fonction "
"``apply_impulse``, nous utilisons la ``collision_normal`` multipliée par la "
"``linear_velocity`` du nœud de l'épée :ref:`RigidBody <class_RigidBody>` "
"multipliée par ``COLLISION_FORCE``."

msgid ""
"If the sword is being held by a VR controller, ``controller`` is not equal "
"to ``null``, then we move the :ref:`RigidBody <class_RigidBody>` node the "
"sword collided with using the ``apply_impulse`` function. For the "
"``position`` of the ``apply_impulse`` function, we use "
"``collision_position`` variable stored within the :ref:`KinematicCollision "
"<class_KinematicCollision>` class in ``collision_results``. For the "
"``velocity`` of the ``apply_impulse`` function, we use the "
"``collision_normal`` multiplied by the VR controller's velocity multiplied "
"by ``COLLISION_FORCE``."
msgstr ""
"Si l'épée est tenue par un contrôleur VR, ``controller`` n'est pas égal à "
"``null``, alors nous déplaçons le nœud :ref:`RigidBody <class_RigidBody>` "
"avec lequel l'épée est entrée en collision en utilisant la fonction "
"``apply_impulse``. Pour la ``position`` de la fonction ``apply_impulse``, "
"nous utilisons la variable ``collision_position`` stockée dans la classe :"
"ref:`KinematicCollision <class_KinematicCollision>` dans "
"``collision_results``. Pour la ``velocity`` de la fonction "
"``apply_impulse``, nous utilisons la ``collision_normal`` multipliée par la "
"vitesse du contrôleur VR multipliée par la ``COLLISION_FORCE``."

msgid ""
"Finally, regardless of whether the :ref:`PhysicsBody <class_PhysicsBody>` is "
"a :ref:`RigidBody <class_RigidBody>` or not, we play the sound of the sword "
"colliding with something by calling ``play`` on ``sword_noise``."
msgstr ""
"Enfin, que le :ref:`PhysicsBody <class_PhysicsBody>` soit un :ref:`RigidBody "
"<class_RigidBody>` ou non, nous jouons le son de l'épée qui entre en "
"collision avec quelque chose en appelant ``play`` sur ``sword_noise``."

msgid "Sword finished"
msgstr "Épée terminée"

msgid ""
"With that done, you can now slice through the targets! You can find the "
"sword in the corner in between the shotgun and the pistol."
msgstr ""
"Cela étant fait, vous pouvez maintenant découper les cibles ! Vous pouvez "
"trouver l'épée dans le coin entre le fusil et le pistolet."

msgid "Updating the target UI"
msgstr "Mise à jour de l'UI cible"

msgid "Let's update the UI as the sphere targets are destroyed."
msgstr ""
"Mettons à jour l'interface utilisateur au fur et à mesure que les sphères "
"cibles sont détruites."

msgid ""
"Open up ``Main_VR_GUI.tscn``, which you can find in the ``Scenes`` folder. "
"Feel free to look at how the scene is setup if you want, but in an effort to "
"keep this tutorial from becoming too long, we will not be covering the scene "
"setup in this tutorial."
msgstr ""
"Ouvrez ``Main_VR_GUI.tscn``, que vous trouverez dans le dossier ``Scenes``. "
"N'hésitez pas à regarder comment la scène est configurée si vous le "
"souhaitez, mais pour éviter que ce tutoriel ne devienne trop long, nous ne "
"couvrirons pas la configuration de la scène dans ce tutoriel."

msgid ""
"Expand the ``GUI`` :ref:`Viewport <class_Viewport>` node and then select the "
"``Base_Control`` node. Add a new script called ``Base_Control.gd``, and add "
"the following:"
msgstr ""
"Développez le nœud ``GUI`` :ref:`Viewport <class_Viewport>` et sélectionnez "
"ensuite le nœud ``Base_Control``. Ajoutez un nouveau script appelé "
"``Base_Control.gd``, et ajoutez ce qui suit :"

msgid "Let's go over how this script works real quick."
msgstr "Voyons comment ce script fonctionne très rapidement."

msgid ""
"First, in ``_ready``, we get the :ref:`Label <class_Label>` that shows how "
"many spheres are left and assign it to the ``sphere_count_label`` class "
"variable. Next, we get ``Game.gd`` by using ``get_tree().root`` and assign "
"``sphere_ui`` to this script."
msgstr ""
"D'abord, dans ``_ready``, nous obtenons le :ref:`Label <class_Label>` qui "
"indique combien de sphères il reste et nous l'attribuons à la variable de "
"classe ``sphere_count_label``. Ensuite, nous obtenons ``Game.gd`` en "
"utilisant ``get_tree().root`` et nous assignons ``sphere_ui`` à ce script."

msgid ""
"In ``update_ui``, we change the sphere :ref:`Label <class_Label>`'s text. If "
"there is at least one sphere remaining, we change the text to show how many "
"spheres are still left in the world. If there are no more spheres remaining, "
"we change the text and congratulate the player."
msgstr ""
"Dans ``update_ui``, nous changeons le texte du :ref:`Label <class_Label>` "
"sphère. S'il reste au moins une sphère, nous modifions le texte pour montrer "
"combien de sphères il reste dans le monde. S'il ne reste plus de sphères, "
"nous changeons le texte et félicitons le joueur."

msgid "Adding the final special RigidBody"
msgstr "Ajout du dernier RigidBody spécial"

msgid ""
"Finally, before we finish this tutorial, let's add a way to reset the game "
"while in VR."
msgstr ""
"Enfin, avant de terminer ce tutoriel, ajoutons un moyen de réinitialiser le "
"jeu à l'intérieur de la VR."

msgid ""
"Open up ``Reset_Box.tscn``, which you will find in ``Scenes``. Select the "
"``Reset_Box`` :ref:`RigidBody <class_RigidBody>` node and make a new script "
"called ``Reset_Box.gd``. Add the following code:"
msgstr ""
"Ouvrez ``Reset_Box.tscn``, que vous trouverez dans ``Scenes``. Sélectionnez "
"le nœud ``Reset_Box`` :ref:`RigidBody <class_RigidBody>` et créez un nouveau "
"script appelé ``Reset_Box.gd``. Ajouter le code suivant :"

msgid "Let's quickly go over how this script works."
msgstr "Passons rapidement en revue le fonctionnement de ce script."

msgid "Explaining the reset box code"
msgstr "Explication du code de la boîte de réinitialisation"

msgid ""
"Like with the other special :ref:`RigidBody <class_RigidBody>`-based objects "
"we've created, the reset box extends ``VR_Interactable_Rigidbody``."
msgstr ""
"Comme pour les autres objets spéciaux :ref:`RigidBody <class_RigidBody>` que "
"nous avons créés, la boîte de réinitialisation étend "
"``VR_Interactable_Rigidbody``."

msgid ""
"The ``start_transform`` class variable will store the global transform of "
"the reset box when the game starts, the ``reset_timer`` class variable will "
"hold the length of time that has passed since the reset box's position has "
"moved, the ``RESET_TIME`` constant defines the length of time the reset box "
"has to wait before being reset, and the ``RESET_MIN_DISTANCE`` constant "
"defines how far the reset box has to be away from it's initial position "
"before the reset timer starts."
msgstr ""
"La variable de classe ``start_transform`` stockera la transformation globale "
"de la boîte de réinitialisation au début du jeu, la variable de classe "
"``reset_timer`` contiendra la durée qui s'est écoulée depuis que la position "
"de la boîte de réinitialisation s'est déplacée, la constante ``RESET_TIME`` "
"définit la durée pendant laquelle la boîte de réinitialisation doit attendre "
"avant d'être réinitialisée, et la constante ``RESET_MIN_DISTANCE`` définit à "
"quelle distance la boîte de réinitialisation doit se trouver de sa position "
"initiale avant que le minuteur de réinitialisation ne commence."

msgid ""
"In the ``_ready`` function all we are doing is storing the "
"``global_transform`` of the reset position when the scene starts. This is so "
"we can reset the position, rotation, and scale of the reset box object to "
"this initial transform when enough time has passed."
msgstr ""
"Dans la fonction ``_ready``, tout ce que nous faisons est de stocker la "
"``global_transform`` de la position de réinitialisation lorsque la scène "
"commence. Nous pouvons ainsi réinitialiser la position, la rotation et "
"l'échelle de l'objet de la boîte de réinitialisation à cette transformation "
"initiale lorsque suffisamment de temps s'est écoulé."

msgid ""
"In the ``_physics_process`` function, the code checks to see if the reset "
"box's initial position to the reset box's current position is farther than "
"``RESET_MIN_DISTANCE``. If it is farther, then it starts adding time, "
"``delta``, to ``reset_timer``. Once ``reset_timer`` is more than or equal to "
"``RESET_TIME``, we reset the ``global_transform`` to the ``start_transform`` "
"so the reset box is back in its initial position. We then set "
"``reset_timer`` to ``0``."
msgstr ""
"Dans la fonction ``_physics_process``, le code vérifie si la position "
"initiale de la boîte de réinitialisation par rapport à la position actuelle "
"de la boîte de réinitialisation est plus éloignée que la "
"``RESET_MIN_DISTANCE``. Si elle est plus loin, il commence à ajouter du "
"temps, ``delta``, à ``reset_timer``. Une fois que le ``reset_timer`` est "
"supérieur ou égal à ``RESET_TIME``, nous réinitialisons la "
"``global_transform`` à la ``start_transform`` pour que la boîte de "
"réinitialisation soit à nouveau dans sa position initiale. Nous mettons "
"ensuite ``reset_timer`` à ``0``."

msgid ""
"The ``interact`` function simply reloads the ``Game.tscn`` scene using "
"``get_tree().change_scene``. This will reload the game scene, resetting "
"everything."
msgstr ""
"La fonction ``interact`` recharge simplement la scène ``Game.tscn`` en "
"utilisant ``get_tree().change_scene``. Cela va recharger la scène de jeu, en "
"remettant tout à zéro."

msgid ""
"Finally, the ``dropped`` function resets the ``global_transform`` to the "
"initial transform in ``start_transform`` so the reset box has its initial "
"position/rotation. Then ``reset_timer`` is set to ``0`` so the timer is "
"reset."
msgstr ""
"Enfin, la fonction ``dropped`` réinitialise la ``global_transform`` à la "
"transformation initiale ``start_transform`` de sorte que la boîte de "
"réinitialisation est à sa position/rotation initiale. Ensuite, "
"``reset_timer`` est réglé sur ``0``, ce qui réinitialise le minuteur."

msgid "Reset box finished"
msgstr "Boîte de réinitialisation terminée"

msgid ""
"With that done, when you grab and interact with the reset box, the entire "
"scene will reset/restart and you can destroy all the targets again!"
msgstr ""
"Une fois cela fait, lorsque vous saisissez et interagissez avec la boîte de "
"réinitialisation, la scène entière se réinitialise/redémarre et vous pouvez "
"à nouveau détruire toutes les cibles !"

msgid ""
"Resetting the scene abruptly without any sort of transition can lead to "
"discomfort in VR."
msgstr ""
"Rétablir la scène brusquement sans aucune sorte de transition peut entraîner "
"une gêne en VR."

msgid "Final notes"
msgstr "Notes finales"

msgid "Whew! That was a lot of work."
msgstr "Ouf ! C'était beaucoup de travail."

msgid ""
"Now you have a fully working VR project with multiple different types of "
"special :ref:`RigidBody <class_RigidBody>`-based nodes that can be used and "
"extended. Hopefully this will help serve as an introduction to making fully-"
"featured VR games in Godot! The code and concepts detailed in this tutorial "
"can be expanded on to make puzzle games, action games, story-based games, "
"and more!"
msgstr ""
"Vous avez maintenant un projet VR entièrement fonctionnel avec plusieurs "
"types de nœuds spéciaux :ref:`RigidBody <class_RigidBody>` qui peuvent être "
"utilisés et étendus. Nous espérons que cela servira d'introduction à la "
"création de jeux de VR complets dans Godot ! Le code et les concepts "
"détaillés dans ce tutoriel peuvent être développés pour en faire des jeux de "
"puzzle, des jeux d'action, des jeux basés sur l'histoire, et plus encore !"

#, fuzzy
msgid ""
"You can download the finished project for this tutorial series on the "
"`OpenVR GitHub repository <https://github.com/GodotVR/godot_openvr_fps>`__, "
"under the releases tab!"
msgstr ""
"Vous pouvez télécharger le projet terminé de cette série de tutoriels depuis "
"le dépôt `GitHub de OpenVR <https://github.com/GodotVR/godot_openvr_fps>`_, "
"sous l'onglet releases !"
