# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2022, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-11 15:14+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "VR starter tutorial part 1"
msgstr "Tutoriel pour commencer en VR partie 1"

msgid "Introduction"
msgstr "Introduction"

msgid ""
"This tutorial will show you how to make a beginner VR game project in Godot."
msgstr ""
"Ce tutoriel vous montrera comment réaliser un projet de jeu de VR pour "
"débutants dans Godot."

msgid ""
"Keep in mind, **one of the most important things when making VR content is "
"getting the scale of your assets correct**! It can take lots of practice and "
"iterations to get this right, but there are a few things you can do to make "
"it easier:"
msgstr ""
"Gardez à l'esprit que **l'une des choses les plus importantes lorsque vous "
"créez un contenu de VR est de faire en sorte que l'échelle de vos assets "
"soit correcte** ! Il faut parfois beaucoup de pratique et d'itérations pour "
"y parvenir, mais il y a quelques petites choses que vous pouvez faire pour "
"faciliter les choses :"

msgid ""
"In VR, 1 unit is typically considered 1 meter. If you design your assets "
"around that standard, you can save yourself a lot of headache."
msgstr ""
"Dans la VR, une unité est généralement considérée comme un mètre. Si vous "
"concevez vos assets en fonction de cette norme, vous pouvez vous épargner "
"bien des maux de tête."

msgid ""
"In your 3D modeling program, see if there is a way to measure and use real "
"world distances. In Blender, you can use the MeasureIt add-on; in Maya, you "
"can use the Measure Tool."
msgstr ""
"Dans votre programme de modélisation 3D, voyez s'il existe un moyen de "
"mesurer et d'utiliser les distances du monde réel. Dans Blender, vous pouvez "
"utiliser l'add-on MeasureIt ; dans Maya, vous pouvez utiliser l'outil de "
"mesure."

msgid ""
"You can make rough models using a tool like `Google Blocks <https://vr."
"google.com/blocks/>`__, and then refine in another 3D modelling program."
msgstr ""
"Vous pouvez faire des modèles approximatifs en utilisant un outil comme "
"`Google Blocks <https://vr.google.com/blocks/>`__, puis les affiner dans un "
"autre programme de modélisation 3D."

msgid ""
"Test often, as the assets can look dramatically different in VR than on a "
"flat screen!"
msgstr ""
"Testez souvent, car les assets peuvent avoir une apparence très différente "
"en VR et sur un écran plat !"

msgid "Throughout the course of this tutorial, we will cover:"
msgstr "Tout au long de ce tutoriel, nous couvrirons :"

msgid "How to tell Godot to run in VR."
msgstr "Comment dire à godot de s'exécuter en mode VR."

msgid ""
"How to make a teleportation locomotion system that uses the VR controllers."
msgstr ""
"Comment réaliser un système de locomotion par téléportation qui utilise les "
"contrôleurs VR."

msgid ""
"How to make a artificial movement locomotion system that uses the VR "
"controllers."
msgstr ""
"Comment réaliser un système de locomotion à mouvement artificiel qui utilise "
"les contrôleurs VR."

msgid ""
"How to create a :ref:`RigidBody <class_RigidBody>`-based system that allows "
"for picking up, dropping, and throwing RigidBody nodes using the VR "
"controllers."
msgstr ""
"Comment créer un système basé sur :ref:`RigidBody <class_RigidBody>` qui "
"permet de ramasser, déposer et lancer des nœuds RigidBody en utilisant les "
"contrôleurs VR."

msgid "How to create simple destroyable target."
msgstr "Comment créer une simple cible destructible."

msgid ""
"How to create some special :ref:`RigidBody <class_RigidBody>`-based objects "
"that can destroy the targets."
msgstr ""
"Comment créer des objets spéciaux :ref:`RigidBody <class_RigidBody>`qui "
"peuvent détruire les cibles."

msgid ""
"While this tutorial can be completed by beginners, it is highly advised to "
"complete :ref:`doc_your_first_2d_game`, if you are new to Godot and/or game "
"development."
msgstr ""
"Bien que ce tutoriel puisse être complété par des débutants, il est "
"fortement conseillé d'avoir fini :ref:`doc_your_first_2d_game`, si vous êtes "
"nouveau dans Godot et/ou dans le développement de jeu."

msgid ""
"**Some experience with making 3D games is required** before going through "
"this tutorial series. This tutorial assumes you have experience with the "
"Godot editor, GDScript, and basic 3D game development. A OpenVR-ready "
"headset and two OpenVR-ready controllers are required."
msgstr ""
"**Une certaine expérience dans la réalisation de jeux en 3D est requise** "
"avant de suivre cette série de tutoriels. Ce tutoriel suppose que vous avez "
"de l'expérience avec l'éditeur Godot, le GDScript et le développement de "
"jeux 3D de base. Un casque prêt pour l'OpenVR et deux contrôleurs prêts pour "
"l'OpenVR sont nécessaires."

msgid ""
"This tutorial was written and tested using a Windows Mixed Reality headset "
"and controllers. This project has also been tested on the HTC Vive. Code "
"adjustments may be required for other VR Headsets, such as the Oculus Rift."
msgstr ""
"Ce tutoriel a été écrit et testé à l'aide d'un casque et de contrôleurs "
"Windows Mixed Reality. Ce projet a également été testé sur le HTC Vive. Des "
"ajustements de code peuvent être nécessaires pour d'autres casques de VR, "
"tels que le Oculus Rift."

msgid ""
"The Godot project for this tutorial is found on the `OpenVR GitHub "
"repository <https://github.com/GodotVR/godot_openvr_fps>`__. The starter "
"assets for this tutorial can be found in the releases section on the GitHub "
"repository. The starter assets contain some 3D models, sounds, scripts, and "
"scenes that are configured for this tutorial."
msgstr ""
"Le projet Godot pour ce tutoriel se trouve dans le `dépôt GitHub de OpenVR "
"<https://github.com/GodotVR/godot_openvr_fps>`__. Les éléments de départ de "
"ce tutoriel se trouvent dans la section releases du dépôt GitHub. Les assets "
"de démarrage contiennent des modèles 3D, des sons, des scripts et des scènes "
"qui sont configurés pour ce tutoriel."

msgid "**Credits for the assets provided**:"
msgstr "**Crédits pour les assets fournis** :"

msgid ""
"The sky panorama was created by `CGTuts <https://cgi.tutsplus.com/articles/"
"freebie-8-awesome-ocean-hdris--cg-5684>`__."
msgstr ""
"Le ciel panoramique a été créé par `CGTuts <https://cgi.tutsplus.com/"
"articles/freebie-8-awesome-ocean-hdris--cg-5684>`__."

msgid "The font used is Titillium-Regular"
msgstr "La police utilisée est Titillium-Regular"

msgid "The font is licensed under the SIL Open Font License, Version 1.1"
msgstr "La police est sous licence SIL Open Font License, Version 1.1"

msgid ""
"The audio used are from several different sources, all downloaded from the "
"Sonniss #GameAudioGDC Bundle (`License PDF <https://sonniss.com/gdc-bundle-"
"license/>`__)"
msgstr ""
"Les fichiers audio utilisés proviennent de plusieurs sources différentes, "
"toutes téléchargées à partir du pack Sonniss #GameAudioGDC Bundle (`License "
"PDF <https://sonniss.com/gdc-bundle-license/>`__)"

msgid ""
"The folders where the audio files are stored have the same name as folders "
"in the Sonniss audio bundle."
msgstr ""
"Les dossiers dans lesquels les fichiers audio sont stockés portent le même "
"nom que les dossiers du paquet audio Sonniss."

msgid ""
"The OpenVR addon was created by `Bastiaan Olij <https://github.com/"
"BastiaanOlij>`__ and is released under the MIT license. It can be found both "
"on the `Godot Asset Library <https://godotengine.org/asset-library/"
"asset/150>`__ and on `GitHub <https://github.com/GodotVR/godot-openvr-"
"asset>`__. *3rd party code and libraries used in the OpenVR addon may be "
"under a different license.*"
msgstr ""
"L'addon OpenVR a été créé par `Bastiaan Olij <https://github.com/"
"BastiaanOlij>`__ et est publié sous la licence MIT. On peut le trouver à la "
"fois sur la `Godot Asset Library <https://godotengine.org/asset-library/"
"asset/150>`__ et sur `GitHub <https://github.com/GodotVR/godot-openvr-"
"asset>`__. *Le code tierce partie et les bibliothèques utilisées dans "
"l'addon OpenVR peuvent être sous une licence différente.*"

msgid ""
"The initial project, 3D models, and scripts were created by `TwistedTwigleg "
"<https://github.com/TwistedTwigleg>`__ and is released under the MIT license."
msgstr ""
"Le projet initial, les modèles 3D et les scripts ont été créés par "
"`TwistedTwigleg <https://github.com/TwistedTwigleg>`__ et est publié sous la "
"licence du MIT."

msgid ""
"You can find the finished project on the `OpenVR GitHub repository <https://"
"github.com/GodotVR/godot_openvr_fps>`__."
msgstr ""
"Vous pouvez trouver le projet fini dans le dépôt `OpenVR GitHub <https://"
"github.com/GodotVR/godot_openvr_fps>`__."

msgid "Getting everything ready"
msgstr "Tout préparer"

msgid ""
"If you have not already, go to the `OpenVR GitHub repository <https://github."
"com/GodotVR/godot_openvr_fps/releases/>`__ and download the \"Starter "
"Assets\" file from the releases. Once you have the starter assets "
"downloaded, open up the project in Godot."
msgstr ""
"Si vous ne l'avez pas encore fait, allez dans le `dépôt GitHub OpenVR "
"<https://github.com/GodotVR/godot_openvr_fps/releases/>`__ et téléchargez le "
"fichier \"Starter Assets\" depuis les releases. Une fois que vous avez "
"téléchargé les éléments de départ, ouvrez le projet dans Godot."

msgid ""
"The starter assets are not required to use the scripts provided in this "
"tutorial. The starter assets include several premade scenes and scripts that "
"will be used throughout the tutorial."
msgstr ""
"Ces assets de départ ne sont pas nécessaires pour utiliser les scripts "
"fournis dans ce tutoriel. Les ressources de départ comprennent plusieurs "
"scènes et scripts pré-faits qui seront utilisés tout au long du tutoriel."

msgid ""
"When the project is first loaded, the Game.tscn scene will be opened. This "
"will be the main scene used for the tutorial. It includes several nodes and "
"scenes already placed throughout the scene, some background music, and "
"several GUI-related :ref:`MeshInstance <class_MeshInstance>` nodes."
msgstr ""
"Au premier chargement du projet, la scène Game.tscn sera ouverte. Ce sera la "
"scène principale utilisée pour le tutoriel. Elle comprend plusieurs nœuds et "
"scènes déjà placés dans la scène, une musique de fond et plusieurs nœuds :"
"ref:`MeshInstance <class_MeshInstance>` liés à l'interface graphique."

msgid ""
"The GUI-related :ref:`MeshInstance <class_MeshInstance>` nodes already have "
"scripts attached to them. These scripts will set the texture of a :ref:"
"`Viewport <class_Viewport>` node to the albedo texture of the material of "
"the :ref:`MeshInstance <class_MeshInstance>` node. This is used to display "
"text within the VR project. Feel free to take a look at the script, ``GUI."
"gd``, if you want. We will not be going over how to to use :ref:`Viewport "
"<class_Viewport>` nodes for displaying UI on :ref:`MeshInstance "
"<class_MeshInstance>` nodes in this tutorial ."
msgstr ""
"Les nœuds :ref:`MeshInstance <class_MeshInstance>` liés à l'interface "
"graphique ont déjà des scripts qui leur sont attachés. Ces scripts vont "
"définir la texture d'un nœud :ref:`Viewport <class_Viewport>` à la texture "
"d'albédo du matériau du nœud :ref:`MeshInstance <class_MeshInstance>`. Il "
"est utilisé pour afficher du texte dans le cadre du projet de VR. N'hésitez "
"pas à consulter le script, \"GUI.gd\", si vous le souhaitez. Nous ne "
"reviendrons pas sur la manière d'utiliser les nœuds :ref:`Viewport "
"<class_Viewport>` pour afficher l'interface utilisateur sur les nœuds :ref:"
"`MeshInstance <class_MeshInstance>` dans ce tutoriel."

msgid ""
"If you are interested in how to use :ref:`Viewport <class_Viewport>` nodes "
"for displaying UI on :ref:`MeshInstance <class_MeshInstance>` nodes, see "
"the :ref:`doc_viewport_as_texture` tutorial. It covers how to use a :ref:"
"`Viewport <class_Viewport>` as a render texture, along with how to apply "
"that texture onto a :ref:`MeshInstance <class_MeshInstance>` node."
msgstr ""
"Si vous souhaitez savoir comment utiliser les nœuds :ref:`Viewport "
"<class_Viewport>` pour afficher l'interface utilisateur sur les nœuds :ref:"
"`MeshInstance <class_MeshInstance>`, consultez le tutoriel :ref:"
"`doc_viewport_as_texture`. Il explique comment utiliser un :ref:`Viewport "
"<class_Viewport>` comme texture de rendu, ainsi que comment appliquer cette "
"texture sur un nœud :ref:`MeshInstance <class_MeshInstance>`."

msgid ""
"Before we jump into the tutorial, let's take a moment to talk about how the "
"nodes used for VR work."
msgstr ""
"Avant de passer au tutoriel, prenons un moment pour parler du fonctionnement "
"des nœuds utilisés pour la VR."

msgid ""
"The :ref:`ARVROrigin <class_ARVROrigin>` node is the center point of the VR "
"tracking system. The position of the :ref:`ARVROrigin <class_ARVROrigin>` is "
"the position the VR system considers the 'center' point on the floor. The :"
"ref:`ARVROrigin <class_ARVROrigin>` has a `world scale` property that "
"effects the size of the user within the VR scene. For this tutorial, it is "
"set to `1.4`, as the world was originally just a tad to big. As mentioned "
"earlier, keeping the scale relatively consistent is important in VR."
msgstr ""
"Le nœud :ref:`ARVROrigin <class_ARVROrigin>` est le point central du système "
"de suivi de la VR. La position du :ref:`ARVROrigin <class_ARVROrigin>` est "
"la position que le système de VR considère comme le point 'center' sur le "
"sol. Le :ref:`ARVROrigin <class_ARVROrigin>` a une propriété `world scale` "
"qui affecte la taille de l'utilisateur dans la scène de VR. Pour ce "
"tutoriel, il est réglé sur `1.4`, car le monde n'était à l'origine qu'un peu "
"trop grand. Comme mentionné précédemment, il est important de maintenir une "
"échelle relativement cohérente dans la VR."

msgid ""
"The :ref:`ARVRCamera <class_ARVRCamera>` is the player's headset and view "
"into the scene. The :ref:`ARVRCamera <class_ARVRCamera>` is offset on the Y "
"axis by the VR user's height, which will be important later when we add "
"teleportation locomotoin. If the VR system supports room tracking, then the :"
"ref:`ARVRCamera <class_ARVRCamera>` will move as the player moves. This "
"means that the :ref:`ARVRCamera <class_ARVRCamera>` is not guaranteed to be "
"in the same position as the :ref:`ARVROrigin <class_ARVROrigin>` node."
msgstr ""
"L' :ref:`ARVRCamera <class_ARVRCamera>` est le casque du joueur et sa vue "
"dans la scène. L' :ref:`ARVRCamera <class_ARVRCamera>` est décalée sur l'axe "
"Y de la hauteur de l'utilisateur de la VR, ce qui sera important plus tard "
"lorsque nous ajouterons la locomotion téléportation. Si le système de VR "
"supporte le suivi de salle, alors l' :ref:`ARVRCamera <class_ARVRCamera>` se "
"déplacera au fur et à mesure que le joueur se déplace. Cela signifie que le "
"nœud :ref:`ARVRCamera <class_ARVRCamera>` n'est pas garanti d'être dans la "
"même position que le nœud :ref:`ARVROrigin <class_ARVROrigin>`."

msgid ""
"The :ref:`ARVRController <class_ARVRController>` node represents a VR "
"controller. The :ref:`ARVRController <class_ARVRController>` will follow the "
"position and rotation of the VR controller relative to the :ref:`ARVROrigin "
"<class_ARVROrigin>` node. All of the input for the VR controllers happens "
"through the :ref:`ARVRController <class_ARVRController>` node. An :ref:"
"`ARVRController <class_ARVRController>` node with an ``ID`` of ``1`` "
"represents the left VR controller, while an :ref:`ARVRController "
"<class_ARVRController>` controller with an ``ID`` of ``2`` represents the "
"right VR controller."
msgstr ""
"Le nœud :ref:`ARVRController <class_ARVRController>` représente un "
"contrôleur VR. Le :ref:`ARVRController <class_ARVRController>` suivra la "
"position et la rotation du contrôleur VR par rapport au nœud :ref:"
"`ARVROrigin <class_ARVROrigin>`. Toutes les entrées pour les contrôleurs VR "
"se font par le nœud :ref:`ARVRController <class_ARVRController>`. Un nœud :"
"ref:`ARVRController <class_ARVRController>` avec un ``ID`` de ``1`` "
"représente le contrôleur VR gauche, tandis qu'un nœud :ref:`ARVRController "
"<class_ARVRController>` avec un ``ID`` de ``2`` représente le contrôleur VR "
"droit."

msgid "To summarize:"
msgstr "Pour résumer :"

msgid ""
"The :ref:`ARVROrigin <class_ARVROrigin>` node is the center of the VR "
"tracking system and is positioned on the floor."
msgstr ""
"Le nœud :ref:`ARVROrigin <class_ARVROrigin>` est le centre du système de "
"suivi de la VR et est positionné au sol."

msgid ""
"The :ref:`ARVRCamera <class_ARVRCamera>` is the player's VR headset and view "
"into the scene."
msgstr ""
"L' :ref:`ARVRCamera <class_ARVRCamera>` est le casque VR du joueur et sa vue "
"dans la scène."

msgid ""
"The :ref:`ARVRCamera <class_ARVRCamera>` node is offset on the Y axis by the "
"user's height."
msgstr ""
"Le nœud :ref:`ARVRCamera <class_ARVRCamera>` est décalé sur l'axe Y de la "
"hauteur de l'utilisateur."

msgid ""
"If the VR system supports room tracking, then the :ref:`ARVRCamera "
"<class_ARVRCamera>` node may be offset on the X and Z axes as the player "
"moves."
msgstr ""
"Si le système de VR supporte le suivi de salle, alors le nœud :ref:"
"`ARVRCamera <class_ARVRCamera>` peut être décalé sur les axes X et Z lorsque "
"le joueur se déplace."

msgid ""
"The :ref:`ARVRController <class_ARVRController>` nodes represent the VR "
"controllers and handle all of the input from the VR controllers."
msgstr ""
"Les nœuds :ref:`ARVRController <class_ARVRController>` représentent les "
"contrôleurs VR et gèrent toutes les entrées des contrôleurs VR."

msgid "Starting VR"
msgstr "Commencer en VR"

msgid ""
"Now that we have gone over the VR nodes, let's start working on the project. "
"While in ``Game.tscn``, select the ``Game`` node and make a new script "
"called ``Game.gd``. In the ``Game.gd`` file, add the following code:"
msgstr ""
"Maintenant que nous avons passé en revue les nœuds VR, commençons à "
"travailler sur le projet. Dans ``Game.tscn``, sélectionnez le nœud ``Game`` "
"et créez un nouveau script appelé ``Game.gd``. Dans le fichier ``Game.gd``, "
"ajoutez le code suivant :"

msgid "Let's go over what this code does."
msgstr "Voyons ce que fait ce code."

msgid ""
"In the ``_ready`` function, we first get the OpenVR VR interface using the "
"``find_interface`` function in the :ref:`ARVRServer <class_ARVRServer>` and "
"assign it to a variable called `VR`. If the :ref:`ARVRServer "
"<class_ARVRServer>` finds an interface with the name OpenVR, it will return "
"it, otherwise it will return ``null``."
msgstr ""
"Dans la fonction ``_ready``, nous obtenons d'abord l'interface VR OpenVR en "
"utilisant la fonction ``find_interface`` dans l' :ref:`ARVRServer "
"<class_ARVRServer>` et nous l'assignons à une variable appelée `VR`. Si l' :"
"ref:`ARVRServer <class_ARVRServer>` trouve une interface avec le nom OpenVR, "
"il la renverra, sinon il renverra ``null``."

msgid ""
"The OpenVR VR interface is not included with Godot by default. You will need "
"to download the OpenVR asset from the `Asset Library <https://godotengine."
"org/asset-library/asset/150>`__ or `GitHub <https://github.com/GodotVR/godot-"
"openvr-asset>`__."
msgstr ""
"L'interface OpenVR VR n'est pas incluse par défaut avec Godot. Vous devrez "
"télécharger l'asset OpenVR à partir de la `Bibliothèque d'assets <https://"
"godotengine.org/asset-library/asset/150>`__ ou `GitHub <https://github.com/"
"GodotVR/godot-openvr-asset>`__."

msgid ""
"The code then combines two conditionals, one to check if the `VR` variable "
"is NOT null (``if VR``) and another calls the initialize function, which "
"returns a boolean based on whether the OpenVR interface was able to "
"initialize or not. If both of these conditionals return true, then we can "
"turn the main Godot :ref:`Viewport <class_Viewport>` into an ARVR viewport."
msgstr ""
"Le code combine alors deux conditionnels, l'un pour vérifier si la variable "
"`VR` n'est PAS nulle (``if VR``) et l'autre appelle la fonction "
"d'initialisation, qui renvoie un booléen basé sur le fait que l'interface "
"OpenVR a pu s'initialiser ou non. Si ces deux conditions renvoient vrai, "
"alors nous pouvons transformer le :ref:`Viewport <class_Viewport>` Godot "
"principal en un viewport ARVR."

msgid ""
"If the VR interface initialized successfully, we then get the root :ref:"
"`Viewport <class_Viewport>` and set the `arvr` property to ``true``. This "
"will tell Godot to use the initialized ARVR interface to drive the :ref:"
"`Viewport <class_Viewport>` display."
msgstr ""
"Si l'interface VR s'est initialisée avec succès, nous obtenons alors la "
"racine :ref:`Viewport <class_Viewport>` et définissons la propriété `arvr` à "
"``true``. Cela indiquera à Godot d'utiliser l'interface ARVR initialisée "
"pour piloter l'affichage :ref:`Viewport <class_Viewport>`."

msgid ""
"Finally, we disable VSync so the Frames Per Second (FPS) is not capped by "
"the computer monitor. After this we tell Godot to render at ``90`` frames "
"per second, which is the standard for most VR headsets. Without disabling "
"VSync, the normal computer monitor may limit the frame rate of the VR "
"headset to the frame rate of the computer monitor."
msgstr ""
"Enfin, nous désactivons VSync pour que le nombre d'images par seconde (FPS) "
"ne soit pas plafonné par l'écran de l'ordinateur. Après cela, nous disons à "
"Godot de rendre à ``90`` images par seconde, ce qui est la norme pour la "
"plupart des casques VR. Sans désactiver VSync, l'écran normal de "
"l'ordinateur peut limiter la fréquence d'images du casque VR à celle de "
"l'écran d'ordinateur."

msgid ""
"In the project settings, under the ``Physics->Common`` tab, the physics FPS "
"has been set to ``90``. This makes the physics engine run at the same frame "
"rate as the VR display, which makes physics reactions look smoother when in "
"VR."
msgstr ""
"Dans les paramètres du projet, sous l'onglet ``Physics->Common``, le FPS "
"physique a été réglé sur ``90``. Le moteur physique fonctionne ainsi à la "
"même fréquence d'images que l'affichage de la VR, ce qui donne aux réactions "
"physiques une apparence plus lisse en VR."

msgid ""
"That is all we need to do for Godot to launch OpenVR within the project! Go "
"ahead and give it a try if you want. Assuming everything works, you will be "
"able to look around the world. If you have a VR headset with room tracking, "
"then you will be able to move around the scene within the limits of the room "
"tracking."
msgstr ""
"C'est tout ce que nous devons faire pour que Godot lance OpenVR dans le "
"cadre du projet ! Allez-y, essayez si vous voulez. En supposant que tout "
"fonctionne, vous pourrez regarder le monde autour. Si vous avez un casque VR "
"avec suivi de pièce, vous pourrez alors vous déplacer dans les limites du "
"suivi de pièce."

msgid "Creating the controllers"
msgstr "Création des contrôleurs"

msgid ""
"Right now all that the VR user can do is stand around, which isn't really "
"what we are going for unless we are working on a VR film. Lets write the "
"code for the VR controllers. We are going to write all the code for the VR "
"controllers in one go, so the code is rather long. That said, once we are "
"finished you will be able to teleport around the scene, artificially move "
"using the touchpad/joystick on the VR controller, and be able to pick up, "
"drop, and throw :ref:`RigidBody <class_RigidBody>`-based nodes."
msgstr ""
"Pour l'instant, tout ce que l'utilisateur VR peut faire, c'est rester "
"debout, ce qui n'est pas vraiment ce que nous recherchons, à moins de "
"travailler sur un film de VR. Écrivons le code pour les contrôleurs de la "
"VR. Nous allons écrire tout le code pour les contrôleurs de la VR en une "
"seule fois, donc le code est assez long. Cela dit, une fois que nous aurons "
"terminé, vous pourrez vous téléporter dans la scène, vous déplacer "
"artificiellement à l'aide du touchpad/joystick du contrôleur VR, et être "
"capable de prendre, déposer et lancer des nœuds basés sur :ref:`RigidBody "
"<class_RigidBody>`."

msgid ""
"First we need to open the scene used for the VR controllers. "
"``Left_Controller.tscn`` or ``Right_Controller.tscn``. Let's briefly go over "
"how the scene is setup."
msgstr ""
"Nous devons d'abord ouvrir la scène utilisée pour les contrôleurs de la VR. "
"``Left_Controller.tscn`` ou ``Right_Controller.tscn``. Voyons brièvement "
"comment la scène est mise en place."

msgid "How the VR controller scene is setup"
msgstr "Comment la scène du contrôleur de la VR est configurée"

msgid ""
"In both scenes the root node is a ARVRController node. The only difference "
"is that the ``Left_Controller`` scene has the ``Controller Id`` property set "
"to ``1`` while the ``Right_Controller`` has the ``Controller Id`` property "
"set to ``2``."
msgstr ""
"Dans les deux scènes, le nœud racine est un nœud ARVRController. La seule "
"différence est que la scène ``Left_Controller`` a la propriété ``Controller "
"Id`` fixée à ``1`` alors que la scène ``Right_Controller`` a la propriété "
"``Controller Id`` fixée à ``2``."

msgid ""
"The :ref:`ARVRServer <class_ARVRServer>` attempts to use these two IDs for "
"the left and right VR controllers. For VR systems that support more than 2 "
"controllers/tracked-objects, these IDs may need adjusting."
msgstr ""
"L' :ref:`ARVRServer <class_ARVRServer>` tente d'utiliser ces deux ID pour "
"les contrôleurs VR gauche et droit. Pour les systèmes de VR qui prennent en "
"charge plus de 2 contrôleurs/objets suivis, ces identifiants peuvent "
"nécessiter un ajustement."

msgid ""
"Next is the ``Hand`` :ref:`MeshInstance <class_MeshInstance>` node. This "
"node is used to display the hand mesh that will be used when the VR "
"controller is not holding onto a :ref:`RigidBody <class_RigidBody>` node. "
"The hand in the ``Left_Controller`` scene is a left hand, while the hand on "
"the ``Right_Controller`` scene is a right hand."
msgstr ""
"Ensuite, il y a le nœud ``Hand`` :ref:`MeshInstance <class_MeshInstance>`. "
"Ce nœud est utilisé pour afficher le maillage de la main qui sera utilisé "
"lorsque le contrôleur VR ne tient pas un nœud :ref:`RigidBody "
"<class_RigidBody>`. La main dans la scène ``Left_Controller`` est une main "
"gauche, tandis que la main dans la scène ``Right_Controller`` est une main "
"droite."

msgid ""
"The node named ``Raycast`` is a :ref:`Raycast <class_Raycast>` node that is "
"used for aiming where to teleport to when the VR controller is teleporting. "
"The length of the :ref:`Raycast <class_Raycast>` is set to ``-16`` on the Y "
"axis and is rotated so that it points out of the pointer finger of the hand. "
"The ``Raycast`` node has a single child node, ``Mesh``, that is a :ref:"
"`MeshInstance <class_MeshInstance>`. This is used for visually showing where "
"the teleportation :ref:`Raycast <class_Raycast>` is aiming."
msgstr ""
"Le nœud nommé ``Raycast`` est un nœud :ref:`Raycast <class_Raycast>` qui est "
"utilisé pour viser où téléporter lorsque le contrôleur VR téléporte. La "
"longueur du :ref:`Raycast <class_Raycast>` est fixée à ``-16`` sur l'axe Y "
"et est tournée de manière à pointer depuis le doigt de la main. Le nœud "
"``Raycast`` a un seul nœud enfant, ``Mesh``, qui est un :ref:`MeshInstance "
"<class_MeshInstance>`. Il est utilisé pour montrer visuellement où le :ref:"
"`Raycast <class_Raycast>` de téléportation vise."

msgid ""
"The node named ``Area`` is a :ref:`Area <class_Area>` node will be used for "
"grabbing :ref:`RigidBody <class_RigidBody>`-based nodes when the VR "
"controller grab mode is set to ``AREA``. The ``Area`` node has a single "
"child node, ``CollisionShape``, that defines a sphere :ref:`CollisionShape "
"<class_CollisionShape>`. When the VR controller is not holding any objects "
"and the grab button is pressed, the first :ref:`RigidBody <class_RigidBody>`-"
"based node within the ``Area`` node will be picked up."
msgstr ""
"Le nœud nommé ``Area`` est un nœud :ref:`Area <class_Area>` sera utilisé "
"pour la saisie :ref:`RigidBody <class_RigidBody>` des nœuds basés sur le "
"contrôleur VR lorsque le mode de saisie est réglé sur ``AREA``. Le nœud "
"``Area`` a un seul nœud enfant, ``CollisionShape``, qui définit une sphère : "
"ref:`CollisionShape <class_CollisionShape>`. Lorsque le contrôleur VR ne "
"tient aucun objet et que le bouton de saisie est enfoncé, le premier nœud "
"basé sur :ref:`RigidBody <class_RigidBody>` dans le nœud ``Area`` sera "
"récupéré."

msgid ""
"Next is a :ref:`Position3D <class_Position3D>` node called ``Grab_Pos``. "
"This is used to define the position that grabbed :ref:`RigidBody "
"<class_RigidBody>` nodes will follow then they are held by the VR controller."
msgstr ""
"Ensuite, il y a un nœud :ref:`Position3D <class_Position3D>` appelé "
"``Grab_Pos``. Celui-ci est utilisé pour définir la position où ont été saisi "
"les nœuds :ref:`RigidBody <class_RigidBody>` qui suivront et seront tenus "
"par le contrôleur VR."

msgid ""
"A large :ref:`Area <class_Area>` node called ``Sleep_Area`` is used to "
"disable sleeping for any RigidBody nodes within its :ref:`CollisionShape "
"<class_CollisionShape>`, simple called ``CollisionShape``. This is needed "
"because if a :ref:`RigidBody <class_RigidBody>` node falls asleep, then the "
"VR controller will be unable to grab it. By using ``Sleep_Area``, we can "
"write code that makes any :ref:`RigidBody <class_RigidBody>` node within it "
"not able to sleep, therefore allowing the VR controller to grab it."
msgstr ""
"Un grand nœud :ref:`Area <class_Area>` appelé ``Sleep_Area`` est utilisé "
"pour désactiver la mise en sommeil de tout nœud RigidBody dans la zone de "
"sa :ref:`CollisionShape <class_CollisionShape>`, simplement appelé "
"``CollisionShape``. Ceci est nécessaire car si un nœud :ref:`RigidBody "
"<class_RigidBody>` s'endort, alors le contrôleur VR sera incapable de le "
"saisir. En utilisant ``Sleep_Area``, nous pouvons écrire un code qui rend "
"n'importe quel nœud :ref:`RigidBody <class_RigidBody>` à l'intérieur de "
"celui-ci incapable de dormir, permettant ainsi au contrôleur VR de le saisir."

msgid ""
"An :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node called "
"``AudioStreamPlayer3D`` has a sound loaded that we will use when an object "
"has been picked up, dropped or thrown by the VR controller. While this is "
"not necessary for the functionality of the VR controller, it makes grabbing "
"and dropping objects feel more natural."
msgstr ""
"Un nœud :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` appelé "
"``AudioStreamPlayer3D`` a un son chargé que nous utiliserons quand un objet "
"a été ramassé, déposé ou lancé par le contrôleur VR. Bien que cela ne soit "
"pas nécessaire pour la fonctionnalité du contrôleur VR, cela donne une "
"impression plus naturel lorsqu'on saisit et laisse tomber des objets."

msgid ""
"Finally, the last nodes are the ``Grab_Cast`` node and it's only child node, "
"``Mesh``. The ``Grab_Cast`` node will be used for grabbing :ref:`RigidBody "
"<class_RigidBody>`-based nodes when the VR controller grab mode is set to "
"``RAYCAST``. This will allow the VR controller to grab objects that are just "
"slightly out of reach using a Raycast. The ``Mesh`` node is used for "
"visually showing where the teleportation :ref:`Raycast <class_Raycast>` is "
"aiming."
msgstr ""
"Enfin, les derniers nœuds sont les nœuds ``Grab_Cast`` et son seul enfant, "
"``Mesh``. Le nœud ``Grab_Cast`` sera utilisé pour la saisie des nœuds basés "
"sur :ref:`RigidBody <class_RigidBody>` lorsque le mode de saisie du "
"contrôleur VR est réglé sur ``RAYCAST``. Cela permettra au contrôleur VR de "
"saisir des objets qui sont juste un peu hors de portée en utilisant un "
"Raycast. Le nœud ``Mesh`` est utilisé pour montrer visuellement où le :ref:"
"`Raycast <class_Raycast>` de téléportation vise."

msgid ""
"That is a quick overview of how the VR controller scenes are setup, and how "
"we will be using the nodes to provide the functionality for them. Now that "
"we have looked at the VR controller scene, let's write the code that will "
"drive them."
msgstr ""
"C'est un aperçu rapide de la manière dont les scènes du contrôleur VR sont "
"configurées et de la manière dont nous utiliserons les nœuds pour leur "
"fournir les fonctionnalités. Maintenant que nous avons examiné la scène du "
"contrôleur de la VR, écrivons le code qui les pilotera."

msgid "The code for the VR controllers"
msgstr "Le code pour les contrôleurs VR"

msgid ""
"Select the root node of the scene, either ``Right_Controller`` or "
"``Left_Controller``, and make a new script called ``VR_Controller.gd``. Both "
"scenes will be using the same script, so it doesn't matter which you use "
"first. With ``VR_Controller.gd`` opened, add the following code:"
msgstr ""
"Sélectionnez le nœud racine de la scène, soit ``Right_Controller`` soit "
"``Left_Controller``, et faites un nouveau script appelé ``VR_Controller."
"gd``. Les deux scènes utiliseront le même script, donc peu importe lequel "
"vous utilisez en premier. Avec ``VR_Controller.gd`` ouvert, ajoutez le code "
"suivant :"

msgid ""
"You can copy and paste the code from this page directly into the script "
"editor."
msgstr ""
"Vous pouvez copier et coller le code de cette page directement dans "
"l'éditeur de script."

msgid ""
"If you do this, all the code copied will be using spaces instead of tabs."
msgstr ""
"Si vous faites cela, tout le code copié utilisera des espaces au lieu de "
"tabulations."

msgid ""
"To convert the spaces to tabs in the script editor, click the ``Edit`` menu "
"and select ``Convert Indent To Tabs``. This will convert all the spaces into "
"tabs. You can select ``Convert Indent To Spaces`` to convert tabs back into "
"spaces."
msgstr ""
"Pour convertir les espaces en tabulations dans l'éditeur de script, cliquez "
"sur le menu ``Edit`` et sélectionnez ``Convert Indent To Tabs``. Ceci "
"convertira tous les espaces en tabulations. Vous pouvez sélectionner "
"``Convert Indent To Spaces`` pour convertir les tabulations en espaces."

msgid ""
"This is quite a bit of code to go through. Let's go through what the code "
"does step-by-step."
msgstr ""
"C'est beaucoup de code à parcourir. Passons en revue, étape par étape, ce "
"que fait le code."

msgid "Explaining the VR controller code"
msgstr "Explication du code du contrôleur VR"

msgid "First, let's go through all the class variables in the script:"
msgstr ""
"Tout d'abord, passons en revue toutes les variables de classe dans le "
"script :"

msgid ""
"``controller_velocity``: A variable to hold a rough approximation of the VR "
"controller's velocity."
msgstr ""
"``controller_velocity`` : Une variable qui contient une approximation de la "
"vitesse du contrôleur VR."

msgid ""
"``prior_controller_position``: A variable to hold the VR controller's last "
"position in 3D space."
msgstr ""
"``prior_controller_position`` : Une variable pour maintenir la dernière "
"position du contrôleur VR dans l'espace 3D."

msgid ""
"``prior_controller_velocities``: An Array to hold the last 30 calculated VR "
"controller velocities. This is used to smooth the velocity calculations over "
"time."
msgstr ""
"``prior_controller_velocities`` : Un Array qui contient les 30 dernières "
"vitesses calculées du contrôleur VR. Cela permet de lisser les calculs de "
"vitesse dans le temps."

msgid ""
"``held_object``: A variable to hold a reference to the object the VR "
"controller is holding. If the VR controller is not holding any objects, this "
"variable will be ``null``."
msgstr ""
"``held_object`` : Une variable qui contient une référence à l'objet que le "
"contrôleur VR détient. Si le contrôleur VR ne déient aucun objet, cette "
"variable sera ``null``."

msgid ""
"``held_object_data``: A dictionary to hold data for the :ref:`RigidBody "
"<class_RigidBody>` node being held by the VR controller. This is used to "
"reset the :ref:`RigidBody <class_RigidBody>`'s data when it is no longer "
"held."
msgstr ""
"``held_object_data`` : Un dictionnaire pour contenir les données du nœud :"
"ref:`RigidBody <class_RigidBody>` détenu par le contrôleur VR. Ceci est "
"utilisé pour réinitialiser les données du :ref:`RigidBody <class_RigidBody>` "
"lorsqu'elles ne sont plus conservées."

msgid ""
"``grab_area``: A variable to hold the :ref:`Area <class_Area>` node used to "
"grab objects with the VR controller."
msgstr ""
"``grab_area`` : Une variable pour contenir le nœud :ref:`Area <class_Area>` "
"utilisé pour saisir des objets avec le contrôleur VR."

msgid ""
"``grab_raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` node "
"used to grab objects with the VR controller."
msgstr ""
"``grab_raycast`` : Une variable pour contenir le nœud :ref:`Raycast "
"<class_Raycast>` utilisé pour saisir des objets avec le contrôleur VR."

msgid ""
"``grab_mode``: A variable to define the grab mode the VR controller is "
"using. There are only two modes for grabbing objects in this tutorial, "
"``AREA`` and ``RAYCAST``."
msgstr ""
"``grab_mode`` : Une variable permettant de définir le mode de saisie utilisé "
"par le contrôleur VR. Il n'y a que deux modes de saisie d'objets dans ce "
"tutoriel, ``AREA`` et ``RAYCAST``."

msgid ""
"``grab_pos_node``: A variable to hold the node that will be used to update "
"the position and rotation of held objects."
msgstr ""
"``grab_pos_node`` : Une variable qui contient le nœud qui sera utilisée pour "
"mettre à jour la position et la rotation des objets tenus."

msgid ""
"``hand_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that contains the hand mesh for the VR "
"controller. This mesh will be shown when the VR controller is not holding "
"anything."
msgstr ""
"``hand_mesh`` : Une variable pour contenir le nœud :ref:`MeshInstance "
"<class_MeshInstance>` qui contient le maillage de la main du contrôleur VR. "
"Ce maillage s'affiche lorsque le contrôleur de la RV ne tient rien."

msgid ""
"``hand_pickup_drop_sound``: A variable to hold the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node that contains the pickup/drop sound."
msgstr ""
"``hand_pickup_drop_sound`` : Une variable pour contenir le nœud :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` qui contient le son pickup/"
"drop."

msgid ""
"``teleport_pos``: A variable to hold the position the player will be "
"teleported to when the VR controller teleports the player."
msgstr ""
"``teleport_pos`` : Une variable pour maintenir la position à laquelle le "
"joueur sera téléporté lorsque le contrôleur de la VR téléporte le joueur."

msgid ""
"``teleport_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node used to show where the player is teleporting to."
msgstr ""
"``teleport_mesh`` : Une variable pour contenir le nœud :ref:`MeshInstance "
"<class_MeshInstance>` utilisé pour montrer où le lecteur se téléporte."

msgid ""
"``teleport_button_down``: A variable used to track whether the controller's "
"teleport button is held down. This will be used to detect if this VR "
"controller is trying to teleport the player."
msgstr ""
"``teleport_button_down`` : Une variable utilisée pour savoir si le bouton de "
"téléportation du contrôleur est maintenu enfoncé. Cela sera utilisé pour "
"détecter si ce contrôleur VR essaie de téléporter le joueur."

msgid ""
"``teleport_raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` "
"node used to calculate the teleport position. This node also has a :ref:"
"`MeshInstance <class_MeshInstance>` that acts as a 'laser sight' for aiming."
msgstr ""
"``teleport_raycast`` : Une variable qui contient le nœud :ref:`Raycast "
"<class_Raycast>` utilisé pour calculer la position de téléportation. Ce nœud "
"a également un :ref:`MeshInstance <class_MeshInstance>` qui agit comme un "
"'laser sight' pour la visée."

msgid ""
"``CONTROLLER_DEADZONE``: A constant to define the deadzone for both the "
"trackpad and the joystick on the VR controller. See the note below for more "
"information."
msgstr ""
"``CONTROLLER_DEADZONE`` : Une constante permettant de définir la zone morte "
"pour le trackpad et le joystick du contrôleur VR. Voir la note ci-dessous "
"pour plus d'informations."

msgid ""
"``MOVEMENT_SPEED``: A constant to define the speed the player moves at when "
"using the trackpad/joystick to move artificially."
msgstr ""
"``MOVEMENT_SPEED`` : Une constante pour définir la vitesse à laquelle le "
"joueur se déplace lorsqu'il utilise le trackpad/joystick pour se déplacer "
"artificiellement."

msgid ""
"``CONTROLLER_RUMBLE_FADE_SPEED``: A constant to define how fast the VR "
"controller rumble fades."
msgstr ""
"``CONTROLLER_RUMBLE_FADE_SPEED`` : Une constante pour définir la vitesse à "
"laquelle le grondement du contrôleur VR s'estompe."

msgid ""
"``directional_movement``: A variable to hold whether this VR controller is "
"moving the player using the touchpad/joystick."
msgstr ""
"``directional_movement`` : Une variable qui permet de savoir si ce "
"contrôleur de VR déplace le joueur à l'aide du touchpad/joystick."

msgid ""
"You can find a great article explaining all about how to handle touchpad/"
"joystick dead zones `here <https://web.archive.org/web/20191208161810/http://"
"www.third-helix.com/2013/04/12/doing-thumbstick-dead-zones-right.html>`__."
msgstr ""
"Vous pouvez trouver un bon article qui explique tout sur la façon de gérer "
"les zones mortes des touchpad/joystick : `ici <https://web.archive.org/"
"web/20191208161810/http://www.third-helix.com/2013/04/12/doing-thumbstick-"
"dead-zones-right.html>`__."

msgid ""
"We are using a translated version of the scaled radial dead zone code "
"provided in that article for the VR controller's joystick/touchpad. The "
"article is a great read, and I highly suggest giving it a look!"
msgstr ""
"Nous utilisons une version traduite du code de zone morte radiale mis à "
"l'échelle fourni dans cet article pour le joystick/touchpad du contrôleur "
"VR. L'article est une excellente lecture, et je vous conseille vivement d'y "
"jeter un coup d'œil !"

msgid ""
"That is quite a few class variables. Most of them are used to hold "
"references to nodes we will need throughout the code. Next let's start "
"looking at the functions, starting with the ``_ready`` function."
msgstr ""
"Cela représente un certain nombre de variables de classe. La plupart d'entre "
"eux sont utilisés pour contenir des références aux nœuds dont nous aurons "
"besoin tout au long du code. Commençons ensuite par examiner les fonctions, "
"en commençant par la fonction ``_ready``."

msgid "``_ready`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``_ready``"

msgid ""
"First we tell Godot to silence the warnings about not using the values "
"returned by the ``connect`` function. We will not need the returned values "
"for this tutorial."
msgstr ""
"Nous disons d'abord à Godot de faire taire les avertissements concernant la "
"non-utilisation des valeurs renvoyées par la fonction ``connect``. Nous "
"n'aurons pas besoin des valeurs renvoyées pour ce tutoriel."

msgid ""
"Next we get the :ref:`Raycast <class_Raycast>` node we are going to use for "
"determining the position for teleporting and assign it to the "
"``teleport_raycast`` variable. We then get the :ref:`MeshInstance "
"<class_MeshInstance>` node that we will use to show where the player will be "
"teleporting to. The node we are using for teleporting is a child of the "
"``Game`` scene. We do this so the teleport mesh node is not effected by "
"changes in the VR controller, and so the teleport mesh can be used by both "
"VR controllers."
msgstr ""
"Ensuite, nous obtenons le nœud :ref:`Raycast <class_Raycast>` que nous "
"allons utiliser pour déterminer la position de téléportation et l'assignons "
"à la variable ``teleport_raycast``. Nous obtenons alors le nœud :ref:"
"`MeshInstance <class_MeshInstance>` que nous utiliserons pour montrer où le "
"joueur se téléportera. Le nœud que nous utilisons pour la téléportation est "
"un enfant de la scène ``Game``. Nous faisons cela pour que le nœud de "
"maillage de téléportation ne soit pas affecté par des changements dans le "
"contrôleur VR, et donc que le maillage de téléportation puisse être utilisé "
"par les deux contrôleurs VR."

msgid ""
"Then the ``teleport_button_down`` variable is set to false, ``teleport_mesh."
"visible`` is set to ``false``, and ``teleport_raycast.visible`` is set to "
"``false``. This sets up the variables for teleporting the player into their "
"initial, not teleporting the player, state."
msgstr ""
"Ensuite, la variable ``teleport_button_down`` est définie sur false, "
"``teleport_mesh.visible`` est définie sur ``false`` et ``teleport_raycast."
"visible`` est définie sur ``false``. Ceci définit les variables pour "
"téléporter le joueur dans son état initial, ne téléporte pas le joueur."

msgid ""
"The code then gets the ``grab_area`` node, the ``grab_raycast`` node, and "
"the ``grab_pos_node`` node and assigns them all to their respective "
"variables for use later."
msgstr ""
"Le code obtient alors le nœud ``grab_area``, le nœud ``grab_raycast`` et le "
"nœud ``grab_pos_node`` et les assigne tous à leurs variables respectives "
"pour une utilisation ultérieure."

msgid ""
"Next the ``grab_mode`` is set to ``AREA`` so the VR controller will attempt "
"to grab objects using the :ref:`Area <class_Area>` node defined in "
"``grab_area`` when the VR controller's grab/grip button is pressed. We also "
"set the ``grab_raycast`` node's ``visible`` property to ``false`` so the "
"'laser sight' child node of ``grab_raycast`` is not visible."
msgstr ""
"Ensuite, le ``grab_mode`` est réglé sur ``AREA`` donc le contrôleur VR va "
"tenter de saisir des objets en utilisant le nœud :ref:`Area <class_Area>` "
"défini dans ``grab_area`` lorsque le bouton de saisie du contrôleur VR est "
"pressé. Nous avons également défini la propriété ``visible`` du nœud "
"``grab_raycast`` à ``false``, de sorte que le nœud enfant 'laser sight' de "
"``grab_raycast`` n'est pas visible."

msgid ""
"After that we connect the ``body_entered`` and ``body_exited`` signals from "
"the ``Sleep_Area`` node in the VR controller to the ``sleep_area_entered`` "
"and ``sleep_area_exited`` functions. The ``sleep_area_entered`` and "
"``sleep_area_exited`` functions will be used to make :ref:`RigidBody "
"<class_RigidBody>` nodes unable to sleep when nearby the VR controller."
msgstr ""
"Ensuite, nous connectons les signaux ``body_entered`` et ``body_exited`` du "
"nœud ``Sleep_Area`` du contrôleur VR aux fonctions ``sleep_area_entered`` et "
"``sleep_area_exited``. Les fonctions ``sleep_area_entered`` et "
"``sleep_area_exited`` seront utilisées pour rendre les nœuds :ref:`RigidBody "
"<class_RigidBody>` incapables de dormir lorsqu'ils sont à proximité du "
"contrôleur VR."

msgid ""
"Then the ``hand_mesh`` and ``hand_pickup_drop_sound`` nodes are gotten and "
"assigned them to their respective variables for use later."
msgstr ""
"Ensuite, les nœuds ``hand_mesh`` et ``hand_pickup_drop_sound`` sont obtenus "
"et assignés à leurs variables respectives pour une utilisation ultérieure."

msgid ""
"Finally, the ``button_pressed`` and ``button_release`` signals in the :ref:"
"`ARVRController <class_ARVRController>` node, which the VR controller "
"extends, are connected to the ``button_pressed`` and ``button_released`` "
"functions respectively. This means that when a button on the VR controller "
"is pressed or released, the ``button_pressed`` or ``button_released`` "
"functions defined in this script will be called."
msgstr ""
"Enfin, les signaux ``button_pressed`` et ``button_release`` dans le nœud :"
"ref:`ARVRController <class_ARVRController>`, que le contrôleur VR étend, "
"sont connectés aux fonctions ``button_pressed`` et ``button_released`` "
"respectivement. Cela signifie que lorsqu'un bouton du contrôleur VR est "
"pressé ou relâché, les fonctions ``button_pressed`` or ``button_released`` "
"définies dans ce script seront appelées."

msgid "``_physics_process`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``_physics_process``"

msgid ""
"First we check to see if the ``rumble`` variable is more than zero. If the "
"``rumble`` variable, which is a property of the :ref:`ARVRController "
"<class_ARVRController>` node, is more than zero then the VR controller "
"rumbles."
msgstr ""
"Nous vérifions d'abord si la variable ``rumble`` est supérieure à zéro. Si "
"la variable ``rumble``, qui est une propriété du nœud :ref:`ARVRController "
"<class_ARVRController>`, est supérieure à zéro, alors le contrôleur VR "
"gronde."

msgid ""
"If the ``rumble`` variable is more than zero, then we reduce the rumble by "
"``CONTROLLER_RUMBLE_FADE_SPEED`` every second by subtracting "
"``CONTROLLER_RUMBLE_FADE_SPEED`` multiplied by delta. There is then a ``if`` "
"condition to check if ``rumble`` is less than zero, which sets ``rumble`` to "
"zero if its value is less than zero."
msgstr ""
"Si la variable ``rumble`` est supérieure à zéro, alors nous réduisons le "
"grondement par ``CONTROLLER_RUMBLE_FADE_SPEED`` toutes les secondes en "
"soustrayant ``CONTROLLER_RUMBLE_FADE_SPEED`` multiplié par delta. Il y a "
"ensuite une condition ``if`` pour vérifier si ``rumble`` est inférieur à "
"zéro, qui met ``rumble`` à zéro si sa valeur est inférieure à zéro."

msgid ""
"This small section of code is all we need for reducing the VR controller's "
"rumble. Now when we set ``rumble`` to a value, this code will automatically "
"make it fade over time."
msgstr ""
"Cette petite section de code est tout ce dont nous avons besoin pour réduire "
"le grondement du contrôleur VR. Maintenant, lorsque nous fixons une valeur à "
"``rumble``, ce code la fera automatiquement disparaître avec le temps."

msgid ""
"The first section of code checks to see if the ``teleport_button_down`` "
"variable is equal to ``true``, which means this VR controller is trying to "
"teleport."
msgstr ""
"La première section du code vérifie si la variable ``teleport_button_down`` "
"est égale à ``true``, ce qui signifie que ce contrôleur VR essaie de "
"téléporter."

msgid ""
"If ``teleport_button_down`` is equal to ``true``, we force the "
"``teleport_raycast`` :ref:`Raycast <class_Raycast>` node to update using the "
"``force_raycast_update`` function. The ``force_raycast_update`` function "
"will update the properties within the :ref:`Raycast <class_Raycast>` node "
"with the latest version of the physics world."
msgstr ""
"Si ``teleport_button_down`` est égal à ``true``, nous forçons le nœud "
"``teleport_raycast`` :ref:`Raycast <class_Raycast>` à se mettre à jour en "
"utilisant la fonction ``force_raycast_update``. La fonction "
"``force_raycast_update`` met à jour les propriétés du nœud :ref:`Raycast "
"<class_Raycast>` avec la dernière version du monde physique."

msgid ""
"The code then checks to see if the ``teleport_raycast`` collided with "
"anything by checking of the ``is_colliding`` function in "
"``teleport_raycast`` is true. If the :ref:`Raycast <class_Raycast>` collided "
"with something, we then check to see if the :ref:`PhysicsBody "
"<class_PhysicsBody>` the raycast collided with is a :ref:`StaticBody "
"<class_StaticBody>` or not. We then check to see if the collision normal "
"vector returned by the raycast is greater than or equal to ``0.85`` on the Y "
"axis."
msgstr ""
"Le code vérifie ensuite si le ``teleport_raycast`` est entré en collision "
"avec quelque chose en vérifiant si la fonction ``is_colliding`` dans "
"``teleport_raycast`` est vraie. Si le :ref:`Raycast <class_Raycast>` a "
"heurté quelque chose, nous vérifions alors si le :ref:`PhysicsBody "
"<class_PhysicsBody>` avec lequel le raycast s'est heurté est un :ref:"
"`StaticBody <class_StaticBody>` ou non. Nous vérifions ensuite si le vecteur "
"normal de collision renvoyé par le raycast est supérieur ou égal à ``0.85`` "
"sur l'axe Y."

msgid ""
"We do this because we do not want the user to be able to teleport onto "
"RigidBody nodes and we only want the player to be able to teleport on floor-"
"like surfaces."
msgstr ""
"Nous faisons cela parce que nous ne voulons pas que l'utilisateur puisse se "
"téléporter sur des nœuds RigidBody et nous voulons seulement que le joueur "
"puisse se téléporter sur des surfaces ressemblant à un sol."

msgid ""
"If all these conditions are met, then we assign the ``teleport_pos`` "
"variable to the ``get_collision_point`` function in ``teleport_raycast``. "
"This will assign ``teleport_pos`` to the position the raycast collided at in "
"world space. We then move the ``teleport_mesh`` to the world position stored "
"in ``teleport_pos``."
msgstr ""
"Si toutes ces conditions sont remplies, alors nous assignons la variable "
"``teleport_pos`` à la fonction ``get_collision_point`` dans "
"``teleport_raycast``. Cela permettra d'assigner ``teleport_pos`` à la "
"position à laquelle le raycast est entré en collision dans l'espace mondial. "
"Nous déplaçons ensuite le ``teleport_mesh`` vers la position mondiale "
"stockée dans ``teleport_pos``."

msgid ""
"This section of code will get the position the player is aiming at with the "
"teleportation raycast and update the teleportation mesh, giving a visual "
"update on where the user will be teleporting to when the release the "
"teleport button."
msgstr ""
"Cette section de code permet d'obtenir la position que le joueur vise avec "
"le raycast de téléportation et de mettre à jour le maillage de "
"téléportation, donnant une mise à jour visuelle de l'endroit où "
"l'utilisateur se téléportera quand il relâchera le bouton de téléportation."

msgid ""
"The next section of code first checks to see if the VR controller is active "
"through the ``get_is_active`` function, which is defined by :ref:"
"`ARVRController <class_ARVRController>`. If the VR controller is active, "
"then it calls the ``_physics_process_update_controller_velocity`` function."
msgstr ""
"La section suivante du code vérifie d'abord si le contrôleur VR est actif "
"grâce à la fonction ``get_is_active``, qui est définie par :ref:"
"`ARVRController <class_ARVRController>`. Si le contrôleur VR est actif, "
"alors il appelle la fonction ``_physics_process_update_controller_velocity``."

msgid ""
"The ``_physics_process_update_controller_velocity`` function will calculate "
"the VR controller's velocity through changes in position. It is not perfect, "
"but this process gets a rough idea of the velocity of the VR controller, "
"which is fine for the purposes of this tutorial."
msgstr ""
"La fonction ``physics_process_update_controller_velocity`` calculera la "
"vitesse du contrôleur VR en fonction des changements de position. Il n'est "
"pas parfait, mais ce procédé permet d'avoir une idée approximative de la "
"vitesse du contrôleur VR, ce qui est très bien pour les besoins de ce "
"tutoriel."

msgid ""
"The next section of code checks to see if the VR controller is holding an "
"object by checking to see if the ``held_object`` variable is not equal to "
"``null``."
msgstr ""
"La section suivante du code vérifie si le contrôleur VR tient un objet en "
"vérifiant si la variable ``held_object`` n'est pas égale à ``null``."

msgid ""
"If the VR controller is holding an object, we first store it's scale in a "
"temporary variable called ``held_scale``. We then set the "
"``global_transform`` of the held object to the ``global_transform`` of the "
"``held_object`` node. This will make the held object have the same position, "
"rotation, and scale of the ``grab_pos_node`` node in world space."
msgstr ""
"Si le contrôleur VR tient un objet, nous stockons d'abord son échelle dans "
"une variable temporaire appelée ``held_scale``. Nous définissons ensuite la "
"``global_transform`` de l'objet retenu à la ``global_transform`` du nœud "
"``held_object``. L'objet tenu aura ainsi la même position, la même rotation "
"et la même échelle que le nœud ``grab_pos_node`` dans l'espace mondial."

msgid ""
"However, because we do not want the held object to change in scale when it "
"is grabbed, we need to set the ``scale`` property of the ``held_object`` "
"node back to ``held_scale``."
msgstr ""
"Cependant, comme nous ne voulons pas que l'objet retenu change d'échelle "
"lorsqu'il est saisi, nous devons remettre la propriété ``scale`` du nœud "
"``held_object`` à ``held_scale``."

msgid ""
"This section of code will keep the held object in the same position and "
"rotation as the VR controller, keeping it synced with the VR controller."
msgstr ""
"Cette section de code permet de maintenir l'objet tenu dans la même position "
"et rotation que le contrôleur VR, en le gardant synchronisé avec le "
"contrôleur VR."

msgid ""
"Finally, the last section of code simply calls the "
"``_physics_process_directional_movement`` function. This function contains "
"all the code for moving the player when the touchpad/joystick on the VR "
"controller moves."
msgstr ""
"Enfin, la dernière section du code appelle simplement la fonction "
"``_physics_process_directional_movement``. Cette fonction contient tout le "
"code permettant de déplacer le joueur lorsque le touchpad/joystick du "
"contrôleur VR se déplace."

msgid ""
"``_physics_process_update_controller_velocity`` function step-by-step "
"explanation"
msgstr ""
"Explication étape par étape de la fonction "
"``_physics_process_update_controller_velocity``"

msgid ""
"First this function resets the ``controller_velocity`` variable to zero :ref:"
"`Vector3 <class_Vector3>`."
msgstr ""
"Tout d'abord, cette fonction réinitialise la variable "
"``controller_velocity`` à zéro :ref:`Vector3 <class_Vector3>`."

msgid ""
"Then we check to see if there are any stored/cached VR controller velocities "
"saved in the ``prior_controller_velocities`` array. We do this by checking "
"to see if the ``size()`` function returns a value greater than ``0``. If "
"there are cached velocities within ``prior_controller_velocities``, then we "
"iterate through each of the stored velocities using a ``for`` loop."
msgstr ""
"Ensuite, nous vérifions s'il y a des vitesses de contrôleur VR stockées/en "
"cache dans le tableau ``prior_controller_velocities``. Nous le faisons en "
"vérifiant si la fonction ``size()`` renvoie une valeur supérieure à ``0``. "
"S'il y a des vitesses mises en cache dans ``prior_controller_velocities``, "
"alors nous itérons à travers chacune des vitesses stockées en utilisant une "
"boucle ``for``."

msgid ""
"For each of the cached velocities, we simply add its value to "
"``controller_velocity``. Once the code has gone through all of the cached "
"velocities in ``prior_controller_velocities``, we divide "
"``controller_velocity`` by the size of the ``prior_controller_velocities`` "
"array, which will give us the combined velocity value. This helps take the "
"previous velocities into account, making the direction of the controller's "
"velocity more accurate."
msgstr ""
"Pour chacune des vitesses mises en cache, nous ajoutons simplement sa valeur "
"à ``controller_velocity``. Une fois que le code a traversé toutes les "
"vitesses mises en cache dans ``prior_controller_velocities``, nous divisons "
"``controller_velocity`` par la taille du tableau "
"``prior_controller_velocities``, ce qui nous donnera la valeur de vitesse "
"combinée. Cela permet de prendre en compte les vitesses précédentes, ce qui "
"rend la direction de la vitesse du contrôleur plus précise."

msgid ""
"Next we calculate the change in position the VR controller has taken since "
"the last ``_physics_process`` function call. We do this by subtracting "
"``prior_controller_position`` from the global position of the VR controller, "
"``global_transform.origin``. This will give us a :ref:`Vector3 "
"<class_Vector3>` that points from the position in "
"``prior_controller_position`` to the current position of the VR controller, "
"which we store in a variable called ``relative_controller_position``."
msgstr ""
"Ensuite, nous calculons le changement de position du contrôleur VR depuis le "
"dernier appel de fonction ``physics_process``. Nous le faisons en "
"soustrayant la ``prior_controller_position`` de la position globale du "
"contrôleur VR, ``global_transform.origin``. Cela nous donnera un :ref:"
"`Vector3 <class_Vector3>` qui pointe de la position dans "
"``prior_controller_position`` à la position actuelle du contrôleur VR, que "
"nous stockons dans une variable appelée ``relative_controller_position``."

msgid ""
"Next we add the change in position to ``controller_velocity`` so the latest "
"change in position is taken into account in the velocity calculation. We "
"then add ``relative_controller_position`` to ``prior_controller_velocities`` "
"so it can be taken into account on the next calculation of the VR "
"controller's velocity."
msgstr ""
"Ensuite, nous ajoutons le changement de position à ``controller_velocity``, "
"de sorte que le dernier changement de position est pris en compte dans le "
"calcul de la vitesse. Nous ajoutons ensuite la "
"``relative_controller_position`` à la ``prior_controller_velocities`` afin "
"qu'elle puisse être prise en compte dans le prochain calcul de la vitesse du "
"contrôleur VR."

msgid ""
"Then ``prior_controller_position`` is updated with the global position of "
"the VR controller, ``global_transform.origin``. We then divide "
"``controller_velocity`` by ``delta`` so the velocity is higher, giving "
"results like those we expect, while still being relative to the amount of "
"time that has passed. It is not a perfect solution, but the results look "
"decent most of the time and for the purposes of this tutorial, it is good "
"enough."
msgstr ""
"Ensuite, ``prior_controller_position`` est mis à jour avec la position "
"globale du contrôleur VR, ``global_transform.origin``. Nous divisons ensuite "
"la ``controller_velocity`` par le ``delta`` pour que la vitesse soit plus "
"élevée, ce qui donne des résultats comme ceux que nous attendons, tout en "
"étant relatif au temps qui s'est écoulé. Ce n'est pas une solution parfaite, "
"mais les résultats semblent décents la plupart du temps et pour les besoins "
"de ce tutoriel, ils sont suffisants."

msgid ""
"Finally, the function checks to see if the ``prior_controller_velocities`` "
"has more than ``30`` velocities cached by checking if the ``size()`` "
"function returns a value greater than ``30``. If there are more than ``30`` "
"cached velocities stored in ``prior_controller_velocities``, then we simply "
"remove the oldest cached velocity by calling the ``remove`` function and "
"passing in a index position of ``0``."
msgstr ""
"Enfin, la fonction vérifie si la ``prior_controller_velocities`` a plus de "
"``30`` vitesses en cache en vérifiant si la fonction ``size()`` renvoie une "
"valeur supérieure à ``30``. S'il y a plus de ``30`` vitesses mises en cache "
"dans les ``prior_controller_velocities``, alors nous retirons simplement la "
"vitesse la plus ancienne mise en cache en appelant la fonction ``remove`` et "
"en passant à une position d'index de ``0``."

msgid ""
"What this function ultimately does is that it gets a rough idea of the VR "
"controller's velocity by calculating the VR controller's relative changes in "
"position over the last thirty ``_physics_process`` calls. While this is not "
"perfect, it gives a decent idea of how fast the VR controller is moving in "
"3D space."
msgstr ""
"Cette fonction permet en fin de compte d'obtenir une idée approximative de "
"la vitesse du contrôleur VR en calculant les changements relatifs de "
"position du contrôleur VR au cours des trente derniers appels de "
"``_physics_process``. Bien que cela ne soit pas parfait, cela donne une idée "
"décente de la vitesse à laquelle le contrôleur VR se déplace dans l'espace "
"3D."

msgid ""
"``_physics_process_directional_movement`` function step-by-step explanation"
msgstr ""
"Explication étape par étape de la fonction "
"``_physics_process_directional_movement``"

msgid ""
"First this function gets the axes for the trackpad and the joystick and "
"assigns them to :ref:`Vector2 <class_Vector2>` variables called "
"``trackpad_vector`` and ``joystick_vector`` respectively."
msgstr ""
"D'abord, cette fonction récupère les axes du trackpad et du joystick et les "
"assigne à des variables :ref:`Vector2 <class_Vector2>` appelées "
"respectivement ``trackpad_vector`` et ``joystick_vector``."

msgid ""
"You may need to remap the joystick and/or touchpad index values depending on "
"your VR headset and controller. The inputs in this tutorial are the index "
"values of a Windows Mixed Reality headset."
msgstr ""
"Vous devrez peut-être redéfinir les valeurs d'index du joystick et/ou du "
"touchpad en fonction de votre casque et de votre contrôleur VR. Les entrées "
"de ce tutoriel sont les valeurs d'index d'un casque Windows Mixed Reality."

msgid ""
"Then ``trackpad_vector`` and ``joystick_vector`` have their deadzones "
"account for. The code for this is detailed in the article below, with slight "
"changes as the code is converted from C# to GDScript."
msgstr ""
"Ensuite, ``trackpad_vector`` et ``joystick_vector`` ont leurs zones mortes. "
"Le code est détaillé dans l'article ci-dessous, avec de légères "
"modifications au fur et à mesure de la conversion du code C# en GDScript."

msgid ""
"Once the ``trackpad_vector`` and ``joystick_vector`` variables have had "
"their deadzones account for, the code then gets the forward and right "
"direction vectors relative to the global transform of the :ref:`ARVRCamera "
"<class_ARVRCamera>`. What this does is that it gives us vectors that point "
"forward and right relative to the rotation of the user camera, the :ref:"
"`ARVRCamera <class_ARVRCamera>`, in world space. These vectors point in the "
"same direction of the blue and red arrows when you select an object in the "
"Godot editor with the ``local space mode`` button enabled. The forward "
"direction vector is stored in a variable called ``forward_direction``, while "
"the right direction vector is stored in a variable called "
"``right_direction``."
msgstr ""
"Une fois que les variables ``trackpad_vector`` et ``joystick_vector`` ont eu "
"prises en compte leurs zones mortes, le code obtient alors les vecteurs de "
"direction avant et droite par rapport à la transformation globale de la :ref:"
"`ARVRCamera <class_ARVRCamera>`. Cela nous donne des vecteurs qui pointent "
"vers l'avant et vers la droite par rapport à la rotation de la caméra "
"utilisateur, la :ref:`ARVRCamera <class_ARVRCamera>`, dans l'espace mondial. "
"Ces vecteurs pointent dans la même direction que les flèches bleues et "
"rouges lorsque vous sélectionnez un objet dans l'éditeur Godot avec le "
"bouton ``local space mode`` activé. Le vecteur de direction avant est stocké "
"dans une variable appelée ``forward_direction``, tandis que le vecteur de "
"direction droite est stocké dans une variable appelée ``right_direction``."

msgid ""
"Next the code adds the ``trackpad_vector`` and ``joystick_vector`` variables "
"together and normalizes the results using the ``normalized`` function. This "
"gives us the combined movement direction of both input devices, so we can "
"use a single :ref:`Vector2 <class_Vector2>` for moving the user. We assign "
"the combined direction to a variable called ``movement_vector``."
msgstr ""
"Ensuite, le code ajoute les variables ``trackpad_vector`` et "
"``joystick_vector`` ensemble et normalise les résultats en utilisant la "
"fonction ``normalized``. Cela nous donne la direction de mouvement combinée "
"des deux périphériques d'entrée, de sorte que nous pouvons utiliser un seul :"
"ref:`Vecteur2 <classe_Vecteur2>` pour déplacer l'utilisateur. Nous assignons "
"la direction combinée à une variable appelée ``movement_vector``."

msgid ""
"Then we calculate the distance the user will move forward, relative to the "
"forward direction stored in ``forward_direction``. To calculate this, we "
"multiply ``forward_direction`` by ``movement_vector.x``, ``delta``, and "
"``MOVEMENT_SPEED``. This will give us the distance the user will move "
"forward when the trackpad/joystick is pushed forward or backwards. We assign "
"this to a variable called ``movement_forward``."
msgstr ""
"Ensuite, nous calculons la distance que l'utilisateur va parcourir, par "
"rapport à la direction d'avance stockée dans ``forward_direction``. Pour "
"calculer cela, nous multiplions ``forward_direction`` par ``movement_vector."
"x``, ``delta`` et ``MOVEMENT_SPEED``. Cela nous donnera la distance de "
"laquelle l'utilisateur avancera lorsque le trackpad/joystick sera poussé "
"vers l'avant ou vers l'arrière. Nous l'attribuons à une variable appelée "
"``movement_forward``."

msgid ""
"We do a similar calculation for the distance the user will move right, "
"relative to the right direction stored in ``right_direction``. To calculate "
"the distance the user will move right, we multiply ``right_direction`` by "
"``movement_vector.y``, ``delta``, and ``MOVEMENT_SPEED``. This will give us "
"the distance the user will move right when the trackpad/joystick is pushed "
"right or left. We assign this to a variable called ``movement_right``."
msgstr ""
"Nous faisons un calcul similaire pour la distance que l'utilisateur va "
"parcourir vers la droite, par rapport direction droite stockée dans "
"``right_direction``. Pour calculer la distance à laquelle l'utilisateur se "
"déplacera vers la droite, nous multiplions la ``right_direction`` par "
"``movement_vector.y``, ``delta`` et la ``MOVEMENT_SPEED``. Cela nous donnera "
"la distance à laquelle l'utilisateur se déplacera vers la droite lorsque le "
"trackpad/joystick est poussé à droite ou à gauche. Nous l'attribuons à une "
"variable appelée ``movement_right``."

msgid ""
"Next we remove any movement on the ``Y`` axis of ``movement_forward`` and "
"``movement_right`` by assigning their ``Y`` values to ``0``. We do this so "
"the user cannot fly/fall simply by moving the trackpad or joystick. Without "
"doing this, the player could fly in the direction they are facing."
msgstr ""
"Ensuite, nous supprimons tout mouvement sur l'axe ``Y`` de "
"``movement_forward`` et ``movement_right`` en attribuant leur valeur ``Y`` à "
"``0``. Nous faisons cela pour que l'utilisateur ne puisse pas voler/chuter "
"simplement en déplaçant le trackpad ou le joystick. Sans cela, le joueur "
"pourrait voler dans la direction à laquelle il fait face."

msgid ""
"Finally, we check to see if the ``length`` function on ``movement_right`` or "
"``movement_forward`` is greater than ``0``. If it is, then we need to move "
"the user. To move the user, we perform a global translation to the :ref:"
"`ARVROrigin <class_ARVROrigin>` node using ``get_parent().global_translate`` "
"and pass in the ``movement_right`` variable with the ``movement_forward`` "
"variable added to it. This will move the player in the direction the "
"trackpad/joystick is pointing, relative to the rotation of the VR headset. "
"We also set the ``directional_movement`` variable to ``true`` so the code "
"knows this VR controller is moving the player."
msgstr ""
"Enfin, nous vérifions si la fonction ``length`` de ``movement_right`` ou "
"``movement_forward`` est supérieure à ``0``. Si c'est le cas, nous devons "
"déplacer l'utilisateur. Pour déplacer l'utilisateur, nous effectuons une "
"translation globale vers le nœud :ref:`ARVROrigin <class_ARVROrigin>` en "
"utilisant ``get_parent().global_translate`` et nous passons dans la variable "
"``movement_right`` avec la variable ``movement_forward`` ajoutée à celle-ci. "
"Le joueur se déplacera ainsi dans la direction indiquée par le trackpad/"
"joystick, par rapport à la rotation du casque VR. Nous avons aussi mis la "
"variable ``directional_movement`` à ``true`` pour que le code sache que ce "
"contrôleur VR déplace le joueur."

msgid ""
"If the ``length`` function on ``movement_right`` or ``movement_forward`` is "
"less than or equal to ``0``, then we simply set the ``directional_movement`` "
"variable to ``false`` so the code knows this VR controller is not moving the "
"player."
msgstr ""
"Si la fonction ``length`` de ``movement_right`` ou ``movement_forward`` est "
"inférieure ou égale à ``0``, alors nous mettons simplement la variable "
"``directional_movement`` à ``false`` pour que le code sache que ce "
"contrôleur VR ne déplace pas le joueur."

msgid ""
"What this function ultimately does is takes the input from the VR "
"controller's trackpad and joystick and moves the player in the direction the "
"player is pushing them. Movement is relative to the rotation of the VR "
"headset, so if the player pushes forward and turns their head to the left, "
"they will move to the left."
msgstr ""
"Cette fonction permet de prendre les entrées du trackpad et du joystick du "
"contrôleur VR et de déplacer le joueur dans la direction où il les pousse. "
"Le mouvement est relatif à la rotation du casque VR, donc si le joueur "
"pousse vers l'avant et tourne sa tête vers la gauche, il se déplacera vers "
"la gauche."

msgid "``button_pressed`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``button_pressed``"

msgid ""
"This function checks to see if the VR button that was just pressed is equal "
"to one of the VR buttons used in this project. The ``button_index`` variable "
"is passed in by the ``button_pressed`` signal in :ref:`ARVRController "
"<class_ARVRController>`, which we connected in the ``_ready`` function."
msgstr ""
"Cette fonction vérifie si le bouton VR qui vient d'être enfoncé est égal à "
"l'un des boutons VR utilisés dans ce projet. La variable ``button_index`` "
"est passée par le signal ``button_pressed`` dans :ref:`ARVRController "
"<class_ARVRController>`, que nous avons connecté dans la fonction ``ready``."

msgid ""
"There are only three buttons we are looking for in this project: the trigger "
"button, the grab/grip button, and the menu button."
msgstr ""
"Il n'y a que trois boutons que nous recherchons dans ce projet : le bouton "
"de déclenchement, le bouton de saisie et le bouton de menu."

msgid ""
"You may need to remap these button index values depending on your VR headset "
"and controller. The inputs in this tutorial are the index values of a "
"Windows Mixed Reality headset."
msgstr ""
"Vous devrez peut-être redéfinir ces valeurs d'index de bouton en fonction de "
"votre casque VR et de vos contrôleurs. Les entrées de ce tutoriel sont les "
"valeurs d'index d'un casque Windows Mixed Reality."

msgid ""
"First we check if the ``button_index`` is equal to ``15``, which should map "
"to the trigger button on the VR controller. If the button pressed is the "
"trigger button, then the ``_on_button_pressed_trigger`` function is called."
msgstr ""
"Nous vérifions d'abord si ``button_index`` est égal à ``15``, ce qui devrait "
"correspondre au bouton de déclenchement du contrôleur VR. Si le bouton "
"pressé est le bouton de déclenchement, alors la fonction "
"``on_button_pressed_trigger`` est appelée."

msgid ""
"If the ``button_index`` is equal to ``2``, then the grab button was just "
"pressed. If the button pressed is the grab button, the "
"``_on_button_pressed_grab`` function is called."
msgstr ""
"Si ``button_index`` est égal à ``2``, alors le bouton de saisie vient d'être "
"enfoncé. Si le bouton pressé est le bouton de saisie, la fonction "
"``on_button_pressed_grab`` est appelée."

msgid ""
"Finally, if the ``button_index`` is equal to ``1``, then the menu button was "
"just pressed. If the button pressed is the menu button, the "
"``_on_button_pressed_menu`` function is called."
msgstr ""
"Enfin, si ``button_index`` est égal à ``1``, alors le bouton de menu vient "
"d'être enfoncé. Si le bouton pressé est le bouton de menu, la fonction "
"``on_button_pressed_menu`` est appelée."

msgid "``_on_button_pressed_trigger`` function step-by-step explanation"
msgstr ""
"Explication étape par étape de la fonction ``_on_button_pressed_trigger``"

msgid ""
"First this function checks to see if the VR controller is not holding by "
"checking if ``held_object`` is equal to ``null``. If the VR controller is "
"not holding anything, then we assume that the trigger press on the VR "
"controller was for teleporting. We then make sure that ``teleport_mesh."
"visible`` is equal to ``false``. We use this to tell if the other VR "
"controller is trying to teleport or not, as ``teleport_mesh`` will be "
"visible if the other VR controller is teleporting."
msgstr ""
"Cette fonction vérifie d'abord si le contrôleur VR ne tient rien en "
"vérifiant si ``held_object`` est égal à ``null``. Si le contrôleur VR ne "
"tient rien, alors nous supposons que la pression sur le déclencheur du "
"contrôleur VR était pour la téléportation. Nous nous assurons ensuite que "
"``teleport_mesh.visible`` est égal à ``false``. Nous l'utilisons pour savoir "
"si l'autre contrôleur VR essaie de téléporter ou non, car ``teleport_mesh`` "
"sera visible si l'autre contrôleur VR téléporte."

msgid ""
"If ``teleport_mesh.visible`` is equal to ``false``, then we can teleport "
"with this VR controller. We set the ``teleport_button_down`` variable to "
"``true``, set ``teleport_mesh.visible`` to true, and set ``teleport_raycast."
"visible`` to ``true``. This will tell the code in ``_physics_process`` that "
"this VR controller is going to teleport, it will make the ``teleport_mesh`` "
"visible so the user knows where the are teleporting to, and will make "
"``teleport_raycast`` visible to the player has a 'laser sight' they can use "
"to aim the teleportation pos."
msgstr ""
"Si ``teleport_mesh.visible`` est égal à ``false``, alors nous pouvons nous "
"téléporter avec ce contrôleur VR. Nous définissons la variable "
"``teleport_button_down`` à ``true``, nous définissons ``teleport_mesh."
"visible`` à true, et nous définissons ``teleport_raycast.visible`` à "
"``true``. Cela indiquera au code du ``_physics_process`` que ce contrôleur "
"VR va téléporter, il rendra le ``teleport_mesh`` visible pour que "
"l'utilisateur sache où il se téléporte, et rendra le ``teleport_raycast`` "
"visible pour que le joueur dispose d'un 'laser sight' qu'il pourra utiliser "
"pour viser la position de téléportation."

msgid ""
"If ``held_object`` is not equal to ``null``, then the VR controller is "
"holding something. We then check to see if the object that is being held, "
"``held_object``, extends a class called ``VR_Interactable_Rigidbody``. We "
"have not made ``VR_Interactable_Rigidbody`` yet, but "
"``VR_Interactable_Rigidbody`` will be a custom class we will use on all of "
"the special/custom :ref:`RigidBody <class_RigidBody>`-based nodes in the "
"project."
msgstr ""
"Si ``held_object`` n'est pas égal à ``null``, alors le contrôleur VR tient "
"quelque chose. Nous vérifions ensuite si l'objet qui est tenu, "
"``held_object``, étend une classe appelée ``VR_Interactable_Rigidbody``. "
"Nous n'avons pas encore créé ``VR_Interactable_Rigidbody``, mais "
"``VR_Interactable_Rigidbody`` sera une classe personnalisée que nous "
"utiliserons sur tous les nœuds basés sur les :ref:`RigidBody "
"<class_RigidBody>` spéciaux/personnalisés dans le projet."

msgid ""
"Don't worry, we will cover ``VR_Interactable_Rigidbody`` after this section!"
msgstr ""
"Ne vous inquiétez pas, nous couvrirons ``VR_Interactable_Rigidbody`` après "
"cette section !"

msgid ""
"If the ``held_object`` extends ``VR_Interactable_Rigidbody``, then we call "
"the ``interact`` function, so the held object can do whatever it is supposed "
"to do when the trigger is pressed and the object is held by the VR "
"controller."
msgstr ""
"Si l'``held_object`` étend le ``VR_Interactable_Rigidbody``, alors nous "
"appelons la fonction ``interact``, de sorte que l'objet tenu peut faire ce "
"qu'il est censé faire lorsque le déclencheur est pressé et que l'objet est "
"tenu par le contrôleur VR."

msgid "``_on_button_pressed_grab`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``_on_button_pressed_grab``"

msgid ""
"First this function checks to see if ``teleport_button_down`` is equal to "
"``true``. If it is, then it calls ``return``. We do this because we do not "
"want the user to be able to pick up objects while teleporting."
msgstr ""
"Cette fonction vérifie d'abord si ``teleport_button_down`` est égal à "
"``true``. Si c'est le cas, elle appelle ``return``. Nous faisons cela parce "
"que nous ne voulons pas que l'utilisateur puisse prendre des objets pendant "
"la téléportation."

msgid ""
"Then we check to see if the VR controller is currently not holding anything "
"by checking if ``held_object`` is equal to ``null``. If the VR controller is "
"not holding anything, then the ``_pickup_rigidbody`` function is called. If "
"the VR controller is holding something, ``held_object`` is not equal to "
"``null``, then the ``_throw_rigidbody`` function is called."
msgstr ""
"Ensuite, nous vérifions si le contrôleur VR ne tient rien actuellement en "
"vérifiant si ``held_object`` est égal à ``null``. Si le contrôleur VR ne "
"contient rien, alors la fonction ``_pickup_rigidbody`` est appelée. Si le "
"contrôleur VR tient quelque chose, ``held_object`` n'est pas égal à "
"``null``, alors la fonction ``throw_rigidbody`` est appelée."

msgid ""
"Finally, the pick-up/drop sound is played by calling the ``play`` function "
"on ``hand_pickup_drop_sound``."
msgstr ""
"Enfin, le son de pick-up/drop est joué en appelant la fonction ``play`` sur "
"``hand_pickup_drop_sound``."

msgid "``_pickup_rigidbody`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``_pickup_rigidbody``"

msgid ""
"First the function makes a variable called ``rigid_body``, which we'll be "
"using to store the :ref:`RigidBody <class_RigidBody>` that the VR controller "
"is going to pick up, assuming there is a RigidBody to pick up."
msgstr ""
"D'abord, la fonction crée une variable appelée ``rigid_body``, que nous "
"utiliserons pour stocker le :ref:`RigidBody <class_RigidBody>` que le "
"contrôleur VR va ramasser, en supposant qu'il y ait un RigidBody à ramasser."

msgid ""
"Then the function checks to see if the ``grab_mode`` variable is equal to "
"``AREA``. If it is, then it gets all of the :ref:`PhysicsBody "
"<class_PhysicsBody>` nodes within the ``grab_area`` using the "
"``get_overlapping_bodies`` functions. This function will return an array of :"
"ref:`PhysicsBody <class_PhysicsBody>` nodes. We assign the array of :ref:"
"`PhysicsBody <class_PhysicsBody>` to a new variable called ``bodies``."
msgstr ""
"Ensuite, la fonction vérifie si la variable ``grab_mode`` est égale à "
"``AREA``. Si c'est le cas, il récupère tous les nœuds :ref:`PhysicsBody "
"<class_PhysicsBody>` dans la ``grab_area`` en utilisant les fonctions "
"``get_overlapping_bodies``. Cette fonction renvoie un tableau de nœuds :ref:"
"`PhysicsBody <class_PhysicsBody>`. Nous assignons le tableau de :ref:"
"`PhysicsBody <class_PhysicsBody>` à une nouvelle variable appelée ``bodies``."

msgid ""
"We then check to see if the length of the ``bodies`` variable is more than "
"``0``. If it is, we go through each of the :ref:`PhysicsBody "
"<class_PhysicsBody>` nodes in ``bodies`` using a for loop."
msgstr ""
"Nous vérifions ensuite si la longueur de la variable ``bodies`` est "
"supérieure à ``0``. Si c'est le cas, nous passons par chacun des nœuds :ref:"
"`PhysicsBody <class_PhysicsBody>` dans ``bodies`` en utilisant une boucle "
"for."

msgid ""
"For each :ref:`PhysicsBody <class_PhysicsBody>` node, we check if it is, or "
"extends, a :ref:`RigidBody <class_RigidBody>` node using ``if body is "
"RigidBody``, which will return ``true`` if the :ref:`PhysicsBody "
"<class_PhysicsBody>` node is or extends the :ref:`RigidBody "
"<class_RigidBody>` node. If the object is a :ref:`RigidBody "
"<class_RigidBody>`, then we check to make sure there is not a variable/"
"constant called ``NO_PICKUP`` defined in the body. We do this because if you "
"want to have :ref:`RigidBody <class_RigidBody>` nodes that cannot be picked "
"up, all you have to do is define a constant/variable called ``NO_PICKUP`` "
"and the VR controller will be unable to pick it up. If the :ref:`RigidBody "
"<class_RigidBody>` node does not have a variable/constant defined with the "
"name ``NO_PICKUP``, then we assign the ``rigid_body`` variable to the :ref:"
"`RigidBody <class_RigidBody>` node and break the for loop."
msgstr ""
"Pour chaque nœud :ref:`PhysicsBody <class_PhysicsBody>`, nous vérifions s'il "
"s'agit, ou s'il étend, d'un nœud :ref:`RigidBody <class_RigidBody>` en "
"utilisant ``if body is RigidBody``, qui retournera ``true`` si le :ref:"
"`PhysicsBody <class_PhysicsBody>` est ou étend du nœud :ref:`RigidBody "
"<class_RigidBody>`. Si l'objet est un :ref:`RigidBody <class_RigidBody>`, "
"alors nous vérifions qu'il n'y a pas une variable/constante appelée "
"``NO_PICKUP`` définie dedans. Nous faisons cela parce que si vous voulez "
"avoir des nœuds :ref:`RigidBody <class_RigidBody>` qui ne peuvent pas être "
"ramassés, tout ce que vous avez à faire est de définir une constante/"
"variable appelée ``NO_PICKUP`` et le contrôleur VR ne pourra pas les "
"ramasser. Si le nœud :ref:`RigidBody <class_RigidBody>` n'a pas de variable/"
"constante définie avec le nom ``NO_PICKUP``, alors nous assignons la "
"variable ``rigid_body`` au nœud :ref:`RigidBody <class_RigidBody>` et "
"cassons la boucle for."

msgid ""
"What this section of code does is goes through all of the physics bodies "
"within the ``grab_area`` and grabs the first :ref:`RigidBody "
"<class_RigidBody>` node that does not have a variable/constant named "
"``NO_PICKUP`` and assigns it to the ``rigid_body`` variable so we can do "
"some additional post processing later in this function."
msgstr ""
"Cette section de code passe par tous les physics bodies de la ``grab_area`` "
"et prend le premier nœud :ref:`RigidBody <class_RigidBody>` qui n'a pas de "
"variable/constante nommée ``NO_PICKUP`` et l'assigne à la variable "
"``rigid_body`` pour que nous puissions faire un post-traitement "
"supplémentaire plus tard dans cette fonction."

msgid ""
"If the ``grab_mode`` variable is not equal to ``AREA``, we then check to see "
"if it is equal to ``RAYCAST`` instead. If it is equal to ``RAYCAST``, we "
"force the ``grab_raycast`` node to update using the ``force_raycast_update`` "
"function. The ``force_raycast_update`` function will update the :ref:"
"`Raycast <class_Raycast>` with the latest changes in the physics world. We "
"then check to see if the ``grab_raycast`` node collided with something using "
"the ``is_colliding`` function, which will return true if the :ref:`Raycast "
"<class_Raycast>` hit something."
msgstr ""
"Si la variable ``grab_mode`` n'est pas égale à ``AREA``, nous vérifions "
"alors si elle est égale à ``RAYCAST`` à la place. S'il est égal à "
"``RAYCAST``, nous forçons le nœud ``grab_raycast`` à se mettre à jour en "
"utilisant la fonction ``force_raycast_update``. La fonction "
"``force_raycast_update`` mettra à jour le :ref:`Raycast <class_Raycast>` "
"avec les derniers changements dans le monde physique. Nous vérifions ensuite "
"si le nœud ``grab_raycast`` est entré en collision avec quelque chose en "
"utilisant la fonction ``is_colliding``, qui retournera vrai si le :ref:"
"`Raycast <class_Raycast>` a touché quelque chose."

msgid ""
"If the ``grab_raycast`` hit something, we get the :ref:`PhysicsBody "
"<class_PhysicsBody>` node hit using the ``get_collider`` function. The code "
"then checks to see if the node hit is a :ref:`RigidBody <class_RigidBody>` "
"node using ``if body is RigidBody``, which will return ``true`` if the :ref:"
"`PhysicsBody <class_PhysicsBody>` node is or extends the :ref:`RigidBody "
"<class_RigidBody>` node. Then the code checks to see if the :ref:`RigidBody "
"<class_RigidBody>` node does not have a variable named ``NO_PICKUP``, and if "
"it does not, then it assigns the :ref:`RigidBody <class_RigidBody>` node to "
"the ``rigid_body`` variable."
msgstr ""
"Si le ``grab_raycast`` touche quelque chose, nous obtenons le nœud :ref:"
"`PhysicsBody <class_PhysicsBody>` touché en utilisant la fonction "
"``get_collider``. Le code vérifie ensuite si le nœud touché est un nœud :ref:"
"`RigidBody <class_RigidBody>` en utilisant ``if body is RigidBody``, qui "
"retournera ``true`` si le nœud :ref:`PhysicsBody <class_PhysicsBody>` est ou "
"étend du nœud :ref:`RigidBody <class_RigidBody>`. Ensuite, le code vérifie "
"si le nœud :ref:`RigidBody <class_RigidBody>` n'a pas une variable nommée "
"``NO_PICKUP``, et si ce n'est pas le cas, alors il assigne le nœud :ref:"
"`RigidBody <class_RigidBody>` à la variable ``rigid_body``."

msgid ""
"What this section of code does is sends the ``grab_raycast`` :ref:`Raycast "
"<class_Raycast>` node out and checks if it collided with a :ref:`RigidBody "
"<class_RigidBody>` node that does not have a variable/constant named "
"``NO_PICKUP``. If it collided with a RigidBody without ``NO_PICKUP``, it "
"assigns the node to the ``rigid_body`` variable so we can do some additional "
"post processing later in this function."
msgstr ""
"Cette section de code envoie le nœud ``grab_raycast`` :ref:`Raycast "
"<class_Raycast>` et vérifie s'il est entré en collision avec un nœud :ref:"
"`RigidBody <class_RigidBody>` qui n'a pas de variable/constante nommée "
"``NO_PICKUP``. S'il entre en collision avec un RigidBody sans ``NO_PICKUP``, "
"il assigne le nœud à la variable ``rigid_body`` pour que nous puissions "
"faire un post-traitement supplémentaire plus tard dans cette fonction."

msgid ""
"The final section of code first checks to see if ``rigid_body`` is not equal "
"to ``null``. If ``rigid_body`` is not equal to ``null``, then the VR "
"controller found a :ref:`RigidBody <class_RigidBody>`-based node that can be "
"picked up."
msgstr ""
"La dernière section du code vérifie d'abord si ``rigid_body`` n'est pas égal "
"à ``null``. Si ``rigid_body`` n'est pas égal à ``null``, alors le contrôleur "
"VR a trouvé un nœud basé sur :ref:`RigidBody <class_RigidBody>` qui peut "
"être récupéré."

msgid ""
"If there is a VR controller to pickup, we assign ``held_object`` to the :ref:"
"`RigidBody <class_RigidBody>` node stored in ``rigid_body``. We then store "
"the :ref:`RigidBody <class_RigidBody>` node's ``mode``, ``collision_layer``, "
"and ``collision_mask`` in ``held_object_data`` using ``mode``, ``layer``, "
"and ``mask`` as keys for the respective values. This is so we can reapply "
"them later when the object is dropped by the VR controller."
msgstr ""
"S'il y a un contrôleur VR effectuant un ramassage, nous assignons "
"``held_object`` au nœud :ref:`RigidBody <class_RigidBody>` stocké dans "
"``rigid_body``. Nous stockons ensuite ``mode``, ``collision_layer``, et "
"``collision_mask`` du nœud :ref:`RigidBody <class_RigidBody>` dans "
"``held_object_data`` en utilisant ``mode``, ``layer``, et ``mask`` comme "
"clés pour les valeurs respectives. Cela nous permet de les réappliquer plus "
"tard, lorsque l'objet est déposé par le contrôleur VR."

msgid ""
"We then set the :ref:`RigidBody <class_RigidBody>`'s mode to "
"``MODE_STATIC``, it's ``collision_layer`` to zero, and it's "
"``collision_mask`` to zero. This will make it where the held :ref:`RigidBody "
"<class_RigidBody>` cannot interact with other objects in the physics world "
"when held by the VR controller."
msgstr ""
"Nous réglons ensuite le mode du :ref:`RigidBody <class_RigidBody>` sur "
"``MODE_STATIC``, son ``collision_layer`` à zéro, et son ``collision_mask`` à "
"zéro. Cela fera en sorte que le :ref:`RigidBody <class_RigidBody>` ne puisse "
"pas interagir avec d'autres objets dans le monde physique lorsqu'il est tenu "
"par le contrôleur VR."

msgid ""
"Next the ``hand_mesh`` :ref:`MeshInstance <class_MeshInstance>` is made "
"invisible by setting the ``visible`` property to ``false``. This is so the "
"hand does not get in the way of the held object. Likewise, the "
"``grab_raycast`` 'laser sight' is made invisible by setting the ``visible`` "
"property to ``false``."
msgstr ""
"Ensuite, le :ref:`MeshInstance <class_MeshInstance>` ``hand_mesh`` est rendu "
"invisible en réglant la propriété ``visible`` sur ``false``. Ainsi la main "
"ne gêne pas l'objet tenu. De même, le 'laser sight' de ``grab_raycast`` est "
"rendu invisible en réglant la propriété ``visible`` sur ``false``."

msgid ""
"Then the code checks to see if the held object extends a class called "
"``VR_Interactable_Rigidbody``. If it does, then sets a variable called "
"``controller`` on ``held_object`` to ``self``, and calls the ``picked_up`` "
"function on ``held_object``. While we haven't made "
"``VR_Interactable_Rigidbody`` just yet, what this will do is set tell the "
"``VR_Interactable_Rigidbody`` class that it is being held by a VR "
"controller, where the a reference to the controller is stored in the "
"``controller`` variable, through calling the ``picked_up`` function."
msgstr ""
"Ensuite, le code vérifie si l'objet tenu étend d'une classe appelée "
"``VR_Interactable_Rigidbody``. Si c'est le cas, alors il définit une "
"variable appelée ``controller`` sur ``held_object`` à ``self``, et appelle "
"la fonction ``picked_up`` sur ``held_object``. Bien que nous n'ayons pas "
"encore créé de ``VR_Interactable_Rigidbody``, cela va permettre de dire à la "
"classe ``VR_Interactable_Rigidbody`` qu'elle est détenue par un contrôleur "
"VR, où la référence au contrôleur est stockée dans la variable "
"``controller``, en appelant la fonction ``picked_up``."

msgid ""
"The code should make more sense after completing part 2 of this tutorial "
"series, where we will actually be using ``VR_Interactable_Rigidbody``."
msgstr ""
"Le code devrait avoir plus de sens après avoir terminé la deuxième partie de "
"cette série de tutoriels, où nous utiliserons ``VR_Interactable_Rigidbody``."

msgid ""
"What this section of code does is that if a :ref:`RigidBody "
"<class_RigidBody>` was found using the grab :ref:`Area <class_Area>` or :ref:"
"`Raycast <class_Raycast>`, it sets it up so that it can be carried by the VR "
"controller."
msgstr ""
"Ce que fait cette section de code est que si un :ref:`RigidBody "
"<class_RigidBody>` a été trouvé en utilisant le grab :ref:`Area "
"<class_Area>` ou :ref:`Raycast <class_Raycast>`, il le configure de manière "
"à ce qu'il puisse être porté par le contrôleur VR."

msgid "``_throw_rigidbody`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``_throw_rigidbody``"

msgid ""
"First the function checks to see if the VR controller is not holding any "
"object by checking if the ``held_object`` variable is equal to ``null``. If "
"it is, then it simply calls ``return`` so nothing happens. While this "
"shouldn't be possible, the ``_throw_rigidbody`` function should only be "
"called if an object is held, this check helps ensure that if something "
"strange happens, this function will react as expected."
msgstr ""
"Tout d'abord, la fonction vérifie si le contrôleur VR ne contient pas "
"d'objet en vérifiant si la variable ``held_object`` est égale à ``null``. Si "
"c'est le cas, il se contente d'appeler ``return`` pour que rien ne se passe. "
"Bien que cela ne devrait pas être possible, la fonction ``throw_rigidbody`` "
"ne devrait être appelée que si un objet est tenu, cette vérification permet "
"de s'assurer que si quelque chose d'étrange se produit, cette fonction "
"réagira comme prévu."

msgid ""
"After checking if the VR controller is holding an object, we assume it is "
"and set the stored :ref:`RigidBody <class_RigidBody>` data back to the held "
"object. We take the ``mode``, ``layer`` and ``mask`` data stored in the "
"``held_object_data`` dictionary and reapply it to the object in "
"``held_object``. This will set the :ref:`RigidBody <class_RigidBody>` back "
"to the state it was prior to being picked up."
msgstr ""
"Après avoir vérifié si le contrôleur VR tient un objet, nous supposons que "
"c'est le cas et nous remettons les données :ref:`RigidBody "
"<class_RigidBody>` stockées dans l'objet détenu. Nous prenons les données "
"``mode``, ``layer`` et ``mask`` stockées dans le dictionnaire "
"``held_object_data`` et les appliquons à nouveau à l'objet dans "
"``held_object``. Cela va remettre le :ref:`RigidBody <class_RigidBody>` dans "
"l'état où il était avant d'être ramassé."

msgid ""
"Then we call ``apply_impulse`` on the ``held_object`` so that the :ref:"
"`RigidBody <class_RigidBody>` is thrown in the direction of the VR "
"controller's velocity, ``controller_velocity``."
msgstr ""
"Ensuite, nous appelons ``apply_impulse`` sur l'objet ``held_object`` de "
"sorte que le :ref:`RigidBody <class_RigidBody>` soit lancé dans la direction "
"de la vitesse du contrôleur VR, ``controller_velocity``."

msgid ""
"We then check to see if the object held extends a class called "
"``VR_Interactable_Rigidbody``. If it does, then we call a function called "
"``dropped`` in ``held_object`` and set ``held_object.controller`` to "
"``null``. While we have not made ``VR_Interactable_Rigidbody`` yet, but what "
"this will do is call the ``droppped`` function so the :ref:`RigidBody "
"<class_RigidBody>` can do whatever it needs to do when dropped, and we set "
"the ``controller`` variable to ``null`` so that the :ref:`RigidBody "
"<class_RigidBody>` knows that it is not being held."
msgstr ""
"Nous vérifions ensuite si l'objet tenu étend d'une classe appelée "
"``VR_Interactable_Rigidbody``. Si c'est le cas, alors nous appelons une "
"fonction appelée ``dropped`` dans ``held_object`` et nous mettons "
"``held_object.controller`` à ``null``. Bien que nous n'ayons pas encore fait "
"de ``VR_Interactable_Rigidbody``, ce que cela va faire, c'est appeler la "
"fonction ``droppped`` de sorte que le :ref:`RigidBody <class_RigidBody>` "
"puisse faire tout ce qu'il doit faire lorsqu'il est déposé, et nous avons "
"mis la variable ``controller`` à ``null`` de sorte que le :ref:`RigidBody "
"<class_RigidBody>` sache qu'il n'est plus tenu."

msgid ""
"Regardless of whether ``held_object`` extends ``VR_Interactable_Rigidbody`` "
"or not, we then set ``held_object`` to ``null`` so the VR controller knows "
"it is no longer holding anything. Because the VR controller is no longer "
"holding anything, we make the ``hand_mesh`` visible by setting ``hand_mesh."
"visible`` to true."
msgstr ""
"Peu importe que ``held_object`` étende de ``VR_Interactable_Rigidbody`` ou "
"non, nous mettons alors ``held_object`` à ``null`` pour que le contrôleur VR "
"sache qu'il ne tient plus rien. Comme le contrôleur VR ne tient plus rien, "
"nous rendons le ``hand_mesh`` visible en mettant ``hand_mesh.visible`` à "
"true."

msgid ""
"Finally, if the ``grab_mode`` variable is set to ``RAYCAST``, we set "
"``grab_raycast.visible`` to ``true`` so the 'laser sight' for the :ref:"
"`Raycast <class_Raycast>` in ``grab_raycast`` is visible."
msgstr ""
"Enfin, si la variable ``grab_mode`` est définie sur ``RAYCAST``, nous "
"définissons ``grab_raycast.visible`` sur ``true``, de sorte que le 'laser "
"sight' :ref:`Raycast <class_Raycast>` dans ``grab_raycast`` soit visible."

msgid "``_on_button_pressed_menu`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``_on_button_pressed_menu``"

msgid ""
"First this function checks to see if the ``grab_mode`` variable is equal to "
"``AREA``. If it is, then it sets ``grab_mode`` to ``RAYCAST``. It then "
"checks to see if the VR controller is not holding anything by checking to "
"see if ``held_object`` is equal to ``null``. If the VR controller is not "
"holding anything, then ``grab_raycast.visible`` is set to ``true`` so the "
"'laser sight' on the grab raycast is visible."
msgstr ""
"Cette fonction vérifie d'abord si la variable ``grab_mode`` est égale à "
"``AREA``. Si c'est le cas, alors il met ``grab_mode`` à ``RAYCAST``. Il "
"vérifie ensuite si le contrôleur VR ne tient rien en vérifiant si "
"``held_object`` est égal à ``null``. Si le contrôleur VR ne tient rien, "
"alors ``grab_raycast.visible`` est réglé sur ``true``, de sorte que la "
"'laser sight' sur le grab raycast est visible."

msgid ""
"If the ``grab_mode`` variable is not equal to ``AREA``, then it checks to "
"see if it is equal to ``RAYCAST``. If it is, then it sets the ``grab_mode`` "
"to ``AREA`` and sets ``grab_raycast.visible`` to ``false`` so the 'laser "
"sight' on the grab raycast is not visible."
msgstr ""
"Si la variable ``grab_mode`` n'est pas égale à ``AREA``, alors il vérifie si "
"elle est égale à ``RAYCAST``. Si c'est le cas, il règle le ``grab_mode`` à "
"``AREA`` et règle ``grab_raycast.visible`` à ``false``, de sorte que la "
"'laser sight' sur le grab raycast n'est pas visible."

msgid ""
"This section of code simply changes how the VR controller will grab :ref:"
"`RigidBody <class_RigidBody>`-based nodes when the grab/grip button is "
"pressed. If ``grab_mode`` is set to ``AREA``, then the :ref:`Area "
"<class_Area>` node in ``grab_area`` will be used for detecting :ref:"
"`RigidBody <class_RigidBody>` nodes, while if ``grab_mode`` is set to "
"``RAYCAST`` the :ref:`Raycast <class_Raycast>` node in ``grab_raycast`` will "
"be used for detecting :ref:`RigidBody <class_RigidBody>` nodes."
msgstr ""
"Cette section de code change simplement la façon dont le contrôleur VR va "
"saisir les nœuds basés sur :ref:`RigidBody <class_RigidBody>` lorsque le "
"bouton de saisie est pressé. Si ``grab_mode`` est réglé sur ``AREA``, alors "
"le nœud :ref:`Area <class_Area>` dans ``grab_area`` sera utilisé pour "
"détecter les nœuds :ref:`RigidBody <class_RigidBody>`, tandis que si "
"``grab_mode`` est réglé sur ``RAYCAST``, le nœud :ref:`Raycast "
"<class_Raycast>` dans ``grab_raycast`` sera utilisé pour détecter les nœuds :"
"ref:`RigidBody <class_RigidBody>`."

msgid "``button_released`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``button_released``"

msgid ""
"The only section of code in this function checks to see if the index of the "
"button that was just released, ``button_index``, is equal to ``15``, which "
"should map to the trigger button on the VR controller. The ``button_index`` "
"variable is passed in by the ``button_release`` signal in :ref:"
"`ARVRController <class_ARVRController>`, which we connected in the "
"``_ready`` function."
msgstr ""
"L'unique section de code dans cette fonction vérifie si l'index du bouton "
"qui vient d'être relâché, ``button_index``, est égal à ``15``, ce qui "
"devrait correspondre au bouton de déclenchement du contrôleur VR. La "
"variable ``button_index`` est passée par le signal ``button_release`` dans :"
"ref:`ARVRController <class_ARVRController>`, que nous avons connecté dans la "
"fonction ``_ready``."

msgid ""
"If the trigger button was just released, then the "
"``_on_button_released_trigger`` function is called."
msgstr ""
"Si le bouton de déclenchement vient d'être relâché, alors la fonction "
"``on_button_released_trigger`` est appelée."

msgid "``_on_button_released_trigger`` function step-by-step explanation"
msgstr ""
"Explication étape par étape de la fonction ``_on_button_released_trigger``"

msgid ""
"The only section of code in this function first checks to see if the VR "
"controller is trying to teleport by checking if the ``teleport_button_down`` "
"variable is equal to ``true``."
msgstr ""
"L'unique section de code dans cette fonction vérifie d'abord si le "
"contrôleur VR essaie d téléporter en vérifiant si la variable "
"``teleport_button_down`` est égale à ``true``."

msgid ""
"If the ``teleport_button_down`` variable is equal to ``true``, the code then "
"checks if there is a teleport position set and whether the teleport mesh is "
"visible. It does this by checking to see if ``teleport_pos`` is not equal to "
"``null`` and if ``teleport_mesh.visible`` is equal to ``true``."
msgstr ""
"Si la variable ``teleport_button_down`` est égale à ``true``, le code "
"vérifie alors s'il y a une position de téléportation définie et si le "
"maillage de téléportation est visible. Il le fait en vérifiant si "
"``teleport_pos`` n'est pas égal à ``null`` et si ``teleport_mesh.visible`` "
"est égal à ``true``."

msgid ""
"If there is a teleport position set and the teleport mesh is visible, the "
"code then calculates the offset from the camera to the :ref:`ARVROrigin "
"<class_ARVROrigin>` node, which is assumed to be the parent node of the VR "
"controller. To calculate the offset, the global position (``global_transform."
"origin``) of the ``Player_Camera`` node has the global position of the :ref:"
"`ARVROrigin <class_ARVROrigin>` subtracted from it. This will result in a "
"vector that points from the :ref:`ARVROrigin <class_ARVROrigin>` to the :ref:"
"`ARVRCamera <class_ARVRCamera>`, which we store in a variable called "
"``camera_offset``."
msgstr ""
"Si une position de téléportation est définie et que le maillage de "
"téléportation est visible, le code calcule alors le décalage de la caméra "
"vers le nœud :ref:`ARVROrigin <class_ARVROrigin>`, qui est supposé être le "
"nœud parent du contrôleur VR. Pour calculer le décalage, la position globale "
"(``global_transform.origin``) du nœud ``Player_Camera`` est soustraite de la "
"position globale du :ref:`ARVROrigin <class_ARVROrigin>`. Le résultat sera "
"un vecteur qui pointe de :ref:`ARVROrigin <class_ARVROrigin>` vers :ref:"
"`ARVRCamera <class_ARVRCamera>`, que nous stockons dans une variable appelée "
"``camera_offset``."

msgid ""
"The reason we need to know the offset is because some VR headsets use room "
"tracking, where the player's camera can be offset from the :ref:`ARVROrigin "
"<class_ARVROrigin>` node. Because of this, when we teleport we want to keep "
"the offset created by room tracking so that when the player teleports, the "
"offset created by the room tracking is not applied. Without this, if you "
"moved in a room and then teleported, instead of appearing at the position "
"you wanted to teleport at, your position would be offset by the amount of "
"distance you have from the :ref:`ARVROrigin <class_ARVROrigin>` node."
msgstr ""
"La raison pour laquelle nous devons connaître le décalage est que certains "
"casques VR utilisent le room tracking, où la caméra du joueur peut être "
"décalée du nœud :ref:`ARVROrigin <class_ARVROrigin>`. C'est pourquoi, "
"lorsque nous nous téléportons, nous voulons conserver le décalage créé par "
"le room tracking, de sorte que lorsque le joueur se téléporte, le décalage "
"créé par le room tracking ne soit pas appliqué. Sans cela, si vous vous "
"déplacez dans une pièce et que vous vous téléportez ensuite, au lieu "
"d'apparaître à la position où vous voulez vous téléporter, votre position "
"serait décalée de la distance que vous avez par rapport au nœud :ref:"
"`ARVROrigine <classe_ARVROrigine>`."

msgid ""
"Now that we know the offset from the VR camera to the VR origin, we need to "
"remove the difference on the ``Y`` axis. We do this because we do not want "
"to offset based on the user's height. If we did not do this, when "
"teleporting the player's head would be level with the ground."
msgstr ""
"Maintenant que nous connaissons le décalage entre la caméra VR et l'origine "
"VR, nous devons supprimer la différence sur l'axe ``Y``. Nous le faisons "
"parce que nous ne voulons pas compenser en fonction de la taille de "
"l'utilisateur. Si nous ne le faisions pas, lors de la téléportation, la tête "
"du joueur serait au niveau du sol."

msgid ""
"Then we can 'teleport' the player by setting the global position "
"(``global_transform.origin``) of the ARVROrigin node to the position stored "
"in ``teleport_pos`` with ``camera_offset`` subtracted from it. This will "
"teleport the player and remove the room tracking offset, so the user appears "
"exactly where they want when teleporting."
msgstr ""
"Ensuite, nous pouvons 'teleporter' le joueur en fixant la position globale "
"(``global_transform.origin``) du nœud ARVROrigin à la position stockée dans "
"``teleport_pos`` avec ``camera_offset`` soustrait de celle-ci. Cela permet "
"de téléporter le joueur et de supprimer le décalage de room tracking, de "
"sorte que les utilisateurs apparaissent exactement là où ils veulent "
"lorsqu'ils se téléportent."

msgid ""
"Finally, regardless of whether the VR controller teleported the user or not, "
"we reset the teleport related variables. ``teleport_button_down`` is set to "
"``false``, ``teleport_mesh.visible`` is set to ``false`` so the mesh is "
"invisible, ``teleport_raycast.visible`` is set to ``false``, and "
"``teleport_pos`` is set to ``null``."
msgstr ""
"Enfin, que le contrôleur VR ait ou non téléporté l'utilisateur, nous "
"réinitialisons les variables liées à la téléportation. "
"``teleport_button_down`` est réglé sur ``false``, ``teleport_mesh.visible`` "
"est réglé sur ``false`` donc le maillage est invisible, ``teleport_raycast."
"visible`` est réglé sur ``false``, et ``teleport_pos`` est réglé sur "
"``null``."

msgid "``sleep_area_entered`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``sleep_area_entered``"

msgid ""
"The only section of code in this function checks to see if the :ref:"
"`PhysicsBody <class_PhysicsBody>` node that entered the ``Sleep_Area`` node "
"has a variable called ``can_sleep``. If it does, then it sets the "
"``can_sleep`` variable to ``false`` and sets the ``sleeping`` variable to "
"``false``."
msgstr ""
"L'unique section de code dans cette fonction vérifie si le nœud :ref:"
"`PhysicsBody <class_PhysicsBody>` qui est entré dans le nœud ``Sleep_Area`` "
"a une variable appelée ``can_sleep``. Si c'est le cas, alors il met la "
"variable ``can_sleep`` à ``false`` et met la variable ``sleeping`` à "
"``false``."

msgid ""
"Without doing this, sleeping :ref:`PhysicsBody <class_PhysicsBody>` nodes "
"would not be able to be picked up by the VR controller, even if the VR "
"controller is at the same position as the :ref:`PhysicsBody "
"<class_PhysicsBody>` node. To work around this, we simply 'wake up' :ref:"
"`PhysicsBody <class_PhysicsBody>` nodes that are close to the VR controller."
msgstr ""
"Sans cela, les nœuds dormants :ref:`PhysicsBody <class_PhysicsBody>` ne "
"pourraient pas être ramassés par le contrôleur VR, même si le contrôleur VR "
"est à la même position que le nœud :ref:`PhysicsBody <class_PhysicsBody>`. "
"Pour contourner ce problème, il suffit de 'réveiller' les nœuds :ref:"
"`PhysicsBody <class_PhysicsBody>` qui sont proches du contrôleur VR."

msgid "``sleep_area_exited`` function step-by-step explanation"
msgstr "Explication étape par étape de la fonction ``sleep_area_exited``"

msgid ""
"The only section of code in this function checks to see if the :ref:"
"`PhysicsBody <class_PhysicsBody>` node that entered the ``Sleep_Area`` node "
"has a variable called ``can_sleep``. If it does, then it sets the "
"``can_sleep`` variable to ``true``."
msgstr ""
"L'unique section de code dans cette fonction vérifie si le nœud :ref:"
"`PhysicsBody <class_PhysicsBody>` qui est entré dans le nœud ``Sleep_Area`` "
"a une variable appelée ``can_sleep``. Si c'est le cas, alors il met la "
"variable ``can_sleep`` à ``true``."

msgid ""
"This allows :ref:`RigidBody <class_RigidBody>` nodes that leave the "
"``Sleep_Area`` to sleep again, saving performance."
msgstr ""
"Cela permet aux nœuds :ref:`RigidBody <class_RigidBody>` qui quittent la "
"``Sleep_Area`` de se rendormir, ce qui permet de gagner en performance."

msgid ""
"Okay, whew! That was a lot of code! Add the same script, ``VR_Controller."
"gd`` to the other VR controller scene so both VR controllers have the same "
"script."
msgstr ""
"D'accord, ouf ! C'était beaucoup de code ! Ajoutez le même script, "
"``VR_Controller.gd`` à l'autre scène de contrôleur VR pour que les deux "
"contrôleurs VR aient le même script."

msgid ""
"Now we just need to do one thing before testing the project! Right now we "
"are referencing a class called ``VR_Interactable_Rigidbody``, but we have "
"not defined it yet. While we will not be using ``VR_Interactable_Rigidbody`` "
"in this tutorial, let's create it real quick so the project can be run."
msgstr ""
"Il ne nous reste plus qu'une chose à faire avant de tester le projet ! Pour "
"l'instant, nous faisons référence à une classe appelée "
"``VR_Interactable_Rigidbody``, mais nous ne l'avons pas encore définie. Bien "
"que nous n'utiliserons pas ``VR_Interactable_Rigidbody`` dans ce tutoriel, "
"créons-le très rapidement pour que le projet puisse être exécuté."

msgid "Creating a base class for interactable VR objects"
msgstr "Création d'une classe de base pour les objets VR interactifs"

msgid ""
"With the ``Script`` tab still open, create a new GDScript called "
"``VR_Interactable_Rigidbody.gd``."
msgstr ""
"Avec l'onglet ``Script`` encore ouvert, créez un nouveau GDScript appelé "
"``VR_Interactable_Rigidbody.gd``."

msgid ""
"You can create GDScripts in the ``Script`` tab by pressing ``File -> New "
"Script...``."
msgstr ""
"Vous pouvez créer des GDScripts dans l'onglet ``Script`` en appuyant sur "
"``Fichier -> Nouveau Script...``."

msgid ""
"Once you have ``VR_Interactable_Rigidbody.gd`` open, add the following code:"
msgstr ""
"Une fois que vous avez ``VR_Interactable_Rigidbody.gd`` ouvert, ajoutez le "
"code suivant :"

msgid "Let's quickly go through what this script."
msgstr "Passons rapidement en revue ce qu'est ce script."

msgid ""
"First we start the script with ``class_name VR_Interactable_Rigidbody``. "
"What this does is that it tells Godot that this GDScript is a new class that "
"called ``VR_Interactable_Rigidbody``. This allows us to compare nodes "
"against the ``VR_Interactable_Rigidbody`` class in other script files "
"without having to load the script directly or do anything special. We can "
"compare the class just like all of the built-in Godot classes."
msgstr ""
"Nous commençons d'abord le script par ``class_name "
"VR_Interactable_Rigidbody``. Ce que cela fait, c'est qu'il indique à Godot "
"que ce GDScript est une nouvelle classe qui s'appelle "
"``VR_Interactable_Rigidbody``. Cela nous permet de comparer les nœuds avec "
"la classe ``VR_Interactable_Rigidbody`` dans d'autres fichiers de script "
"sans avoir à charger directement le script ou à faire quoi que ce soit de "
"spécial. Nous pouvons comparer la classe comme toutes les classes Godot "
"intégrées."

msgid ""
"Next is a class variable called ``controller``. ``controller`` will be used "
"to hold a reference to the VR controller that is currently holding the "
"object. If a VR controller is not holding the object, then the "
"``controller`` variable will be ``null``. The reason we need to have a "
"reference to the VR controller is so held objects can access VR controller "
"specific data, like ``controller_velocity``."
msgstr ""
"Ensuite, il y a une variable de classe appelée ``controller``. "
"``controller`` sera utilisé pour contenir une référence au contrôleur VR qui "
"détient actuellement l'objet. Si un contrôleur VR ne tient pas d'objet, "
"alors la variable ``controller`` sera ``null``. La raison pour laquelle nous "
"avons besoin d'une référence au contrôleur VR est que les objets tenus "
"peuvent accéder aux données spécifiques du contrôleur VR, comme "
"``controller_velocity``."

msgid ""
"Finally, we have four functions. The ``_ready`` function is defined by Godot "
"and all we do is simply have ``pass`` as there is nothing we need to do when "
"the object is added to the scene in ``VR_Interactable_Rigidbody``."
msgstr ""
"Enfin, nous avons quatre fonctions. La fonction ``_ready`` est définie par "
"Godot et tout ce que nous faisons c'est simplement avoir ``pass`` car il n'y "
"a rien à faire lorsque l'objet est ajouté à la scène dans "
"``VR_Interactable_Rigidbody``."

msgid ""
"The ``interact`` function is a stub function that will be called when the "
"interact button on the VR controller, the trigger in this case, is pressed "
"while the object is held."
msgstr ""
"La fonction ``interact`` est une fonction stub qui sera appelée lorsque le "
"bouton ``interact`` du contrôleur VR, le déclencheur dans ce cas, est pressé "
"alors que l'objet est maintenu."

msgid ""
"A stub function is a function that is defined but does not have any code. "
"Stub functions are generally designed to be overwritten or extended. In this "
"project, we are using the stub functions so there is a consistent interface "
"across all interactable :ref:`RigidBody <class_RigidBody>` objects."
msgstr ""
"Une fonction stub est une fonction qui est définie mais qui n'a pas de code. "
"Les fonctions stub sont généralement conçues pour être écrasées ou étendues. "
"Dans ce projet, nous utilisons les fonctions stub afin d'obtenir une "
"interface cohérente pour tous les objets interactifs :ref:`RigidBody "
"<class_RigidBody>`."

msgid ""
"The ``picked_up`` and ``dropped`` functions are stub functions that will be "
"called when the object is picked up and dropped by the VR controller."
msgstr ""
"Les fonctions ``picked_up`` et ``dropped`` sont des fonctions stub qui "
"seront appelées lorsque l'objet sera ramassé et déposé par le contrôleur VR."

msgid ""
"That is all we need to do for now! In the next part of this tutorial series, "
"we'll start making special interactable :ref:`RigidBody <class_RigidBody>` "
"objects."
msgstr ""
"C'est tout ce que nous devons faire pour l'instant ! Dans la prochaine "
"partie de cette série de tutoriels, nous allons commencer à faire les objets "
"spéciaux interactifs :ref:`RigidBody <class_RigidBody>`."

msgid ""
"Now that the base class is defined, the code in the VR controller should "
"work. Go ahead and try the game again, and you should find you can teleport "
"around by pressing the touch pad, and can grab and throw objects using the "
"grab/grip buttons."
msgstr ""
"Maintenant que la classe de base est définie, le code dans le contrôleur VR "
"devrait fonctionner. Essayez à nouveau le jeu et vous devriez découvrir que "
"vous pouvez vous téléporter en appuyant sur le touch pad et que vous pouvez "
"saisir et lancer des objets en utilisant les boutons de saisie."

msgid ""
"Now, you may want to try moving using the trackpads and/or joysticks, but "
"**it may make you motion sick!**"
msgstr ""
"Maintenant, vous pouvez essayer de vous déplacer en utilisant les trackpads "
"et/ou les joysticks, mais **cela pourrait vous rendre malade !**"

msgid ""
"One of the main reasons this can make you feel motion sick is because your "
"vision tells you that you are moving, while your body is not moving. This "
"conflict of signals can make the body feel sick. Let's add a vignette shader "
"to help reduce motion sickness while moving in VR!"
msgstr ""
"L'une des principales raisons pour lesquelles cela peut vous donner le mal "
"des transports est que votre vision vous dit que vous bougez, alors que "
"votre corps ne bouge pas. Ce conflit de signaux peut rendre le corps malade. "
"Ajoutons un shader vignette pour aider à réduire le mal des transports lors "
"des déplacements VR !"

msgid "Reducing motion sickness"
msgstr "Réduire le mal des transports"

msgid ""
"There are plenty of ways to reduce motion sickness in VR, and there is no "
"one perfect way to reduce motion sickness. See `this page on the Oculus "
"Developer Center <https://developer.oculus.com/design/latest/concepts/bp-"
"locomotion/>`__ for more information on how to implement locomotion and "
"reducing motion sickness."
msgstr ""
"Il existe de nombreuses façons de réduire le mal des transports en VR, et il "
"n’y a pas une seule façon parfaite de réduire le mal des transports. Voir "
"`cette page sur l'Oculus Developer Center <https://developer.oculus.com/"
"design/latest/concepts/bp-locomotion/>`__, pour plus d’informations sur la "
"façon d’implémenter la locomotion et de réduire le mal des transports."

msgid ""
"To help reduce motion sickness while moving, we are going to add a vignette "
"effect that will only be visible while the player moves."
msgstr ""
"Pour aider à réduire le mal des transports pendant les déplacements, nous "
"allons ajouter un effet de vignette qui ne sera visible que lorsque le "
"joueur se déplacera."

msgid ""
"First, quickly switch back to ``Game.tscn```. Under the :ref:`ARVROrigin "
"<class_ARVROrigin>` node there is a child node called ``Movement_Vignette``. "
"This node is going to apply a simple vignette to the VR headset when the "
"player is moving using the VR controllers. This should help reduce motion "
"sickness."
msgstr ""
"Tout d'abord, revenez rapidement à ``Game.tscn``. Sous le nœud :ref:"
"`ARVROrigin <class_ARVROrigin>` il y a un nœud enfant appelé "
"``Movement_Vignette``. Ce nœud va appliquer une simple vignette au casque VR "
"lorsque le joueur se déplace à l'aide des contrôleurs VR. Cela devrait "
"contribuer à réduire le mal des transports."

msgid ""
"Open up ``Movement_Vignette.tscn``, which you can find in the ``Scenes`` "
"folder. The scene is just a :ref:`ColorRect <class_ColorRect>` node with a "
"custom shader. Feel free to look at the custom shader if you want, it is "
"just a slightly modified version of the vignette shader you can find in the "
"`Godot demo repository <https://github.com/godotengine/godot-demo-"
"projects>`__."
msgstr ""
"Ouvrez le fichier ``Movement_Vignette.tscn``, que vous trouverez dans le "
"dossier ``Scenes``. La scène est juste un nœud :ref:`ColorRect "
"<class_ColorRect>` avec un shader personnalisé. N'hésitez pas à regarder le "
"shader personnalisé si vous le souhaitez, c'est juste une version légèrement "
"modifiée du shader vignette que vous pouvez trouver dans le `dépôt de démo "
"Godot <https://github.com/godotengine/godot-demo-projects>`__."

msgid ""
"Let's write the code that will make the vignette shader visible when the "
"player is moving. Select the ``Movement_Vignette`` node and create a new "
"script called ``Movement_Vignette.gd``. Add the following code:"
msgstr ""
"Écrivons le code qui rendra le shader vignette visible lorsque le joueur est "
"en mouvement. Sélectionnez le nœud ``Movement_Vignette`` et créez un nouveau "
"script appelé ``Movement_Vignette.gd``. Ajouter le code suivant :"

msgid ""
"Because this script is fairly brief, let's quickly go over what it does."
msgstr ""
"Comme ce script est assez bref, passons rapidement en revue son contenu."

msgid "Explaining the vignette code"
msgstr "Explication du code de vignette"

msgid ""
"There are two class variables, ``controller_one`` and ``controller_two``. "
"These variables will hold references to the left and right VR controllers."
msgstr ""
"Il y a deux variables de classe, ``controller_one`` et ``controller_two``. "
"Ces variables contiendront des références aux contrôleurs VR gauche et droit."

msgid ""
"In the ``_ready`` function first waits for four frames using ``yield``. The "
"reason we are waiting four frames is because we want to ensure the VR "
"interface is ready and accessible."
msgstr ""
"Dans la fonction ``_ready``, on attend d'abord quatre images en utilisant "
"``yield``. Si nous attendons quatre images, c'est parce que nous voulons "
"nous assurer que l'interface VR est prête et accessible."

msgid ""
"After waiting the primary VR interface is retrieved using ``ARVRServer."
"primary_interface``, which is assigned to a variable called ``interface``. "
"The code then checks to see if ``interface`` is equal to ``null``. If "
"``interface`` is equal to ``null``, then ``_process`` is disabled using "
"``set_process`` with a value of ``false``."
msgstr ""
"Après avoir attendu, l'interface VR primaire est récupérée en utilisant "
"``ARVRServer.primary_interface``, qui est assignée à une variable appelée "
"``interface``. Le code vérifie ensuite si ``interface`` est égal à ``null``. "
"Si ``interface`` est égal à ``null``, alors ``_process`` est désactivé en "
"utilisant ``set_process`` avec une valeur de ``false``."

msgid ""
"If ``interface`` is not ``null``, then we set the ``rect_size`` of the "
"vignette shader to the render size of the VR viewport so it takes up the "
"entire screen. We need to do this because different VR headsets have "
"different resolutions and aspect ratios, so we need to resize the node "
"accordingly. We also set the ``rect_position`` of the vignette shader to "
"zero so it is in the correct position relative to the screen."
msgstr ""
"Si ``interface`` n'est pas ``null``, alors nous fixons la ``rect_size`` du "
"shader vignette à la taille de rendu du viewport VR de façon à ce qu'elle "
"occupe tout l'écran. Nous devons le faire parce que les différents casques "
"de VR ont des résolutions et des rapports d'aspect différents, nous devons "
"donc redimensionner le nœud en conséquence. Nous avons également mis à zéro "
"la ``rect_position`` du shader vignette afin qu'il soit dans la bonne "
"position par rapport à l'écran."

msgid ""
"The left and right VR controllers are then retrieved and assigned to "
"``controller_one`` and ``controller_two`` respectively. Finally, the "
"vignette shader is made invisible by default by setting it's ``visible`` "
"property to ``false``."
msgstr ""
"Les contrôleurs VR gauche et droit sont alors récupérés et affectés "
"respectivement au ``controller_one`` et au ``controller_two``. Enfin, le "
"shader vignette est rendu invisible par défaut en réglant sa propriété "
"``visible`` sur ``false``."

msgid ""
"In ``_process`` the code first checks if either ``controller_one`` or "
"``controller_two`` are equal to ``null``. If either node is equal to "
"``null``, then ``return`` is called so nothing happens."
msgstr ""
"Dans ``_process``, le code vérifie d'abord si ``controller_one`` ou "
"``controller_two`` est égal à ``null``. Si l'un des nœuds est égal à "
"``null``, alors ``return`` est appelé de sorte que rien ne se passe."

msgid ""
"Then the code checks to see if either of the VR controllers are moving the "
"player using the touchpad/joystick by checking if ``directional_movement`` "
"is equal to ``true`` in ``controller_one`` or ``controller_two``. If either "
"of the VR controllers are moving the player, then the vignette shader makes "
"itself visible by setting it's ``visible`` property to ``true``. If neither "
"VR controller is moving the player, so ``directional_movement`` is ``false`` "
"in both VR controllers, than the vignette shader makes itself invisible by "
"setting it's ``visible`` property to ``false``."
msgstr ""
"Ensuite, le code vérifie si l'un des contrôleurs VR déplace le joueur en "
"utilisant le touchpad/joystick en vérifiant si ``directional_movement`` est "
"égal à ``true`` dans ``controller_one`` ou ``controller_two``. Si l'un des "
"contrôleurs VR déplace le joueur, alors le shader vignette se rend visible "
"en réglant sa propriété ``visible`` à ``true``. Si aucun des deux "
"contrôleurs VR ne déplace le joueur, donc ``directional_movement`` est "
"``false`` dans les deux contrôleurs VR, alors le shader vignette se rend "
"invisible en mettant sa propriété ``visible`` à ``false``."

msgid ""
"That is the whole script! Now that we have written the code, go ahead and "
"try moving around with the trackpad and/or joystick. You should find that it "
"is less motion sickness-inducing then before!"
msgstr ""
"C'est tout le script ! Maintenant que nous avons écrit le code, allez-y et "
"essayez de vous déplacer avec le trackpad et/ou le joystick. Vous devriez "
"constater que cela rend moins malade qu'auparavant !"

msgid ""
"As previously mentioned, there are plenty of ways to reduce motion sickness "
"in VR. Check out `this page on the Oculus Developer Center <https://"
"developer.oculus.com/design/latest/concepts/bp-locomotion/>`__ for more "
"information on how to implement locomotion and reducing motion sickness."
msgstr ""
"Comme mentionné précédemment, il existe de nombreux moyens de réduire le mal "
"des transports dans la VR. Consultez `cette page sur le Oculus Developer "
"Center <https://developer.oculus.com/design/latest/concepts/bp-locomotion/"
">`__ pour plus d'informations sur la façon de mettre en œuvre la locomotion "
"et de réduire le mal des transports."

msgid "Final notes"
msgstr "Notes finales"

msgid ""
"Now you have fully working VR controllers that can move around the "
"environment and interact with :ref:`RigidBody <class_RigidBody>`-based "
"objects. In the next part of this tutorial series, we will be creating some "
"special :ref:`RigidBody <class_RigidBody>`-based objects for the player to "
"use!"
msgstr ""
"Vous disposez maintenant de contrôleurs VR entièrement fonctionnels qui "
"peuvent bouger dans l'environnement et interagir avec des objets basés sur :"
"ref:`RigidBody <class_RigidBody>`. Dans la prochaine partie de cette série "
"de tutoriels, nous allons créer des objets spéciaux basés sur :ref:"
"`RigidBody <class_RigidBody>` que le joueur pourra utiliser !"

msgid ""
"You can download the finished project for this tutorial series on the Godot "
"OpenVR GitHub repository, under the releases tab!"
msgstr ""
"Vous pouvez télécharger le projet terminé pour cette série de tutoriels sur "
"le dépôt GitHub de Godot OpenVR, sous l'onglet releases !"

msgid "Translation status"
msgstr "État de la traduction"
