# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced post-processing"
msgstr "Post-traitement avancé"

msgid "Introduction"
msgstr "Introduction"

msgid ""
"This tutorial describes an advanced method for post-processing in Godot. In "
"particular, it will explain how to write a post-processing shader that uses "
"the depth buffer. You should already be familiar with post-processing "
"generally and, in particular, with the methods outlined in the :ref:`custom "
"post-processing tutorial <doc_custom_postprocessing>`."
msgstr ""
"Ce tutoriel décrit une méthode avancée de post-traitement dans Godot. Il "
"expliquera notamment comment écrire un shader de post-traitement qui utilise "
"le tampon de profondeur. Vous devriez déjà être familier avec le post-"
"traitement en général et, en particulier, avec les méthodes décrites dans le "
"tutoriel :ref:`custom post-processing tutorial <doc_custom_postprocessing>`."

#, fuzzy
msgid ""
"In the previous post-processing tutorial, we rendered the scene to a :ref:"
"`Viewport <class_Viewport>` and then rendered the Viewport in a :ref:"
"`SubViewportContainer <class_SubViewportContainer>` to the main scene. One "
"limitation of this method is that we could not access the depth buffer "
"because the depth buffer is only available in shaders and Viewports do not "
"maintain depth information."
msgstr ""
"Dans le précédent tutoriel de post-traitement, nous avons rendu la scène "
"dans un :ref:`Viewport <class_Viewport>` et ensuite rendu le Viewport dans "
"un :ref:`ViewportContainer <class_ViewportContainer>` dans la scène "
"principale. L'une des limites de cette méthode est que nous ne pouvons pas "
"accéder au tampon de profondeur car celui-ci n'est disponible que dans les "
"shaders spatiaux et les Viewports ne conservent pas d'informations sur la "
"profondeur."

msgid "Full screen quad"
msgstr "Quadrant plein écran"

msgid ""
"In the :ref:`custom post-processing tutorial <doc_custom_postprocessing>`, "
"we covered how to use a Viewport to make custom post-processing effects. "
"There are two main drawbacks of using a Viewport:"
msgstr ""
"Dans le tutoriel :ref:`custom post-processing tutorial "
"<doc_custom_postprocessing>`, nous avons couvert comment utiliser un "
"Viewport pour faire des effets de post-traitement personnalisés. "
"L'utilisation d'un Viewport présente deux inconvénients majeurs :"

msgid "The depth buffer cannot be accessed"
msgstr "Le tampon de profondeur n'est pas accessible"

msgid "The effect of the post-processing shader is not visible in the editor"
msgstr "L'effet du shader de post-traitement n'est pas visible dans l'éditeur"

#, fuzzy
msgid ""
"To get around the limitation on using the depth buffer, use a :ref:"
"`MeshInstance3D <class_MeshInstance3D>` with a :ref:`QuadMesh "
"<class_QuadMesh>` primitive. This allows us to use a shader and to access "
"the depth texture of the scene. Next, use a vertex shader to make the quad "
"cover the screen at all times so that the post-processing effect will be "
"applied at all times, including in the editor."
msgstr ""
"Pour contourner la limitation d'utilisation du tampon de profondeur, "
"utilisez une :ref:`MeshInstance <class_MeshInstance>` avec une :ref:"
"`QuadMesh <class_QuadMesh>` primitive. Cela nous permet d'utiliser un shader "
"spatial et d'accéder à la texture de profondeur de la scène. Ensuite, "
"utilisez un shader de sommet pour que le quad couvre l'écran en permanence "
"afin que l'effet de post-traitement soit appliqué à tout moment, y compris "
"dans l'éditeur."

#, fuzzy
msgid ""
"First, create a new MeshInstance3D and set its mesh to a QuadMesh. This "
"creates a quad centered at position ``(0, 0, 0)`` with a width and height of "
"``1``. Set the width and height to ``2`` and enable **Flip Faces**. Right "
"now, the quad occupies a position in world space at the origin. However, we "
"want it to move with the camera so that it always covers the entire screen. "
"To do this, we will bypass the coordinate transforms that translate the "
"vertex positions through the difference coordinate spaces and treat the "
"vertices as if they were already in clip space."
msgstr ""
"Tout d'abord, créez une nouvelle MeshInstance et réglez son maillage sur une "
"QuadMesh. Cela crée un quad centré sur la position ``(0, 0, 0)`` avec une "
"largeur et une hauteur de ``1``. Réglez la largeur et la hauteur sur ``2``. "
"Actuellement, le quad occupe une position dans l'espace monde à l'origine, "
"mais nous voulons qu'il se déplace avec la caméra pour qu'il couvre toujours "
"l'ensemble de l'écran. Pour ce faire, nous contournerons les transformées de "
"coordonnées qui traduisent les positions des sommets à travers les "
"différents espaces de coordonnées et traiterons les sommets comme s'ils "
"étaient déjà dans l'espace de clipping."

msgid ""
"The vertex shader expects coordinates to be output in clip space, which are "
"coordinates ranging from ``-1`` at the left and bottom of the screen to "
"``1`` at the top and right of the screen. This is why the QuadMesh needs to "
"have height and width of ``2``. Godot handles the transform from model to "
"view space to clip space behind the scenes, so we need to nullify the "
"effects of Godot's transformations. We do this by setting the ``POSITION`` "
"built-in to our desired position. ``POSITION`` bypasses the built-in "
"transformations and sets the vertex position directly."
msgstr ""
"Le shader de sommet s'attend à ce que les coordonnées soient affichées dans "
"l'espace de clipping, qui sont des coordonnées allant de ``-1`` en bas et à "
"gauche de l'écran à ``1`` en haut et à droite de l'écran. C'est pourquoi la "
"QuadMesh doit avoir une hauteur et une largeur de ``2``. Godot s'occupe de "
"la transformation d'espace de modèle en espace de vue pour couper l'espace "
"en coulisses, nous devons donc annuler les effets des transformations de "
"Godot. Nous le faisons en plaçant la ``POSITION`` intégrée à la position "
"souhaitée. La ``POSITION`` contourne les transformations intégrées et fixe "
"directement la position du sommet."

msgid ""
"Even with this vertex shader, the quad keeps disappearing. This is due to "
"frustum culling, which is done on the CPU. Frustum culling uses the camera "
"matrix and the AABBs of Meshes to determine if the Mesh will be visible "
"*before* passing it to the GPU. The CPU has no knowledge of what we are "
"doing with the vertices, so it assumes the coordinates specified refer to "
"world positions, not clip space positions, which results in Godot culling "
"the quad when we turn away from the center of the scene. In order to keep "
"the quad from being culled, there are a few options:"
msgstr ""
"Même avec ce shader de sommet, le quad continue de disparaître. Cela est dû "
"au frustum culling, qui se fait sur le CPU. Le Frustum culling utilise la "
"matrice de la caméra et les AABB des mailles pour déterminer si la maille "
"sera visible *avant* de la passer au GPU. Le CPU ne sait pas ce que nous "
"faisons avec les sommets, il suppose donc que les coordonnées spécifiées se "
"réfèrent à des positions mondiales, et non à des positions d'espace de "
"clipping, ce qui a pour conséquence que Godot élimine le quadrant lorsque "
"nous nous éloignons du centre de la scène. Afin d'éviter que le quad ne soit "
"éliminé, il existe plusieurs options :"

msgid ""
"Add the QuadMesh as a child to the camera, so the camera is always pointed "
"at it"
msgstr ""
"Ajouter le QuadMesh comme enfant de la caméra, de sorte que la caméra "
"regarde toujours vers lui"

msgid ""
"Set the Geometry property ``extra_cull_margin`` as large as possible in the "
"QuadMesh"
msgstr ""
"Définissez la propriété ``extra_cull_margin`` aussi large que possible dans "
"le QuadMesh"

msgid ""
"The second option ensures that the quad is visible in the editor, while the "
"first option guarantees that it will still be visible even if the camera "
"moves outside the cull margin. You can also use both options."
msgstr ""
"La deuxième option garantie que le quad soit visible dans l'éditeur, alors "
"que la première option assure qu'il reste visible même si la caméra se "
"déplace en dehors de l'espace d'affichage. Vous pouvez également utiliser "
"les deux options."

msgid "Depth texture"
msgstr "Texture de profondeur"

msgid ""
"To read from the depth texture, we first need to create a texture uniform "
"set to the depth buffer by using ``hint_depth_texture``."
msgstr ""

msgid ""
"Once defined, the depth texture can be read with the ``texture()`` function."
msgstr ""

msgid ""
"Similar to accessing the screen texture, accessing the depth texture is only "
"possible when reading from the current viewport. The depth texture cannot be "
"accessed from another viewport to which you have rendered."
msgstr ""
"Semblable à l'accès à la texture d'écran, accéder à la texture de profondeur "
"n'est possible qu'en lisant à partir du viewport courant. La texture de "
"profondeur n'est pas accessible à partir d'un autre viewport dans lequel "
"vous avez fait un rendu."

#, fuzzy
msgid ""
"The values returned by ``depth_texture`` are between ``0.0`` and ``1.0`` and "
"are nonlinear. When displaying depth directly from the ``depth_texture``, "
"everything will look almost white unless it is very close. This is because "
"the depth buffer stores objects closer to the camera using more bits than "
"those further, so most of the detail in depth buffer is found close to the "
"camera. In order to make the depth value align with world or model "
"coordinates, we need to linearize the value. When we apply the projection "
"matrix to the vertex position, the z value is made nonlinear, so to "
"linearize it, we multiply it by the inverse of the projection matrix, which "
"in Godot, is accessible with the variable ``INV_PROJECTION_MATRIX``."
msgstr ""
"Les valeurs retournées par ``DEPTH_TEXTURE`` sont comprises entre ``0`` et "
"``1`` et ne sont pas linéaire. Lorsque l'on affiche directement la "
"profondeur depuis ``DEPTH_TEXTURE``, tout ce qui n'est pas très proche "
"semble presque blanc. Cela est du au fait que le tampon de profondeur "
"utilise plus de bits pour stocker les objets près de la caméra que pour ceux "
"plus éloignés, de fait, la plupart des détails du tampon de profondeur se "
"trouvent à proximité de la caméra. Pour que la valeur de profondeur soit "
"cohérente avec les coordonnées du monde ou du modèle, il nous faut "
"linéariser la valeur. Lorsque l'on applique la matrice de projection à la "
"position du sommet, la valeur z n'est pas linéaire, pour la linéariser, il "
"faut la multiplier par la matrice de projection inverse qui, dans Godot, est "
"accessible par la variable ``INV_PROJECTION_MATRIX``."

#, fuzzy
msgid ""
"Firstly, take the screen space coordinates and transform them into "
"normalized device coordinates (NDC). NDC run ``-1.0`` to ``1.0`` in ``x`` "
"and ``y`` directions and from ``0.0`` to ``1.0`` in the ``z`` direction when "
"using the Vulkan backend. Reconstruct the NDC using ``SCREEN_UV`` for the "
"``x`` and ``y`` axis, and the depth value for ``z``."
msgstr ""
"Tout d'abord, prenons les coordonnée de l'espace écran et transformons les "
"en coordonnées normalisées pour l'appareil (NDC). Les NDC vont de ``-1`` à "
"``1``, comme les bornes des coordonnées de l'espace. Reconstruisez le NDC en "
"utilisant ``SCREEN_UV`` pour les axes ``x`` et ``y``, et la valeur de "
"profondeur pour ``z``."

msgid ""
"This tutorial assumes the use of the Vulkan renderer, which uses NDCs with a "
"Z-range of ``[0.0, 1.0]``. In contrast, OpenGL uses NDCs with a Z-range of "
"``[-1.0, 1.0]``."
msgstr ""

msgid ""
"Convert NDC to view space by multiplying the NDC by "
"``INV_PROJECTION_MATRIX``. Recall that view space gives positions relative "
"to the camera, so the ``z`` value will give us the distance to the point."
msgstr ""
"Convertissez les NDC en coordonnées de l'espace visuel les NDC en "
"multipliant par ``INV_PROJECTION_MATRIX``. Rappelez-vous que l'espace visuel "
"donne les positions relatives à la caméra, la valeur de ``z`` nous renseigne "
"donc sur la distance au point."

msgid ""
"Because the camera is facing the negative ``z`` direction, the position will "
"have a negative ``z`` value. In order to get a usable depth value, we have "
"to negate ``view.z``."
msgstr ""
"Comme la caméra est orientée dans la direction ``z`` négative, la position "
"aura une valeur ``z`` négative. Pour obtenir une valeur de profondeur "
"utilisable, il nous faut mettre``view.z`` négative."

#, fuzzy
msgid ""
"The world position can be constructed from the depth buffer using the "
"following code. Note that the ``INV_VIEW_MATRIX`` is needed to transform the "
"position from view space into world space, so it needs to be passed to the "
"fragment shader with a varying."
msgstr ""
"Les positions dans l'espace global peuvent être construites à partir du "
"tampon de profondeur en utilisant le code suivant. Notez que "
"``CAMERA_MATRIX`` est nécessaire pour transposer la position de l'espace "
"visuel à l'espace global, elle doit être passée au fragment shader par un "
"varying."

msgid "An optimization"
msgstr "Une optimisation"

msgid ""
"You can benefit from using a single large triangle rather than using a full "
"screen quad. The reason for this is explained `here <https://michaldrobot."
"com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_. However, the "
"benefit is quite small and only beneficial when running especially complex "
"fragment shaders."
msgstr ""
"Vous pouvez tirer profit de l'utilisation d'un seul grand triangle plutôt "
"que d'un grand quadrilatère de la taille de l'écran. Vous trouverez une "
"explication à `cette adresse <https://michaldrobot.com/2014/04/01/gcn-"
"execution-patterns-in-full-screen-passes>`_. Cependant, le bénéfice est "
"assez faible et seulement utile lors de l'utilisation de fragments shaders "
"particulièrement complexes."

#, fuzzy
msgid ""
"Set the Mesh in the MeshInstance3D to an :ref:`ArrayMesh <class_ArrayMesh>`. "
"An ArrayMesh is a tool that allows you to easily construct a Mesh from "
"Arrays for vertices, normals, colors, etc."
msgstr ""
"Réglez le Mesh dans la MeshInstance sur un :ref:`ArrayMesh "
"<class_ArrayMesh>`. Un ArrayMesh est un outil qui vous permet de construire "
"facilement un Mesh à partir de Arrays pour les sommets, les normales, les "
"couleurs, etc."

#, fuzzy
msgid "Now, attach a script to the MeshInstance3D and use the following code:"
msgstr ""
"Maintenant, attachez un script à MeshInstance et utilisez le code suivant :"

#, fuzzy
msgid ""
"The triangle is specified in normalized device coordinates. Recall, NDC run "
"from ``-1.0`` to ``1.0`` in both the ``x`` and ``y`` directions. This makes "
"the screen ``2`` units wide and ``2`` units tall. In order to cover the "
"entire screen with a single triangle, use a triangle that is ``4`` units "
"wide and ``4`` units tall, double its height and width."
msgstr ""
"Le triangle est spécifié en coordonnées normalisées de l'appareil. Rappelons "
"que les NDC vont de ``-1`` à ``1`` dans les directions ``x`` et ``y``. Ce "
"qui donne une taille d'écran de ``2`` unités en largeur et ``2`` unités en "
"hauteur. Afin de couvrir l'entièreté de l'écran avec un seul triangle, "
"utilisez un triangle de ``4`` unités de largeur et ``4`` unités de hauteur, "
"soit le double de la hauteur et de la largeur de l'écran."

msgid ""
"Assign the same vertex shader from above and everything should look exactly "
"the same."
msgstr ""
"Assignez le même vertex shader qu'au-dessus et tout devrait avoir exactement "
"la même apparence."

#, fuzzy
msgid ""
"The one drawback to using an ArrayMesh over using a QuadMesh is that the "
"ArrayMesh is not visible in the editor because the triangle is not "
"constructed until the scene is run. To get around that, construct a single "
"triangle Mesh in a modeling program and use that in the MeshInstance3D "
"instead."
msgstr ""
"Le seul inconvénient de l'utilisation d'un ArrayMesh par rapport à celle "
"d'un QuadMesh est que le ArrayMesh n'est pas visible dans l'éditeur car le "
"triangle n'est pas construit avant que la scène ne soit exécutée. Pour "
"contourner ce problème, construisez un Mesh triangulaire dans un programme "
"de modélisation et utilisez-le dans le MeshInstance à la place du ArrayMesh."

msgid "Translation status"
msgstr "État de la traduction"
