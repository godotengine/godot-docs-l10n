# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2022, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-09 16:03+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#, fuzzy
msgid "Coding the player"
msgstr "移動玩家"

msgid ""
"In this lesson, we'll add player movement, animation, and set it up to "
"detect collisions."
msgstr ""

#, fuzzy
msgid ""
"To do so, we need to add some functionality that we can't get from a built-"
"in node, so we'll add a script. Click the ``Player`` node and click the "
"\"Attach Script\" button:"
msgstr ""
"現在我們需要一個內建節點沒有提供的功能，所以需要自己寫腳本了。點擊 "
"``Player`` 節點，然後點擊 [附加腳本] 按鈕："

msgid ""
"In the script settings window, you can leave the default settings alone. "
"Just click \"Create\":"
msgstr "腳本設定視窗內的設定可以保持預設值。直接點擊 [建立] 就好："

msgid ""
"If you're creating a C# script or other languages, select the language from "
"the `language` drop down menu before hitting create."
msgstr ""
"如果要建立 C# 腳本或其他語言的腳本，在點擊建立前記得在 [語言] 下拉選單內選擇"
"語言。"

msgid ""
"If this is your first time encountering GDScript, please read :ref:"
"`doc_scripting` before continuing."
msgstr ""

msgid "Start by declaring the member variables this object will need:"
msgstr "首先我們先宣告這個物件所需要的成員變數："

msgid ""
"Using the ``export`` keyword on the first variable ``speed`` allows us to "
"set its value in the Inspector. This can be handy for values that you want "
"to be able to adjust just like a node's built-in properties. Click on the "
"``Player`` node and you'll see the property now appears in the \"Script "
"Variables\" section of the Inspector. Remember, if you change the value "
"here, it will override the value written in the script."
msgstr ""
"在第一個變數 ``speed`` 上使用 ``export`` 關鍵字可以讓我們稍後在屬性面板中指"
"定 speed 的值。當希望讓成員變數與節點內建屬性一樣可以在屬性面板中調整的話，就"
"可以用這個功能。點擊 ``Player`` 節點，就可以在 [Script Variables] (腳本變數) "
"內看到這個屬性。但請記得，如果在屬性面板中修改了數值，會覆蓋掉腳本內所指定的"
"值。"

msgid ""
"If you're using C#, you need to (re)build the project assemblies whenever "
"you want to see new export variables or signals. This build can be manually "
"triggered by clicking the word \"Mono\" at the bottom of the editor window "
"to reveal the Mono Panel, then clicking the \"Build Project\" button."
msgstr ""
"使用 C# 時，若要看到新匯出的變數或訊號，就需要建置或重新建置專案。要重新建置"
"專案可以手動點擊編輯器視窗底部的 [Mono] 文字來打開 Mono 面板，然後點擊 [建置"
"專案] 按鈕。"

msgid ""
"The ``_ready()`` function is called when a node enters the scene tree, which "
"is a good time to find the size of the game window:"
msgstr ""
"``_ready()`` 函式是當節點進入場景樹後會呼叫的函式，這裡正是取得遊戲視窗大小的"
"好時機："

msgid ""
"Now we can use the ``_process()`` function to define what the player will "
"do. ``_process()`` is called every frame, so we'll use it to update elements "
"of our game, which we expect will change often. For the player, we need to "
"do the following:"
msgstr ""
"接著我們可以使用 ``_process()`` 函式來定義玩家要做的事。 ``_process()`` 在每"
"一幀都會被呼叫，所以我們會用 _process() 來更新遊戲內需要常常變化的元素。而對"
"於 Player，我們需要做這些事："

msgid "Check for input."
msgstr "檢查輸入。"

msgid "Move in the given direction."
msgstr "沿指定方向移動。"

msgid "Play the appropriate animation."
msgstr "播放適當的動畫。"

#, fuzzy
msgid ""
"First, we need to check for input - is the player pressing a key? For this "
"game, we have 4 direction inputs to check. Input actions are defined in the "
"Project Settings under \"Input Map\". Here, you can define custom events and "
"assign different keys, mouse events, or other inputs to them. For this game, "
"we will map the arrow keys to the four directions."
msgstr ""
"首先，我們需要檢查輸入——玩家有按按鍵嗎？在這個遊戲中，我們需要檢查四個方向的"
"輸入。輸入操作是在專案設定中的 [輸入映射] 裡設定的。可以在輸入映射中定義自定"
"事件，並給事件指定不同的按鍵、滑鼠事件或其他輸入。在這個示範遊戲中，我們會使"
"用預設事件，這些事件是被分配到鍵盤上的方向鍵。"

msgid ""
"Click on *Project -> Project Settings* to open the project settings window "
"and click on the *Input Map* tab at the top. Type \"move_right\" in the top "
"bar and click the \"Add\" button to add the ``move_right`` action."
msgstr ""

msgid ""
"We need to assign a key to this action. Click the \"+\" icon on the right, "
"then click the \"Key\" option in the drop-down menu. A dialog asks you to "
"type in the desired key. Press the right arrow on your keyboard and click "
"\"Ok\"."
msgstr ""

msgid "Repeat these steps to add three more mappings:"
msgstr ""

msgid "``move_left`` mapped to the left arrow key."
msgstr ""

msgid "``move_up`` mapped to the up arrow key."
msgstr ""

msgid "And ``move_down`` mapped to the down arrow key."
msgstr ""

#, fuzzy
msgid "Your input map tab should look like this:"
msgstr "現在場景看起來會這樣："

msgid "Click the \"Close\" button to close the project settings."
msgstr ""

msgid ""
"We only mapped one key to each input action, but you can map multiple keys, "
"joystick buttons, or mouse buttons to the same input action."
msgstr ""

msgid ""
"You can detect whether a key is pressed using ``Input.is_action_pressed()``, "
"which returns ``true`` if it's pressed or ``false`` if it isn't."
msgstr ""
"可以用 ``Input.is_action_pressed()`` 來偵測按鍵是否被按下。這個函式會在按鍵被"
"按下時回傳 ``true`` ，若沒按下則會回傳 ``false`` 。"

msgid ""
"We start by setting the ``velocity`` to ``(0, 0)`` - by default, the player "
"should not be moving. Then we check each input and add/subtract from the "
"``velocity`` to obtain a total direction. For example, if you hold ``right`` "
"and ``down`` at the same time, the resulting ``velocity`` vector will be "
"``(1, 1)``. In this case, since we're adding a horizontal and a vertical "
"movement, the player would move *faster* diagonally than if it just moved "
"horizontally."
msgstr ""
"我們先從設定 ``velocity`` (速率) 開始，設定成 ``(0, 0)`` ——這表示在預設情況"
"下，玩家應該不會移動。接著依據不同的輸入來增加／減少 ``velocity`` 來往不同方"
"向移動。例如，如果同時按住 ``右`` 與 ``下`` 方向鍵，最終的 ``velocity`` 向量"
"值應該是 ``(1, 1)`` 。因為這個情況下我們同時增加了水平與垂直方向的移動距離，"
"所以玩家的移動速度應該比只在水平方向上移動 **還要快** 。"

msgid ""
"We can prevent that if we *normalize* the velocity, which means we set its "
"*length* to ``1``, then multiply by the desired speed. This means no more "
"fast diagonal movement."
msgstr ""
"我們可以通過 **正規化** (Normalize) 速率來防止這種情況，也就是要把移動的 **距"
"離** 設定為 ``1`` ，接著乘以需要的速度。這表示在對角線上移動不會比水平移動還"
"要快了。"

msgid ""
"If you've never used vector math before, or need a refresher, you can see an "
"explanation of vector usage in Godot at :ref:`doc_vector_math`. It's good to "
"know but won't be necessary for the rest of this tutorial."
msgstr ""
"如果你從來沒學習過向量數學運算或是需要複習的話，可以參考這篇 :ref:"
"`doc_vector_math` 瞭解 Godot 中是如何使用向量的。雖然對於這篇本篇教學剩下的部"
"分來說不必要，但若能瞭解 Godot 中的向量是最好不過的了。"

#, fuzzy
msgid ""
"We also check whether the player is moving so we can call ``play()`` or "
"``stop()`` on the AnimatedSprite."
msgstr ""
"同時也需要檢查玩家有沒有在移動，這樣才能呼叫 AnimatedSprite 上的 ``play()`` "
"跟 ``stop()`` 。"

#, fuzzy
msgid ""
"``$`` is shorthand for ``get_node()``. So in the code above, "
"``$AnimatedSprite.play()`` is the same as ``get_node(\"AnimatedSprite\")."
"play()``."
msgstr ""
"``$`` 是 ``get_node()`` 的簡寫。所以上面的程式碼中 ``$AnimatedSprite."
"play()`` 等同於 ``get_node(\"AnimatedSprite\").play()`` 。"

#, fuzzy
msgid ""
"In GDScript, ``$`` returns the node at the relative path from the current "
"node, or returns ``null`` if the node is not found. Since AnimatedSprite is "
"a child of the current node, we can use ``$AnimatedSprite``."
msgstr ""
"在 GDScript 中， ``$`` 會回傳與目前節點相對路徑上的節點，若找不到則會回傳 "
"``null`` 。由於 AnimatedSprite 是目前節點的子節點，所以可以寫成 "
"``$AnimatedSprite`` 。"

msgid ""
"Now that we have a movement direction, we can update the player's position. "
"We can also use ``clamp()`` to prevent it from leaving the screen. "
"*Clamping* a value means restricting it to a given range. Add the following "
"to the bottom of the ``_process`` function (make sure it's not indented "
"under the `else`):"
msgstr ""
"現在玩家會面向不同方向了，可以接著來更新玩家的位置。還可以使用 ``clamp()`` "
"(箝制) 來防止 Player 物件跑出畫面外。**箝制** 一個值，就代表把值限制在一個給"
"定的範圍內。將下列程式碼放到 ``_process`` 函式的末尾 (記得確定不要放到 "
"`else` 縮排下了)："

msgid ""
"The `delta` parameter in the `_process()` function refers to the *frame "
"length* - the amount of time that the previous frame took to complete. Using "
"this value ensures that your movement will remain consistent even if the "
"frame rate changes."
msgstr ""
"**_process()** 函式的 **delta** 參數代表了 **影格時長** ——即是自從上一個影格"
"到現在這個影格所花費的時間。通過這個數值可以確保即使幀率發生變化，移動的距離"
"也能保持不變。"

#, fuzzy
msgid ""
"Click \"Play Scene\" (:kbd:`F6`, :kbd:`Cmd + R` on macOS) and confirm you "
"can move the player around the screen in all directions."
msgstr "點擊 [執行場景] (``F6``) 並測試玩家能否夠移動到任何一個方向。"

msgid "If you get an error in the \"Debugger\" panel that says"
msgstr "若「除錯工具」中出現了這樣的錯誤"

msgid ""
"``Attempt to call function 'play' in base 'null instance' on a null "
"instance``"
msgstr ""
"``Attempt to call function 'play' in base 'null instance' on a null "
"instance`` (嘗試在基礎型別為「null 實體」的 null 實體上呼叫「play」函式)"

#, fuzzy
msgid ""
"this likely means you spelled the name of the AnimatedSprite node wrong. "
"Node names are case-sensitive and ``$NodeName`` must match the name you see "
"in the scene tree."
msgstr ""
"通常這代表程式中的 AnimatedSprite 節點名稱拼錯了。節點名稱有區分大小寫，而且 "
"``$NodeName`` 這種語法中的名稱必須與場景樹裡能看到的節點名稱一致。"

msgid "Choosing animations"
msgstr "選擇動畫"

#, fuzzy
msgid ""
"Now that the player can move, we need to change which animation the "
"AnimatedSprite is playing based on its direction. We have the \"walk\" "
"animation, which shows the player walking to the right. This animation "
"should be flipped horizontally using the ``flip_h`` property for left "
"movement. We also have the \"up\" animation, which should be flipped "
"vertically with ``flip_v`` for downward movement. Let's place this code at "
"the end of the ``_process()`` function:"
msgstr ""
"現在玩家可以移動了，現在讓我們來根據移動的方向改變播放的 AnimatedSprite。"
"「walk」動畫會讓玩家看起來朝右邊行走，朝左邊行走時使用 ``flip_h`` 屬性來水平"
"翻轉動畫。另一個動畫是「up」，朝下行走時使用 ``flip_v`` 來垂直翻轉。來把程式"
"碼放到 ``_process()`` 函式的尾端："

msgid ""
"The boolean assignments in the code above are a common shorthand for "
"programmers. Since we're doing a comparison test (boolean) and also "
"*assigning* a boolean value, we can do both at the same time. Consider this "
"code versus the one-line boolean assignment above:"
msgstr ""
"在這段程式碼中的布林賦值是程式設計師常用的一種簡寫方式。因為做了數值比較 (會"
"得到布林值) 後也需要將這個布林值 **賦值** 到變數上，所以我們可以把這兩件事合"
"在一起做。可以比較看看下面這段程式碼跟上方範例中單行布林賦值的程式："

msgid ""
"Play the scene again and check that the animations are correct in each of "
"the directions."
msgstr "再執行一次場景來看看各個方向的動畫是否正確。"

msgid ""
"A common mistake here is to type the names of the animations wrong. The "
"animation names in the SpriteFrames panel must match what you type in the "
"code. If you named the animation ``\"Walk\"``, you must also use a capital "
"\"W\" in the code."
msgstr ""
"很多人會在這裡打錯動畫名稱。SpriteFrames 面板上的動畫名稱必須與程式碼中輸入的"
"名稱一致。如果動畫名稱為 ``「Walk」`` ，則程式碼中也必須使用大寫的「W」。"

msgid ""
"When you're sure the movement is working correctly, add this line to "
"``_ready()``, so the player will be hidden when the game starts:"
msgstr ""
"確保能正常移動後，來把下面這行程式碼加到 ``_ready()`` 裡。如此一來在遊戲開始"
"的時候玩家會隱藏起來："

msgid "Preparing for collisions"
msgstr "準備碰撞"

msgid ""
"We want ``Player`` to detect when it's hit by an enemy, but we haven't made "
"any enemies yet! That's OK, because we're going to use Godot's *signal* "
"functionality to make it work."
msgstr ""
"我們希望 ``Player`` 被敵人撞到時能偵測到，但我們還沒做好敵人！沒關係，因為我"
"們會用 Godot 的 **訊號** 來做這個功能。"

msgid "Add the following at the top of the script, after ``extends Area2D``:"
msgstr "將下列程式碼加在腳本頂部的 ``extends Area2D`` 後："

msgid ""
"This defines a custom signal called \"hit\" that we will have our player "
"emit (send out) when it collides with an enemy. We will use ``Area2D`` to "
"detect the collision. Select the ``Player`` node and click the \"Node\" tab "
"next to the Inspector tab to see the list of signals the player can emit:"
msgstr ""
"這段程式碼定義了一個叫做「hit」的自定訊號，稍後我們會讓玩家在碰撞到敵人的時候"
"送出這個訊號。我們會使用 ``Area2D`` 來偵測碰撞。先選擇 ``Player`` 節點，然後"
"點擊屬性面板旁邊的 [節點] 分頁來看看所有 Player 能送出的訊號："

msgid ""
"Notice our custom \"hit\" signal is there as well! Since our enemies are "
"going to be ``RigidBody2D`` nodes, we want the ``body_entered(body: Node)`` "
"signal. This signal will be emitted when a body contacts the player. Click "
"\"Connect..\" and the \"Connect a Signal\" window appears. We don't need to "
"change any of these settings so click \"Connect\" again. Godot will "
"automatically create a function in your player's script."
msgstr ""
"可以看到我們自定的「hit」訊號出現在這裡了！由於敵人使用 ``RigidBody2D`` 節"
"點，所以我們會需要 ``body_entered(body: Node)`` 訊號。這個訊號會在敵人的形體 "
"(Body) 接觸到玩家時送出。點擊 [連接...] 後會出現「連接訊號」視窗。我們先不動"
"這裡的設定，點擊 [連接]。Godot 會自動在玩家腳本內建立一個函式。"

msgid ""
"Note the green icon indicating that a signal is connected to this function. "
"Add this code to the function:"
msgstr ""
"可以注意到，出現了一個綠色圖示。這個圖示代表有訊號連到這個函式上。將這段程式"
"碼加到函式中："

msgid ""
"Each time an enemy hits the player, the signal is going to be emitted. We "
"need to disable the player's collision so that we don't trigger the ``hit`` "
"signal more than once."
msgstr ""
"每當敵人碰撞到玩家後都會送出這個訊號。這時我們需要關閉玩家的碰撞偵測，這樣才"
"不會觸發超過一次的 ``hit`` 訊號。"

msgid ""
"Disabling the area's collision shape can cause an error if it happens in the "
"middle of the engine's collision processing. Using ``set_deferred()`` tells "
"Godot to wait to disable the shape until it's safe to do so."
msgstr ""
"如果在引擎處理碰撞過程中間禁用碰撞區域可能會發生錯誤。所以我們需要使用 "
"``set_deferred()`` 來讓 Godot 等到能安全禁用碰撞區域後再禁用。"

msgid ""
"The last piece is to add a function we can call to reset the player when "
"starting a new game."
msgstr "最後我們要做的，就是新增一個函式，用來在開始新遊戲時重設玩家。"

msgid "With the player working, we'll work on the enemy in the next lesson."
msgstr ""

msgid "Translation status"
msgstr "翻譯狀態"
