# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-31 15:34+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:4
msgid "Nodes and terminology"
msgstr "節點與術語"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:6
msgid ""
"Before continuing, it must be noted that the *Node* terminology needs to be "
"used with care. When referring to *Visual Script Nodes* (or generally "
"*Nodes*) this text will refer to the little boxes you connect with lines, "
"which are part of a graph. When referring to *Scene Nodes*, it is implied "
"that the elements that make up a Scene are being referred, which are part of "
"a tree. Their naming is similar but their function is different. When "
"referring to *Node* here, it will be implied that a *Visual Script Node* is "
"referred to unless indicated otherwise."
msgstr ""
"在繼續之前，我們必須先瞭解 **節點** 這個術語要怎麼使用。當我們講 **視覺腳本節"
"點** (或一般講 **節點**)，則代表圖表上那些小盒子，可以用線段來連接。而講 **場"
"景節點** 則指的是構成場景的元素，屬於場景樹的一部分。這兩個名稱很類似，但功能"
"不同。當我們在這裡說 **節點** ，除非有特別說明，否則都是指 **視覺腳本節點"
"** 。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:15
msgid "Node properties"
msgstr "節點屬性"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:17
msgid ""
"Like in most visual scripting implementations, each node has editable "
"properties. In Godot, though, we try to avoid bloating the nodes with "
"editable controls for the sake of readability."
msgstr ""
"與其他大部分視覺腳本實作一樣，每個節點都有可編輯的屬性。但在 Godot 中，我們希"
"望避免用可編輯的控制元件來讓節點變得複雜而難以閱讀。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:20
msgid ""
"Nodes still display the required information as text, but editing is done "
"via the *Inspector*. To edit them, select any node and edit its properties "
"in the *Inspector*."
msgstr ""
"節點依然會將需要的資訊顯示為文字，但編輯是通過 **屬性面板** 來做的。要編輯屬"
"性，先選擇任意節點並在 **屬性面板** 中編輯屬性。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:25
msgid "Ports and connections"
msgstr "連接埠與連線"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:27
msgid ""
"Programming in Godot Visual Scripting is done via *Nodes* and *Port "
"Connections* inside each function."
msgstr ""
"在 Godot 視覺腳本中進行程式設計是通過各個函式的 **節點** 與 **連接埠連線** 來"
"完成的。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:31
msgid "Ports"
msgstr "連接埠"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:33
msgid ""
"Nodes in Godot Visual Scripting have *Ports*. These are endpoints that "
"appear to the left and right of nodes and which can be used to make "
"*Connections*: There are two types of *Ports*: *Sequence* and *Data*."
msgstr ""
"在 Godot 視覺腳本中的節點有 **連接埠** 。連接埠是顯示在節點左右兩側的端點，可"
"以用來建立 **連線** 。有兩種類型的 **連接埠** ：**序列** 與 **資料**。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:40
msgid ""
"*Sequence Ports* indicate the order in which operations are executed. "
"Typically when a *Node* is done processing, it will go to the next node from "
"one of the ports at the right. If nothing is connected, the function may "
"end, or another output *Sequence Port* might be tried (this depends on the "
"node). Thanks to this, you can follow the logic flow within a function by "
"following the white lines. Not every *Node* has *Sequence Ports*. In fact, "
"most do not."
msgstr ""
"**序列埠** 用來表示執行操作的順序。通常當 **節點** 完成處理後，該節點會從右邊"
"的其中一個連接埠繼續執行下一個節點。若沒有連接任何節點，則函式會結束執行，或"
"試著輸出到另一個 **序列埠** (依據節點而有所不同)。因此，只需要跟著白色線即代"
"表韓世忠的邏輯流程。並非所有 **節點** 都有 **序列埠** ，而事實上大部分節點都"
"沒有。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:46
msgid ""
"*Data Ports* ports contain typed values. Types can be any regular Godot "
"types, such as a boolean, an integer, a string, a Vector3, an array, any "
"Object or Scene Node, etc. A *Data Port* on the right side of a node is "
"considered an output, while, a port on the left side is an input. Connecting "
"them allows information to flow to the next node."
msgstr ""
"**資料埠** 包含了特定型別的數值。數值的型別可以是任何一般 Godot 型別，如布"
"林、整數、字串、Vector3、陣列、物件或場景節點…等。在節點右側的 **資料埠** 可"
"以當作輸出，而左側的連接埠則是輸入。通過連接這些連接埠可以用來讓資訊從一個節"
"點流動到下一個節點。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:51
msgid ""
"Not all *Data Port* types are compatible and will allow connections, though. "
"Pay special attention to colors and icons, as each type has a different "
"representation:"
msgstr ""
"但並非所有 **資料埠** 都互相相容以及可連接。請注意看色彩與圖示，每個型別都有"
"不同的顯示方式："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:58
msgid "Connections"
msgstr "連接"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:60
msgid ""
"Connecting is a relatively simple process. Drag an *Output Port* towards an "
"*Input Port*."
msgstr "連接連接埠則是相對簡單。拖移 **輸出連接埠** 到 **輸入連接埠** 。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:65
msgid ""
"Disconnecting takes a bit more practice. Disconnecting in *Data Ports* "
"happens by dragging the *Input* away, while for *Sequence Ports*, this "
"happens by dragging the *Output* away."
msgstr ""
"斷開連接則需要一點練習。要斷開連接 **資料埠** 需要把 **輸入** 拖移走，而 **序"
"列埠** 則是將 **輸出** 拖移走。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:71
msgid ""
"This may seem strange at first, but it happens because *Data Ports* are 1:N "
"(A single output port can connect to many inputs), while *Sequence Ports* "
"are N:1 (Many sequence outputs can be connected to a single input)."
msgstr ""
"一開始看這個方式可能有點奇怪，但會這麼設計是因為 **資料埠** 為 1:N (單一輸出"
"連接埠可以連接到多個輸入)，而 **序列埠** 則為 N:1 (多個序列輸出可以連接到單一"
"輸入)。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:75
msgid ""
"Connecting to empty space (drag to connect but unpress over empty space) is "
"also context sensitive, it will supply a list of most common operations. For "
"sequences, it will be conditional nodes:"
msgstr ""
"連接到空白區域 (拖移來連接後在空白區域放開) 也與上下文有關，放開後會列出常用"
"操作。序列埠會顯示條件節點："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:81
msgid "While, for data, a contextual set/get/call menu will open:"
msgstr "而資料埠則會開啟設定／取得／呼叫的上下文選單："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:87
msgid "Adding nodes"
msgstr "新增節點"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:89
msgid ""
"Finally! We got to the fun part! But, before explaining in more detail what "
"each type of node does, let's take a short look at how nodes are most "
"commonly added and dealt with."
msgstr ""
"最後！到了最有趣的部分了！但是，在詳細解釋各型別節點的功能前，先來看看節點通"
"常是怎麼新增以及如何處理節點的。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:94
msgid "Accessing scene nodes"
msgstr "存取場景節點"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:96
msgid ""
"One of the most common tasks is accessing Scene Tree Nodes (again, not to "
"mistake with *Visual Script Nodes*). Dragging from the Scene Tree and "
"dropping into the canvas will ask you to *call a method* (sometimes referred "
"to as *member function*) on this node."
msgstr ""
"最常見的任務之一就是存取場景樹節點了 (不要與 **視覺腳本節點** 搞混了)。從場景"
"樹拖移過來並在畫布上放開，會詢問是否要在節點上 **呼叫方法** (有時也稱為 **成"
"員函式**)。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:102
msgid ""
"While accessing properties is desired in most cases (more on that below), "
"sometimes *calling methods* can be useful too. Methods execute specific "
"actions on objects. In the above case, the mouse pointer can be warped to a "
"position in local coordinates to the control. Another common use case is "
"queueing a node for deletion, which is done with the *queue_free* method."
msgstr ""
"雖然大多數情況下我們都是要存取屬性 (詳細請見下方)，但有時 **呼叫方法** 也很實"
"用。方法是用來對物件執行特定的操作。在上圖例子中，可以將滑鼠遊標包裝到控制元"
"件 (按鈕) 的指定座標位置上。另一個常見的呼叫方法用途則是使用 **queue_free** "
"方法將刪除節點排入佇列。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:109
msgid ""
"Care must be taken that this only works if the scene being edited contains "
"your *Visual Script* in one of the nodes! Otherwise, a warning will be shown."
msgstr ""
"請注意，這種做法只能在編輯中場景的其中一個節點有包含 **視覺腳本** 時才可以"
"用！否則會顯示警告。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:113
msgid "Accessing scene node properties"
msgstr "存取場景節點屬性"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:115
msgid ""
"This is the most common way to edit *Scene Nodes* in Visual Scripting. "
"Select a *Scene Node* from the *Scene Tree*, go to the Inspector, find *the "
"Name* of the property you want to edit (hint, *not* the value!) and drag it "
"to the canvas:"
msgstr ""
"這是在視覺腳本中編輯 **場景節點** 最常見的方法。從 **場景樹** 中選擇一個 **場"
"景節點** ，然後在屬性面板中找到要編輯的屬性 **名稱** (而不是 **值**)，並將名"
"稱拖移至畫布上："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:120
msgid ""
"The result is that this value can be changed from your script by writing to "
"a *Data Port*."
msgstr "之後這個至便可以通過寫入 **資料埠** 來從腳本內修改。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:122
msgid ""
"If instead reading this value is desired, drag the node again but hold :kbd:"
"`Ctrl` (or :kbd:`Cmd` on macOS). This will create a getter:"
msgstr ""
"若不是要編輯值而是讀取值，則可以在拖移節點時按住 :kbd:`Ctrl` (或 macOS 上 :"
"kbd:`Cmd` )，就可以建立 Getter："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:127
msgid "In this case, the value can be read from a *Data Port*."
msgstr "這樣一來便能從 **資料埠** 來讀取值。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:131
msgid "Variables"
msgstr "變數"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:133
msgid ""
"Variables are memory containers local to the script which can hold a value. "
"This value can be read from any of the functions of the script or from other "
"scripts via the method described in the previous step."
msgstr ""
"變數是一種能保存數值的記憶體容器，對於腳本來說是區域性的。變數值可以從腳本中"
"任何函式讀取，或是通過由上一個步驟中說民的方法來從其他腳本讀取。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:135
msgid ""
"To add a Variable, push the \"+\" button on the *Variables* section of the "
"Members panel. Double-click the new variable to rename it:"
msgstr ""
"要新增變數，點擊 [成員] 面板中的 **[變數]** 分類下點擊 [+] 按鈕。點兩下新變數"
"名稱來重新命名："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:140
msgid "Right-clicking the variable allows you to configure its properties:"
msgstr "右鍵點擊變數便可設定變數屬性："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:147
msgid ""
"As it can be seen above, the type and initial value of the variable can be "
"changed, as well as some property hints. Ticking the \"Export\" option makes "
"the variable visible in the Inspector when selecting the node. This also "
"makes it available to other scripts via the method described in the previous "
"step."
msgstr ""
"就像上面看到的，可以更改變數的型別與初始值以及一些屬性提示。點擊 [匯出] 選項"
"可以讓變數在選擇節點時出現在屬性面板中。也可以讓其他腳本能通過上一個步驟中說"
"明的方法來使用這個變數。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:153
msgid ""
"To use the variable in the script, simply drag it to the canvas to create a "
"getter:"
msgstr "要在腳本中使用變數，只需要將變數拖移到畫布上就能建立 Getter："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:158
msgid "Likewise, hold :kbd:`Ctrl` (or :kbd:`Cmd` on macOS) to drop a setter:"
msgstr "同樣地，按住 :kbd:`Ctrl` (或 macOS 上 :kbd:`Cmd`) 即可放置 Setter："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:164
msgid "Signals"
msgstr "訊號"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:166
msgid ""
"It is also possible to create your own signals in a script and use them. For "
"this, do the same steps you did for variables in the previous step, except "
"for *Signals*:"
msgstr ""
"也可以在腳本中建立自定訊號並使用。為此，只需要重複上一個步驟中相同，但這次選"
"擇 **訊號** ："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:171
msgid ""
"A signal can also be edited via the right-click menu to customize its "
"arguments:"
msgstr "訊號也可以在右鍵選單中編輯來自定參數："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:176
msgid ""
"The signal you have created will appear in the Inspector, along with the "
"built-in node signals. This allows you to connect it from another script "
"from another *Scene Node*:"
msgstr ""
"建立好的訊號會與內建節點訊號一樣出現在屬性面板中。從這裡可以連接訊號到另一個 "
"**場景節點** 的另一個腳本上："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:181
msgid "Finally, to emit the signal, simply drag it to the canvas:"
msgstr "最後，要送出訊號只需要將訊號拖曳到畫布上即可："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:186
msgid ""
"Remember that emitting a signal is a sequenced operation, so it must come "
"from a Sequence port."
msgstr "請記得，送出訊號是有順序的操作，所以必須要從 **序列埠** 連出來。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:190
msgid "Adding more nodes"
msgstr "新增更多節點"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:192
msgid ""
"Now that the basics are covered, let's discuss the large amount of utility "
"nodes available for your canvas! Below the member panel, exists the list of "
"all available node types:"
msgstr ""
"現在我們已經講完基礎了，來說一下可以在畫布上使用的更多公用節點！在成員面板下"
"方有列出所有可用的節點類型："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:198
msgid ""
"Pressing :kbd:`Ctrl + F` (or :kbd:`Cmd + F` on macOS) allows you to search "
"the list."
msgstr "按 :kbd:`Ctrl + F` (或 macOS 上 :kbd:`Cmd + F`) 可以搜尋列表。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:200
msgid ""
"Any of them can be dragged to the scene. Unlike nodes (e.g. dragging a "
"property from the Inspector sets the context to the node being edited "
"automatically), these are added without any \"contextual\" information, so "
"this has to be done manually."
msgstr ""
"列表中的所有節點都可以拖移只場景中。與其他節點不同 (如：從屬性面板中拖移屬性"
"說來會自動將上下文設定到正在編輯的節點)，列表中的節點在加入時不會加上「上下"
"文」資訊，必須手動設定。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:206
msgid ""
"Remember that you can check the class reference for what each node does, as "
"they are documented there. That mentioned, a brief overview of node types "
"follows:"
msgstr ""
"請記得，可以從類別參考中瞭解各個節點的功能，類別參考中有文件說明。就像剛才說"
"得，各個節點的簡介如下："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:211
msgid "Constants"
msgstr "常數"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:213
msgid ""
"Constant nodes are nodes that provide values that, while not changing over "
"time, can be useful as reference values. Most of the time they are integer "
"or float."
msgstr ""
"常數節點是用來提供不會隨時間變化的數值，適合用來作為參考值。大多數的時候常數"
"節點都是整數或浮點數。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:219
msgid ""
"The first one is \"Constant\", which allows you to select any value of any "
"type as constant, from an integer (42) to a String (\"Hello!\"). In general, "
"this node is not used that often because of default input values in *Data "
"Ports*, but it's good to know it exists."
msgstr ""
"第一個是「常數」，能用來選擇任意類型的任意數值作為常數，不管是整數 (42) 還是"
"字串 (\"你好！\")。一般來說，因為 **資料埠** 有預設輸入值，所以不會很常用到常"
"數節點，但知道有這東西還是不錯的。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:221
msgid ""
"The second is the GlobalConstant node, which contains a long list of "
"constants for global types in Godot. In there you can find some useful "
"constants to refer to key names, joystick or mouse buttons, etc."
msgstr ""
"第二個則是 GlobalConstant 節點，這個節點包含了 Godot 中用於全域型別的常數列"
"表。可以在這個節點中找到用來參照按鍵名稱、搖桿或滑鼠按鈕…等的實用常數。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:224
msgid ""
"The third one is MathConstant, which provides typical mathematical "
"constants, such as PI, E, etc."
msgstr "第三種則是 MathConstant，提供了常見的數學常數，如 PI, E …等。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:228
msgid "Data"
msgstr "資料"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:230
msgid ""
"Data nodes deal with all sorts of access to information. Any information in "
"Godot is accessed via these nodes, so they are some of the most important "
"ones to use and pretty diverse."
msgstr ""
"資料節點用來除了各類的資訊存取。在 Godot 中所有的資訊都是通過這些節點來存取"
"的，所以也是最重要的一些節點，同時也有許多種類。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:236
msgid ""
"There are many types of nodes of interest here, so a short attempt to "
"describe them will follow:"
msgstr "其中有許多種有趣的節點，這裡簡單說明一下："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:240
msgid "Action"
msgstr "操作"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:242
msgid ""
"Action nodes are vital when dealing with input from a device. You can read "
"more about actions in the (@TODO ACTION TUTE LINK). In the following example "
"below, the control is moved to the right when the \"move_right\" action is "
"pressed."
msgstr ""
"操作節點在處理從裝置來的輸入時很重要。更多關於操作的說明請參考此處 (@TODO 連"
"結待補)。在下方的範例中，控制元件會在「move_right」操作按下後往右移動。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:249
msgid "Engine Singleton"
msgstr "Engine Singleton 引擎單例"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:251
msgid ""
"Engine singletons are global interfaces (meaning they can be accessed "
"without a reference; unlike Scene Nodes, they are always available). They "
"have several purposes, but in general, they are useful for low-level access "
"or OS-related access."
msgstr ""
"引擎單例 (Singleton) 是全域介面 (代表這些介面可以不通過參照來存取，與場景節點"
"不同，這些介面隨時可用)。這些節點有許多功能，但一般來說，這些節點都適合用來存"
"取低階或作業系統相關的功能。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:257
msgid ""
"Remember that dragging a connection to empty space will help you call "
"functions or set/get properties on these:"
msgstr "記得，將連線拖移到空白出可以呼叫函式或設定／取得屬性："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:263
msgid "Local Variables"
msgstr "Local Variables 區域變數"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:265
msgid ""
"These are nodes you can use as temporary storage for your graphs. Make sure "
"they all have the same name and type when using them and they will reference "
"the same piece of memory."
msgstr ""
"這些節點可以用來為圖表作臨時儲存。只要使用相同的名稱與型別，就會參照到相同的"
"記憶體。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:270
msgid ""
"As it can be seen above, there are two nodes available: A simple getter, and "
"a sequenced setter (setting requires a sequence port)."
msgstr ""
"就像上面看到的，有兩個可用的節點：一個簡單的 Getter 與一個序列 Setter (設定需"
"要有序列埠)。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:274
msgid "Scene Node"
msgstr "Scene Node 場景節點"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:276
msgid ""
"This is just a reference to a node in the tree, but it's easier to use this "
"node by dragging the actual node from the scene tree to the canvas (this "
"will create it and configure it)."
msgstr ""
"只是參照到場景樹中的節點，但直接從場景樹拖移實際節點到畫布上比用這個節點簡單"
"多了 (直接拖移會建立並設定節點)。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:281
msgid "Self"
msgstr "僅自己"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:283
msgid ""
"In some rare occasions, it may be desired to pass this Scene Node as "
"argument. It can be used to call functions and set/get properties, or drag "
"nodes (or event the node itself that has the script) from the Scene Tree to "
"the canvas for this."
msgstr ""
"在某些罕見的情況下，可能會需要將此節點作為參數傳給場景節點。自身節點可以用來"
"呼叫函式與設定或取得屬性或是為本節點從場景樹拖移節點 (或是有腳本的節點自己) "
"到畫布上。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:288
msgid "SceneTree"
msgstr "\\ SceneTree"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:290
msgid ""
"This node is similar to the Singleton node because it references the "
"SceneTree, which contains the active scene. SceneTree, however, only works "
"when the node is sitting in the scene and active, otherwise accessing it "
"will return an error."
msgstr ""
"自身節點與單例節點很像，因為這兩個節點都是參照到包含有效場景的 SceneTree。但 "
"SceneTree 只在節點位於場景內且有效的情況下可以用，否則存取的時候會回傳錯誤。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:294
msgid ""
"SceneTree allows for many low-level things, like setting stretch options, "
"calling groups, make timers, or even load another scene. It's a good class "
"to get familiar with."
msgstr ""
"SceneTree 允許許多低階的操作，如設定拉伸選項、呼叫群組、建立 Timer 或甚至載入"
"其他場景。建議多瞭解 SceneTree 類別。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:299
msgid "Preload"
msgstr "Preload 預載"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:301
msgid ""
"This does the same function as preload() in GDScript. It maintains this "
"resource loaded and ready to use. Rather than instancing the node, it's "
"simpler to drag the desired resource from the filesystem dock to the canvas."
msgstr ""
"預載節點與 GDScript 中的 preload() 功能相同。該節點可以用來讓載入指定資源並準"
"備好使用。比起實體化節點，從檔案系統拖所需的資源到畫布上還比較簡單。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:306
msgid "Resource Path"
msgstr "資源路徑"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:308
msgid ""
"This node is a simple helper to get a string with a path to a resource you "
"can pick. It's useful in functions that load things from disk."
msgstr ""
"資源路徑節點只是一個簡單的協助程式，可以用來取得所選資源的路徑字串。當有函數"
"需要從硬碟載入東西時很有用。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:313
msgid "Comment"
msgstr "Comment 註解"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:315
msgid ""
"A Comment node works as a node you can resize to put around other nodes. It "
"will not try to get focus or be brought to top when selecting it. It can "
"also be used to write text on it."
msgstr ""
"註解節點與節點一樣，可以縮放並放置在其他節點的周圍。當選擇註解節點時，焦點不"
"會跑到註解節點上，也不會跑到最上層。可以在註解上面寫字。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:322
msgid "Flow Control"
msgstr "Flow Control 流程控制"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:324
msgid ""
"Flow control nodes allow the execution to take different branches, usually "
"depending on a given condition."
msgstr "流程控制節點通常會依據給定的條件，執行不同的分支。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:331
msgid "Condition"
msgstr "Condition 條件"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:333
msgid ""
"This is a simple node that checks a bool port. If ``true``, it will go via "
"the \"true\" sequence port. If ``false``, the second. After going for either "
"of them, it goes via the \"done\" port. Leaving sequence ports disconnected "
"is fine if not all of them are used."
msgstr ""
"條件是一個很簡單的節點，只用來確認一個布林連接埠。若 ``true`` 則會執行"
"「true」序列埠，若 ``false`` 則會執行第二個。執行完任一個後，便會繼續執行"
"「done」連接埠。若不是全部的連接埠都有用到的話，也可以不連接序列埠。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:339
msgid "Iterator"
msgstr "Iterator 迭代器"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:341
msgid ""
"Some data types in Godot (ie, arrays, dictionaries) are iterable. This means "
"that a bit of code can run for each element that it has."
msgstr ""
"在 Godot 中，有些資料型別 (如陣列、字典) 是可迭代的。可迭代表示能在這些資料型"
"別的每個元素上執行某一段程式碼。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:344
msgid ""
"The Iterator node goes through all elements and, for each of them, it goes "
"via the \"each\" sequence port, making the element available in the \"elem\" "
"data port."
msgstr ""
"迭代器節點會通過每一個元素，並會將每一個元素都傳到「each」序列埠，然後讓元素"
"能通過「elem」資料埠存取。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:347
msgid "When done, it goes via the \"exit\" sequence port."
msgstr "迭代結束後將跑到「exit」序列埠。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:351
msgid "Return"
msgstr "Return 回傳"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:353
msgid ""
"Some functions can return values. In general for virtual ones, Godot will "
"add the Return node for you. A return node forces the function to end."
msgstr ""
"有些函式可以回傳數值。一般來說，Godot 會自動為虛擬函式加上回傳節點。回傳節點"
"可以強制函式結束。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:358
msgid "Sequence"
msgstr "Sequance 序列"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:360
msgid ""
"This node is useful mostly for organizing your graph. It calls its sequence "
"ports in order."
msgstr "序列節點適合用來組織圖表。會照順序呼叫序列埠。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:364
msgid "TypeCast"
msgstr "TypeCast 型別轉換"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:366
msgid ""
"This is a useful and commonly used node. You can use it to cast arguments or "
"other objects to the type you desire. Afterwards, you can even drag the "
"object output to get full completion."
msgstr ""
"TypeCast 是很實用也很常用的節點。可以通過 TypeCast 來將引數或其他物件轉換成想"
"要的型別。之後，還可以拖移物件輸出來完成。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:372
msgid ""
"It is also possible to cast to a script, which will allow complete script "
"properties and functions:"
msgstr "也可以將引數轉換為腳本，用來製作完整的腳本屬性與方法："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:378
msgid "Switch"
msgstr "Switch 切換"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:380
msgid ""
"The Switch node is similar to the Condition node, but it matches many values "
"at the same time."
msgstr "Switch 節點與 Condition 節點類似，但 Switch 節點會一次配對多個值。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:384
msgid "While"
msgstr "\\ While"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:386
msgid ""
"This is a more primitive form of iteration. \"repeat\" sequence output will "
"be called as long as the condition in the \"cond\" data port is met."
msgstr ""
"While 是比較原始的迭代方法。只要「cond」資料埠中的條件符合，就會一直重複呼叫"
"「repeat」序列輸出。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:391
msgid "Functions"
msgstr "函式"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:393
msgid ""
"Functions are simple helpers, most of the time deterministic. They take some "
"arguments as input and return an output. They are almost never sequenced."
msgstr ""
"函式是簡單的輔助程式，大部分情況下都可預測。函數會取得一些引數作為輸入，並回"
"傳輸出。函數通常都沒有序列。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:398
msgid "Built-In"
msgstr "Built-in 內建"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:400
msgid ""
"There is a list of built-in helpers. The list is almost identical to the one "
"from :ref:`GDScript<class_@GDScript>`. Most of them are mathematical "
"functions, but others can be useful helpers. Make sure to take a look at the "
"list at some point."
msgstr ""
"內建節點列出了內建輔助程式。這個列表與 :ref:`GDScript<class_@GDScript>` 文件"
"中的幾乎一樣。其中大部分都是數學函式，但還有一些其他很有用的輔助程式。若有空"
"記得去看一下。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:404
msgid "By Type"
msgstr "By Type 依型別"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:406
msgid ""
"Those are the methods available to basic types. For example, if you want a "
"dot-product, you can search for \"dot\" instead of the Vector3 category. In "
"most cases just search the list of nodes, it should be faster."
msgstr ""
"這些節點是基礎型別用的方法。如，若想計算內積，可以搜尋「dot (點)」而不是 "
"Vector3 分類。大多數情況下，直接搜尋節點列表會比較快。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:411
msgid "Call"
msgstr "Call 呼叫"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:413
msgid ""
"This is the generic calling node. It is rarely used directly but by dragging "
"to empty space on an already configured node."
msgstr ""
"呼叫是通用的呼叫節點。很少會用到這種節點，通常都直接從已設定好的節點拖移到空"
"白處。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:417
msgid "Constructors"
msgstr "Constructors 建置函式"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:419
msgid ""
"These are all the functions needed to create Godot basic datatypes. For "
"example, If you need to create a Vector3 out of 3 floats, a constructor must "
"be used."
msgstr ""
"這些節點是用來建立 Godot 基礎資料型別的所有函式。例如，當需要從三個浮點數建立"
"一個 Vector3，就必須使用建置函式。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:425
msgid "Destructor"
msgstr "Destructor 解構函式"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:427
msgid ""
"This is the opposite to Constructor, it allows to separate any basic type "
"(ie, Vector3) into its sub-elements."
msgstr ""
"解構函式與 Contructor 建置函式相反，用來將基礎型別 (如 Vector3) 分離為子元"
"素。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:433
msgid "Emit Signal"
msgstr "Emit Signal 送出訊號"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:435
msgid ""
"Emits signals from any object. In general it's not that useful, as dragging "
"a signal to the canvas works better."
msgstr ""
"從任意物件送出訊號。通常來說這種節點不是很實用，因為直接把訊號拖移到畫布上比"
"較好。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:439
msgid "Get/Set"
msgstr "Get/Set 取值或設值"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:441
msgid ""
"Generic Getter/Setter node. Dragging properties from the Inspector works "
"better, as they appear properly configured on drop."
msgstr ""
"通用的 Getter 與 Setter 節點。從屬性面板中拖移屬性過來比較好，因為會在放開的"
"時候正確設定。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:445
msgid "Wait"
msgstr "Wait 等待"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:447
msgid ""
"The Wait nodes will suspend execution of the function until something "
"happens (many frames can pass until resuming, in fact). Default nodes allow "
"you to wait for a frame to pass, a fixed frame or a given amount of time "
"until execution is resumed."
msgstr ""
"Wait 節點會暫停函式的執行，直到某些事情發生 (事實上，在繼續執行之前可以等待好"
"幾幀)。預設節點能用來等待一幀、固定數量的幀或是指定時間後再繼續執行。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:452
msgid "Yield"
msgstr "\\ Yield"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:454
msgid ""
"This node completely suspends the execution of the script, and it will make "
"the function return a value that can be used to resume execution."
msgstr "該節點會完全暫停腳本的執行，並讓函式回傳可以用來繼續執行的值。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:458
msgid "Yield Signal"
msgstr "Yield Signal - Yield 訊號"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:460
msgid "Same as Yield, but will wait until a given signal is emitted."
msgstr "與 Yield 相同，但會等待到指定訊號送出。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:464
msgid "Index"
msgstr "Index - 索引"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:466
msgid ""
"Generic indexing operator, not often used but it's good that it exists just "
"in case."
msgstr "通用索引運算元，不常使用，但以備不時之需。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:470
msgid "Operators"
msgstr "運算子"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:472
msgid ""
"These are mostly generic operators, such as addition, multiplication, "
"comparison, etc. By default, these mostly accept any datatype (and will "
"throw an error at run-time if the types fed do not match those expected by "
"the operator). It is always recommended to set the right type for operators "
"to catch errors faster and make the graph easier to read."
msgstr ""
"最通用的運算子，如加法、乘法、比較…等。預設情況下，這幾個運算元通常都接受所有"
"資料型別 (而若給的型別不符合運算元的預期，則會在執行時拋出錯誤)。建議給運算子"
"設定正確的型別，以便早期發現問題，並讓圖表更易讀。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:481
msgid "Expression Node"
msgstr "Expression Node 運算式節點"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:483
msgid ""
"Among the operators, the *Expression* node is the most powerful. If well "
"used, it allows you to enormously simplify visual scripts that are math or "
"logic heavy. Type any expression on it and it will be executed in real-time."
msgstr ""
"在所有運算子中，**Expression** 節點是最強大的。若正確使用，將可以極大地簡化腳"
"本中吃重數學或邏輯的部分。只需要在 Expression 節點上輸入任何的運算式，就能即"
"時執行。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:486
msgid "Expression nodes can:"
msgstr "運算式節點可以："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:488
msgid ""
"Perform math and logic expressions based on custom inputs (eg: \"a*5+b\", "
"where a and b are custom inputs):"
msgstr ""
"依據自定輸入來執行數理或邏輯運算式 (如「a * 5 + b」，其中 a 與 b 為自定輸"
"入)："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:493
msgid "Access local variables or properties:"
msgstr "存取區域變數或屬性："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:498
msgid ""
"Use most of the existing built-in functions that are available to GDScript, "
"such as ``sin()``, ``cos()``, ``print()``, as well as constructors, such as "
"``Vector3(x, y, z)``, ``Rect2(...)``, etc.:"
msgstr ""
"使用大部分 GDScript 中現有的內建函式，如 ``sin()``, ``cos()``, ``print()`` 與"
"建置函式，如 ``Vector3(x, y, z)``, ``Rect2(...)`` …等："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:503
msgid "Call API functions:"
msgstr "呼叫 API 函式："

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:508
msgid ""
"Use sequenced mode, which makes more sense in case of respecting the "
"processing order:"
msgstr "使用序列模式，就可以更妥善處理執行順序："
