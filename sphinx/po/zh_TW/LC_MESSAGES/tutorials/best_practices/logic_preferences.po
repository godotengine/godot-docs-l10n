# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Logic preferences"
msgstr "邏輯偏好"

msgid ""
"Ever wondered whether one should approach problem X with strategy Y or Z? "
"This article covers a variety of topics related to these dilemmas."
msgstr ""
"可曾想過問題 X 要用策略 Y 還是 Z 來解決？本篇文章將探討關於這類難題的各種主"
"題。"

msgid "Adding nodes and changing properties: which first?"
msgstr "先新增節點還是先修改屬性？"

msgid ""
"When initializing nodes from a script at runtime, you may need to change "
"properties such as the node's name or position. A common dilemma is, when "
"should you change those values?"
msgstr ""
"運作時使用腳本初始化節點時，你可能需要對節點的名稱、位置等屬性進行修改。常見"
"的糾結點在於，你應該什麼時候去修改？"

msgid ""
"It is the best practice to change values on a node before adding it to the "
"scene tree. Some property's setters have code to update other corresponding "
"values, and that code can be slow! For most cases, this code has no impact "
"on your game's performance, but in heavy use cases such as procedural "
"generation, it can bring your game to a crawl."
msgstr ""
"最佳實踐是在節點加入場景樹之前修改取值。部分屬性的 setter 程式碼會更新其他對"
"應的值，可能會比較慢！大多數情況下，這樣的程式碼不會對遊戲的性能產生影響，但"
"對於程式式生成之類的重型使用場景，就可能讓遊戲卡成 PPT。"

msgid ""
"For these reasons, it is always a best practice to set the initial values of "
"a node before adding it to the scene tree."
msgstr "綜上，最佳的做法就是先為節點設定初始值，然後再把它新增到場景樹中。"

msgid "Loading vs. preloading"
msgstr "載入 (Load) vs. 預載入 (Preload)"

msgid ""
"In GDScript, there exists the global :ref:`preload "
"<class_@GDScript_method_preload>` method. It loads resources as early as "
"possible to front-load the \"loading\" operations and avoid loading "
"resources while in the middle of performance-sensitive code."
msgstr ""
"在 GDScript 中，有一個全域的 :ref:`preload <class_@GDScript_method_preload>` "
"方法。通過這個方法可以儘量將「載入」操作提早執行，並避免在效能敏感的程式執行"
"時載入資源。"

msgid ""
"Its counterpart, the :ref:`load <class_@GDScript_method_load>` method, loads "
"a resource only when it reaches the load statement. That is, it will load a "
"resource in-place which can cause slowdowns when it occurs in the middle of "
"sensitive processes. The ``load()`` function is also an alias for :ref:"
"`ResourceLoader.load(path) <class_ResourceLoader_method_load>` which is "
"accessible to *all* scripting languages."
msgstr ""
"相對地，:ref:`load <class_@GDScript_method_load>` 方法則只會在碰到 load 陳述"
"式時才載入資源。也就是說，load 方法只會就地載入資源，而當在敏感的處理過程中使"
"用 load 就會讓程式變慢。 ``load`` 方法同時也是 :ref:`ResourceLoader."
"load(path) <class_ResourceLoader_method_load>` 的別名，這個方法可以在 **所有"
"** 腳本語言中存取。"

msgid ""
"So, when exactly does preloading occur versus loading, and when should one "
"use either? Let's see an example:"
msgstr ""
"那麼，Load 與 Preload 實際上到底差在哪裡呢？什麼時候又該用什麼呢？請看看這個"
"範例："

msgid ""
"Preloading allows the script to handle all the loading the moment one loads "
"the script. Preloading is useful, but there are also times when one doesn't "
"wish for it. To distinguish these situations, there are a few things one can "
"consider:"
msgstr ""
"預加載可以讓腳本在載入腳本的時候處理所有的載入。預加載很好用，但有時我們不會"
"想用預加載。為了搞清楚是指那些情況，我們可以想想下面這幾個問題："

msgid ""
"If one cannot determine when the script might load, then preloading a "
"resource, especially a scene or script, could result in further loads one "
"does not expect. This could lead to unintentional, variable-length load "
"times on top of the original script's load operations."
msgstr ""
"如果我們無法判斷腳本什麼時候會載入，那麼，（特別是在場景或腳本中）預加載資源"
"可能會進一步導致未預期的載入。這樣可能會導致除了原本腳本的載入操作意外，多出"
"意外且動態長度的載入時間。"

msgid ""
"If something else could replace the value (like a scene's exported "
"initialization), then preloading the value has no meaning. This point isn't "
"a significant factor if one intends to always create the script on its own."
msgstr ""
"若可以使用其他東西來代替某個值 (特別是場景的匯出初始化)，則預加載這個值就沒有"
"意義。如果平常都是自行製作腳本的話，那麼這一點就並非重要因素。"

msgid ""
"If one wishes only to 'import' another class resource (script or scene), "
"then using a preloaded constant is often the best course of action. However, "
"in exceptional cases, one may wish not to do this:"
msgstr ""
"如果只是想要「匯入」另一個類別資源 (腳本或場景)，那麼使用預加載的常數應該是最"
"好的方法。但是，有幾個例外情況下最好不要這麼做："

msgid ""
"If the 'imported' class is liable to change, then it should be a property "
"instead, initialized either using an ``export`` or a ``load()`` (and perhaps "
"not even initialized until later)."
msgstr ""
"若「匯入」的類別很有可能會更改的話，則應該使用屬性來代替，使用 ``export`` 或 "
"``load`` 來初始化 (或甚至不要一開始就初始化)。"

msgid ""
"If the script requires a great many dependencies, and one does not wish to "
"consume so much memory, then one may wish to, load and unload various "
"dependencies at runtime as circumstances change. If one preloads resources "
"into constants, then the only way to unload these resources would be to "
"unload the entire script. If they are instead loaded properties, then one "
"can set them to ``null`` and remove all references to the resource entirely "
"(which, as a :ref:`RefCounted <class_RefCounted>`-extending type, will cause "
"the resources to delete themselves from memory)."
msgstr ""
"若腳本有大量的相依性，則我們通常不會想消耗太多的記憶體，而會想在執行階段依據"
"特定情況來載入或取消載入各種相依性。若我們將資源預加載進常數內，那麼要取消載"
"入這些資源就只能把整個腳本都取消載入了。而若改用屬性來載入的話，那我們就能通"
"過將屬性設為 ``null`` 並完整移除該屬性的所有參照來取消載入 (這是指，繼承了 :"
"ref:`Reference <class_Reference>` 的型別會在這麼做之後將自己從記憶體內刪除)。"

msgid "Large levels: static vs. dynamic"
msgstr "大型關卡：靜態 vs. 動態"

msgid ""
"If one is creating a large level, which circumstances are most appropriate? "
"Should they create the level as one static space? Or should they load the "
"level in pieces and shift the world's content as needed?"
msgstr ""
"在建立大型關卡時，哪個情況才適用呢？要將關卡製作成一個獨立的靜態空間嗎？還是"
"應該將關卡切成各種小部分並隨著需求來在世界內容中切換？"

msgid ""
"Well, the simple answer is, \"when the performance requires it.\" The "
"dilemma associated with the two options is one of the age-old programming "
"choices: does one optimize memory over speed, or vice versa?"
msgstr ""
"這個嘛，用一句話來回答的話就是，「如果效能有需要的時候。」。其實這種兩難的情"
"況跟一個古老的程式設計問題有關：要對記憶體最佳化還是對速度最佳化？"

msgid ""
"The naive answer is to use a static level that loads everything at once. "
"But, depending on the project, this could consume a large amount of memory. "
"Wasting users' RAM leads to programs running slow or outright crashing from "
"everything else the computer tries to do at the same time."
msgstr ""
"而最簡單的方法就是使用單一靜態關卡，並一次載入所有東西。但是，依據不同的專"
"案，這樣可能會吃掉很多的記憶體。浪費使用者的 RAM 也會導致程式執行地很慢，或是"
"當電腦嘗試同時做其他事情時讓遊戲當機。"

msgid ""
"No matter what, one should break larger scenes into smaller ones (to aid in "
"reusability of assets). Developers can then design a node that manages the "
"creation/loading and deletion/unloading of resources and nodes in real-time. "
"Games with large and varied environments or procedurally generated elements "
"often implement these strategies to avoid wasting memory."
msgstr ""
"無論如何，我們都應該將大型場景切分成許多小的場景 (來提升素材的可復用性)。開發"
"人員可以設計一個節點，來即時管理資源與節點的建立／載入與刪除／取消載入。有大"
"型且多樣化環境的遊戲，或是會連續產生多個元素的遊戲，通常會使用這種策略來減少"
"浪費記憶體。"

msgid ""
"On the flip side, coding a dynamic system is more complex, i.e. uses more "
"programmed logic, which results in opportunities for errors and bugs. If one "
"isn't careful, they can develop a system that bloats the technical debt of "
"the application."
msgstr ""
"另一方面，要撰寫一套動態的系統是一件複雜的工作——會使用到更多的程式邏輯。而使"
"用到更多邏輯，就代表產生錯誤與 Bug 的機率更高。一不小心就有可能因為開發了這個"
"系統而增加了許多技術債。"

msgid "As such, the best options would be..."
msgstr "因此，最好的做法應該是…"

msgid "To use a static level for smaller games."
msgstr "在小型遊戲上使用靜態關卡。"

msgid ""
"If one has the time/resources on a medium/large game, create a library or "
"plugin that can code the management of nodes and resources. If refined over "
"time, so as to improve usability and stability, then it could evolve into a "
"reliable tool across projects."
msgstr ""
"如果有時間與資源來處理中大型遊戲的話，那麼可以製作一個函式庫或外掛程式來管理"
"資源與節點。如果可以不斷地改進可用性與穩定性的話，那麼這套工具可以發展成在各"
"個專案間可靠的工具。"

msgid ""
"Code the dynamic logic for a medium/large game because one has the coding "
"skills, but not the time or resources to refine the code (game's gotta get "
"done). Could potentially refactor later to outsource the code into a plugin."
msgstr ""
"如果有能力但沒有時間或資源來修改程式的話 (因為必須要最好遊戲)，可以為中大型遊"
"戲撰寫動態邏輯。之後可能有機會重構並將這部分的程式拆解為外掛。"

msgid ""
"For an example of the various ways one can swap scenes around at runtime, "
"please see the :ref:`\"Change scenes manually\" "
"<doc_change_scenes_manually>` documentation."
msgstr ""
"有關在執行時間切換場景的各種方法的範例，請參考 :ref:`「手動更改場景」 "
"<doc_change_scenes_manually>` 說明文件。"

msgid "Translation status"
msgstr "翻譯狀態"
