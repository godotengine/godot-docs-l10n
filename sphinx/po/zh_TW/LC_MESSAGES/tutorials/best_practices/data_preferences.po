# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Data preferences"
msgstr "資料偏好"

msgid ""
"Ever wondered whether one should approach problem X with data structure Y or "
"Z? This article covers a variety of topics related to these dilemmas."
msgstr ""
"有沒有煩惱過問題 X 應該要用資料結構 Y 還是 Z 來處理？本篇文章將圍繞這種困擾來"
"展開。"

msgid ""
"This article makes references to \"[something]-time\" operations. This "
"terminology comes from algorithm analysis' `Big O Notation <https://rob-bell."
"net/2009/06/a-beginners-guide-to-big-o-notation/>`_."
msgstr ""
"本文中參考使用了「[什麼什麼]-時間」格式。該術語來自演算法分析中的 `大 O 符號 "
"(英文) <https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/"
">`_ 。"

msgid ""
"Long-story short, it describes the worst-case scenario of runtime length. In "
"laymen's terms:"
msgstr ""
"長話短說，這種方式是用來表示最糟情況下所需要的執行事件。用業餘的方式來說："

msgid ""
"\"As the size of a problem domain increases, the runtime length of the "
"algorithm...\""
msgstr "「隨著問題領域變大，演算法的執行時間長度…」"

msgid "Constant-time, ``O(1)``: \"...does not increase.\""
msgstr "常數時間， ``O(1)`` ：「…不會增加。」"

msgid "Logarithmic-time, ``O(log n)``: \"...increases at a slow rate.\""
msgstr "對數時間， ``O(log n)`` ：「…緩慢增加。」"

msgid "Linear-time, ``O(n)``: \"...increases at the same rate.\""
msgstr "線性時間， ``O(n)`` ：「…等速增加。」"

msgid "Etc."
msgstr "…等。"

msgid ""
"Imagine if one had to process 3 million data points within a single frame. "
"It would be impossible to craft the feature with a linear-time algorithm "
"since the sheer size of the data would increase the runtime far beyond the "
"time allotted. In comparison, using a constant-time algorithm could handle "
"the operation without issue."
msgstr ""
"試想一下需要在每幀處理 300 萬筆資料點的情況。這時候就沒辦法使用線性時間演算"
"法，因為隨著資料大小的增加，執行時間也會大幅增加。相較之下，使用常數時間演算"
"法來處理就沒有問題。"

msgid ""
"By and large, developers want to avoid engaging in linear-time operations as "
"much as possible. But, if one keeps the scale of a linear-time operation "
"small, and if one does not need to perform the operation often, then it may "
"be acceptable. Balancing these requirements and choosing the right "
"algorithm / data structure for the job is part of what makes programmers' "
"skills valuable."
msgstr ""
"大致上來說，開發人員總是希望能儘可能避免使用線性時間操作。但，若只保持小規模"
"的線性時間操作，且不需要常常有這類操作，則還算可接受。在需求間找到平衡點，並"
"依據正在進行的任務選擇正確的演算法與資料型別即是使程式設計師技術有價值的部"
"分。"

msgid "Array vs. Dictionary vs. Object"
msgstr "陣列 vs. 字典 vs. 物件"

msgid ""
"Godot stores all variables in the scripting API in the `Variant <https://"
"docs.godotengine.org/en/latest/development/cpp/variant_class.html>`_ class. "
"Variants can store Variant-compatible data structures such as :ref:`Array "
"<class_Array>` and :ref:`Dictionary <class_Dictionary>` as well as :ref:"
"`Object <class_Object>` s."
msgstr ""
"Godot 將腳本 API 中所有的變數都保存在 :ref:`Variant <doc_variant_class>` 類別"
"內。Variant 可以保存 Variant 相容的資料結構，如 :ref:`Array <class_Array>` "
"與 :ref:`Dictionary <class_Dictionary>` 以及 :ref:`Object <class_Object>` 。"

msgid ""
"Godot implements Array as a ``Vector<Variant>``. The engine stores the Array "
"contents in a contiguous section of memory, i.e. they are in a row adjacent "
"to each other."
msgstr ""
"Godot 以 ``Vector<Variant>`` 來實作陣列。引擎會將陣列的內容儲存在一段連續的記"
"憶體當中。也就是說，陣列的元素是相鄰的。"

msgid ""
"For those unfamiliar with C++, a Vector is the name of the array object in "
"traditional C++ libraries. It is a \"templated\" type, meaning that its "
"records can only contain a particular type (denoted by angled brackets). So, "
"for example, a :ref:`PoolStringArray <class_PoolStringArray>` would be "
"something like a ``Vector<String>``."
msgstr ""
"對不熟悉 C++ 的人來說，Vector 是在傳統 C++ 函式庫中陣列物件的名稱，是一種「樣"
"板化 (Templated)」型別。這代表，Vector 內的記錄只能包含特定型別 (在角括號內標"
"示)。因此，舉例來說， :ref:`PoolStringArray <class_PoolStringArray>` 就是類"
"似 **Vector<String>** 之類的東西。"

msgid "Contiguous memory stores imply the following operation performance:"
msgstr "連續記憶體儲存，也就代表了下列操作效能："

msgid "**Iterate:** Fastest. Great for loops."
msgstr "**迭代：** 最快。最適合迴圈。"

msgid "Op: All it does is increment a counter to get to the next record."
msgstr "操作：迭代要做的就是增加計數器來移動到下一筆資料。"

msgid "**Insert, Erase, Move:** Position-dependent. Generally slow."
msgstr "**插入、移除、移動：** 取決於位置。普通慢。"

msgid ""
"Op: Adding/removing/moving content involves moving the adjacent records over "
"(to make room / fill space)."
msgstr "操作：新增／移除／移動會需要移動相鄰的記錄 (才能騰出空間／填補空間)。"

msgid "Fast add/remove *from the end*."
msgstr "**從結尾** 新增／移除 - 快速。"

msgid "Slow add/remove *from an arbitrary position*."
msgstr "**從任意位置** 新增／移除 - 慢。"

msgid "Slowest add/remove *from the front*."
msgstr "**從最前面** 新增／移除 - 最慢。"

msgid "If doing many inserts/removals *from the front*, then..."
msgstr "若 **從前面** 進行插入／移除多筆資料，則..."

msgid "invert the array."
msgstr "反轉陣列。"

msgid "do a loop which executes the Array changes *at the end*."
msgstr "執行從陣列 **結尾** 更改的迴圈。"

msgid "re-invert the array."
msgstr "重新反轉陣列。"

msgid ""
"This makes only 2 copies of the array (still constant time, but slow) versus "
"copying roughly 1/2 of the array, on average, N times (linear time)."
msgstr ""
"這樣一來，比起平均要複製 N 次大約 1/2 個陣列 (線性時間)， 就只會產生 2 個陣列"
"的副本 (一樣是常數時間，但比較慢)。"

#, fuzzy
msgid ""
"**Get, Set:** Fastest *by position*. E.g. can request 0th, 2nd, 10th record, "
"etc. but cannot specify which record you want."
msgstr ""
"**取值、設值：** **依位置** 最快。如，可要求第 0、第 2 與第 10 筆記錄…等。但"
"無法指定要哪個記錄。"

msgid "Op: 1 addition operation from array start position up to desired index."
msgstr "操作：需要 1 個額外的操作來將陣列從起始位置移至需要的位置。"

msgid "**Find:** Slowest. Identifies the index/position of a value."
msgstr "**搜尋：** 最慢。找到一個值的索引／位置。"

msgid ""
"Op: Must iterate through array and compare values until one finds a match."
msgstr "操作：必須要迭代陣列並比較各個值，直到找到相符的元素。"

msgid ""
"Performance is also dependent on whether one needs an exhaustive search."
msgstr "效能還會依據是否需要完整的搜尋而有所不同。"

msgid ""
"If kept ordered, custom search operations can bring it to logarithmic time "
"(relatively fast). Laymen users won't be comfortable with this though. Done "
"by re-sorting the Array after every edit and writing an ordered-aware search "
"algorithm."
msgstr ""
"若陣列有排序，則搜尋操作可達對數時間 (相對較快)。不過，業餘使用者可能會不太習"
"慣這種方法。這種方法會需要在每次編輯陣列後進行重新排列，並編寫適用於有序陣列"
"的搜尋演算法。"

msgid ""
"Godot implements Dictionary as an ``OrderedHashMap<Variant, Variant>``. The "
"engine stores a small array (initialized to 2^3 or 8 records) of key-value "
"pairs. When one attempts to access a value, they provide it a key. It then "
"*hashes* the key, i.e. converts it into a number. The \"hash\" is used to "
"calculate the index into the array. As an array, the OHM then has a quick "
"lookup within the \"table\" of keys mapped to values. When the HashMap "
"becomes too full, it increases to the next power of 2 (so, 16 records, then "
"32, etc.) and rebuilds the structure."
msgstr ""
"Godot 通過 ``OrderedHashMap<Variant, Variant>`` 來實作字典 (Dictionary) 型"
"別。Godot 會儲存一個小型索引鍵／值配對的陣列 (初始化為 2^3 或 8 筆記錄)。當使"
"用者存取數值時，這組陣列就會提供索引鍵。接著再對索引鍵進行 **雜湊** ，如將其"
"轉換為數字。這裡的「雜湊」是用於將索引計算到陣列中。由於是陣列，OHM 會快速地"
"「查表」來將索引鍵對應到數值上。如果 HashMap 變得太滿的話，Godot 會將其大小增"
"加到下一個 2 的冪次 (也就是 16 筆資料，然後是 32 筆…以此類推)，然後重新建立這"
"個架構。"

msgid ""
"Hashes are to reduce the chance of a key collision. If one occurs, the table "
"must recalculate another index for the value that takes the previous "
"position into account. In all, this results in constant-time access to all "
"records at the expense of memory and some minor operational efficiency."
msgstr ""
"雜湊是為了降低索引鍵碰撞的機率。若發生碰撞，表格就必須要為該數值重新計算另一"
"個索引來處理前一個位置。這樣一來，就可以常數時間來存取所有記錄，但卻需要犧牲"
"一些記憶體與執行效率。"

msgid "Hashing every key an arbitrary number of times."
msgstr "對每個索引鍵雜湊任意次。"

msgid ""
"Hash operations are constant-time, so even if an algorithm must do more than "
"one, as long as the number of hash calculations doesn't become too dependent "
"on the density of the table, things will stay fast. Which leads to..."
msgstr ""
"雜湊操作為常數時間，所以即使某個演算法需要被執行超過一次，只要雜湊計算的數字"
"不要太依賴表格的密度，就能保持高速。這樣一來…"

msgid "Maintaining an ever-growing size for the table."
msgstr "維護表格持續增長的大小。"

msgid ""
"HashMaps maintain gaps of unused memory interspersed in the table on purpose "
"to reduce hash collisions and maintain the speed of accesses. This is why it "
"constantly increases in size quadratically by powers of 2."
msgstr ""
"雜湊表 (HashMap) 會維護穿插在表格間所沒有使用到的記憶體空間，來減少雜湊碰撞的"
"機率並保持存取的速度。這也是為什麼雜湊表大小成長的速度是以 2 的冪次在成長的。"

msgid ""
"As one might be able to tell, Dictionaries specialize in tasks that Arrays "
"do not. An overview of their operational details is as follows:"
msgstr ""
"我們可以說，字典可以做一些陣列沒辦法做的任務。下面列出一些字典能做的操作："

msgid "**Iterate:** Fast."
msgstr "**迭代：** 快速。"

msgid ""
"Op: Iterate over the map's internal vector of hashes. Return each key. "
"Afterwards, users then use the key to jump to and return the desired value."
msgstr ""
"操作：在映射表內部的雜湊向量間迭代。回傳每個索引鍵。然後，使用者便能通過該索"
"引鍵來跳至並回傳所需的值。"

msgid "**Insert, Erase, Move:** Fastest."
msgstr "**插入、移除、移動：** 最快。"

msgid ""
"Op: Hash the given key. Do 1 addition operation to look up the appropriate "
"value (array start + offset). Move is two of these (one insert, one erase). "
"The map must do some maintenance to preserve its capabilities:"
msgstr ""
"操作：雜湊給定的索引鍵。需要 1 個額外操作來找到適當的值 (陣列起始 + 偏移)。移"
"動是由這其中的兩個操作組成的 (一個新增、一個刪除)。映射表為了保持其功能性，必"
"須要做一些維護操作："

msgid "update ordered List of records."
msgstr "更新記錄的有序列表。"

msgid "determine if table density mandates a need to expand table capacity."
msgstr "判斷表格的密度，決定是否有需要增加表格的大小。"

msgid ""
"The Dictionary remembers in what order users inserted its keys. This enables "
"it to execute reliable iterations."
msgstr ""
"字典會記得使用者插入索引鍵的順序。這樣一來在執行迭代的時候就能確保可靠性。"

msgid "**Get, Set:** Fastest. Same as a lookup *by key*."
msgstr "**取值、設值：** 最快。與 **以索引鍵** 查詢相同。"

msgid "Op: Same as insert/erase/move."
msgstr "操作：與插入／移除／移動相同。"

msgid "**Find:** Slowest. Identifies the key of a value."
msgstr "**查詢：** 最慢。需要找出值的索引鍵。"

msgid ""
"Op: Must iterate through records and compare the value until a match is "
"found."
msgstr "操作：必須要在每個記錄間迭代，並比較各個值來找出相符合的項目。"

msgid ""
"Note that Godot does not provide this feature out-of-the-box (because they "
"aren't meant for this task)."
msgstr "請注意，Godot 並沒有直接提供這個功能 (因為字典並非設計來做這項工作)。"

msgid ""
"Godot implements Objects as stupid, but dynamic containers of data content. "
"Objects query data sources when posed questions. For example, to answer the "
"question, \"do you have a property called, 'position'?\", it might ask its :"
"ref:`script <class_Script>` or the :ref:`ClassDB <class_ClassDB>`. One can "
"find more information about what objects are and how they work in the :ref:"
"`doc_what_are_godot_classes` article."
msgstr ""
"Godot 實作物件的方法很單純，但卻有動態資料內容容器。物件會在被要求的時候查詢"
"資料來源。舉例來說，當物件需要回答「你有沒有一個叫『position』的屬性？」這種"
"問題時，物件可能會詢問 :ref:`Script <class_Script>` 或 :ref:`ClassDB "
"<class_ClassDB>` 。更多關於物件的資訊以及物件如何運作的資訊，請參考 :ref:"
"`doc_what_are_godot_classes` 一文。"

msgid ""
"The important detail here is the complexity of the Object's task. Every time "
"it performs one of these multi-source queries, it runs through *several* "
"iteration loops and HashMap lookups. What's more, the queries are linear-"
"time operations dependent on the Object's inheritance hierarchy size. If the "
"class the Object queries (its current class) doesn't find anything, the "
"request defers to the next base class, all the way up until the original "
"Object class. While these are each fast operations in isolation, the fact "
"that it must make so many checks is what makes them slower than both of the "
"alternatives for looking up data."
msgstr ""
"此處有一個重要的細節，就是有關物件任務中的複雜度。每當物件執行一次這種多來源"
"的查詢時，物件會執行 **多個** 迭代迴圈以及雜湊表查詢。而且，查詢的線性時間會"
"依據物件的繼承與層級大小而異。若物件查詢的類別 (目前的類別) 沒有找到任何東"
"西，則查詢會被傳遞到更上一層，直到最原始的 Object 類別。雖然這些操作單獨來看"
"都很快，但事實上因為這些操作需要做到很多確認，所以會讓查詢比起查詢陣列或字典"
"的兩種方法都來得慢。"

msgid ""
"When developers mention how slow the scripting API is, it is this chain of "
"queries they refer to. Compared to compiled C++ code where the application "
"knows exactly where to go to find anything, it is inevitable that scripting "
"API operations will take much longer. They must locate the source of any "
"relevant data before they can attempt to access it."
msgstr ""
"當開發人員提到腳本的 API 有多慢時，指的是這個查詢鏈很慢。跟經過編譯的 C++ 程"
"式碼比起來，這些 C++ 程式在查詢會知道要讀取的準確位置，因此相比起來腳本 API "
"就不可避免地慢很多。腳本 API 必須要在嘗試存取資料前找過所有相關資料的來源。"

msgid ""
"The reason GDScript is slow is because every operation it performs passes "
"through this system."
msgstr ""
"GDScript 比較慢的原因就是因為在執行所有操作前都必須要經歷過一次這個系統。"

msgid ""
"C# can process some content at higher speeds via more optimized bytecode. "
"But, if the C# script calls into an engine class' content or if the script "
"tries to access something external to it, it will go through this pipeline."
msgstr ""
"C# 可以通過最佳化的 Bytecode 來以更快的速度處理一些內容。但是，若 C# 腳本要呼"
"叫引擎的類別內容，或是腳本試圖存取腳本外部的東西，則還是需要走過一次這個過"
"程。"

msgid ""
"NativeScript C++ goes even further and keeps everything internal by default. "
"Calls into external structures will go through the scripting API. In "
"NativeScript C++, registering methods to expose them to the scripting API is "
"a manual task. It is at this point that external, non-C++ classes will use "
"the API to locate them."
msgstr ""
"NativeScript C++ 則更進一步，預設會將所有東西都保持在內部。呼叫外部結構的時候"
"會經過腳本 API。在 NativeScript C++ 中，必須要手動註冊方法並將方法暴露給腳本 "
"API。這樣一來，非 C++ 類別就可以通過 API 來找到這些方法。"

msgid ""
"So, assuming one extends from Reference to create a data structure, like an "
"Array or Dictionary, why choose an Object over the other two options?"
msgstr ""
"因此，假設我們需要繼承 Reference 來建立一個資料結構，類似 Array 或 "
"Dictionary，誰還要用 Object 而不用 Array 或 Dictionary 呢？"

msgid ""
"**Control:** With objects comes the ability to create more sophisticated "
"structures. One can layer abstractions over the data to ensure the external "
"API doesn't change in response to internal data structure changes. What's "
"more, Objects can have signals, allowing for reactive behavior."
msgstr ""
"**控制：** 因為物件能建立更複雜的結構，所以我們可以將資料抽象化成抽象層，來確"
"保對外的 API 不會因為內部資料結構的更改而需要跟著改變。而且，物件還可以有訊"
"號，可以作出回應式的行為。"

msgid ""
"**Clarity:** Objects are a reliable data source when it comes to the data "
"that scripts and engine classes define for them. Properties may not hold the "
"values one expects, but one doesn't need to worry about whether the property "
"exists in the first place."
msgstr ""
"**明確：** 當使用到腳本與引擎類別定義的資料時，物件是可信任的資料結構。屬性中"
"的值可能與使用者期望的不同，但是在使用時不需要擔心物件上是否有某個屬性。"

msgid ""
"**Convenience:** If one already has a similar data structure in mind, then "
"extending from an existing class makes the task of building the data "
"structure much easier. In comparison, Arrays and Dictionaries don't fulfill "
"all use cases one might have."
msgstr ""
"**便利：** 在已有類似資料結構的情況下，就可以通過繼承現有類別來更輕鬆地製作資"
"料結構。相較起來，陣列與字典並非適用於所有情況。"

msgid ""
"Objects also give users the opportunity to create even more specialized data "
"structures. With it, one can design their own List, Binary Search Tree, "
"Heap, Splay Tree, Graph, Disjoint Set, and any host of other options."
msgstr ""
"物件也讓使用者有機會製作更專門的資料結構。使用物件，開發人員就能設計客製化的"
"列表、二元搜尋樹、堆積、Splay Tree、Graph、非交集集合以及其他選項。"

msgid ""
"\"Why not use Node for tree structures?\" one might ask. Well, the Node "
"class contains things that won't be relevant to one's custom data structure. "
"As such, it can be helpful to construct one's own node type when building "
"tree structures."
msgstr ""
"可能有人會問，「為什麼不用 Node 來處理樹狀結構？」。其實，Node 節點包含了一些"
"與客製化資料結構不相關的東西，因此，在自行製作樹狀結構的時候，可以考慮自行建"
"立自製的 Node 型別。"

msgid ""
"From here, one can then create their own structures with specific features, "
"limited only by their imagination."
msgstr "就這樣，我們能製作適用於特定功能的客製化結構。"

msgid "Enumerations: int vs. string"
msgstr "列舉類型：整數 vs. 字串"

msgid ""
"Most languages offer an enumeration type option. GDScript is no different, "
"but unlike most other languages, it allows one to use either integers or "
"strings for the enum values (the latter only when using the ``export`` "
"keyword in GDScript). The question then arises, \"which should one use?\""
msgstr ""
"大多數語言都提供了列舉類型，GDScript 也不例外。但與其他語言不同的是，"
"GDScript 的列舉類型值只允許要嘛使用整數，要嘛就是字串 (而字串只允許在 "
"GDScript 中使用 ``export`` 關鍵字時使用)。這裡便沿伸出了一個問題，「要使用哪"
"一個？」"

msgid ""
"The short answer is, \"whichever you are more comfortable with.\" This is a "
"feature specific to GDScript and not Godot scripting in general; The "
"languages prioritizes usability over performance."
msgstr ""
"用一句話來回答的話，就是「哪個用習慣就用哪個。」。這項特性是 GDScript 特有"
"的，而不是 Godot 中所有的腳本語言都這樣。GDScript 首先考慮的是易用性而非效"
"能。"

msgid ""
"On a technical level, integer comparisons (constant-time) will happen faster "
"than string comparisons (linear-time). If one wants to keep up other "
"languages' conventions though, then one should use integers."
msgstr ""
"但技術上來說，整數型別的比較 (常數時間) 比字串比較 (線型時間) 要來得快。如果"
"想保持與其他語言一樣的慣例，則應該用整數。"

msgid ""
"The primary issue with using integers comes up when one wants to *print* an "
"enum value. As integers, attempting to print MY_ENUM will print ``5`` or "
"what-have-you, rather than something like ``\"MyEnum\"``. To print an "
"integer enum, one would have to write a Dictionary that maps the "
"corresponding string value for each enum."
msgstr ""
"當我們想 **印出** 列舉類型時，就會遇到使用整數的主要問題了。使用整數時，嘗試"
"印出 MY_ENUM 會得到 ``5`` 這樣的值，而不是 ``\"MyEnum\"`` 。如果要印出整數列"
"舉類型，就必須要寫一個將字串值映射到各個列舉值的字典 (Dictionary)。"

msgid ""
"If the primary purpose of using an enum is for printing values and one "
"wishes to group them together as related concepts, then it makes sense to "
"use them as strings. That way, a separate data structure to execute on the "
"printing is unnecessary."
msgstr ""
"若使用列舉類型的主要是為了要印出數值，而且想將相關的概念群組化，則可以使用字"
"串。這樣一來，就不需要在印出數值時使用另一個分開的資料結構。"

msgid ""
"AnimatedTexture vs. AnimatedSprite vs. AnimationPlayer vs. AnimationTree"
msgstr ""
"\\ AnimatedTexture vs. AnimatedSprite vs. AnimationPlayer vs. AnimationTree"

msgid ""
"Under what circumstances should one use each of Godot's animation classes? "
"The answer may not be immediately clear to new Godot users."
msgstr ""
"在哪個情況下該用哪個 Godot 動畫類別？對於新的 Godot 使用者來說，可能無法馬上"
"清楚答案。"

msgid ""
":ref:`AnimatedTexture <class_AnimatedTexture>` is a texture that the engine "
"draws as an animated loop rather than a static image. Users can manipulate..."
msgstr ""
":ref:`AnimatedTexture <class_AnimatedTexture>` 是引擎繪製為動畫循環的紋理貼"
"圖，而不是靜態圖片。使用者可以進行如下操作……"

msgid "the rate at which it moves across each section of the texture (fps)."
msgstr "在紋理貼圖的各個部分移動的速率 (FPS)。"

msgid "the number of regions contained within the texture (frames)."
msgstr "紋理貼圖中包含的區域數量 (幀數)。"

msgid ""
"Godot's :ref:`VisualServer <class_VisualServer>` then draws the regions in "
"sequence at the prescribed rate. The good news is that this involves no "
"extra logic on the part of the engine. The bad news is that users have very "
"little control."
msgstr ""
"Godot 的 :ref:`VisualServer <class_VisualServer>` 接著會依指定的速度來按照區"
"域的順序繪製。好消息是，這個過程不會在引擎這邊產生額外的邏輯。但壞消息是，使"
"用者幾乎沒什麼控制權。"

msgid ""
"Also note that AnimatedTexture is a :ref:`Resource <class_Resource>` unlike "
"the other :ref:`Node <class_Node>` objects discussed here. One might create "
"a :ref:`Sprite <class_Sprite>` node that uses AnimatedTexture as its "
"texture. Or (something the others can't do) one could add AnimatedTextures "
"as tiles in a :ref:`TileSet <class_TileSet>` and integrate it with a :ref:"
"`TileMap <class_TileMap>` for many auto-animating backgrounds that all "
"render in a single batched draw call."
msgstr ""
"另外也要注意，AnimatedTexture 是一個 :ref:`資源 <class_Resource>` ，而不像這"
"裡討論的其他東西是 :ref:`節點 <class_Node>` 。我們可以建立一個 :ref:`Sprite "
"<class_Sprite>` 節點，然後使用 AnimatedTexture 來當作 Sprite 的貼圖。或是 (其"
"他動畫類別做不到的) 我們可以將 AnimatedTexture 作為圖塊來加到 :ref:`TileSet "
"<class_TileSet>` 中，然後跟 :ref:`TileMap <class_TileMap>` 整合使用，來製作許"
"多會在單一繪製呼叫中同時算繪的自動動畫背景。"

msgid ""
"The AnimatedSprite node, in combination with the :ref:`SpriteFrames "
"<class_SpriteFrames>` resource, allows one to create a variety of animation "
"sequences through spritesheets, flip between animations, and control their "
"speed, regional offset, and orientation. This makes them well-suited to "
"controlling 2D frame-based animations."
msgstr ""
"當我們將 AnimatedSprite 節點與 :ref:`SpriteFrames <class_SpriteFrames>` 資源"
"一起使用時，就可以通過 SpriteSheet 來製作許多不同種類的動畫序列、反覆播放動"
"畫，並且可以控制動畫的播放速度、區域偏移量與方向。這種使用方式盒適合用來控制"
"基於影格的 2D 動畫。"

msgid ""
"If one needs trigger other effects in relation to animation changes (for "
"example, create particle effects, call functions, or manipulate other "
"peripheral elements besides the frame-based animation), then will need to "
"use an :ref:`AnimationPlayer <class_AnimationPlayer>` node in conjunction "
"with the AnimatedSprite."
msgstr ""
"如果有需要觸發其他與動畫更改有關的效果 (如，建立粒子效果、呼叫函式或是操作基"
"於影格的動畫之其他周邊元素)，則需要使用 :ref:`AnimationPlayer "
"<class_AnimationPlayer>` 來搭配 AnimatedSprite。"

msgid ""
"AnimationPlayers are also the tool one will need to use if they wish to "
"design more complex 2D animation systems, such as..."
msgstr ""
"當想設計更複雜的 2D 動畫系統時，AnimationPlayer 也是必要工具。更複雜的 2D 動"
"畫系統包含…"

msgid "**Cut-Out animations:** editing sprites' transforms at runtime."
msgstr "**剪影動畫：** 在執行階段編輯 Sprite 的變換。"

msgid ""
"**2D Mesh animations:** defining a region for the sprite's texture and "
"rigging a skeleton to it. Then one animates the bones which stretch and bend "
"the texture in proportion to the bones' relationships to each other."
msgstr ""
"**2D 網格動畫：** 為 Sprite 的材質定義一個區域，並將其骨骼固定在裡面。接著我"
"們為骨骼製作動畫，依據骨骼之間互相的關係來縮放紋理貼圖。"

msgid "A mix of the above."
msgstr "上述類型的組合。"

msgid ""
"While one needs an AnimationPlayer to design each of the individual "
"animation sequences for a game, it can also be useful to combine animations "
"for blending, i.e. enabling smooth transitions between these animations. "
"There may also be a hierarchical structure between animations that one plans "
"out for their object. These are the cases where the :ref:`AnimationTree "
"<class_AnimationTree>` shines. One can find an in-depth guide on using the "
"AnimationTree :ref:`here <doc_animation_tree>`."
msgstr ""
"雖然我們需要 AnimationPlayer 來設計遊戲的個別動畫序列，但 AnimationPlayer 也"
"適合用來混合各個動畫，如，在這幾個動畫間平滑地轉換。我們在設計物件的時候，可"
"能也會在動畫間設計出階層結構。這幾種狀況就很適合 :ref:`AnimationTree "
"<class_AnimationTree>` 。有關使用 AnimationTree 更深入的指南，請參考 :ref:`這"
"裡 <doc_animation_tree>` 。"

msgid "Translation status"
msgstr "翻譯狀態"
