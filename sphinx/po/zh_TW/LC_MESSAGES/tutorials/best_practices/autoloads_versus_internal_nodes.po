# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Autoloads versus regular nodes"
msgstr "Autoload v.s. 一般節點"

msgid ""
"Godot offers a feature to automatically load nodes at the root of your "
"project, allowing you to access them globally, that can fulfill the role of "
"a Singleton: :ref:`doc_singletons_autoload`. These auto-loaded nodes are not "
"freed when you change the scene from code with :ref:`SceneTree.change_scene "
"<class_SceneTree_method_change_scene>`."
msgstr ""
"Godot 提供了一個能自動在專案根節點上載入的功能。這些自動載入的節點能夠在所有"
"地方存取，並且能充當單例： :ref:`doc_singletons_autoload` 的角色。這些自動在"
"如的節點不會在從程式碼中用 :ref:`SceneTree.change_scene "
"<class_SceneTree_method_change_scene>` 時被釋放。"

msgid ""
"In this guide, you will learn when to use the Autoload feature, and "
"techniques you can use to avoid it."
msgstr ""
"在本篇指南中，我們將學習如何使用 Autoload 功能，以及可以避免使用 Autoload 的"
"一些技巧。"

msgid "The cutting audio issue"
msgstr "音訊截斷問題"

msgid ""
"Other engines can encourage the use of creating manager classes, singletons "
"that organize a lot of functionality into a globally accessible object. "
"Godot offers many ways to avoid global state thanks to the node tree and "
"signals."
msgstr ""
"其他的引擎鼓勵使用 Manager 類別，即一種用來管理許多全域存取物件功能的單例。託"
"節點樹與訊號的福，Godot 中提供了許多方法來避免全域狀態。"

msgid ""
"For example, let's say we are building a platformer and want to collect "
"coins that play a sound effect. There's a node for that: the :ref:"
"`AudioStreamPlayer <class_AudioStreamPlayer>`. But if we call the "
"``AudioStreamPlayer`` while it is already playing a sound, the new sound "
"interrupts the first."
msgstr ""
"舉例來說，假設我們正在做平台遊戲，並且想在蒐集到金幣時播放音效。有可以播放音"
"效的節點： :ref:`AudioStreamPlayer <class_AudioStremPlayer>` 。但如果我們在 "
"``AudioStreamPlayer`` 正在播放聲音的時候呼叫，新的音效就會中斷之前播放的音"
"效。"

msgid ""
"A solution is to code a global, auto-loaded sound manager class. It "
"generates a pool of ``AudioStreamPlayer`` nodes that cycle through as each "
"new request for sound effects comes in. Say we call that class ``Sound``, "
"you can use it from anywhere in your project by calling ``Sound."
"play(\"coin_pickup.ogg\")``. This solves the problem in the short term but "
"causes more problems:"
msgstr ""
"有一種解決方法是撰寫一個全域且自動載入的音訊管理員類別。這個類別要產生一個 "
"``AudioStreamPlayer`` 節點集區，然後在遇到音效播放要求的時候照順序讓每一個 "
"``AudioStreamPlayer`` 來播放。假設我們管這個類別叫 ``Sound`` ，則我們在專案任"
"何一個地方都可以通過呼叫 ``Sound.play(\"coin_pickup.ogg\")`` 來使用。這樣一來"
"便在短期內解決了問題，但接著會引發更多的問題："

msgid ""
"**Global state**: one object is now responsible for all objects' data. If "
"the ``Sound`` class has errors or doesn't have an AudioStreamPlayer "
"available, all the nodes calling it can break."
msgstr ""
"**全域狀態** ：現在，有一個物件必須要負責所有物件的資料。若 ``Sound`` 類別發"
"生錯誤，或是沒有可用的 AudioStreamPlayer，則所有呼叫 Sound 的節點都會壞掉。"

msgid ""
"**Global access**: now that any object can call ``Sound.play(sound_path)`` "
"from anywhere, there's no longer an easy way to find the source of a bug."
msgstr ""
"**全域存取** ：現在所有物件都能從任何地方呼叫 ``Sound.play(sound_path)`` ，所"
"以要找到 Bug 的原因變得更加困難了。"

msgid ""
"**Global resource allocation**: with a pool of ``AudioStreamPlayer`` nodes "
"stored from the start, you can either have too few and face bugs, or too "
"many and use more memory than you need."
msgstr ""
"**全域資源分配** ：現在從一開始就有一個 ``AudioStreamPlayer`` 節點集區，如果"
"數量太少的話便會遇到 Bug，而數量太多的話則會佔用過多的記憶體。"

msgid ""
"About global access, the problem is that Any code anywhere could pass wrong "
"data to the ``Sound`` autoload in our example. As a result, the domain to "
"explore to fix the bug spans the entire project."
msgstr ""
"有關全域存取，問題在於，在本例中，任何地方的「所有」程式碼都有可能將錯誤的資"
"料傳給 ``Sound`` Autoload。因此，發生問題時要尋找的範圍就變成了整個專案。"

msgid ""
"When you keep code inside a scene, only one or two scripts may be involved "
"in audio."
msgstr "如果將程式碼保留在場景中，則只有一兩個程式碼可能會與音訊有關。"

msgid ""
"Contrast this with each scene keeping as many ``AudioStreamPlayer`` nodes as "
"it needs within itself and all these problems go away:"
msgstr ""
"相較之下，如果每個場景都在自己內部保佑必要數量的 ``AudioStreamPlayer`` 的話，"
"則這些所有的問題便解決了："

msgid ""
"Each scene manages its own state information. If there is a problem with the "
"data, it will only cause issues in that one scene."
msgstr ""
"每個場景都管理自己的狀態資訊，所以當資料由問題的時候，就只會影響到單一場景。"

msgid ""
"Each scene accesses only its own nodes. Now, if there is a bug, it's easy to "
"find which node is at fault."
msgstr ""
"每個場景都只存取自己的節點。所以當現在出現 Bug 時，就很容易找出是哪個節點的"
"錯。"

msgid "Each scene allocates exactly the amount of resources it needs."
msgstr "每個場景都只分配到所需數量的資源。"

msgid "Managing shared functionality or data"
msgstr "管理共用功能或資料"

msgid ""
"Another reason to use an Autoload can be that you want to reuse the same "
"method or data across many scenes."
msgstr ""
"另一個使用 Autoload 的理由是這樣就可以在不同的場景間重複使用相同的方法或資"
"料。"

#, fuzzy
msgid ""
"In the case of functions, you can create a new type of ``Node`` that "
"provides that feature for an individual scene using the :ref:`class_name "
"<doc_gdscript_basics_class_name>` keyword in GDScript."
msgstr ""
"如果用函式的話，可以建立一個新型的 ``Node`` ，然後通過 GDScript 中的 :ref:"
"`class_name <doc_scripting_continued_class_name>` 關鍵字來為個別場景提供功"
"能。"

msgid "When it comes to data, you can either:"
msgstr "但遇到要處理資料的時候，就必須選擇："

msgid ""
"Create a new type of :ref:`Resource <class_Resource>` to share the data."
msgstr "建立一個新型的 :ref:`Resource <class_Resource>` 來共享資料。"

msgid ""
"Store the data in an object to which each node has access, for example using "
"the ``owner`` property to access the scene's root node."
msgstr ""
"將資料儲存在每個節點都能存取的一個物件當中，比如說使用 ``owner`` 屬性來存取場"
"景的根節點。"

msgid "When you should use an Autoload"
msgstr "什麼時候該用 Autoload"

msgid "Auto-loaded nodes can simplify your code in some cases:"
msgstr "自動載入的節點在某些情況下可以簡化程式碼："

msgid ""
"**Static Data**: if you need data that is exclusive to one class, like a "
"database, then an autoload can be a good tool. There is no scripting API in "
"Godot to create and manage static data otherwise."
msgstr ""
"**靜態資料** ：若需要的資料只有一個類別會用到，如資料庫，則用 Autoload 是個不"
"錯的選擇。目前在 Godot 中沒有腳本 API 可以建立與管理靜態資料。"

msgid ""
"**Static functions**: creating a library of functions that only return "
"values."
msgstr "**靜態函式** ：建立一個函式庫，只回傳數值。"

msgid ""
"**Systems with a wide scope**: If the singleton is managing its own "
"information and not invading the data of other objects, then it's a great "
"way to create systems that handle broad-scoped tasks. For example, a quest "
"or a dialogue system."
msgstr ""
"**作用域更廣的系統** ：若單例管理自己的資訊，且不會存取到其他物件的資料，則建"
"立一個處理廣域資料的系統也不錯。例如，任務或對話系統。"

msgid ""
"Until Godot 3.1, another use was just for convenience: autoloads have a "
"global variable for their name generated in GDScript, allowing you to call "
"them from any script file in your project. But now, you can use the "
"``class_name`` keyword instead to get auto-completion for a type in your "
"entire project."
msgstr ""
"直到 Godot 3.1 版以前，另一個方便的做法是：每個 Autoload 都有一個由 GDScript "
"以其名稱產生的全域變數，這個全域變數可以用來在專案中的任何腳本呼叫 Autoload。"
"但現在，必須使用 ``class_name`` 關鍵字來代替，才能在整個專案中享有型別的自動"
"補全。"

msgid ""
"Autoload is not exactly a Singleton. Nothing prevents you from instantiating "
"copies of an auto-loaded node. It is only a tool that makes a node load "
"automatically as a child of the root of your scene tree, regardless of your "
"game's node structure or which scene you run, e.g. by pressing :kbd:`F6` key."
msgstr ""
"Autoload 並不完全同等與單例 (Singleton)。在 Autoload 中沒有方法可以防止再次實"
"體化一個 Autoload 的節點。只能算是一種能不考慮遊戲節點架構以及目前執行的節點"
"是什麼，就讓節點作為場景樹子節點自動載入的方法，例如，按 :kbd:`F6` 鍵。"

msgid ""
"As a result, you can get the auto-loaded node, for example an autoload "
"called ``Sound``, by calling ``get_node(\"/root/Sound\")``."
msgstr ""
"然後，就能取得自動載入的節點，例如有一個叫 ``Sound`` 的 Autoload，則可以呼叫 "
"``get_node(\"/root/Sound\")`` 。"

msgid "Translation status"
msgstr "翻譯狀態"
