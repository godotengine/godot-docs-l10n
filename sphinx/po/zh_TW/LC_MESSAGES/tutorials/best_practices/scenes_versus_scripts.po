# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "When to use scenes versus scripts"
msgstr "何時使用場景 v.s. 腳本"

msgid ""
"We've already covered how scenes and scripts are different. Scripts define "
"an engine class extension with imperative code, scenes with declarative code."
msgstr ""
"我們已經解釋了場景與腳本有什麼不同。腳本通過了指令式程式碼定義了引擎類別的延"
"伸，而場景則是用宣告性程式碼定義。"

msgid ""
"Each system's capabilities are different as a result. Scenes can define how "
"an extended class initializes, but not what its behavior actually is. Scenes "
"are often used in conjunction with a script, the scene declaring a "
"composition of nodes, and the script adding behaviour with imperative code."
msgstr ""
"因此，每個系統的能力都不同。場景可以定義要如何擴充類別初始化，而不是類別實際"
"的行為。場景通常與腳本一起結合使用，這樣場景就可以作為腳本中宣告性程式碼的擴"
"充來使用。"

msgid "Anonymous types"
msgstr "匿名型別"

msgid ""
"It *is* possible to completely define a scenes' contents using a script "
"alone. This is, in essence, what the Godot Editor does, only in the C++ "
"constructor of its objects."
msgstr ""
"完全 **可以** 只使用腳本來定義場景。從本質上來說，這就是 Godot Editor 做的，"
"只是是使用物件的 C++ 建置函式而已。"

msgid ""
"But, choosing which one to use can be a dilemma. Creating script instances "
"is identical to creating in-engine classes whereas handling scenes requires "
"a change in API:"
msgstr ""
"但是，選擇要使用哪種方法可能很難決定。建立腳本實體就與建立引擎內類別相同，而"
"處理場景則需修改 API："

msgid ""
"Also, scripts will operate a little slower than scenes due to the speed "
"differences between engine and script code. The larger and more complex the "
"node, the more reason there is to build it as a scene."
msgstr ""
"另外，使用腳本也會比場景慢一點，這就是引擎與腳本程式碼速度的不同。越大與越複"
"雜的節點，就更應該使用場景來建立。"

msgid "Named types"
msgstr "有名稱的型別"

msgid ""
"Scripts can be registered as a new type within the editor itself. This "
"displays it as a new type in the node or resource creation dialog with an "
"optional icon. This way, the user's ability to use the script is much more "
"streamlined. Rather than having to..."
msgstr ""
"有些情況下，使用者可以在編輯器中將腳本註冊為新型別。這樣在節點或資源建立視窗"
"中就可以顯示該腳本為新型別，並帶有一個可選的圖示。這些時候，使用者能對腳本做"
"的事就更流暢了。而不需要..."

msgid "Know the base type of the script they would like to use."
msgstr "知道要使用哪個腳本的基本型別。"

msgid "Create an instance of that base type."
msgstr "建立該基礎型別的實體。"

msgid "Add the script to the node."
msgstr "將腳本附加到節點。"

msgid ""
"With a registered script, the scripted type instead becomes a creation "
"option like the other nodes and resources in the system. The creation dialog "
"even has a search bar to look up the type by name."
msgstr ""
"使用已註冊的腳本，則腳本型別就會與其他系統內的節點與資源一樣變成建立選項。我"
"們就不需要再進行上述步驟了。建立對話框中甚至還有一個搜尋框可以按名稱搜尋型"
"別。"

msgid "There are two systems for registering types:"
msgstr "有兩種系統可以註冊型別..."

msgid ":ref:`Custom Types <doc_making_plugins>`"
msgstr ":ref:`自定型別 <doc_making_plugins>`"

msgid "Editor-only. Typenames are not accessible at runtime."
msgstr "限編輯器。型別名稱在執行時無法存取。"

msgid "Does not support inherited custom types."
msgstr "不支援繼承自定型別。"

msgid "An initializer tool. Creates the node with the script. Nothing more."
msgstr "初始設定式工具。以腳本建立節點。就這樣。"

msgid ""
"Editor has no type-awareness of the script or its relationship to other "
"engine types or scripts."
msgstr "編輯器不會偵測腳本的型別或其與其他引擎型別或腳本的關係。"

msgid "Allows users to define an icon."
msgstr "使用者可以定義圖示。"

msgid ""
"Works for all scripting languages because it deals with Script resources in "
"abstract."
msgstr "適用於所有腳本語言，因為該腳本是以抽象方法處理 Script 資源。"

msgid ""
"Set up using :ref:`EditorPlugin.add_custom_type "
"<class_EditorPlugin_method_add_custom_type>`."
msgstr ""
"使用 :ref:`EditorPlugin.add_custom_type "
"<class_EditorPlugin_method_add_custom_type>` 設定。"

msgid ":ref:`Script Classes <doc_gdscript_basics_class_name>`"
msgstr ":ref:`腳本類別 <doc_scripting_continued_class_name>`"

msgid "Editor and runtime accessible."
msgstr "編輯器與執行環境都可存取。"

msgid "Displays inheritance relationships in full."
msgstr "顯示完整的繼承關係。"

msgid ""
"Creates the node with the script, but can also change types or extend the "
"type from the editor."
msgstr "使用腳本建立節點，但也可以在編輯器中更改型別或繼承型別。"

msgid ""
"Editor is aware of inheritance relationships between scripts, script "
"classes, and engine C++ classes."
msgstr "編輯器可以知道腳本、腳本類別與引擎 C++ 類別間的繼承關係。"

msgid ""
"Engine developers must add support for languages manually (both name "
"exposure and runtime accessibility)."
msgstr "引擎開發人員必須為語言手動新增支援 (名稱暴露與執行時的可存取型)。"

msgid "Godot 3.1+ only."
msgstr "限適用於 Godot 3.1+ 版。"

msgid ""
"The Editor scans project folders and registers any exposed names for all "
"scripting languages. Each scripting language must implement its own support "
"for exposing this information."
msgstr ""
"編輯器會掃描專案資料夾並註冊所有腳本語言中所有暴露的名稱。每個腳本語言都必須"
"要實作對這種暴露資訊的支援。"

msgid ""
"Both methodologies add names to the creation dialog, but script classes, in "
"particular, also allow for users to access the typename without loading the "
"script resource. Creating instances and accessing constants or static "
"methods is viable from anywhere."
msgstr ""
"這兩種方法都會在建立視窗中加上名稱，但特別是腳本類別，還允許使用者在不載入腳"
"本資源時存取型別名稱。在任何地方都可以建立實體與存取常數或靜態方法。"

msgid ""
"With features like these, one may wish their type to be a script without a "
"scene due to the ease of use it grants users. Those developing plugins or "
"creating in-house tools for designers to use will find an easier time of "
"things this way."
msgstr ""
"有了這樣的功能，因為很容易使用，於是我們便會想將型別做成無需場景的腳本。開發"
"外掛或製作給設計師用的內部工具的開發人員也可以通過這種方法來省事。"

msgid ""
"On the downside, it also means having to use largely imperative programming."
msgstr "但缺點是，這也代表必須要使用大量的指令式程式。"

msgid "Performance of Script vs PackedScene"
msgstr "腳本效能 vs PackedScene 效能"

msgid ""
"One last aspect to consider when choosing scenes and scripts is execution "
"speed."
msgstr "在選擇場景與腳本時，最後一個需要考慮的點就是執行速度了。"

msgid ""
"As the size of objects increases, the scripts' necessary size to create and "
"initialize them grows much larger. Creating node hierarchies demonstrates "
"this. Each Node's logic could be several hundred lines of code in length."
msgstr ""
"隨著物件的大小增長，要建立物件所需的腳本也變得越來越大。建立節點階層即可重現"
"此狀況。個別節點的邏輯可多達數百行程式碼。"

msgid ""
"The code example below creates a new ``Node``, changes its name, assigns a "
"script to it, sets its future parent as its owner so it gets saved to disk "
"along with it, and finally adds it as a child of the ``Main`` node:"
msgstr ""
"下列程式碼會建立一個新的 ``Node`` 節點、更改名稱、為該節點指派腳本、然後將新"
"節點的母節點設為目前節點，這樣一來該節點才會跟著一起保存到硬碟上，然後最後才"
"將其加為 ``Main`` 節點的子節點："

msgid ""
"Script code like this is much slower than engine-side C++ code. Each "
"instruction makes a call to the scripting API which leads to many "
"\"lookups\" on the back-end to find the logic to execute."
msgstr ""
"像這樣的程式碼會比引擎端 C++ 程式碼還要慢很多。每個改動都會需要額外的腳本 "
"API 呼叫來向後端「查詢」要執行什麼邏輯。"

msgid ""
"Scenes help to avoid this performance issue. :ref:`PackedScene "
"<class_PackedScene>`, the base type that scenes inherit from, defines "
"resources that use serialized data to create objects. The engine can process "
"scenes in batches on the back-end and provide much better performance than "
"scripts."
msgstr ""
"場景系統可以避免這種效能問題。 :ref:`PackedScene <class_PackedScene>` ，即，"
"場景繼承的基礎型別，是一種資源，可以用來序列化資料並建立物件。引擎可以在後端"
"批次處理場景，並可提供比腳本好很多的效能。"

msgid "Conclusion"
msgstr "結論"

msgid "In the end, the best approach is to consider the following:"
msgstr "最後，最好的方法就是要考慮下列事項："

msgid ""
"If one wishes to create a basic tool that is going to be re-used in several "
"different projects and which people of all skill levels will likely use "
"(including those who don't label themselves as \"programmers\"), then "
"chances are that it should probably be a script, likely one with a custom "
"name/icon."
msgstr ""
"如果想製作會在不同專案間重複使用，並且所有程度的人 (包含不把自己成為「程式設"
"計師」的人) 都能使用的基礎工具，那麼這個工具很有可能會是腳本，並且有自定名稱"
"／圖示。"

msgid ""
"If one wishes to create a concept that is particular to their game, then it "
"should always be a scene. Scenes are easier to track/edit and provide more "
"security than scripts."
msgstr ""
"如果想建立專屬於自己的遊戲的概念，則應該使用場景。場景比較好追蹤與編輯，並且"
"比起腳本提供更多安全性。"

msgid ""
"If one would like to give a name to a scene, then they can still sort of do "
"this by declaring a script class and giving it a scene as a constant. The "
"script becomes, in effect, a namespace:"
msgstr ""
"如果想為場景起名，則還是可以在 3.1 版中通過宣告腳本類別並以常數來指定場景來實"
"現類似的目的。該腳本就有了命名空間的效果："

msgid "Translation status"
msgstr "翻譯狀態"
