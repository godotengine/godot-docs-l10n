# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using SceneTree"
msgstr "Using SceneTree"

msgid "Introduction"
msgstr "前言"

msgid ""
"In previous tutorials, everything revolved around the concept of nodes. "
"Scenes are collections of nodes. They become active once they enter the "
"*scene tree*."
msgstr ""
"到目前位置的教學都是圍繞著節點的概念延伸的。場景是節點的集合。而場景會在進入 "
"**場景樹** 後變為有效場景 (Active Scene)。"

msgid "MainLoop"
msgstr "MainLoop"

msgid ""
"The way Godot works internally is as follows. There is the :ref:`OS "
"<class_OS>` class, which is the only instance that runs at the beginning. "
"Afterwards, all drivers, servers, scripting languages, scene system, etc are "
"loaded."
msgstr ""
"Godot 內部以下列方式運作。有一個 :ref:`OS <class_OS>` 類別，是在開始執行的時"
"候唯一的實體。之後便會加載所有的驅動程式、伺服器、腳本語言、場景系統…等。"

msgid ""
"When initialization is complete, :ref:`OS <class_OS>` needs to be supplied "
"a :ref:`MainLoop <class_MainLoop>` to run. Up to this point, all this is "
"internals working (you can check main/main.cpp file in the source code if "
"you are ever interested to see how this works internally)."
msgstr ""
"當初始化完成後， :ref:`OS <class_OS>` 就必須要提供 :ref:`MainLoop "
"<class_MainLoop>` 來執行。到這裡為止，都是屬於內部運作（若你有興趣瞭解內部如"
"何運作，可以閱讀原始碼的 。main/main.cpp 檔案）。"

msgid ""
"The user program, or game, starts in the MainLoop. This class has a few "
"methods, for initialization, idle (frame-synchronized callback), fixed "
"(physics-synchronized callback), and input. Again, this is low level and "
"when making games in Godot, writing your own MainLoop seldom makes sense."
msgstr ""
"使用者程式，或稱為遊戲，會在 MainLoop 內開始執行。這個類別有幾個方法，可以用"
"來初始化、閒置（影格同步回呼）、固定（物理同步回呼）、與輸入。同樣地，這些都"
"屬於低階的功能，而在 Godot 內製作遊戲的時候撰寫自己的 MainLoop 沒什麼意義。"

msgid "SceneTree"
msgstr "SceneTree"

msgid ""
"One of the ways to explain how Godot works is that it's a high level game "
"engine over a low level middleware."
msgstr ""
"還有一種可以說明 Godot 運作方式的方法就是將 Godot 看作是有低級中間件 "
"(Middleware) 的高級遊戲引擎。"

msgid ""
"The scene system is the game engine, while the :ref:`OS <class_OS>` and "
"servers are the low level API."
msgstr "場景系統是遊戲引擎，而 :ref:`OS <class_OS>` 與伺服器則為低階 API。"

msgid ""
"The scene system provides its own main loop to OS, :ref:`SceneTree "
"<class_SceneTree>`. This is automatically instanced and set when running a "
"scene, no need to do any extra work."
msgstr ""
"場景系統提供了自己的 MainLoop 給 OS，即為 :ref:`SceneTree "
"<class_SceneTree>` 。這個類別會在場景執行時自動實體化，所以不需要額外做什麼。"

msgid ""
"It's important to know that this class exists because it has a few important "
"uses:"
msgstr "而重要的是要知道有這個類別存在，因為他有一些重要的用途："

msgid ""
"It contains the root :ref:`Viewport <class_Viewport>`, to which a scene is "
"added as a child when it's first opened to become part of the *Scene Tree* "
"(more on that next)."
msgstr ""
"包含了根 :ref:`Viewport <class_Viewport>` ，也就是場景第一次打開並進入 **場景"
"樹** 時會被加為子節點的地方（詳細見下方）。"

msgid ""
"It contains information about the groups and has the means to call all nodes "
"in a group or get a list of them."
msgstr ""
"包含了有關群組的資訊，且能夠呼叫群組中的所有節點或取得群組中節點的列表。"

msgid ""
"It contains some global state functionality, such as setting pause mode or "
"quitting the process."
msgstr "包含了一些全域狀態的功能，如設定暫停模式或結束處理程式。"

msgid ""
"When a node is part of the Scene Tree, the :ref:`SceneTree "
"<class_SceneTree>` singleton can be obtained by calling :ref:`Node."
"get_tree() <class_Node_method_get_tree>`."
msgstr ""
"當節點成為場景樹的一部分後，便可以通過呼叫 :ref:`Node.get_tree() "
"<class_Node_method_get_tree>` 來取得 :ref:`SceneTree <class_SceneTree>` 單例 "
"(Singleton)。"

msgid "Root viewport"
msgstr "根檢視區"

msgid ""
"The root :ref:`Viewport <class_Viewport>` is always at the top of the scene. "
"From a node, it can be obtained in two different ways:"
msgstr ""
"根 :ref:`Viewport <class_Viewport>` 永遠為場景的最上層。在一個節點內，根檢視"
"區可以通過兩種不同方式取得："

msgid ""
"This node contains the main viewport. Anything that is a child of a :ref:"
"`Viewport <class_Viewport>` is drawn inside of it by default, so it makes "
"sense that the top of all nodes is always a node of this type otherwise "
"nothing would be seen."
msgstr ""
"這個節點包含了主檢視區。所有東西 :ref:`Viewport <class_Viewport>` 的子節點預"
"設都是繪製在其內部的，因此所有節點的最上層都會是 Viewport 型別，否則就不會顯"
"示任何東西。"

msgid ""
"While other viewports can be created in the scene (for split-screen effects "
"and such), this one is the only one that is never created by the user. It's "
"created automatically inside SceneTree."
msgstr ""
"雖然場景內也可以建立其他的 Viewport（用於畫面分割效果等），但根 Viewport 永遠"
"都不會是由使用者建立的，而是在 SceneTree 內自動建立的。"

msgid "Scene tree"
msgstr "場景樹"

msgid ""
"When a node is connected, directly or indirectly, to the root viewport, it "
"becomes part of the *scene tree*."
msgstr "當節點直接或間接地連接上了根檢視區，就變成了 **場景樹** 的一部分。"

msgid ""
"This means that as explained in previous tutorials, it will get the "
"``_enter_tree()`` and ``_ready()`` callbacks (as well as ``_exit_tree()``)."
msgstr ""
"這表示，如之前解釋過的，節點會取得 _enter_tree() 與 _ready() 回呼函式（另外還"
"有 _exit_tree()）。"

msgid ""
"When nodes enter the *Scene Tree*, they become active. They get access to "
"everything they need to process, get input, display 2D and 3D visuals, "
"receive and send notifications, play sounds, etc. When they are removed from "
"the *scene tree*, they lose these abilities."
msgstr ""
"當節點進入 **場景樹** 便成為了有效節點。這些節點將可以存取所有節點需要處理的"
"資源，如取得輸入、顯示 2D 或 3D 畫面、接受與送出通知、播放聲音…等。當節點從 "
"**場景樹** 中移除後便失去了這些能力。"

msgid "Tree order"
msgstr "樹順序"

msgid ""
"Most node operations in Godot, such as drawing 2D, processing, or getting "
"notifications are done in *tree order*, or top to bottom as seen in the "
"editor (also known as pre-order traversal):"
msgstr ""

msgid ""
"For example, the top node in a scene has its ``_process()`` function called "
"first, then the node below it has its ``_process()`` function called, then "
"the node below that and so on."
msgstr ""

msgid ""
"An important exception is the ``_ready()`` function: each parent node has "
"its ``_ready()`` function called only after all its child nodes have their "
"``_ready()`` functions called, so that the parent knows its children are "
"completely ready to be accessed. This is also known as post-order traversal. "
"In the above image, ``NameLabel`` would be notified first (but only after "
"its children, if it had any!), followed by ``Name``, etc., and ``Panel`` "
"would be notified last."
msgstr ""

#, fuzzy
msgid ""
"The order of operations can also be overridden using the "
"``process_priority`` node property. Nodes with a lower number are called "
"first. For example, nodes with the priorities \"0, 1, 2, 3\" would be called "
"in that order from left to right."
msgstr ""
"這也可以使用“process_priority”節點屬性來覆寫。首先呼叫編號較小的節點。例如，"
"優先權為「0、1、2、3」的節點將依該順序（從左到右）被呼叫。"

msgid "\"Becoming active\" by entering the *Scene Tree*"
msgstr "藉由進入 **場景樹** 來「成為有效狀態」"

msgid "A scene is loaded from disk or created by scripting."
msgstr "某個場景由硬碟載入或由腳本建立。"

msgid ""
"The root node of that scene (only one root, remember?) is added as either a "
"child of the \"root\" Viewport (from SceneTree), or to any of its "
"descendants."
msgstr ""
"該場景的根節點（只有一個根節點，還記得嗎？）不是被加到（SceneTree 內的）"
"「root」檢視區作為子節點，就是被加到 root 檢視區的子節點或次級子節點當中。"

#, fuzzy
msgid ""
"Every node of the newly added scene will receive the \"enter_tree\" "
"notification ( ``_enter_tree()`` callback in GDScript) in top-to-bottom "
"order (pre-order traversal)."
msgstr ""
"所有新加入場景的節點都會以從上至下的順序收到「enter_tree」通知（GDScript 為 "
"_enter_tree() 回呼函式）。"

#, fuzzy
msgid ""
"Every node will receive the \"ready\" notification ( ``_ready()`` callback "
"in GDScript) for convenience, once all its children have received the "
"\"ready\" notification (post-order traversal)."
msgstr ""
"為了方便起見，當某個節點與其所有子節點都在有效場景中是也會提供另一個額外的通"
"知，「ready」（GDScript 為 _ready() 回呼函式）。"

#, fuzzy
msgid ""
"When a scene (or part of it) is removed, they receive the \"exit scene\" "
"notification ( ``_exit_tree()`` callback in GDScript) in bottom-to-top order "
"(the exact reverse of top-to-bottom order)."
msgstr ""
"當移除一個場景（或場景中的一部分），場景會自下而上地收到「exit scene」通知"
"（GDScript 內為 _exit_tree() 回呼函式）"

msgid "Changing current scene"
msgstr "修改目前場景"

msgid ""
"After a scene is loaded, you may want to change this scene for another one. "
"One way to do this is to use the :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` function:"
msgstr ""
"場景載入後，通常會有需要更改目前的場景成另一個場景。最簡單的方法是使用 :ref:"
"`SceneTree.change_scene() <class_SceneTree_method_change_scene>` 函式："

msgid ""
"Rather than using file paths, one can also use ready-made :ref:`PackedScene "
"<class_PackedScene>` resources using the equivalent function :ref:`SceneTree."
"change_scene_to_packed(PackedScene scene) "
"<class_SceneTree_method_change_scene_to_packed>`:"
msgstr ""
"除了使用檔案路徑，還可以通過 :ref:`SceneTree.change_scene_to(PackedScene "
"scene) <class_SceneTree_method_change_scene_to>` 來使用預先準備好的 :ref:"
"`PackedScene <class_PackedScene>` 資源："

msgid ""
"These are quick and useful ways to switch scenes but have the drawback that "
"the game will stall until the new scene is loaded and running. At some point "
"in the development of your game, it may be preferable to create proper "
"loading screens with progress bar, animated indicators or threaded "
"(background) loading. This must be done manually using :ref:"
"`doc_singletons_autoload` and :ref:`doc_background_loading`."
msgstr ""
"這幾個切換場景的方法比較快速且實用，但缺點是遊戲在新場景載入並開始執行之前都"
"會停止。遊戲開發到某個程度的時候最高做個合適的載入畫面，並配合使用進度條、動"
"畫指示器、或執行緒（背景）載入。這些東西必須手動使用 Autoload（詳見下一章）或"
"是 :ref:`doc_background_loading` 。"

msgid "Translation status"
msgstr "翻譯狀態"
