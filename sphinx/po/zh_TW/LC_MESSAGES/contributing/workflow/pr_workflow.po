# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Pull request workflow"
msgstr "Pull Request 工作流程"

msgid ""
"The so-called \"PR workflow\" used by Godot is common to many projects using "
"Git, and should be familiar to veteran free software contributors. The idea "
"is that only a small number (if any) commit directly to the *master* branch. "
"Instead, contributors *fork* the project (i.e. create a copy of it, which "
"they can modify as they wish), and then use the GitHub interface to request "
"a *pull* from one of their fork's branches to one branch of the original "
"(often named *upstream*) repository."
msgstr ""
"Godot 使用的所謂「PR 工作流程」對於許多使用 Git 的專案來說很場景，對於有經驗"
"的自由軟體貢獻者來說應該很熟悉。PR 的主要概念是，應該只有少數 (甚至沒有) "
"Commit 直接被推送到 **master** 分支上。貢獻者應該要先 **Fork** 專案 (即，建立"
"專案的拷貝，接著貢獻者便能隨意修改)，然後使用 GitHub 的界面來請原始儲存庫 (通"
"常稱謂 **Upstream** - 上游) 從這些 Fork 的分支上 **Pull** 回來。"

msgid ""
"The resulting *pull request* (PR) can then be reviewed by other "
"contributors, which might approve it, reject it, or most often request that "
"modifications be done. Once approved, the PR can then be merged by one of "
"the core developers, and its commit(s) will become part of the target branch "
"(usually the *master* branch)."
msgstr ""
"產生的 **Pull Request** (PR) 可以被其他貢獻者審閱，其他貢獻者可能會允許 PR、"
"拒絕 PR、或是要求要對 PR 作出修改。PR 被允許後，便可由核心開發人員進行合併 "
"(Merge)，而 PR 的 Commit 則會變成合併目標分支中的一部分 (通常為 **master** 分"
"支)。"

msgid ""
"We will go together through an example to show the typical workflow and "
"associated Git commands. But first, let's have a quick look at the "
"organization of Godot's Git repository."
msgstr ""
"我們接著會以一個範例來解釋這個工作流程與其相關的 Git 指令。但首先，我們來看一"
"下 Godot Git 儲存庫的組織架構。"

msgid "Git source repository"
msgstr "Git 原始碼儲存庫"

msgid ""
"The `repository on GitHub <https://github.com/godotengine/godot>`_ is a `Git "
"<https://git-scm.com>`_ code repository together with an embedded issue "
"tracker and PR system."
msgstr ""
"`GitHub 上的儲存庫 <https://github.com/godotengine/godot>`_ 是一個 `Git "
"<https://git-scm.com>`_ 程式碼儲存庫，並含有內建的 Issue Tracker 與 PR 系統。"

msgid ""
"If you are contributing to the documentation, its repository can be found "
"`here <https://github.com/godotengine/godot-docs>`_."
msgstr ""
"若想參與貢獻說明文件，則可在 `此處 <https://github.com/godotengine/godot-"
"docs>`_ 找到其儲存庫。"

msgid ""
"The Git version control system is the tool used to keep track of successive "
"edits to the source code - to contribute efficiently to Godot, learning the "
"basics of the Git command line is *highly* recommended. There exist some "
"graphical interfaces for Git, but they usually encourage users to take bad "
"habits regarding the Git and PR workflow, and we therefore recommend not to "
"use them. In particular, we advise not to use GitHub's online editor for "
"code contributions (although it's tolerated for small fixes or documentation "
"changes) as it enforces one commit per file and per modification, which "
"quickly leads to PRs with an unreadable Git history (especially after peer "
"review)."
msgstr ""
"Git 版本控制系統是用來追送程式碼之連續編輯的工具。若要有效率的為 Godot 參與貢"
"獻，我們 **非常** 建議學習基礎的 Git 命令行使用。目前有許多的 Git 圖形界面，"
"但這些軟體通常都會讓使用者養成關於 Git 與 PR 工作流程的壞習慣，所以我們不建議"
"使用這些軟體。特別是，對於程式碼貢獻，我們不建議使用 GitHub 的線上編輯器 (雖"
"然對於小型修正與說明文件更改來說還可以)，因為 GitHub 的線上編輯器每改一個檔案"
"就有一個 Commit，這樣建立起來的 PR 的 Git 歷史就會很難閱讀 (特別是在同儕審閱"
"後)。"

msgid ""
"The first sections of Git's \"Book\" are a good introduction to the tool's "
"philosophy and the various commands you need to master in your daily "
"workflow. You can read them online on the `Git SCM <https://git-scm.com/book/"
"en/v2>`_ website. You can also try out `GitHub's interactive guide <https://"
"try.github.io/>`__."
msgstr ""
"有關 Git 的理念與日常工作所需掌握的各個指令，可以從 Git「Book」中的第一部分來"
"學習。可以在 `Git SCM <https://git-scm.com/book/zh-tw/v2>` 網站中線上閱讀。"

msgid "The branches on the Git repository are organized as follows:"
msgstr "Git 儲存庫中的分支以下列方式組織："

msgid ""
"The ``master`` branch is where the development of the next major version "
"occurs. As a development branch, it can be unstable and is not meant for use "
"in production. This is where PRs should be done in priority."
msgstr ""
"``master`` 分支用來進行下個主要版本的開發。作為一個開發分支，該分支內的程式是"
"不穩定的，且不適用於正式環境。該分支是 PR 應優先進行的地方。"

msgid ""
"The stable branches are named after their version, e.g. ``3.1`` and ``2.1``. "
"They are used to backport bugfixes and enhancements from the ``master`` "
"branch to the currently maintained stable release (e.g. 3.1.2 or 2.1.6). As "
"a rule of thumb, the last stable branch is maintained until the next minor "
"version (e.g. the ``3.0`` branch was maintained until the release of Godot "
"3.1). If you want to make PRs against a maintained stable branch, please "
"check first if your changes are also relevant for the ``master`` branch, and "
"if so make the PR for the ``master`` branch in priority. Release managers "
"can then cherry-pick the fix to a stable branch if relevant."
msgstr ""
"穩定版分支的名稱使用其版本，如 ``3.1`` 與 ``2.1`` 。這些分支是用來將 Bug 修正"
"與改進從 ``master`` 分支移植回去主線穩定版本的 (如 3.1.2 或 2.1.6)。依照經驗"
"法則，最後一個穩定的分支會一直維護到下一個主要版本退出後 (如 ``3.0`` 分支一直"
"到 Godot 3.1 推出時都還有維護)。若想製作對應主線穩定版的 PR，請先檢查其改動是"
"否也會與 ``master`` 分支有關，若與 ``master`` 分支有關，請優先以 ``master`` "
"作為 PR 的目標。釋出管理員會將相關的修正 Cherry-Pick 到穩定分支。"

msgid ""
"There might occasionally be feature branches, usually meant to be merged "
"into the ``master`` branch at some time."
msgstr ""
"有時候可能會有一些功能性分支，通常這些分支是用來在之後合併到 ``master`` 用"
"的。"

msgid "Forking and cloning"
msgstr "Fork 與 Clone"

msgid ""
"The first step is to *fork* the `godotengine/godot <https://github.com/"
"godotengine/godot>`_ repository on GitHub. To do so, you will need to have a "
"GitHub account and to be logged in. In the top right corner of the "
"repository's GitHub page, you should see the \"Fork\" button as shown below:"
msgstr ""
"第一步是在 GitHub 上 **Fork** `godotengine/godot <https://github.com/"
"godotengine/godot>`_ 儲存庫。要進行 Fork，你必須要先有 GitHub 帳號並登入。在"
"儲存庫 GitHub 頁面的右上角，應該可以看到如下的「Fork」按鈕："

msgid ""
"Click it, and after a while you should be redirected to your own fork of the "
"Godot repo, with your GitHub username as namespace:"
msgstr ""
"點擊該按鈕，稍待片刻後應該會重新導向到你自己 Fork 的 Godot 儲存庫中，並以你"
"的 GitHub 使用者名稱作為命名空間："

msgid ""
"You can then *clone* your fork, i.e. create a local copy of the online "
"repository (in Git speak, the *origin remote*). If you haven't already, "
"download Git from `its website <https://git-scm.com>`_ if you're using "
"Windows or macOS, or install it through your package manager if you're using "
"Linux."
msgstr ""
"接著便可 **Clone** 你的 Fork，即為建立一個線上儲存庫的本機拷貝 (用 Git 的說法"
"來說，線上儲存庫就是 **origin remote**)。若還未下載 Git，Windows 與 macOS 請"
"從 ``Git 網站 <https://git-scm.com>`_ 下載 Git，如果使用 Linux 則請通過套件管"
"理員進行安裝。"

msgid ""
"If you are on Windows, open Git Bash to type commands. macOS and Linux users "
"can use their respective terminals."
msgstr ""
"如果使用 Windows，請開啟 Git Bash 來輸入指令。macOS 與 Linux 使用者則可使用各"
"自的終端機。"

msgid "To clone your fork from GitHub, use the following command:"
msgstr "若要從 GitHub 上 Clone 你的 Fork，請使用下列指令："

msgid ""
"In our examples, the \"$\" character denotes the command line prompt on "
"typical UNIX shells. It is not part of the command and should not be typed."
msgstr ""
"在我們的例子中，「$」字元用來表示一般的 UNIX Shell 命令提示字元。該字元並不是"
"指令的一部分，不應輸入。"

msgid ""
"After a little while, you should have a ``godot`` directory in your current "
"working directory. Move into it using the ``cd`` command:"
msgstr ""
"稍等片刻後，應該可以在目前的工作目錄中看到 ``godot`` 資料夾。請使用 ``cd`` 指"
"令移至該資料夾中："

msgid ""
"We will start by setting up a reference to the original repository that we "
"forked:"
msgstr "我們先從設定所 Fork 的原始儲存庫參照開始："

msgid ""
"This will create a reference named ``upstream`` pointing to the original "
"``godotengine/godot`` repository. This will be useful when you want to pull "
"new commits from its ``master`` branch to update your fork. You have another "
"remote reference named ``origin``, which points to your fork (``USERNAME/"
"godot``)."
msgstr ""
"這個指令會建立一個名為 ``upstream`` 的參照，並指向原始的 ``godotengine/"
"godot`` 儲存庫。這樣設定對於想從其 ``master`` 分支 Pull 新 Commit 來更新你的 "
"Fork 很有用。除了 ``upstream`` 參照外，還有另一個名為 ``origin`` 的遠端參照，"
"指向你自己的 Fork (``使用者名稱/godot``)。"

msgid ""
"You only need to do the above steps once, as long as you keep that local "
"``godot`` folder (which you can move around if you want, the relevant "
"metadata is hidden in its ``.git`` subfolder)."
msgstr ""
"只要保持本機的 ``godot`` 資料夾 (可隨意移動，相關的後設資料隱藏在 ``.git`` 子"
"資料夾中)，上述步驟只需要進行一次即可。"

msgid ""
"*Branch it, pull it, code it, stage it, commit, push it, rebase it... "
"technologic.*"
msgstr "*建立分支、拉取、撰寫程式碼、暫存、推送、rebase……太多技巧了。*"

msgid ""
"This bad take on Daft Punk's *Technologic* shows the general conception Git "
"beginners have of its workflow: lots of strange commands to learn by copy "
"and paste, hoping they will work as expected. And that's actually not a bad "
"way to learn, as long as you're curious and don't hesitate to question your "
"search engine when lost, so we will give you the basic commands to know when "
"working in Git."
msgstr ""
"Daft Punk 的 **Technologic** 中對於這種不良看法表示，Git 初學者通常對 Git 工"
"作流程一般的概念為：用複製貼上來學許多奇怪的指令，然後希望指令能如預期般運"
"作。但只要你保持好奇心，且在遇到問題時能問問搜尋引擎，這就不是什麼不好的學習"
"方式。因此，接下來我們會提供使用 Git 的基本指令。"

msgid ""
"In the following, we will assume as an example that you want to implement a "
"feature in Godot's Project Manager, which is coded in the ``editor/"
"project_manager.cpp`` file."
msgstr ""
"在接下來的部分，我們會以假設你想為 Godot 專案管理員實作新功能為例子，專案管理"
"員的程式碼會寫在 ``editor/project_manager.cpp`` 檔案中。"

msgid "Branching"
msgstr "建立分支"

msgid ""
"By default, the ``git clone`` should have put you on the ``master`` branch "
"of your fork (``origin``). To start your own feature development, we will "
"create a feature branch:"
msgstr ""
"預設情況下，``git clone`` 指令會打開你的 Fork (``origin``) 的 ``master`` 分"
"支。若要開始進行功能開發，我們要先建立一個功能分支："

msgid "This command is equivalent:"
msgstr "下列指令效果相同："

msgid "If you want to go back to the ``master`` branch, you'd use:"
msgstr "若想回到 ``master`` 分支，可以使用："

msgid ""
"You can see which branch you are currently on with the ``git branch`` "
"command:"
msgstr "可以使用 ``git branch`` 指令來看看目前在哪個分支上："

msgid ""
"Be sure to always go back to the ``master`` branch before creating a new "
"branch, as your current branch will be used as the base for the new one. "
"Alternatively, you can specify a custom base branch after the new branch's "
"name:"
msgstr ""
"由於目前的分支會在建立新分支時作為基礎，所以請確保每次建立新分支前都先回到 "
"``master`` 上。或者，也可以在新分支名稱之後指定自定的基礎分支："

msgid "Updating your branch"
msgstr "更新分支"

msgid ""
"This would not be needed the first time (just after you forked the upstream "
"repository). However, the next time you want to work on something, you will "
"notice that your fork's ``master`` is several commits behind the upstream "
"``master`` branch: pull requests from other contributors would have been "
"merged in the meantime."
msgstr ""
"剛開始並不需要更新分支 (也就是剛從上游儲存庫 Fork 完後)。但，之後要進行其他作"
"業時可能會發現 Fork 的 ``master`` 分支比上游 ``master`` 分支還落後了多個 "
"Commit，因為這段期間內其他貢獻者的 Pull Request 被合併到了 ``master`` 內。"

msgid ""
"To ensure there won't be conflicts between the feature you develop and the "
"current upstream ``master`` branch, you will have to update your branch by "
"*pulling* the upstream branch."
msgstr ""
"為了確保你正在開發的功能不會與目前的上游 ``master`` 分支衝突，必須要從上游分"
"支 **Pull** (拉取) 來更新目前的分支。"

msgid ""
"The ``--rebase`` argument will ensure that any local changes that you "
"committed will be re-applied *on top* of the pulled branch, which is usually "
"what we want in our PR workflow. This way, when you open a pull request, "
"your own commits will be the only difference with the upstream ``master`` "
"branch."
msgstr ""
"``--rebase`` 參數可以用來確保在本機 Commit 過的更新被重新套用在 Pull 的分支"
"的 **最前端** ，這也是我們在 PR 工作流程裡通常會做的方式。這樣一來，在開啟 "
"Pull Request 時，你的分支與上游 ``master`` 分支的差別就只會有你的 Commit。"

msgid ""
"While rebasing, conflicts may arise if your commits modified code that has "
"been changed in the upstream branch in the meantime. If that happens, Git "
"will stop at the conflicting commit and will ask you to resolve the "
"conflicts. You can do so with any text editor, then stage the changes (more "
"on that later), and proceed with ``git rebase --continue``. Repeat the "
"operation if later commits have conflicts too, until the rebase operation "
"completes."
msgstr ""
"在 Rebase 時，如果你修改過的程式碼在這段時間內也於上游分支中內有修改過，則會"
"發聲衝突。若發生衝突，則 Git 會停在發生衝突的 Commit，並要求處理衝突。可以在"
"任何文字編輯器中處理衝突，接著將更改預存 (Stage) 起來 (稍後說明)，然後執行 "
"``git rebase --continue`` 。如果之後的 Commit 還有衝突的話，則需要重複這個過"
"程，直到 Rebase 操作完成。"

msgid ""
"If you're unsure about what is going on during a rebase and you panic (no "
"worry, we all do the first few times), you can abort the rebase with ``git "
"rebase --abort``. You will then be back to the original state of your branch "
"before calling ``git pull --rebase``."
msgstr ""
"如果在 Rebase 時害怕不知道現在正在做什麼的話 (別擔心，我們剛開始都會緊張)，可"
"以通過 ``git rebase --abort`` 來中止 Rebase。接著會回到執行 ``git pull --"
"rebase`` 之前的分支狀態。"

msgid ""
"If you omit the ``--rebase`` argument, you will instead create a merge "
"commit which tells Git what to make of the two distinct branches. If any "
"conflicts arise, they would be resolved all at once via this merge commit."
msgstr ""
"如果沒有加上 ``--rebase`` 印數，那麼會建立一個 Merge Commit，該 Commit 用來告"
"訴 Git 要如何處理兩個不同的分支。若發生衝突，則所有的衝突都會通過 Merge "
"Commit 來處理。"

msgid ""
"While this is a valid workflow and the default behavior of ``git pull``, "
"merge commits within PRs are frowned upon in our PR workflow. We only use "
"them when merging PRs into the upstream branch."
msgstr ""
"雖然 Merge Commit 也是有效的工作流程，而且是 ``git pull`` 預設的行為，但在我"
"們的 PR 工作流程內，我們不贊同使用 Merge Commit。我們只會在將 PR 合併回上游分"
"支時使用 Merge Commit。"

msgid ""
"The philosophy is that a PR should represent the final stage of the changes "
"made to the codebase, and we are not interested in mistakes and fixes that "
"would have been done in intermediate stages before merging. Git gives us "
"great tools to \"rewrite the history\" and make it as if we got things right "
"the first time, and we're happy to use it to ensure that changes are easy to "
"review and understand long after they have been merged."
msgstr ""
"這麼做的理念是，PR 應該用來代表對程式碼修改的最終狀態，而我們並不在乎到合併之"
"前這段期間所產生的錯誤與修正。Git 提供了讓我們「重寫歷史」的好工具，通過這個"
"工具可以讓我們把東西做得看起來好像一步到位，而我們很高興能通過這個工具來讓更"
"改更容易被審閱，且即使在合併一段時間後仍容易理解。"

msgid ""
"If you have already created a merge commit without using ``rebase``, or have "
"made any other changes that have resulted in undesired history, the best "
"option is to use an *interactive rebase* on the upstream branch. See the :"
"ref:`dedicated section <doc_pr_workflow_rebase>` for instructions."
msgstr ""
"如果沒有使用 ``rebase`` 且已經建立 Merge Commit 的話，或是造成了一些非期望的"
"歷史記錄，則最好的選擇是在上游分支使用 **Interactive Rebase** (互動式變基)。"
"相關步驟請參考 :ref:`Rebase 一節 <doc_pr_workflow_rebase>` 。"

msgid ""
"If at any time you want to *reset* a local branch to a given commit or "
"branch, you can do so with ``git reset --hard <commit ID>`` or ``git reset --"
"hard <remote>/<branch>`` (e.g. ``git reset --hard upstream/master``)."
msgstr ""
"任何時候，如果想將本機分支 **重設** (Reset) 到特定的 Commit 或分支上，可以通"
"過 ``git reset --hard <Commit ID>`` 或 ``git reset --hard <Remote>/<分支>`` "
"(如 ``git reset --hard upstream/master``) 來實作。"

msgid ""
"Be warned that this will remove any changes that you might have committed in "
"this branch. If you ever lose commits by mistake, use the ``git reflog`` "
"command to find the commit ID of the previous state that you would like to "
"restore, and use it as argument of ``git reset --hard`` to go back to that "
"state."
msgstr ""
"但請注意，這樣也可能會讓任何已經 Commit 到該分支上的改動被移除。如果不小心遺"
"失 Commit，可以使用 ``git reflog`` 指令來找到所要恢復到之前狀態的 Commit ID，"
"然後使用該 ID 作為 ``git reset --hard`` 的參數來回到該狀態。"

msgid "Making changes"
msgstr "做出更改"

msgid ""
"You would then do your changes to our example's ``editor/project_manager."
"cpp`` file with your usual development environment (text editor, IDE, etc.)."
msgstr ""
"你可以通過平常使用的開發環境 (如文字編輯器、IDE…等) 來更改範例的 ``editor/"
"project_manager.cpp`` 檔案。"

msgid ""
"By default, those changes are *unstaged*. The staging area is a layer "
"between your working directory (where you make your modifications) and the "
"local Git repository (the commits and all the metadata in the ``.git`` "
"folder). To bring changes from the working directory to the Git repository, "
"you need to *stage* them with the ``git add`` command, and then to commit "
"them with the ``git commit`` command."
msgstr ""
"預設情況下，做出的改動都是 **未預存** (Unstaged) 的。預存區 (Staging Area) 是"
"一層介於目前工作目錄 (也就是你進行修改的地方) 以及本機 Git 儲存庫 (所有 "
"Commit 與後設資料都在 ``.git`` 資料夾內) 的區域。若要將目前工作資料夾中的更改"
"帶到 Git 儲存庫中，則需要通過 ``git add`` 指令來 **預存** (Stage) 這些改動，"
"然後通過 ``git commit`` 指令來進行 Commit。"

msgid ""
"There are various commands you should know to review your current work, "
"before staging it, while it is staged, and after it has been committed."
msgstr ""
"有許多可以用來檢查目前工作狀態的指令，不管是在預存前、預存時、或是已經 "
"Commit 後。"

msgid ""
"``git diff`` will show you the current unstaged changes, i.e. the "
"differences between your working directory and the staging area."
msgstr ""
"``git diff`` 會顯示目前尚未預存的更改，即，目前工作目錄與暫存區的差異。"

msgid ""
"``git checkout -- <files>`` will undo the unstaged changes to the given "
"files."
msgstr "``git checkout -- <檔案>`` 可以取消改動指定檔案未預存的更改。"

msgid "``git add <files>`` will *stage* the changes on the listed files."
msgstr "``git add <檔案>`` 可以將列出的檔案 **預存** 。"

msgid ""
"``git diff --staged`` will show the current staged changes, i.e. the "
"differences between the staging area and the last commit."
msgstr ""
"``git diff --staged`` 會顯示目前已預存的改動，即，預存區與上一個 Commit 間的"
"差異。"

msgid "``git reset HEAD <files>`` will *unstage* changes to the listed files."
msgstr "``git reset HEAD <檔案>`` 會 **取消預存** 列出的檔案。"

msgid ""
"``git status`` will show you what are the currently staged and unstaged "
"modifications."
msgstr "``git status`` 會顯示目前已預存與未預存的更改。"

msgid ""
"``git commit`` will commit the staged files. It will open a text editor (you "
"can define the one you want to use with the ``GIT_EDITOR`` environment "
"variable or the ``core.editor`` setting in your Git configuration) to let "
"you write a commit log. You can use ``git commit -m \"Cool commit log\"`` to "
"write the log directly."
msgstr ""
"``git commit`` 會 Commit 已預存的檔案。該指令會開啟文字編輯器 (可以使用 "
"``GIT_EDITOR`` 環境變數或是 Git 組態設定的 ``core.editor`` 來定義要使用的編輯"
"器) 來讓你編寫 Commit Log。可以使用 ``git commit -m \"Cool commit log\"`` 來"
"直接撰寫 Commit Log。"

msgid ""
"``git commit --amend`` lets you amend the last commit with your currently "
"staged changes (added with ``git add``). This is the best option if you want "
"to fix a mistake in the last commit (bug, typo, style issue, etc.)."
msgstr ""
"``git commit --amend`` 可以將目前暫存的改動 (以 ``git add`` 新增的) 修正到上"
"一個 Commit 中。當想修正上一個 Commit 中的錯誤，這個指令是最好的選項 (Bug、錯"
"字、樣式問題…等)。"

msgid ""
"``git log`` will show you the last commits of your current branch. If you "
"did local commits, they should be shown at the top."
msgstr ""
"``git log`` 顯示目前分支的最新 Commit。若有進行本機 Commit，則應該會顯示在最"
"上面。"

msgid ""
"``git show`` will show you the changes of the last commit. You can also "
"specify a commit hash to see the changes for that commit."
msgstr ""
"``git show`` 會顯示最新 Commit 的更改。也可以指定一個 Commit 雜湊來檢視該 "
"Commit 的更改。"

msgid ""
"That's a lot to memorize! Don't worry, just check this cheat sheet when you "
"need to make changes, and learn by doing."
msgstr ""
"要記的東西很多！別擔心，只要下次有進行更改的時候再來看一下這張表就好了，做中"
"學。"

msgid "Here's how the shell history could look like on our example:"
msgstr "在這裡的範例中的 Shell 歷史應該長這樣："

msgid ""
"With this, we should have two new commits in our ``better-project-manager`` "
"branch which were not in the ``master`` branch. They are still only local "
"though, the remote fork does not know about them, nor does the upstream repo."
msgstr ""
"這樣一來，我們應該在 ``better-project-manager`` 中建立了兩個新的 Commit，這兩"
"個 Commit 不會出現在 ``master`` 分支上。雖然目前這些 Commit 還只存在本機裡，"
"對於遠端 Fork 與上游 Repo 都還不知道。"

msgid "Pushing changes to a remote"
msgstr "將更改推送 (Push) 到遠端"

msgid ""
"That's where ``git push`` will come into play. In Git, a commit is always "
"done in the local repository (unlike Subversion where a commit will modify "
"the remote repository directly). You need to *push* the new commits to a "
"remote branch to share them with the world. The syntax for this is:"
msgstr ""
"這裡就是 ``git push`` 登場的時機了。在 Git 中，Commit 都是在本機儲存庫上完成"
"的 (與 Subversion 不同，SVN 的 Commit 會直接向遠端儲存庫進行修改)。我們會需要"
"將新的 Commit **Push** 到遠端分支上來將這些 Commit 分享給全世界。語法如下："

msgid ""
"The part about the remote branch can be omitted if you want it to have the "
"same name as the local branch, which is our case in this example, so we will "
"do:"
msgstr ""
"如果想使用與本機分支相同名稱的遠端分支的話，則可以省略遠端分支的那個部分。而"
"本例中就是這樣，所以可以這樣寫："

msgid ""
"Git will ask you for your username and password. For your password, enter "
"your GitHub Personal Access Token (PAT). If you do not have a GitHub "
"Personal Access Token, or do not have one with the correct permissions for "
"your newly forked repository, you will need to create one. Follow this link "
"to create your Personal Access Token: `Creating a personal access token "
"<https://docs.github.com/en/authentication/keeping-your-account-and-data-"
"secure/creating-a-personal-access-token>`_."
msgstr ""
"Git 會詢問您的使用者名稱和密碼。輸入您的 GitHub 個人存取權杖 (PAT) 作為密碼。"
"如果您沒有 GitHub 個人存取令牌，或者沒有對新分叉的儲存庫具有正確權限的令牌，"
"則需要建立一個。點擊此連結建立您的個人存取權令牌：`建立個人存取權杖<https://"
"docs.github.com/en/authentication/keeping-your-account-and-data-secure/"
"creating-a-personal- access -令牌>`_。"

msgid ""
"After you have successfully verified your account using your PAT, the "
"changes will be sent to your remote repository. If you check the fork's page "
"on GitHub, you should see a new branch with your added commits."
msgstr ""
"Git 接著會詢問你帳號密碼，並將修改傳送到遠端。在 GitHub 的 Fork 頁面上確認一"
"下，就可以看到有剛才新增 Commit 的分支。"

msgid "Issuing a pull request"
msgstr "開啟 PR"

msgid ""
"When you load your fork's branch on GitHub, you should see a line saying "
"*\"This branch is 2 commits ahead of godotengine:master.\"* (and potentially "
"some commits behind, if your ``master`` branch was out of sync with the "
"upstream ``master`` branch)."
msgstr ""
"在 GitHub 上打開 Fork 的分支時，應該會看到一行字寫 **「This branch is 2 "
"commits ahead of godotengine:master」** (如果你的 ``master`` 分支沒有與上游 "
"``master`` 分支同步的話，數字可能還更大)。"

msgid ""
"On that line, there is a \"Pull request\" link. Clicking it will open a form "
"that will let you issue a pull request on the ``godotengine/godot`` upstream "
"repository. It should show you your two commits, and state \"Able to "
"merge\". If not (e.g. it has way more commits, or says there are merge "
"conflicts), don't create the PR yet, something went wrong. Go to our `Godot "
"Contributors Chat <https://chat.godotengine.org/>`_ and ask for support :)"
msgstr ""
"在這行文字旁邊，應該有一個「Pull request」連結。點擊該連結來打開在 "
"``godotengine/godot`` 上游儲存庫中建立 PR 的表單。這個頁面應該會顯示你建立的"
"兩個 Commit，並顯示「Able to merge」(可以合併)。如果沒顯示 Able to Merge 的"
"話 (如有更多 Commit 或有 Merge Conflict 的情況)，則請先不要建立 PR，這表示有"
"什麼地方出錯了。請先到 IRC 上尋求幫助 :)"

msgid ""
"Use an explicit title for the PR and put the necessary details in the "
"comment area. You can drag and drop screenshots, GIFs or zipped projects if "
"relevant, to showcase what your work implements. Click \"Create a pull "
"request\", and tadaa!"
msgstr ""
"請為 PR 使用完整的標題，並將所有必要的資訊都寫在 Comment 區域。有必要的話也可"
"以拖放截圖、GIF 或專案壓縮檔來提供你實作內容的展示。點擊「Create a pull "
"request」，就這樣！"

msgid "Modifying a pull request"
msgstr "更改 PR"

msgid ""
"While it is reviewed by other contributors, you will often need to make "
"changes to your yet-unmerged PR, either because contributors requested them, "
"or because you found issues yourself while testing."
msgstr ""
"在經由其他貢獻者審閱的期間，可能會常常修改這個還沒被合併的 PR。可能是因為其他"
"貢獻者要求修改，或是你自己在測試的時候發現問題。"

msgid ""
"The good news is that you can modify a pull request simply by acting on the "
"branch you made the pull request from. You can e.g. make a new commit on "
"that branch, push it to your fork, and the PR will be updated automatically:"
msgstr ""
"好消息是，可以直接在你建立 PR 的分支上進行修改。如，你可以在該分支上建立新 "
"Commit、推送到 Fork 上，然後 PR 就會自動更新："

msgid ""
"However, be aware that in our PR workflow, we favor commits that bring the "
"codebase from one functional state to another functional state, without "
"having intermediate commits fixing up bugs in your own code or style issues. "
"Most of the time, we will prefer a single commit in a given PR (unless "
"there's a good reason to keep the changes separate). Instead of authoring a "
"new commit, consider using ``git commit --amend`` to amend the previous "
"commit with your fixes. The above example would then become:"
msgstr ""
"但是，請注意我們的 PR 工作流程。我們偏好的 Commit 是將整個程式碼從一個功能狀"
"態變成另一個功能狀態的 Commit，而不應有用來修正自己程式碼 Bug、修正樣式問題這"
"樣的中介 Commit。在大多數情況下，我們都偏好一個 PR 一個 Commit (除非有什麼將"
"更改分開 Commit 的好理由)。因此，請避免建立新 Commit，考慮使用 ``git commit "
"--amend`` 來將這些修正合併到前面的 Commit 中。上述的例子會變成這樣："

msgid "The interactive rebase"
msgstr "互動性 Rebase"

#, fuzzy
msgid ""
"If you didn't follow the above steps closely to *amend* changes into a "
"commit instead of creating fixup commits, or if you authored your changes "
"without being aware of our workflow and Git usage tips, reviewers might "
"request you to *rebase* your branch to *squash* some or all of the commits "
"into one."
msgstr ""
"如果沒有嚴格按照上面的步驟來將更改 **合併 (Amend)** 到前面的 Commit 中而建立"
"了修正性的 Commit，或是沒有按照我們的工作流程與 Git 使用說明來建立更改，則審"
"閱者可能會要求你 **Rebase** 你的分支，並將其中的一些或全部 Commit **Squash "
"(壓縮)** 為一個。"

msgid ""
"Indeed, if some commits have been made following reviews to fix bugs, typos, "
"etc. in the original commit, they are not relevant to a future changelog "
"reader who would want to know what happened in the Godot codebase, or when "
"and how a given file was last modified."
msgstr ""
"當然，我們會依據審閱的結果來建立用於修正原始 Commit 中的 Bug、錯字…等，而這些"
"修正對於未來閱讀修改記錄的讀者來說是不相關的，因為這些讀者只想知道 Godot 的原"
"始碼庫發生了哪些變化，或是某個檔案在什麼時候做了什麼修改。"

msgid ""
"To squash those extraneous commits into the main one, we will have to "
"*rewrite history*. Right, we have that power. You may read that it's a bad "
"practice, and it's true when it comes to branches of the upstream repo. But "
"in your fork, you can do whatever you want, and everything is allowed to get "
"neat PRs :)"
msgstr ""
"如果要將這些不相關的 Commit 合併為一個，則我們需要 **重寫歷史** 。沒錯，我們"
"有修改歷史的能力。你可能在其他地方讀過，這是個不好的實踐方法 (Bade "
"Practive)。對於上游儲存庫的分支來說，更改歷史確實是個壞習慣，但對於你的 Fork "
"來說，你可以做任何想事，而對於要產生乾淨的 PR 來說，做什麼都可以 :)"

msgid ""
"We will use the *interactive rebase* ``git rebase -i`` to do this. This "
"command takes a commit ID or a branch name as argument, and will let you "
"modify all commits between that commit/branch and the last one in your "
"working branch, the so-called ``HEAD``."
msgstr ""
"我們會使用 **互動性 Rebase** ``git rebase -I`` 來修改歷史。這個指令接受一個 "
"Commit ID 或分支名稱作為參數，並讓你能修改從該 Commit 或分支起只目前工作分支"
"上最新 Commit (所謂的 ``HEAD``) 間的所有 Commit。"

msgid ""
"While you can give any commit ID to ``git rebase -i`` and review everything "
"in between, the most common and convenient workflow involves rebasing on the "
"upstream ``master`` branch, which you can do with:"
msgstr ""
"雖然可以將任何的 Commit ID 傳入 ``git rebase -I`` 並審閱期間所有的東西，但最"
"常用與最便利的工作流程就是從 **上游 ``master`` 分支** 開始 Rebase，可以通過下"
"列指令："

msgid ""
"Referencing branches in Git is a bit tricky due to the distinction between "
"remote and local branches. Here, ``upstream/master`` (with a `/`) is a local "
"branch which has been pulled from the ``upstream`` remote's ``master`` "
"branch."
msgstr ""
"由於遠端分支與本機分支是不同的，因此要在 Git 中參照分支需要點技巧。此處的 "
"``upstream/master`` (中間有 **/**) 代表的是從遠端 ``upstream`` 的 ``master`` "
"分支拉取回來的本機分支。"

msgid ""
"Interactive rebases can only be done on local branches, so the `/` is "
"important here. As the upstream remote changes frequently, your local "
"``upstream/master`` branch may become outdated, so you can update it with "
"``git fetch upstream master``. Contrarily to ``git pull --rebase upstream "
"master`` which would update your currently checked out branch, ``fetch`` "
"will only update the ``upstream/master`` reference (which is distinct from "
"your local ``master`` branch... yes it's confusing, but you'll become "
"familiar with this little by little)."
msgstr ""
"互動性 Rebase 只能在本機分支上進行，因此此處的 ``/`` 很重要。由於上游遠端常常"
"更改，而你本機的 ``upstream/master`` 分支可能會比較舊，因此需要通過 ``git "
"fetch upstream master`` 來進行更新。與 ``git pull --rebase upstream master`` "
"比較起來，``git pull --rebase`` 會更新目前簽出 (Checkout) 的分支，而 "
"``fetch`` 則只會更新 ``upstream/master`` 參照 (而該參照與本機的 ``master`` 分"
"支不同……沒錯，這些很混亂，但你會滿滿越來越熟悉)。"

msgid ""
"This will open a text editor (``vi`` by default, see `Git docs <https://git-"
"scm.com/book/en/v2/Customizing-Git-Git-Configuration#_core_editor>`_ to "
"configure your favorite one) with something which may look like this:"
msgstr ""
"上述指令會開啟文字編輯器 (預設為 ``vi``，請參考 `Git docs <https://git-scm."
"com/book/en/v2/Customizing-Git-Git-Configuration#_core_editor>`__ 瞭解如何設"
"定為你常用的編輯器)，內容為類似如下："

msgid ""
"The editor will also show instructions regarding how you can act on those "
"commits. In particular, it should tell you that \"pick\" means to use that "
"commit (do nothing), and that \"squash\" and \"fixup\" can be used to *meld* "
"the commit in its parent commit. The difference between \"squash\" and "
"\"fixup\" is that \"fixup\" will discard the commit log from the squashed "
"commit. In our example, we are not interested in keeping the log of the "
"\"Fix a typo\" commit, so we use:"
msgstr ""
"編輯器中也會顯示出如何操作這些 Commit 的說明。詳細來說，在這個檔案內應該有告"
"訴你「pick」代表使用該 Commit (不做任何事)，而「squash」與「fixup」則代表將"
"該 Commit **合併 (Meld)** 進其母 Commit。「Squash」與「Fixup」間的不同就是"
"「Fixup」會移除被合併 Commit 的 Commit Log。在我們的例子中，我們並不打算保留"
"「Fix a typo」的 Commit Log，因此我們可以使用："

msgid ""
"Upon saving and quitting the editor, the rebase will occur. The second "
"commit will be melded into the first one, and ``git log`` and ``git show`` "
"should now confirm that you have only one commit with the changes from both "
"previous commits."
msgstr ""
"保存並退出編輯器後，會進行 Rebase。第二個 Commit 會被合併到第一個 Commit 中，"
"而使用 ``git log`` 與 ``git show`` 確認便可得知現在只有一個 Commit，其中包含"
"了之前兩個 Commit 的所有更改。"

msgid ""
"But! You rewrote the history, and now your local and remote branches have "
"diverged. Indeed, commit 1b4aad7 in the above example will have changed, and "
"therefore got a new commit hash. If you try to push to your remote branch, "
"it will raise an error:"
msgstr ""
"但是！因為我們重寫了歷史，而現在本機與遠端的分支有出入。當然，在上述例子中，"
"Commit 1b4aad7 發生了變化，因此我們有了新的 Commit Hash。此時如果試著將更改推"
"送到遠端分支上，會出現錯誤："

#, fuzzy
msgid ""
"This is reasonable behavior, Git will not let you push changes that would "
"override remote content. But that's actually what we want to do here, so we "
"will have to *force* it:"
msgstr ""
"這是很正常的，因為 Git 不讓你將複寫遠端內容的更改推送過去。但在這裡，複寫遠端"
"內容就是我們要做的，因此我們要來 **強制 (Force)** 推送："

msgid ""
"And tadaa! Git will happily *replace* your remote branch with what you had "
"locally (so make sure that's what you wanted, using ``git log``). This will "
"also update the PR accordingly."
msgstr ""
"就這樣！Git 接著會將遠端分支以本機上的東西 **取代** 掉 (因此請先通過 ``git "
"log`` 確認你想要強制取代)。同時，也會更新相應的 PR。"

msgid "Rebasing onto another branch"
msgstr ""

msgid ""
"If you have accidentally opened your PR on the wrong branch, or need to "
"target another branch for some reason, you might need to filter out a lot of "
"commits that differ between the old branch (for example ``4.2``) and the new "
"branch (for example ``master``). This can make rebasing difficult and "
"tedious. Fortunately ``git`` has a command just for this situation, ``git "
"rebase --onto``."
msgstr ""

msgid ""
"If your PR was created from the ``4.2`` branch and you want to update it to "
"instead start at ``master`` the following steps *should* fix this in one "
"step:"
msgstr ""

msgid ""
"This will take all the commits on your branch *after* the ``4.2`` branch, "
"and then splice them on top of ``master``, ignoring any commits from the "
"``4.2`` branch not on the ``master`` branch. You may still need to do some "
"fixing, but this command should save you a lot of tedious work removing "
"commits."
msgstr ""

msgid ""
"Just like above for the interactive rebase you need to force push your "
"branch to handle the different changes:"
msgstr ""

msgid "Deleting a Git branch"
msgstr "刪除 Git 分支"

msgid ""
"After your pull request gets merged, there's one last thing you should do: "
"delete your Git branch for the PR. There won't be issues if you don't delete "
"your branch, but it's good practice to do so. You'll need to do this twice, "
"once for the local branch and another for the remote branch on GitHub."
msgstr ""
"當 PR 被合併了之後，還有一件事要做：刪除用於該 PR 的 Git 分支。如果不刪除的話"
"也不會怎麼樣，但刪除分支是個好習慣。我們會需要刪除兩次，一次是刪除本機的分"
"支，而另一次是刪除 GitHub 上的遠端分支。"

msgid "To delete our better Project Manager branch locally, use this command:"
msgstr "要在本機上刪除我們的 Better Project Manager 分支，可以使用這個指令："

msgid ""
"Alternatively, if the branch hadn't been merged yet and we wanted to delete "
"it anyway, instead of ``-d`` you would use ``-D``."
msgstr ""
"或者，如果該分支尚未被合併而確定要刪除的話，則應將 ``-d`` 改為 ``-D``。"

msgid "Next, to delete the remote branch on GitHub use this command:"
msgstr "接著，通過下列指令刪除 GitHub 上的遠端分支："

msgid ""
"You can also delete the remote branch from the GitHub PR itself, a button "
"should appear once it has been merged or closed."
msgstr ""
"也可以從 GitHub PR 中刪除遠端分支，當該 PR 合併或關閉後，頁面上應該會有一個按"
"鈕。"

msgid "Translation status"
msgstr "翻譯狀態"
