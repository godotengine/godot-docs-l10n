# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom modules in C++"
msgstr "以 C++ 語言自定模組"

msgid "Modules"
msgstr "模組"

msgid ""
"Godot allows extending the engine in a modular way. New modules can be "
"created and then enabled/disabled. This allows for adding new engine "
"functionality at every level without modifying the core, which can be split "
"for use and reuse in different modules."
msgstr ""
"在 Godot 中可以通過模組化的方法來擴充引擎。可以建立新的模組，並啟用或禁用該模"
"組。這樣一來便能在不修改核心的情況下，在任何一個層級上為引擎加上新功能，而這"
"些功能也能拆分為不同的模組來使用於復用。"

msgid ""
"Modules are located in the ``modules/`` subdirectory of the build system. By "
"default, dozens of modules are enabled, such as GDScript (which, yes, is not "
"part of the base engine), the Mono runtime, a regular expressions module, "
"and others. As many new modules as desired can be created and combined. The "
"SCons build system will take care of it transparently."
msgstr ""
"模組放在建置系統的 ``modules/`` 子資料夾中。Godot 預設啟用了數個模組，如 "
"GDScript (沒錯，GDScript 並非基礎引擎的一部分)、Mono 執行環境、正規表示式模"
"組…以及其他更多模組。可以建立任意數量的新模組並任意組合使用。SCons 會自動處"
"理。"

msgid "What for?"
msgstr "可以做什麼？"

msgid ""
"While it's recommended that most of a game be written in scripting (as it is "
"an enormous time saver), it's perfectly possible to use C++ instead. Adding "
"C++ modules can be useful in the following scenarios:"
msgstr ""
"雖然對於大多數的遊戲來說我們都建議通過腳本來撰寫 (因為能大幅節省時間)，但使"
"用 C++ 也完全沒問題。下列情況適合撰寫新的 C++ 模組："

msgid "Binding an external library to Godot (like PhysX, FMOD, etc)."
msgstr "將外部函式庫繫結到 Godot 中 (如 PhysX, FMOD…等)。"

msgid "Optimize critical parts of a game."
msgstr "最佳化遊戲中重要的部分。"

msgid "Adding new functionality to the engine and/or editor."
msgstr "為引擎與／或編輯器加上新功能。"

msgid "Porting an existing game to Godot."
msgstr "移植現有遊戲。"

msgid "Write a whole, new game in C++ because you can't live without C++."
msgstr "如果你沒有 C++ 活不下去的話，可以用 C++ 來撰寫一個完整的新遊戲。"

msgid "Creating a new module"
msgstr "建立新模組"

msgid ""
"Before creating a module, make sure to :ref:`download the source code of "
"Godot and compile it <toc-devel-compiling>`."
msgstr ""
"在建立模組之前，請先下載 Godot 的原始碼並進行編譯。在說明文件中有相關的教學。"

msgid ""
"To create a new module, the first step is creating a directory inside "
"``modules/``. If you want to maintain the module separately, you can "
"checkout a different VCS into modules and use it."
msgstr ""
"要建立新的模組，第一步就是在 ``modules/`` 中建立一個新資料夾。若想分開維護模"
"組的話，可以將不同的 VCS 簽出 (Checkout) 到 modules 內來使用。"

msgid ""
"The example module will be called \"summator\" (``godot/modules/summator``). "
"Inside we will create a summator class:"
msgstr ""
"實例模組的名字就叫“summator（加法器）”（ ``godot/modules/summator`` ）。我們"
"在裡面建立一個簡單的加法器類："

msgid "And then the cpp file."
msgstr "以及 cpp 檔。"

msgid ""
"Then, the new class needs to be registered somehow, so two more files need "
"to be created:"
msgstr "接著，我們需要用某種方式註冊這個新類別，所以需要建立另外兩個檔案："

msgid ""
"These files must be in the top-level folder of your module (next to your "
"``SCsub`` and ``config.py`` files) for the module to be registered properly."
msgstr ""
"這幾個檔案必須要放在模組的最上層目錄 (也就是 ``SCsub`` 與 ``config.py`` 檔的"
"旁邊)，這樣一來模組才能被正確註冊。"

msgid "These files should contain the following:"
msgstr "這幾個檔案的內容如下："

msgid ""
"Next, we need to create a ``SCsub`` file so the build system compiles this "
"module:"
msgstr "接下來，我們需要建立 ``SCsub`` 檔案，這樣建置系統才能編譯該模組："

msgid ""
"With multiple sources, you can also add each file individually to a Python "
"string list:"
msgstr "當有多個原始碼時，可以分別將各個檔案加到 Python 字串列表中："

msgid ""
"This allows for powerful possibilities using Python to construct the file "
"list using loops and logic statements. Look at some modules that ship with "
"Godot by default for examples."
msgstr ""
"通過這種做法，我們便可以通過 Python 的迴圈與邏輯陳述式來達成各種可能性。請參"
"考 Godot 預設附帶的模組為例。"

msgid ""
"To add include directories for the compiler to look at you can append it to "
"the environment's paths:"
msgstr ""
"要新增讓編譯器搜尋的 include 資料夾，可以將資料夾附加到編譯環境的路徑內："

msgid ""
"If you want to add custom compiler flags when building your module, you need "
"to clone ``env`` first, so it won't add those flags to whole Godot build "
"(which can cause errors). Example ``SCsub`` with custom flags:"
msgstr ""
"若要為模組新增自定編譯器旗標，則需要先複製 ``env`` 變數，以免修改到整個 "
"Godot 建置用的旗標 (進而導致發生錯誤)。下列為使用自定旗標的 ``SCsub`` 範例："

msgid ""
"And finally, the configuration file for the module, this is a Python script "
"that must be named ``config.py``:"
msgstr ""
"最後是模組的組態設定檔，這個設定檔是一個名為 ``config.py`` 的簡易 Python 腳"
"本："

msgid ""
"The module is asked if it's OK to build for the specific platform (in this "
"case, ``True`` means it will build for every platform)."
msgstr ""
"建置時會詢問是否能在各個特定的平台上進行建置 (在這個例子中， ``True`` 則代表"
"所有平台上都會進行建置)。"

msgid ""
"And that's it. Hope it was not too complex! Your module should look like "
"this:"
msgstr "就這樣。希望不會太複雜！最終模組應該會長這樣："

msgid ""
"You can then zip it and share the module with everyone else. When building "
"for every platform (instructions in the previous sections), your module will "
"be included."
msgstr ""
"接著可以將該模組打包為壓縮檔，然後將模組分享給其他人。當為所有平台編譯時 (有"
"關編譯的說明在前一段中)，該模組都會被包含在內。"

msgid ""
"There is a parameter limit of 5 in C++ modules for things such as "
"subclasses. This can be raised to 13 by including the header file ``core/"
"method_bind_ext.gen.inc``."
msgstr ""
"對於如子類別別 (Subclass) 的東西，C++ 模組內限制最多只能有 5 個參數。包含了標"
"頭檔 ``core/method_bind_ext.gen.inc`` 便可提升至 13 個。"

msgid "Using the module"
msgstr "使用模組"

msgid "You can now use your newly created module from any script:"
msgstr "現在，可以在任何腳本內使用剛才建立的模組了："

msgid "The output will be ``60``."
msgstr "輸出為 ``60`` 。"

msgid ""
"The previous Summator example is great for small, custom modules, but what "
"if you want to use a larger, external library? Refer to :ref:"
"`doc_binding_to_external_libraries` for details about binding to external "
"libraries."
msgstr ""
"剛才的 Summator 例子適合小型的自定模組，但如果想使用大型的外部函式庫呢？有關"
"繫結外部函式庫的詳細訊息，請參考 :ref:`doc_binding_to_external_libraries` 。"

msgid ""
"If your module is meant to be accessed from the running project (not just "
"from the editor), you must also recompile every export template you plan to "
"use, then specify the path to the custom template in each export preset. "
"Otherwise, you'll get errors when running the project as the module isn't "
"compiled in the export template. See the :ref:`Compiling <toc-devel-"
"compiling>` pages for more information."
msgstr ""
"若模組時要用來在執行中專案內存取的 (即不只是從編輯器中)，則必須要重新編譯每個"
"要使用到的匯出樣板，然後在各個匯出預設設定中指定自定樣板的路徑。否則在執行專"
"案的時候會產生錯誤，因為模組沒有被編譯到匯出樣板中。更多資訊請參考 :ref:`編"
"譯 <toc-devel-compiling>` 一頁。"

msgid "Compiling a module externally"
msgstr "從外部編譯模組"

msgid ""
"Compiling a module involves moving the module's sources directly under the "
"engine's ``modules/`` directory. While this is the most straightforward way "
"to compile a module, there are a couple of reasons as to why this might not "
"be a practical thing to do:"
msgstr ""
"編譯模組會需要將模組的原始碼直接移至 ``modules/`` 資料夾內。雖然這種方法是編"
"譯模組最直觀的方式，但有些情況下我們可能不想用這種方式："

msgid ""
"Having to manually copy modules sources every time you want to compile the "
"engine with or without the module, or taking additional steps needed to "
"manually disable a module during compilation with a build option similar to "
"``module_summator_enabled=no``. Creating symbolic links may also be a "
"solution, but you may additionally need to overcome OS restrictions like "
"needing the symbolic link privilege if doing this via script."
msgstr ""
"不管要不要編譯模組，每次編譯引擎的時候都需要手動複製模組的原始碼，甚至還需要"
"額外的步驟來手動在編譯時期通過如 ``module_summator_enabled=no`` 這樣的建置選"
"項來停用模組。建立符號連結可能是個解法，但如果要通過腳本實作的話，可能會需要"
"解決一些如符號連結權限這樣的作業系統限制。"

msgid ""
"Depending on whether you have to work with the engine's source code, the "
"module files added directly to ``modules/`` changes the working tree to the "
"point where using a VCS (like ``git``) proves to be cumbersome as you need "
"to make sure that only the engine-related code is committed by filtering "
"changes."
msgstr ""
"依據是否有要修改引擎的程式碼，當使用 VCS (如 ``git``) 時如果將模組檔案直接放"
"到 ``modules/`` 會更改到工作樹，進而造成需要篩選更改來只 Commit 引擎相關程式"
"碼的麻煩。"

msgid ""
"So if you feel like the independent structure of custom modules is needed, "
"lets take our \"summator\" module and move it to the engine's parent "
"directory:"
msgstr ""
"因此，如果想要在自定模組上使用獨立的架構，我們可以將「summator」模組移到引擎"
"上層的資料夾："

msgid ""
"Compile the engine with our module by providing ``custom_modules`` build "
"option which accepts a comma-separated list of directory paths containing "
"custom C++ modules, similar to the following:"
msgstr ""
"然後通過提供一個 ``custom_moduels`` 建置選項來將自定模組與引擎一起編譯。這個"
"建置選項允許傳入一組以逗號分隔的列表，其中為包含自定 C++ 模組的路徑，用法如"
"下："

msgid ""
"The build system shall detect all modules under the ``../modules`` directory "
"and compile them accordingly, including our \"summator\" module."
msgstr ""
"建置系統應該會自動偵測 ``../modules`` 資料夾下的所有模組然後進行編譯。其中，"
"包含了我們的「summator」模組。"

msgid ""
"Any path passed to ``custom_modules`` will be converted to an absolute path "
"internally as a way to distinguish between custom and built-in modules. It "
"means that things like generating module documentation may rely on a "
"specific path structure on your machine."
msgstr ""
"所有傳到 ``custom_modules`` 的路徑都會被自動轉換為絕對路徑，以區分自定與內建"
"模組。這表示，如產生模組說明文件等行為可能需要以來建置用機器上特定的路徑結"
"構。"

msgid ""
":ref:`Introduction to the buildsystem - Custom modules build option "
"<doc_buildsystem_custom_modules>`."
msgstr ""
":ref:`建置系統簡介 - 自定模組建置選項 <doc_buildsystem_custom_modules>` 。"

msgid "Customizing module types initialization"
msgstr "自訂展現形式"

msgid ""
"Modules can interact with other built-in engine classes during runtime and "
"even affect the way core types are initialized. So far, we've been using "
"``register_summator_types`` as a way to bring in module classes to be "
"available within the engine."
msgstr ""
"模組可以在運作時與其他內建引擎類別互動，甚至影響核心型別的初始化方式。到目前"
"為止，我們一直在使用“register_summator_types”作為引入模組類別以在引擎中可用的"
"方法。"

msgid ""
"A crude order of the engine setup can be summarized as a list of the "
"following type registration methods:"
msgstr "引擎設定的粗略順序可以概括為以下型別註冊方法的列表："

msgid ""
"Our ``Summator`` class is initialized during the ``register_module_types()`` "
"call. Imagine that we need to satisfy some common module run-time dependency "
"(like singletons), or allow us to override existing engine method callbacks "
"before they can be assigned by the engine itself. In that case, we want to "
"ensure that our module classes are registered *before* any other built-in "
"type."
msgstr ""
"我們的“Summator”類別在“register_module_types()”呼叫期間初始化。想像一下，我們"
"需要滿足一些常見的模組運作時依賴性（例如單例），或者允許我們覆蓋現有的引擎方"
"法回調，然後才能由引擎本身分配它們。在這種情況下，我們希望確保我們的模組類別"
"在任何其他內建型別*之前*註冊。"

msgid ""
"This is where we can define an optional ``preregister_summator_types()`` "
"method which will be called before anything else during the "
"``preregister_module_types()`` engine setup stage."
msgstr ""
"這是我們可以定義一個可選的“preregister_summator_types()”方法的地方，該方法將"
"在“preregister_module_types()”引擎設定階段期間在其他任何事情之前被呼叫。"

msgid ""
"We now need to add this method to ``register_types`` header and source files:"
msgstr "我們現在需要將此方法新增到「register_types」頭檔和來源檔案："

msgid ""
"Unlike other register methods, we have to explicitly define "
"``MODULE_SUMMATOR_HAS_PREREGISTER`` to let the build system know what "
"relevant method calls to include at compile time. The module's name has to "
"be converted to uppercase as well."
msgstr ""
"與其他註冊方法不同，我們必須明確定義“MODULE_SUMMATOR_HAS_PREREGISTER”，以使建"
"置系統知道在編譯時要包含哪些相關方法呼叫。模組的名稱也必須轉換為大寫。"

msgid "Improving the build system for development"
msgstr "為開發環境改進建置系統"

msgid ""
"This shared library support is not designed to support distributing a module "
"to other users without recompiling the engine. For that purpose, use a "
"GDExtension instead."
msgstr ""
"如果想要在不對引擎進行重新編譯的情況下，將模組分發給其他使用者，請使用 :ref:"
"`GDNative <doc_what_is_gdnative>`。此處的共用庫支援並不是為此設計的。"

msgid ""
"So far, we defined a clean SCsub that allows us to add the sources of our "
"new module as part of the Godot binary."
msgstr ""
"到目前為止，我們建立了一個用來將新模組的原始碼加到 Godot 二進位檔中的一個簡易"
"的 SCsub 檔案。"

msgid ""
"This static approach is fine when we want to build a release version of our "
"game, given we want all the modules in a single binary."
msgstr ""
"當我們只是要建置遊戲的釋出版本時，由於我們想將所有模組都放在單一二進位檔中，"
"這種靜態的方法沒什麼問題。"

msgid ""
"However, the trade-off is that every single change requires a full "
"recompilation of the game. Even though SCons is able to detect and recompile "
"only the file that was changed, finding such files and eventually linking "
"the final binary takes a long time."
msgstr ""
"但是，這種做法的代價就是每次改動時都需要重新編譯整個遊戲。就算 SCons 有辦法偵"
"測並只重新編譯有改動的部分，要找出這些檔案並將其連結到最終的二進位檔是一段耗"
"時且消耗資源的過程。"

msgid ""
"The solution to avoid such a cost is to build our own module as a shared "
"library that will be dynamically loaded when starting our game's binary."
msgstr ""
"要避免消耗這些資源的方法就是將我們的模組建置為會在開啟遊戲二進位檔時動態載入"
"的共用函式庫。"

msgid ""
"Once compiled, we should end up with a ``bin`` directory containing both the "
"``godot*`` binary and our ``libsummator*.so``. However given the .so is not "
"in a standard directory (like ``/usr/lib``), we have to help our binary find "
"it during runtime with the ``LD_LIBRARY_PATH`` environment variable:"
msgstr ""
"編譯後，就會出現同時包含了 ``godot*`` 與 ``libsummator*.so`` 的 ``bin`` 。"
"但，由於 .so 並不在標準資料夾內 (如 ``/usr/lib``) 中，因此我們必須要通過 "
"``LD_LIBRARY_PATH`` 環境變數來讓我們的二進位檔能在執行時期找到這些函式庫："

msgid ""
"You have to ``export`` the environment variable. Otherwise, you won't be "
"able to run your project from the editor."
msgstr "必須要 ``export`` 環境變數，否則將無法從編輯器來執行專案。"

msgid ""
"On top of that, it would be nice to be able to select whether to compile our "
"module as shared library (for development) or as a part of the Godot binary "
"(for release). To do that we can define a custom flag to be passed to SCons "
"using the ``ARGUMENT`` command:"
msgstr ""
"此外，也可以能夠選擇是要將我們的模組作為共用函式庫 (用於開發) 還是作為 Godot "
"二進位檔的一部分 (用於釋出) 也不錯。要這麼做，我們必須要通過 ``ARGUMENT`` 指"
"令定義一個會傳給 SCons 的自定旗標："

msgid ""
"Now by default ``scons`` command will build our module as part of Godot's "
"binary and as a shared library when passing ``summator_shared=yes``."
msgstr ""
"現在，預設的 ``scons`` 指令會將我們的模組作為 Godot 二進位檔的一部分來編譯，"
"而傳入 ``summator_shared=yes`` 時則會作為共用函式庫編譯。"

msgid ""
"Finally, you can even speed up the build further by explicitly specifying "
"your shared module as target in the SCons command:"
msgstr ""
"最後，我們還可以明確將共享函式庫指定為 SCons 指令的建構目標來進一步加速建構過"
"程："

msgid "Writing custom documentation"
msgstr "撰寫自定說明文件"

msgid ""
"Writing documentation may seem like a boring task, but it is highly "
"recommended to document your newly created module to make it easier for "
"users to benefit from it. Not to mention that the code you've written one "
"year ago may become indistinguishable from the code that was written by "
"someone else, so be kind to your future self!"
msgstr ""
"撰寫說明文件看起來可能是一件無聊的工作，但我們非常建議為新建立的模組撰寫說明"
"文件，這樣一來可以讓其他使用者更輕鬆地從模組中獲益。更不用提你自己一年前寫的"
"程式碼看起來可能跟別人寫的程式差不多，因此也請善待未來的自己吧！"

msgid "There are several steps in order to setup custom docs for the module:"
msgstr "要為模組設定自定說明文件有幾個步驟："

msgid ""
"Make a new directory in the root of the module. The directory name can be "
"anything, but we'll be using the ``doc_classes`` name throughout this "
"section."
msgstr ""
"在模組的根目錄建立新資料夾。該資料夾可任意明明，但我們會在本段落中使用 "
"``doc_classes`` 這個名稱。"

msgid "Now, we need to edit ``config.py``, add the following snippet:"
msgstr "接著，我們需要編輯 ``config.py`` ，加入下列程式碼片段："

msgid ""
"The ``get_doc_path()`` function is used by the build system to determine the "
"location of the docs. In this case, they will be located in the ``modules/"
"summator/doc_classes`` directory. If you don't define this, the doc path for "
"your module will fall back to the main ``doc/classes`` directory."
msgstr ""
"``get_doc_path()`` 函式是建置系統所使用的，用於判斷說明文件的位置。在這個例子"
"中，說明文件會放在 ``modules/summator/doc_classes`` 資料夾中。若沒有定義這個"
"函式，則模組說明文件的路徑會被遞補為主要的 ``doc/classes`` 資料夾。"

msgid ""
"The ``get_doc_classes()`` method is necessary for the build system to know "
"which registered classes belong to the module. You need to list all of your "
"classes here. The classes that you don't list will end up in the main ``doc/"
"classes`` directory."
msgstr ""
"必須要有 ``get_doc_classes()`` 方法，這樣一來建置系統才知道哪些已註冊的類別屬"
"於這個模組。在此處必須要列出所有的類別。沒有在此處定義的類別會遞補到主要的 "
"``doc/classes`` 資料夾中。"

msgid ""
"You can use Git to check if you have missed some of your classes by checking "
"the untracked files with ``git status``. For example::"
msgstr ""
"可以使用 ``git status`` 來通過 Git 檢查未簽出與未追蹤的檔案，來確認是否有遺漏"
"的類別。舉例來說："

msgid "Example output::"
msgstr "範例輸出："

msgid "Now we can generate the documentation:"
msgstr "接著，我們可以產生說明文件："

msgid ""
"We can do this via running Godot's doctool i.e. ``godot --doctool <path>``, "
"which will dump the engine API reference to the given ``<path>`` in XML "
"format."
msgstr ""
"可以通過執行 Godot 的 doctool 來產生，即 ``godot --doctool <路徑>`` ，該指令"
"會以 XML 格式傾印引擎的 API 參照文件到指定的 ``<路徑>`` 內。"

msgid ""
"In our case we'll point it to the root of the cloned repository. You can "
"point it to an another folder, and just copy over the files that you need."
msgstr ""
"在這個例子中，我們會將文件輸出至 Clone 的儲存庫根目錄內。在實際使用時可以指定"
"其他資料夾，然後依據需求複製這些檔案到所需的地方。"

msgid "Run command:"
msgstr "執行指令："

msgid ""
"Now if you go to the ``godot/modules/summator/doc_classes`` folder, you will "
"see that it contains a ``Summator.xml`` file, or any other classes, that you "
"referenced in your ``get_doc_classes`` function."
msgstr ""
"接著若開啟 ``godot/modules/summator/doc_classes`` 資料夾，就可以看到裡面有 "
"``Summator.xml`` 檔案，或在 ``get_doc_classes`` 函式中參照的其他類別。"

msgid ""
"Edit the file(s) following :ref:`doc_class_reference_primer` and recompile "
"the engine."
msgstr ""
"依據 :ref:`doc_updating_the_class_reference` 中的說明編輯這些檔案，然後重新編"
"譯引擎。"

msgid ""
"Once the compilation process is finished, the docs will become accessible "
"within the engine's built-in documentation system."
msgstr "完成編譯後，就可以從引擎內建的說明文件系統中存取這些文件。"

msgid ""
"In order to keep documentation up-to-date, all you'll have to do is simply "
"modify one of the XML files and recompile the engine from now on."
msgstr ""
"之後若要維持這些文件為最新版本，只需要修改其中的 XML 檔，然後重新編譯引擎。"

msgid ""
"If you change your module's API, you can also re-extract the docs, they will "
"contain the things that you previously added. Of course if you point it to "
"your godot folder, make sure you don't lose work by extracting older docs "
"from an older engine build on top of the newer ones."
msgstr ""
"當修改了模組 API 時，則也需要重新截取說明文件。截取出來的說明文件會包含之前新"
"增過的內容。當然，若將說明文件指向到 Godot 資料夾時，請確保不要從舊的引擎建置"
"截取到新的引擎建置上，以免遺失改動。"

msgid ""
"Note that if you don't have write access rights to your supplied ``<path>``, "
"you might encounter an error similar to the following:"
msgstr "如果沒有所提供 ``<路徑>`` 的寫入權限，則可能會遇到類似下列錯誤："

msgid "Writing custom unit tests"
msgstr "撰寫自定說明文件"

msgid ""
"It's possible to write self-contained unit tests as part of a C++ module. If "
"you are not familiar with the unit testing process in Godot yet, please "
"refer to :ref:`doc_unit_testing`."
msgstr ""
"可以將獨立的單元測試編寫為 C++ 模組的一部分。如果您還不熟悉 Godot 中的單元測"
"試流程，請參閱 doc_unit_testing。"

msgid "The procedure is the following:"
msgstr "有下列事項需注意："

msgid "Create a new directory named ``tests/`` under your module's root:"
msgstr "在模組的根目錄下建立一個名為「tests/」的新目錄："

msgid ""
"Create a new test suite: ``test_summator.h``. The header must be prefixed "
"with ``test_`` so that the build system can collect it and include it as "
"part of the ``tests/test_main.cpp`` where the tests are run."
msgstr ""
"建立一個新的測試套件：「test_summator.h」。標頭必須以“test_”為前綴，以便建置"
"系統可以收集它並將其包含在執行測試的“tests/test_main.cpp”中。"

msgid "Write some test cases. Here's an example:"
msgstr "編寫一些測試案例。這是一個例子："

msgid ""
"Compile the engine with ``scons tests=yes``, and run the tests with the "
"following command:"
msgstr "使用“sconstests=yes”編譯引擎，並使用以下命令執行測試："

msgid "You should see the passing assertions now."
msgstr "現在你就應該會看到出現了群組。"

msgid "Adding custom editor icons"
msgstr "新增自定編輯器圖示"

msgid ""
"Similarly to how you can write self-contained documentation within a module, "
"you can also create your own custom icons for classes to appear in the "
"editor."
msgstr ""
"與在模組中撰寫自封式說明文件類似，也可以為類別建立會出現在編輯器中的自定圖"
"示。"

msgid ""
"For the actual process of creating editor icons to be integrated within the "
"engine, please refer to :ref:`doc_editor_icons` first."
msgstr ""
"有關建立整合進引擎之編輯器圖示的實際過程，請先參考 :ref:`doc_editor_icons` 。"

msgid "Once you've created your icon(s), proceed with the following steps:"
msgstr "建立好圖示後，請執行下列步驟："

msgid ""
"Make a new directory in the root of the module named ``icons``. This is the "
"default path for the engine to look for module's editor icons."
msgstr ""
"在模組的根目錄建立一個名為 ``icons`` 的資料夾。該資料夾是引擎尋找模組編輯器圖"
"示的預設路徑。"

msgid ""
"Move your newly created ``svg`` icons (optimized or not) into that folder."
msgstr "將新建立的 ``svg`` 圖示 (無論是否經過最佳化) 移至該資料夾內。"

msgid ""
"Recompile the engine and run the editor. Now the icon(s) will appear in "
"editor's interface where appropriate."
msgstr "重新編譯引擎並執行編輯器。接著，該圖示會顯示在編輯器界面中適當的位置。"

msgid ""
"If you'd like to store your icons somewhere else within your module, add the "
"following code snippet to ``config.py`` to override the default path:"
msgstr ""
"如果想將圖示儲存在模組中其他的位置，請將下列程式碼片段新增至 ``config.py`` 以"
"複寫預設路徑："

msgid "Summing up"
msgstr "總結"

msgid "Remember to:"
msgstr "請記住："

msgid "Use ``GDCLASS`` macro for inheritance, so Godot can wrap it."
msgstr "使用 ``GDCLASS`` 來處理繼承，這樣 Godot 才能對其進行封裝"

msgid ""
"Use ``_bind_methods`` to bind your functions to scripting, and to allow them "
"to work as callbacks for signals."
msgstr ""
"使用 ``_bind_methods`` 來將函式繫結至腳本，這樣才能讓這些函式擁有回呼與訊號的"
"功能。"

msgid ""
"**Avoid multiple inheritance for classes exposed to Godot**, as ``GDCLASS`` "
"doesn't support this. You can still use multiple inheritance in your own "
"classes as long as they're not exposed to Godot's scripting API."
msgstr ""
"**避免暴露給 Godot 的類別的多重繼承**，因為「GDCLASS」不支援這一點。您仍然可"
"以在自己的類別中使用多重繼承，只要它們不暴露於 Godot 的腳本 API。"

msgid ""
"But this is not all, depending what you do, you will be greeted with some "
"(hopefully positive) surprises."
msgstr ""
"但依據使用情況，還有其他要注意的點。在實際製作模組的過程還會遇到許多驚喜 (希"
"望是正面的驚喜)。"

msgid ""
"If you inherit from :ref:`class_Node` (or any derived node type, such as "
"Sprite2D), your new class will appear in the editor, in the inheritance tree "
"in the \"Add Node\" dialog."
msgstr ""
"若從 :ref:`class_Node` (以及其他衍生 Node 型別，如 Sprite) 繼承，則新類別會出"
"現在編輯器的「新增節點」對話框中的繼承樹中。"

msgid ""
"If you inherit from :ref:`class_Resource`, it will appear in the resource "
"list, and all the exposed properties can be serialized when saved/loaded."
msgstr ""
"若從 :ref:`class_Resource` 繼承，則類別會出現在資源列表中，且所有暴露的屬性都"
"能在保存與載入時被序列化。"

msgid ""
"By this same logic, you can extend the Editor and almost any area of the "
"engine."
msgstr "通過相同的方法，也可以擴充編輯器以及引擎幾乎所有的部分。"

msgid "Translation status"
msgstr "翻譯狀態"
