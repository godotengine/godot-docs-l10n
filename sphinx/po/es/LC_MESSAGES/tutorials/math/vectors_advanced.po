# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced vector math"
msgstr "Matemática vectorial avanzada"

msgid "Planes"
msgstr "Planos"

msgid ""
"The dot product has another interesting property with unit vectors. Imagine "
"that perpendicular to that vector (and through the origin) passes a plane. "
"Planes divide the entire space into positive (over the plane) and negative "
"(under the plane), and (contrary to popular belief) you can also use their "
"math in 2D:"
msgstr ""
"El producto punto tiene otra propiedad interesante con los vectores "
"unitarios. Imaginemos que perpendicular a ese vector (y a través del origen) "
"pasa un plano. Los planos dividen todo el espacio en positivo (sobre el "
"plano) y negativo (debajo del plano), y (contrariamente a la creencia "
"popular) también puedes usar sus matemáticas en 2D:"

msgid ""
"Unit vectors that are perpendicular to a surface (so, they describe the "
"orientation of the surface) are called **unit normal vectors**. Though, "
"usually they are just abbreviated as *normals*. Normals appear in planes, 3D "
"geometry (to determine where each face or vertex is siding), etc. A "
"**normal** *is* a **unit vector**, but it's called *normal* because of its "
"usage. (Just like we call (0,0) the Origin!)."
msgstr ""
"Los vectores unitarios que son perpendiculares a una superficie (por lo "
"tanto, describen la orientación de la superficie) se denominan **vectores "
"unitarios normales**. Sin embargo, por lo general son sólo abreviados como "
"*normales*. Las normales aparecen en planos, geometría 3D (para determinar "
"dónde está el revestimiento de cada cara o vértice), etc. Un **normal** *es* "
"un **vector unitario**, pero se le llama *normal* debido a su uso. (¡Igual "
"que llamamos (0,0) al Origen!)."

#, fuzzy
msgid ""
"The plane passes by the origin and the surface of it is perpendicular to the "
"unit vector (or *normal*). The side towards the vector points to is the "
"positive half-space, while the other side is the negative half-space. In 3D "
"this is exactly the same, except that the plane is an infinite surface "
"(imagine an infinite, flat sheet of paper that you can orient and is pinned "
"to the origin) instead of a line."
msgstr ""
"Es tan simple como parece. El plano pasa por el origen y su superficie es "
"perpendicular al vector unitario (o *normal*). El lado que apunta hacia el "
"vector es el semiespacio positivo, mientras que el otro lado es el "
"semiespacio negativo. En 3D esto es exactamente lo mismo, excepto que el "
"plano es una superficie infinita (imagina una hoja de papel plana e infinita "
"que puedes orientar y que está anclada al origen) en lugar de una línea."

msgid "Distance to plane"
msgstr "Distancia del plano"

msgid ""
"Now that it's clear what a plane is, let's go back to the dot product. The "
"dot product between a **unit vector** and any **point in space** (yes, this "
"time we do dot product between vector and position), returns the **distance "
"from the point to the plane**:"
msgstr ""
"Ahora que está claro lo que es un plano, volvamos al producto punto. El "
"producto punto entre un **vector unitario** y cualquier **punto en el "
"espacio** (sí, esta vez hacemos producto de puntos entre vector y posición), "
"devuelve la **distancia entre el punto y el plano**:"

msgid ""
"But not just the absolute distance, if the point is in the negative half "
"space the distance will be negative, too:"
msgstr ""
"Pero no sólo la distancia absoluta, si el punto está en el semiespacio "
"negativo, la distancia también será negativa:"

msgid "This allows us to tell which side of the plane a point is."
msgstr "Esto nos permite saber de qué lado del plano está un punto."

msgid "Away from the origin"
msgstr "Alejado del origen"

msgid ""
"I know what you are thinking! So far this is nice, but *real* planes are "
"everywhere in space, not only passing through the origin. You want real "
"*plane* action and you want it *now*."
msgstr ""
"¡Sé lo que estás pensando! Hasta ahora esto es agradable, pero los planos "
"*reales* están por todas partes en el espacio, no sólo pasando a través del "
"origen. Quieres acción en un *plano* real y la quieres *ahora*."

msgid ""
"Remember that planes not only split space in two, but they also have "
"*polarity*. This means that it is possible to have perfectly overlapping "
"planes, but their negative and positive half-spaces are swapped."
msgstr ""
"Recuerda que los planos no sólo dividen el espacio en dos, sino que también "
"tienen *polaridad*. Esto significa que es posible tener planos perfectamente "
"superpuestos, pero sus polos negativos y positivos están intercambiados."

msgid ""
"With this in mind, let's describe a full plane as a **normal** *N* and a "
"**distance from the origin** scalar *D*. Thus, our plane is represented by N "
"and D. For example:"
msgstr ""
"Con esto en mente, describamos un plano completo como un **normal** *N* y "
"una **distancia desde el origen** escalar *D*. Así, nuestro plano está "
"representado por N y D. Por ejemplo:"

msgid ""
"For 3D math, Godot provides a :ref:`Plane <class_Plane>` built-in type that "
"handles this."
msgstr ""
"Para matemáticas 3D, Godot proporciona un tipo integrado :ref:`Plano "
"<class_Plane>` que maneja esto."

msgid ""
"Basically, N and D can represent any plane in space, be it for 2D or 3D "
"(depending on the amount of dimensions of N) and the math is the same for "
"both. It's the same as before, but D is the distance from the origin to the "
"plane, travelling in N direction. As an example, imagine you want to reach a "
"point in the plane, you will just do:"
msgstr ""
"Básicamente, N y D pueden representar cualquier plano en el espacio, ya sea "
"para 2D o 3D (dependiendo de la cantidad de dimensiones de N) y la "
"matemática es la misma para ambos. Es igual que antes, pero D es la "
"distancia desde el origen hasta el plano, viajando en dirección N. Por "
"ejemplo, imagina que quieres llegar a un punto en el plano, simplemente lo "
"harás:"

msgid ""
"This will stretch (resize) the normal vector and make it touch the plane. "
"This math might seem confusing, but it's actually much simpler than it "
"seems. If we want to tell, again, the distance from the point to the plane, "
"we do the same but adjusting for distance:"
msgstr ""
"Esto estirará (redimensionará) el vector normal y lo hará tocar el plano. "
"Esta matemática puede parecer confusa, pero en realidad es mucho más simple "
"de lo que parece. Si queremos decir, de nuevo, la distancia desde el punto "
"al plano, hacemos lo mismo pero ajustando la distancia:"

msgid "The same thing, using a built-in function:"
msgstr "Lo mismo, usando una función integrada:"

msgid "This will, again, return either a positive or negative distance."
msgstr "Esto, de nuevo, devolverá una distancia positiva o negativa."

msgid ""
"Flipping the polarity of the plane can be done by negating both N and D. "
"This will result in a plane in the same position, but with inverted negative "
"and positive half spaces:"
msgstr ""
"Invertir la polaridad del plano se puede hacer negando tanto N como D. Esto "
"dará como resultado un plano en la misma posición, pero con semiespacios "
"negativos y positivos invertidos:"

#, fuzzy
msgid ""
"Godot also implements this operator in :ref:`Plane <class_Plane>`. So, using "
"the format below will work as expected:"
msgstr ""
"Por supuesto, Godot también implementa este operador en :ref:`Plano "
"<class_Plane>`, haciendo lo mismo:"

#, fuzzy
msgid ""
"So, remember, the plane's main practical use is that we can calculate the "
"distance to it. So, when is it useful to calculate the distance from a point "
"to a plane? Let's see some examples."
msgstr ""
"Así que, recuerda, un plano es precisamente eso y su principal uso práctico "
"es calcular la distancia hasta él. Entonces, ¿por qué es útil calcular la "
"distancia desde un punto a un plano? Es extremadamente útil! Veamos algunos "
"ejemplos simples..."

msgid "Constructing a plane in 2D"
msgstr "Construyendo un plano en 2D"

msgid ""
"Planes clearly don't come out of nowhere, so they must be built. "
"Constructing them in 2D is easy, this can be done from either a normal (unit "
"vector) and a point, or from two points in space."
msgstr ""
"Los planos claramente no salen de la nada, así que deben ser construidos. "
"Construirlos en 2D es fácil, esto se puede hacer desde un vector normal "
"(vector unitario) y un punto, o desde dos puntos en el espacio."

#, fuzzy
msgid ""
"In the case of a normal and a point, most of the work is done, as the normal "
"is already computed, so calculate D from the dot product of the normal and "
"the point."
msgstr ""
"En el caso de un normal y un punto, la mayor parte del trabajo está "
"realizado, ya que el normal ya está calculado, así que sólo calcula D a "
"partir del producto de punto del normal y el punto."

msgid ""
"For two points in space, there are actually two planes that pass through "
"them, sharing the same space but with normal pointing to the opposite "
"directions. To compute the normal from the two points, the direction vector "
"must be obtained first, and then it needs to be rotated 90° degrees to "
"either side:"
msgstr ""
"Para dos puntos en el espacio, en realidad hay dos planos que pasan a través "
"de ellos, compartiendo el mismo espacio pero con el normal apuntando a las "
"direcciones opuestas. Para calcular la normal a partir de los dos puntos, "
"primero se debe obtener el vector de dirección, y luego se debe girar 90° a "
"cada lado:"

#, fuzzy
msgid ""
"The rest is the same as the previous example. Either point_a or point_b will "
"work, as they are in the same plane:"
msgstr ""
"El resto es igual que en el ejemplo anterior, ya sea el point_a o el point_b "
"funcionarán ya que están en el mismo plano:"

#, fuzzy
msgid ""
"Doing the same in 3D is a little more complex and is explained further down."
msgstr ""
"Hacer lo mismo en 3D es un poco más complejo y se explicará más adelante."

msgid "Some examples of planes"
msgstr "Algunos ejemplos de planos"

#, fuzzy
msgid ""
"Here is an example of what planes are useful for. Imagine you have a `convex "
"<https://www.mathsisfun.com/definitions/convex.html>`__ polygon. For "
"example, a rectangle, a trapezoid, a triangle, or just any polygon where no "
"faces bend inwards."
msgstr ""
"He aquí un ejemplo sencillo de para qué sirven los planos. Imagina que "
"tienes un polígono `convexo <https://www.mathsisfun.com/definitions/convex."
"html>`__. Por ejemplo, un rectángulo, un trapezoide, un triángulo o "
"cualquier polígono en el que no haya caras que se doblen hacia adentro."

msgid ""
"For every segment of the polygon, we compute the plane that passes by that "
"segment. Once we have the list of planes, we can do neat things, for example "
"checking if a point is inside the polygon."
msgstr ""
"Para cada segmento del polígono, calculamos el plano que pasa por ese "
"segmento. Una vez que tenemos la lista de planos, podemos hacer las cosas de "
"forma ordenada, por ejemplo comprobar si un punto está dentro del polígono."

msgid ""
"We go through all planes, if we can find a plane where the distance to the "
"point is positive, then the point is outside the polygon. If we can't, then "
"the point is inside."
msgstr ""
"Pasamos por todos los planos, si podemos encontrar un plano donde la "
"distancia al punto es positiva, entonces el punto está fuera del polígono. "
"Si no podemos, entonces el punto está dentro."

msgid "Code should be something like this:"
msgstr "El código debería ser algo así:"

msgid ""
"Pretty cool, huh? But this gets much better! With a little more effort, "
"similar logic will let us know when two convex polygons are overlapping too. "
"This is called the Separating Axis Theorem (or SAT) and most physics engines "
"use this to detect collision."
msgstr ""
"Bastante genial ¿verdad? ¡Pero esto se pone mucho mejor! Con un poco más de "
"esfuerzo, una lógica similar nos hará saber cuando dos polígonos convexos se "
"superponen también. Esto se llama Teorema del Eje Separador (o SAT) y la "
"mayoría de los motores de física lo utilizan para detectar colisiones."

msgid ""
"With a point, just checking if a plane returns a positive distance is enough "
"to tell if the point is outside. With another polygon, we must find a plane "
"where *all* *the* *other* *polygon* *points* return a positive distance to "
"it. This check is performed with the planes of A against the points of B, "
"and then with the planes of B against the points of A:"
msgstr ""
"Con un punto, basta con comprobar si un plano devuelve una distancia "
"positiva para saber si el punto está fuera. Con otro polígono, debemos "
"encontrar un plano donde *todos los demás puntos del polígono* devuelvan una "
"distancia positiva al mismo. Esta comprobación se realiza con los planos de "
"A contra los puntos de B, y luego con los planos de B contra los puntos de A:"

msgid ""
"As you can see, planes are quite useful, and this is the tip of the iceberg. "
"You might be wondering what happens with non convex polygons. This is "
"usually just handled by splitting the concave polygon into smaller convex "
"polygons, or using a technique such as BSP (which is not used much nowadays)."
msgstr ""
"Como pueden ver, los planos son muy útiles, y esta es la punta del iceberg. "
"Te estarás preguntando qué pasa con los polígonos no convexos. Esto es "
"usualmente manejado dividiendo el polígono cóncavo en polígonos convexos más "
"pequeños, o usando una técnica como BSP (la cual no se usa mucho hoy en día)."

msgid "Collision detection in 3D"
msgstr "Detección de colisiones en 3D"

msgid ""
"This is another bonus bit, a reward for being patient and keeping up with "
"this long tutorial. Here is another piece of wisdom. This might not be "
"something with a direct use case (Godot already does collision detection "
"pretty well) but it's used by almost all physics engines and collision "
"detection libraries :)"
msgstr ""
"Esta es otra píldora de información, una recompensa por ser paciente y "
"seguir el ritmo de este largo tutorial. Aquí hay otro pedazo de sabiduría. "
"Esto podría no ser algo con un caso de uso directo (Godot ya hace detección "
"de colisiones bastante bien) pero es usado por casi todos los motores de "
"física y librerías de detección de colisiones :)"

msgid ""
"Remember that converting a convex shape in 2D to an array of 2D planes was "
"useful for collision detection? You could detect if a point was inside any "
"convex shape, or if two 2D convex shapes were overlapping."
msgstr ""
"¿Recuerdas que convertir una forma convexa en 2D en un array de planos 2D "
"era útil para la detección de colisiones? Podrías detectar si un punto "
"estaba dentro de cualquier forma convexa, o si dos formas convexas 2D se "
"solapaban."

msgid ""
"Well, this works in 3D too, if two 3D polyhedral shapes are colliding, you "
"won't be able to find a separating plane. If a separating plane is found, "
"then the shapes are definitely not colliding."
msgstr ""
"Bueno, esto también funciona en 3D, si dos formas poliédricas 3D chocan, no "
"podrás encontrar un plano de separación. Si se encuentra un plano de "
"separación, entonces las formas definitivamente no están colisionando."

msgid ""
"To refresh a bit a separating plane means that all vertices of polygon A are "
"in one side of the plane, and all vertices of polygon B are in the other "
"side. This plane is always one of the face-planes of either polygon A or "
"polygon B."
msgstr ""
"Para refrescar un poco un plano de separación significa que todos los "
"vértices del polígono A están en un lado del plano, y todos los vértices del "
"polígono B están en el otro lado. Este plano es siempre uno de los planos "
"frontales del polígono A o del polígono B."

msgid ""
"In 3D though, there is a problem to this approach, because it is possible "
"that, in some cases a separating plane can't be found. This is an example of "
"such situation:"
msgstr ""
"En 3D, sin embargo, hay un problema con este enfoque, porque es posible que, "
"en algunos casos, no se pueda encontrar un plano de separación. Este es un "
"ejemplo de tal situación:"

msgid ""
"To avoid it, some extra planes need to be tested as separators, these planes "
"are the cross product between the edges of polygon A and the edges of "
"polygon B"
msgstr ""
"Para evitarlo, algunos planos adicionales necesitan ser evaluados como "
"separadores, estos planos son el producto vectorial entre los bordes del "
"polígono A y los bordes del polígono B"

msgid "So the final algorithm is something like:"
msgstr "Así que el algoritmo final es algo así como:"

msgid "More information"
msgstr "Más información"

msgid ""
"For more information on using vector math in Godot, see the following "
"article:"
msgstr ""
"Para más información sobre el uso de la matemática vectorial en Godot, "
"consulta el siguiente artículo:"

msgid ":ref:`doc_matrices_and_transforms`"
msgstr ":ref:`doc_matrices_and_transforms`"

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video series \"Essence of Linear Algebra\": https://www.youtube."
"com/watch?v=fNk_zzaMoSs&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab"
msgstr ""
"Si desea una explicación adicional, debería ver la excelente serie de videos "
"de 3Blue1Brown \"Essence of Linear Algebra\": https://www.youtube.com/watch?"
"v=fNk_zzaMoSs&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab"

msgid "Translation status"
msgstr "Estado de traducción"
