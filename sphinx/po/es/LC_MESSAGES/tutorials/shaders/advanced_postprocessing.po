# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced post-processing"
msgstr "Post procesamiento avanzado"

msgid "Introduction"
msgstr "Introducción"

msgid ""
"This tutorial describes an advanced method for post-processing in Godot. In "
"particular, it will explain how to write a post-processing shader that uses "
"the depth buffer. You should already be familiar with post-processing "
"generally and, in particular, with the methods outlined in the :ref:`custom "
"post-processing tutorial <doc_custom_postprocessing>`."
msgstr ""
"Este tutorial describe un método avanzado para el post-procesamiento en "
"Godot. En particular, explicará cómo escribir un shader de post-"
"procesamiento que utilice el buffer de profundidad. Ya deberías estar "
"familiarizado con el post-procesamiento en general y, en particular, con los "
"métodos descritos en el :ref:`tutorial de post-procesamiento personalizado "
"<doc_custom_postprocessing>`."

msgid ""
"In the previous post-processing tutorial, we rendered the scene to a :ref:"
"`Viewport <class_Viewport>` and then rendered the Viewport in a :ref:"
"`ViewportContainer <class_ViewportContainer>` to the main scene. One "
"limitation of this method is that we could not access the depth buffer "
"because the depth buffer is only available in spatial shaders and Viewports "
"do not maintain depth information."
msgstr ""
"En el anterior tutorial de post-procesamiento, renderizamos la escena a :ref:"
"`Viewport <class_Viewport>` y luego renderizamos el Viewport en un :ref:"
"`ViewportContainer <class_ViewportContainer>` a la escena principal. Una "
"limitación de este método es que no podemos acceder al buffer de profundidad "
"porque el buffer de profundidad sólo está disponible en los shaders "
"espaciales y los Viewports no mantienen la información de profundidad."

msgid "Full screen quad"
msgstr "Quad de pantalla completa"

msgid ""
"In the :ref:`custom post-processing tutorial <doc_custom_postprocessing>`, "
"we covered how to use a Viewport to make custom post-processing effects. "
"There are two main drawbacks of using a Viewport:"
msgstr ""
"En el tutorial :ref:`custom post-processing <doc_custom_postprocessing>`, "
"cubrimos cómo usar un Viewport para hacer efectos de post-procesamiento "
"personalizados. Hay dos inconvenientes principales de usar un Viewport:"

msgid "The depth buffer cannot be accessed"
msgstr "No se puede acceder al buffer de profundidad"

msgid "The effect of the post-processing shader is not visible in the editor"
msgstr "El efecto del shader de post-procesamiento no es visible en el editor"

msgid ""
"To get around the limitation on using the depth buffer, use a :ref:"
"`MeshInstance <class_MeshInstance>` with a :ref:`QuadMesh <class_QuadMesh>` "
"primitive. This allows us to use a spatial shader and to access the depth "
"texture of the scene. Next, use a vertex shader to make the quad cover the "
"screen at all times so that the post-processing effect will be applied at "
"all times, including in the editor."
msgstr ""
"Para evitar la limitación del uso del buffer de profundidad, usa un :ref:"
"`MeshInstance <class_MeshInstance>` con un :ref:`QuadMesh <class_QuadMesh>` "
"primitivo. Esto nos permite usar un shader espacial y acceder a la textura "
"de profundidad de la escena. A continuación, utilizar un vertex shader para "
"hacer que el quad cubra la pantalla en todo momento para que el efecto de "
"post-procesamiento se aplique en todo momento, incluso en el editor."

msgid ""
"First, create a new MeshInstance and set its mesh to a QuadMesh. This "
"creates a quad centered at position ``(0, 0, 0)`` with a width and height of "
"``1``. Set the width and height to ``2``. Right now, the quad occupies a "
"position in world space at the origin; however, we want it to move with the "
"camera so that it always covers the entire screen. To do this, we will "
"bypass the coordinate transforms that translate the vertex positions through "
"the difference coordinate spaces and treat the vertices as if they were "
"already in clip space."
msgstr ""
"Primero, crear una nueva MeshInstance y establecer su malla en una QuadMesh. "
"Esto crea un quad centrado en la posición ``(0, 0, 0)`` con una anchura y "
"altura de ``1``. Poner el ancho y la altura en ``2``. Ahora mismo, el quah "
"ocupa una posición en el espacio mundial en el origen; sin embargo, queremos "
"que se mueva con la cámara para que siempre cubra toda la pantalla. Para "
"ello, pasaremos por alto las transformaciones de coordenadas que traducen "
"las posiciones de los vértices a través de los espacios de coordenadas de "
"diferencia y trataremos los vértices como si ya estuvieran en el espacio "
"recortado."

msgid ""
"The vertex shader expects coordinates to be output in clip space, which are "
"coordinates ranging from ``-1`` at the left and bottom of the screen to "
"``1`` at the top and right of the screen. This is why the QuadMesh needs to "
"have height and width of ``2``. Godot handles the transform from model to "
"view space to clip space behind the scenes, so we need to nullify the "
"effects of Godot's transformations. We do this by setting the ``POSITION`` "
"built-in to our desired position. ``POSITION`` bypasses the built-in "
"transformations and sets the vertex position directly."
msgstr ""
"El sombreador de vértices espera que se emitan coordenadas en el espacio de "
"los clips, que son coordenadas que van desde ``1`` a la izquierda y la parte "
"inferior de la pantalla hasta ``1`` en la parte superior y la derecha de la "
"pantalla. Por eso la malla cuádruple necesita tener una altura y un ancho de "
"``2``. Godot maneja la transformación de modelo a espacio de vista para "
"recortar el espacio detrás de las escenas, por lo que necesitamos anular los "
"efectos de las transformaciones de Godot. Lo hacemos poniendo la "
"``POSITION`` incorporada en nuestra posición deseada. La ``POSITION`` evita "
"las transformaciones incorporadas y establece la posición del vértice "
"directamente."

msgid ""
"Even with this vertex shader, the quad keeps disappearing. This is due to "
"frustum culling, which is done on the CPU. Frustum culling uses the camera "
"matrix and the AABBs of Meshes to determine if the Mesh will be visible "
"*before* passing it to the GPU. The CPU has no knowledge of what we are "
"doing with the vertices, so it assumes the coordinates specified refer to "
"world positions, not clip space positions, which results in Godot culling "
"the quad when we turn away from the center of the scene. In order to keep "
"the quad from being culled, there are a few options:"
msgstr ""
"Incluso con este shader de vértices, el quad sigue desapareciendo. Esto se "
"debe a la recolección de frustum, que se hace en la CPU. El Frustum culling "
"utiliza la matriz de la cámara y el AABB de las mallas para determinar si la "
"malla será visible *antes* de pasarla a la GPU. La CPU no tiene conocimiento "
"de lo que estamos haciendo con los vértices, por lo que asume que las "
"coordenadas especificadas se refieren a las posiciones del mundo, no a las "
"posiciones del espacio de recorte, lo que resulta en la selección de Godot "
"en el quad cuando nos alejamos del centro de la escena. Para evitar que el "
"quad sea eliminado, hay algunas opciones:"

msgid ""
"Add the QuadMesh as a child to the camera, so the camera is always pointed "
"at it"
msgstr ""
"Añade la QuadMesh como un hijo a la cámara, para que la cámara siempre esté "
"apuntando a ella"

msgid ""
"Set the Geometry property ``extra_cull_margin`` as large as possible in the "
"QuadMesh"
msgstr ""
"Establecer la propiedad de Geometría \"extra_cull_margin\" tan grande como "
"sea posible en el QuadMesh"

msgid ""
"The second option ensures that the quad is visible in the editor, while the "
"first option guarantees that it will still be visible even if the camera "
"moves outside the cull margin. You can also use both options."
msgstr ""
"La segunda opción asegura que el quad sea visible en el editor, mientras que "
"la primera garantiza que seguirá siendo visible incluso si la cámara se "
"mueve fuera del margen de selección. También puedes usar ambas opciones."

msgid "Depth texture"
msgstr "Depth texture"

msgid ""
"To read from the depth texture, perform a texture lookup using ``texture()`` "
"and the uniform variable ``DEPTH_TEXTURE``."
msgstr ""
"Para leer de la textura de profundidad, realice una búsqueda de textura "
"usando ``texture()`` y la variable uniforme ``DEPTH_TEXTURE``."

msgid ""
"Similar to accessing the screen texture, accessing the depth texture is only "
"possible when reading from the current viewport. The depth texture cannot be "
"accessed from another viewport to which you have rendered."
msgstr ""
"De manera similar al acceso a la textura de la pantalla, el acceso a la "
"textura de profundidad sólo es posible cuando se lee desde el puerto de "
"visualización actual. No se puede acceder a la textura de profundidad desde "
"otra ventana de visualización en la que se haya renderizado."

msgid ""
"The values returned by ``DEPTH_TEXTURE`` are between ``0`` and ``1`` and are "
"nonlinear. When displaying depth directly from the ``DEPTH_TEXTURE``, "
"everything will look almost white unless it is very close. This is because "
"the depth buffer stores objects closer to the camera using more bits than "
"those further, so most of the detail in depth buffer is found close to the "
"camera. In order to make the depth value align with world or model "
"coordinates, we need to linearize the value. When we apply the projection "
"matrix to the vertex position, the z value is made nonlinear, so to "
"linearize it, we multiply it by the inverse of the projection matrix, which "
"in Godot, is accessible with the variable ``INV_PROJECTION_MATRIX``."
msgstr ""
"Los valores devueltos por ``DEPTH_TEXTURE`` están entre ``0`` y ``1`` y son "
"nolineales. Cuando se muestra la profundidad directamente desde la "
"``DEPTH_TEXTURE``, todo se verá casi blanco a menos que esté muy cerca. Esto "
"se debe a que la memoria intermedia de profundidad almacena los objetos más "
"cercanos a la cámara usando más bits que los que están más lejos, por lo que "
"la mayor parte de los detalles de la memoria intermedia de profundidad se "
"encuentran cerca de la cámara. Para hacer que el valor de profundidad se "
"alinee con las coordenadas del mundo o del modelo, necesitamos linealizar el "
"valor. Cuando aplicamos la matriz de proyección a la posición del vértice, "
"el valor z se hace no lineal, así que para linealizarlo, lo multiplicamos "
"por el inverso de la matriz de proyección, que en Godot, es accesible con la "
"variable ``INV_PROJECTION_MATRIX``."

msgid ""
"Firstly, take the screen space coordinates and transform them into "
"normalized device coordinates (NDC). NDC run from ``-1`` to ``1``, similar "
"to clip space coordinates. Reconstruct the NDC using ``SCREEN_UV`` for the "
"``x`` and ``y`` axis, and the depth value for ``z``."
msgstr ""
"En primer lugar, tomar las coordenadas del espacio de la pantalla y "
"transformarlas en coordenadas normalizadas del dispositivo (NDC). Las NDC "
"van de ``-1`` a ``1``, similares a las coordenadas del espacio de recorte. "
"Reconstruye el NDC usando ``SCREEN_UV`` para el eje ``x`` y ``y``, y el "
"valor de profundidad para ``z``."

msgid ""
"Convert NDC to view space by multiplying the NDC by "
"``INV_PROJECTION_MATRIX``. Recall that view space gives positions relative "
"to the camera, so the ``z`` value will give us the distance to the point."
msgstr ""
"En primer lugar, tomar las coordenadas del espacio de la pantalla y "
"transformarlas en coordenadas normalizadas del dispositivo (NDC). Las NDC "
"van de ``-1`` a ``1``, similares a las coordenadas del espacio de recorte. "
"Reconstruye el NDC usando ``SCREEN_UV`` para el eje ``x`` y ``y``, y el "
"valor de profundidad para ``z``."

msgid ""
"Because the camera is facing the negative ``z`` direction, the position will "
"have a negative ``z`` value. In order to get a usable depth value, we have "
"to negate ``view.z``."
msgstr ""
"Debido a que la cámara está orientada hacia la dirección ``z`` negativa, la "
"posición tendrá un valor ``z`` negativo. Para obtener un valor de "
"profundidad utilizable, tenemos que negar ``view.z``."

msgid ""
"The world position can be constructed from the depth buffer using the "
"following code. Note that the ``CAMERA_MATRIX`` is needed to transform the "
"position from view space into world space, so it needs to be passed to the "
"fragment shader with a varying."
msgstr ""
"La posición mundial puede construirse a partir del buffer de profundidad "
"usando el siguiente código. Tenga en cuenta que la ``CAMERA_MATRIX`` es "
"necesaria para transformar la posición del espacio visual en el espacio "
"mundial, por lo que debe ser pasada al shader de fragmentos con una "
"variación."

msgid "An optimization"
msgstr "Una optimización"

msgid ""
"You can benefit from using a single large triangle rather than using a full "
"screen quad. The reason for this is explained `here <https://michaldrobot."
"com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_. However, the "
"benefit is quite small and only beneficial when running especially complex "
"fragment shaders."
msgstr ""
"Puedes beneficiarte de usar un solo triángulo grande en lugar de usar un "
"cuadrángulo de pantalla completa. La razón de esto se explica `aquí <https://"
"michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_. "
"Sin embargo, el beneficio es bastante pequeño y sólo beneficioso cuando se "
"ejecutan shaders de fragmentos especialmente complejos."

msgid ""
"Set the Mesh in the MeshInstance to an :ref:`ArrayMesh <class_ArrayMesh>`. "
"An ArrayMesh is a tool that allows you to easily construct a Mesh from "
"Arrays for vertices, normals, colors, etc."
msgstr ""
"Coloca una malla dentro de MeshInstance :ref:`ArrayMesh <clase_ArrayMesh>`. "
"Un ArrayMesh es una herramienta que permite construir fácilmente un Array de "
"Mallas para vértices, normales, colores, etc."

msgid "Now, attach a script to the MeshInstance and use the following code:"
msgstr "Ahora anexa un script a la MeshInstance y usa el siguiente código:"

msgid ""
"The triangle is specified in normalized device coordinates. Recall, NDC run "
"from ``-1`` to ``1`` in both the ``x`` and ``y`` directions. This makes the "
"screen ``2`` units wide and ``2`` units tall. In order to cover the entire "
"screen with a single triangle, use a triangle that is ``4`` units wide and "
"``4`` units tall, double its height and width."
msgstr ""
"El triángulo se especifica en las coordenadas normalizadas del dispositivo. "
"Recuerda, NDC va de ``-1`` a ``1`` en ambas direcciones, ``x`` y ``y``. Esto "
"hace que la pantalla tenga ``2`` unidades de ancho y ``2`` unidades de alto. "
"Para cubrir toda la pantalla con un solo triángulo, usa un triángulo de 4 "
"unidades de ancho y 4 unidades de alto, el doble de su altura y anchura."

msgid ""
"Assign the same vertex shader from above and everything should look exactly "
"the same."
msgstr ""
"Asigne el mismo shader de vértice desde arriba y todo debería verse "
"exactamente igual."

msgid ""
"The one drawback to using an ArrayMesh over using a QuadMesh is that the "
"ArrayMesh is not visible in the editor because the triangle is not "
"constructed until the scene is run. To get around that, construct a single "
"triangle Mesh in a modelling program and use that in the MeshInstance "
"instead."
msgstr ""
"El único inconveniente de usar un ArrayMesh en vez de usar un QuadMesh es "
"que el ArrayMesh no es visible en el editor porque el triángulo no se "
"construye hasta que se ejecuta la escena. Para evitarlo, construye una malla "
"de un solo triángulo en un programa de modelado y úsala en MeshInstance."

msgid "Translation status"
msgstr "Estado de traducción"
