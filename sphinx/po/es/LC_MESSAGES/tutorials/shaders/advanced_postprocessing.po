# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced post-processing"
msgstr "Post procesamiento avanzado"

msgid "Introduction"
msgstr "Introducción"

msgid ""
"This tutorial describes an advanced method for post-processing in Godot. In "
"particular, it will explain how to write a post-processing shader that uses "
"the depth buffer. You should already be familiar with post-processing "
"generally and, in particular, with the methods outlined in the :ref:`custom "
"post-processing tutorial <doc_custom_postprocessing>`."
msgstr ""
"Este tutorial describe un método avanzado para el post-procesamiento en "
"Godot. En particular, explicará cómo escribir un shader de post-"
"procesamiento que utilice el buffer de profundidad. Ya deberías estar "
"familiarizado con el post-procesamiento en general y, en particular, con los "
"métodos descritos en el :ref:`tutorial de post-procesamiento personalizado "
"<doc_custom_postprocessing>`."

#, fuzzy
msgid ""
"In the previous post-processing tutorial, we rendered the scene to a :ref:"
"`Viewport <class_Viewport>` and then rendered the Viewport in a :ref:"
"`SubViewportContainer <class_SubViewportContainer>` to the main scene. One "
"limitation of this method is that we could not access the depth buffer "
"because the depth buffer is only available in shaders and Viewports do not "
"maintain depth information."
msgstr ""
"En el anterior tutorial de post-procesamiento, renderizamos la escena a :ref:"
"`Viewport <class_Viewport>` y luego renderizamos el Viewport en un :ref:"
"`ViewportContainer <class_ViewportContainer>` a la escena principal. Una "
"limitación de este método es que no podemos acceder al buffer de profundidad "
"porque el buffer de profundidad sólo está disponible en los shaders "
"espaciales y los Viewports no mantienen la información de profundidad."

msgid "Full screen quad"
msgstr "Quad de pantalla completa"

msgid ""
"In the :ref:`custom post-processing tutorial <doc_custom_postprocessing>`, "
"we covered how to use a Viewport to make custom post-processing effects. "
"There are two main drawbacks of using a Viewport:"
msgstr ""
"En el tutorial :ref:`custom post-processing <doc_custom_postprocessing>`, "
"cubrimos cómo usar un Viewport para hacer efectos de post-procesamiento "
"personalizados. Hay dos inconvenientes principales de usar un Viewport:"

msgid "The depth buffer cannot be accessed"
msgstr "No se puede acceder al buffer de profundidad"

msgid "The effect of the post-processing shader is not visible in the editor"
msgstr "El efecto del shader de post-procesamiento no es visible en el editor"

#, fuzzy
msgid ""
"To get around the limitation on using the depth buffer, use a :ref:"
"`MeshInstance3D <class_MeshInstance3D>` with a :ref:`QuadMesh "
"<class_QuadMesh>` primitive. This allows us to use a shader and to access "
"the depth texture of the scene. Next, use a vertex shader to make the quad "
"cover the screen at all times so that the post-processing effect will be "
"applied at all times, including in the editor."
msgstr ""
"Para evitar la limitación del uso del buffer de profundidad, usa un :ref:"
"`MeshInstance <class_MeshInstance>` con un :ref:`QuadMesh <class_QuadMesh>` "
"primitivo. Esto nos permite usar un shader espacial y acceder a la textura "
"de profundidad de la escena. A continuación, utilizar un vertex shader para "
"hacer que el quad cubra la pantalla en todo momento para que el efecto de "
"post-procesamiento se aplique en todo momento, incluso en el editor."

#, fuzzy
msgid ""
"First, create a new MeshInstance3D and set its mesh to a QuadMesh. This "
"creates a quad centered at position ``(0, 0, 0)`` with a width and height of "
"``1``. Set the width and height to ``2`` and enable **Flip Faces**. Right "
"now, the quad occupies a position in world space at the origin. However, we "
"want it to move with the camera so that it always covers the entire screen. "
"To do this, we will bypass the coordinate transforms that translate the "
"vertex positions through the difference coordinate spaces and treat the "
"vertices as if they were already in clip space."
msgstr ""
"Primero, crear una nueva MeshInstance y establecer su malla en una QuadMesh. "
"Esto crea un quad centrado en la posición ``(0, 0, 0)`` con una anchura y "
"altura de ``1``. Poner el ancho y la altura en ``2``. Ahora mismo, el quah "
"ocupa una posición en el espacio mundial en el origen; sin embargo, queremos "
"que se mueva con la cámara para que siempre cubra toda la pantalla. Para "
"ello, pasaremos por alto las transformaciones de coordenadas que traducen "
"las posiciones de los vértices a través de los espacios de coordenadas de "
"diferencia y trataremos los vértices como si ya estuvieran en el espacio "
"recortado."

msgid ""
"The vertex shader expects coordinates to be output in clip space, which are "
"coordinates ranging from ``-1`` at the left and bottom of the screen to "
"``1`` at the top and right of the screen. This is why the QuadMesh needs to "
"have height and width of ``2``. Godot handles the transform from model to "
"view space to clip space behind the scenes, so we need to nullify the "
"effects of Godot's transformations. We do this by setting the ``POSITION`` "
"built-in to our desired position. ``POSITION`` bypasses the built-in "
"transformations and sets the vertex position directly."
msgstr ""
"El sombreador de vértices espera que se emitan coordenadas en el espacio de "
"los clips, que son coordenadas que van desde ``1`` a la izquierda y la parte "
"inferior de la pantalla hasta ``1`` en la parte superior y la derecha de la "
"pantalla. Por eso la malla cuádruple necesita tener una altura y un ancho de "
"``2``. Godot maneja la transformación de modelo a espacio de vista para "
"recortar el espacio detrás de las escenas, por lo que necesitamos anular los "
"efectos de las transformaciones de Godot. Lo hacemos poniendo la "
"``POSITION`` incorporada en nuestra posición deseada. La ``POSITION`` evita "
"las transformaciones incorporadas y establece la posición del vértice "
"directamente."

msgid ""
"Even with this vertex shader, the quad keeps disappearing. This is due to "
"frustum culling, which is done on the CPU. Frustum culling uses the camera "
"matrix and the AABBs of Meshes to determine if the Mesh will be visible "
"*before* passing it to the GPU. The CPU has no knowledge of what we are "
"doing with the vertices, so it assumes the coordinates specified refer to "
"world positions, not clip space positions, which results in Godot culling "
"the quad when we turn away from the center of the scene. In order to keep "
"the quad from being culled, there are a few options:"
msgstr ""
"Incluso con este shader de vértices, el quad sigue desapareciendo. Esto se "
"debe a la recolección de frustum, que se hace en la CPU. El Frustum culling "
"utiliza la matriz de la cámara y el AABB de las mallas para determinar si la "
"malla será visible *antes* de pasarla a la GPU. La CPU no tiene conocimiento "
"de lo que estamos haciendo con los vértices, por lo que asume que las "
"coordenadas especificadas se refieren a las posiciones del mundo, no a las "
"posiciones del espacio de recorte, lo que resulta en la selección de Godot "
"en el quad cuando nos alejamos del centro de la escena. Para evitar que el "
"quad sea eliminado, hay algunas opciones:"

msgid ""
"Add the QuadMesh as a child to the camera, so the camera is always pointed "
"at it"
msgstr ""
"Añade la QuadMesh como un hijo a la cámara, para que la cámara siempre esté "
"apuntando a ella"

msgid ""
"Set the Geometry property ``extra_cull_margin`` as large as possible in the "
"QuadMesh"
msgstr ""
"Establecer la propiedad de Geometría \"extra_cull_margin\" tan grande como "
"sea posible en el QuadMesh"

msgid ""
"The second option ensures that the quad is visible in the editor, while the "
"first option guarantees that it will still be visible even if the camera "
"moves outside the cull margin. You can also use both options."
msgstr ""
"La segunda opción asegura que el quad sea visible en el editor, mientras que "
"la primera garantiza que seguirá siendo visible incluso si la cámara se "
"mueve fuera del margen de selección. También puedes usar ambas opciones."

msgid "Depth texture"
msgstr "Textura de profundidad (depth)"

msgid ""
"To read from the depth texture, we first need to create a texture uniform "
"set to the depth buffer by using ``hint_depth_texture``."
msgstr ""

msgid ""
"Once defined, the depth texture can be read with the ``texture()`` function."
msgstr ""

msgid ""
"Similar to accessing the screen texture, accessing the depth texture is only "
"possible when reading from the current viewport. The depth texture cannot be "
"accessed from another viewport to which you have rendered."
msgstr ""
"De manera similar al acceso a la textura de la pantalla, el acceso a la "
"textura de profundidad sólo es posible cuando se lee desde el puerto de "
"visualización actual. No se puede acceder a la textura de profundidad desde "
"otra ventana de visualización en la que se haya renderizado."

#, fuzzy
msgid ""
"The values returned by ``depth_texture`` are between ``0.0`` and ``1.0`` and "
"are nonlinear. When displaying depth directly from the ``depth_texture``, "
"everything will look almost white unless it is very close. This is because "
"the depth buffer stores objects closer to the camera using more bits than "
"those further, so most of the detail in depth buffer is found close to the "
"camera. In order to make the depth value align with world or model "
"coordinates, we need to linearize the value. When we apply the projection "
"matrix to the vertex position, the z value is made nonlinear, so to "
"linearize it, we multiply it by the inverse of the projection matrix, which "
"in Godot, is accessible with the variable ``INV_PROJECTION_MATRIX``."
msgstr ""
"Los valores devueltos por ``DEPTH_TEXTURE`` están entre ``0`` y ``1`` y son "
"nolineales. Cuando se muestra la profundidad directamente desde la "
"``DEPTH_TEXTURE``, todo se verá casi blanco a menos que esté muy cerca. Esto "
"se debe a que la memoria intermedia de profundidad almacena los objetos más "
"cercanos a la cámara usando más bits que los que están más lejos, por lo que "
"la mayor parte de los detalles de la memoria intermedia de profundidad se "
"encuentran cerca de la cámara. Para hacer que el valor de profundidad se "
"alinee con las coordenadas del mundo o del modelo, necesitamos linealizar el "
"valor. Cuando aplicamos la matriz de proyección a la posición del vértice, "
"el valor z se hace no lineal, así que para linealizarlo, lo multiplicamos "
"por el inverso de la matriz de proyección, que en Godot, es accesible con la "
"variable ``INV_PROJECTION_MATRIX``."

#, fuzzy
msgid ""
"Firstly, take the screen space coordinates and transform them into "
"normalized device coordinates (NDC). NDC run ``-1.0`` to ``1.0`` in ``x`` "
"and ``y`` directions and from ``0.0`` to ``1.0`` in the ``z`` direction when "
"using the Vulkan backend. Reconstruct the NDC using ``SCREEN_UV`` for the "
"``x`` and ``y`` axis, and the depth value for ``z``."
msgstr ""
"En primer lugar, tomar las coordenadas del espacio de la pantalla y "
"transformarlas en coordenadas normalizadas del dispositivo (NDC). Las NDC "
"van de ``-1`` a ``1``, similares a las coordenadas del espacio de recorte. "
"Reconstruye el NDC usando ``SCREEN_UV`` para el eje ``x`` y ``y``, y el "
"valor de profundidad para ``z``."

msgid ""
"This tutorial assumes the use of the Vulkan renderer, which uses NDCs with a "
"Z-range of ``[0.0, 1.0]``. In contrast, OpenGL uses NDCs with a Z-range of "
"``[-1.0, 1.0]``."
msgstr ""

msgid ""
"Convert NDC to view space by multiplying the NDC by "
"``INV_PROJECTION_MATRIX``. Recall that view space gives positions relative "
"to the camera, so the ``z`` value will give us the distance to the point."
msgstr ""
"En primer lugar, tomar las coordenadas del espacio de la pantalla y "
"transformarlas en coordenadas normalizadas del dispositivo (NDC). Las NDC "
"van de ``-1`` a ``1``, similares a las coordenadas del espacio de recorte. "
"Reconstruye el NDC usando ``SCREEN_UV`` para el eje ``x`` y ``y``, y el "
"valor de profundidad para ``z``."

msgid ""
"Because the camera is facing the negative ``z`` direction, the position will "
"have a negative ``z`` value. In order to get a usable depth value, we have "
"to negate ``view.z``."
msgstr ""
"Debido a que la cámara está orientada hacia la dirección ``z`` negativa, la "
"posición tendrá un valor ``z`` negativo. Para obtener un valor de "
"profundidad utilizable, tenemos que negar ``view.z``."

#, fuzzy
msgid ""
"The world position can be constructed from the depth buffer using the "
"following code. Note that the ``INV_VIEW_MATRIX`` is needed to transform the "
"position from view space into world space, so it needs to be passed to the "
"fragment shader with a varying."
msgstr ""
"La posición mundial puede construirse a partir del buffer de profundidad "
"usando el siguiente código. Tenga en cuenta que la ``CAMERA_MATRIX`` es "
"necesaria para transformar la posición del espacio visual en el espacio "
"mundial, por lo que debe ser pasada al shader de fragmentos con una "
"variación."

msgid "An optimization"
msgstr "Una optimización"

msgid ""
"You can benefit from using a single large triangle rather than using a full "
"screen quad. The reason for this is explained `here <https://michaldrobot."
"com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_. However, the "
"benefit is quite small and only beneficial when running especially complex "
"fragment shaders."
msgstr ""
"Puedes beneficiarte de usar un solo triángulo grande en lugar de usar un "
"cuadrángulo de pantalla completa. La razón de esto se explica `aquí <https://"
"michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_. "
"Sin embargo, el beneficio es bastante pequeño y sólo beneficioso cuando se "
"ejecutan shaders de fragmentos especialmente complejos."

#, fuzzy
msgid ""
"Set the Mesh in the MeshInstance3D to an :ref:`ArrayMesh <class_ArrayMesh>`. "
"An ArrayMesh is a tool that allows you to easily construct a Mesh from "
"Arrays for vertices, normals, colors, etc."
msgstr ""
"Coloca una malla dentro de MeshInstance :ref:`ArrayMesh <clase_ArrayMesh>`. "
"Un ArrayMesh es una herramienta que permite construir fácilmente un Array de "
"Mallas para vértices, normales, colores, etc."

#, fuzzy
msgid "Now, attach a script to the MeshInstance3D and use the following code:"
msgstr "Ahora anexa un script a la MeshInstance y usa el siguiente código:"

#, fuzzy
msgid ""
"The triangle is specified in normalized device coordinates. Recall, NDC run "
"from ``-1.0`` to ``1.0`` in both the ``x`` and ``y`` directions. This makes "
"the screen ``2`` units wide and ``2`` units tall. In order to cover the "
"entire screen with a single triangle, use a triangle that is ``4`` units "
"wide and ``4`` units tall, double its height and width."
msgstr ""
"El triángulo se especifica en las coordenadas normalizadas del dispositivo. "
"Recuerda, NDC va de ``-1`` a ``1`` en ambas direcciones, ``x`` y ``y``. Esto "
"hace que la pantalla tenga ``2`` unidades de ancho y ``2`` unidades de alto. "
"Para cubrir toda la pantalla con un solo triángulo, usa un triángulo de 4 "
"unidades de ancho y 4 unidades de alto, el doble de su altura y anchura."

msgid ""
"Assign the same vertex shader from above and everything should look exactly "
"the same."
msgstr ""
"Asigne el mismo shader de vértice desde arriba y todo debería verse "
"exactamente igual."

#, fuzzy
msgid ""
"The one drawback to using an ArrayMesh over using a QuadMesh is that the "
"ArrayMesh is not visible in the editor because the triangle is not "
"constructed until the scene is run. To get around that, construct a single "
"triangle Mesh in a modeling program and use that in the MeshInstance3D "
"instead."
msgstr ""
"El único inconveniente de usar un ArrayMesh en vez de usar un QuadMesh es "
"que el ArrayMesh no es visible en el editor porque el triángulo no se "
"construye hasta que se ejecuta la escena. Para evitarlo, construye una malla "
"de un solo triángulo en un programa de modelado y úsala en MeshInstance."

msgid "Translation status"
msgstr "Estado de traducción"
