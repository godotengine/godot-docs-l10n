# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Screen-reading shaders"
msgstr "Shaders de lectura de pantalla"

msgid "Introduction"
msgstr "Introducción"

msgid ""
"It is often desired to make a shader that reads from the same screen to "
"which it's writing. 3D APIs, such as OpenGL or DirectX, make this very "
"difficult because of internal hardware limitations. GPUs are extremely "
"parallel, so reading and writing causes all sorts of cache and coherency "
"problems. As a result, not even the most modern hardware supports this "
"properly."
msgstr ""
"A menudo se desea crear un shader que lea desde la misma pantalla en la que "
"está escribiendo. Las API 3D, como OpenGL o DirectX, hacen esto muy difícil "
"debido a las limitaciones internas del hardware. Las GPU son extremadamente "
"paralelas, por lo que leer y escribir causa problemas de caché y coherencia. "
"Como resultado, ni siquiera el hardware más moderno admite esto "
"correctamente."

msgid ""
"The workaround is to make a copy of the screen, or a part of the screen, to "
"a back-buffer and then read from it while drawing. Godot provides a few "
"tools that make this process easy."
msgstr ""
"La solución alternativa es hacer una copia de la pantalla, o una parte de la "
"pantalla, en un búfer de respaldo y luego leer de él mientras dibuja. Godot "
"proporciona algunas herramientas que facilitan este proceso."

msgid "SCREEN_TEXTURE built-in texture"
msgstr "SCREEN_TEXTURE textura incorporada"

msgid ""
"Godot :ref:`doc_shading_language` has a special texture, ``SCREEN_TEXTURE`` "
"(and ``DEPTH_TEXTURE`` for depth, in the case of 3D). It takes as argument "
"the UV of the screen and returns a vec3 RGB with the color. A special built-"
"in varying: SCREEN_UV can be used to obtain the UV for the current fragment. "
"As a result, this simple canvas_item fragment shader:"
msgstr ""
"Godot :ref:`doc_shading_language` tiene una textura especial, "
"``SCREEN_TEXTURE`` (y ``DEPTH_TEXTURE`` para la profundidad, en el caso de "
"3D). Toma como argumento el UV de la pantalla y devuelve un vec3 RGB con el "
"color. Una variación especial incorporada: SCREEN_UV puede ser usado para "
"obtener el UV del fragmento actual. Como resultado, este simple shader de "
"fragmentos de canvas_item:"

msgid "results in an invisible object, because it just shows what lies behind."
msgstr "resulta en un objeto invisible, porque sólo muestra lo que hay detrás."

msgid ""
"The reason why textureLod must be used is because, when Godot copies back a "
"chunk of the screen, it also does an efficient separatable gaussian blur to "
"its mipmaps."
msgstr ""
"La razón por la que debe usarse textureLod es porque, cuando Godot copia un "
"trozo de la pantalla, también hace un eficiente desenfoque gaussiano "
"separable en sus mipmaps."

msgid ""
"This allows for not only reading from the screen, but reading from it with "
"different amounts of blur at no cost."
msgstr ""
"Esto permite no sólo leer de la pantalla, sino leer de ella con diferentes "
"cantidades de borrosidad sin costo alguno."

msgid ""
"Mipmaps are not generated in GLES2 due to poor performance and compatibility "
"with older devices."
msgstr ""
"Los Mipmaps no se generan en GLES2 debido al pobre rendimiento y la "
"compatibilidad con los dispositivos más antiguos."

msgid "SCREEN_TEXTURE example"
msgstr "ejemplo de SCREEN_TEXTURE"

msgid ""
"``SCREEN_TEXTURE`` can be used for many things. There is a special demo for "
"*Screen Space Shaders*, that you can download to see and learn. One example "
"is a simple shader to adjust brightness, contrast and saturation:"
msgstr ""
"``SCREEN_TEXTURE`` puede ser usada para muchas cosas. Hay una demo especial "
"para *Screen Spade Shader*, que puedes descargar para ver y aprender. Un "
"ejemplo es un simple shader para ajustar el brillo, el contraste y la "
"saturación:"

msgid "Behind the scenes"
msgstr "Entre bastidores"

msgid ""
"While this seems magical, it's not. In 2D, the ``SCREEN_TEXTURE`` built-in, "
"when first found in a node that is about to be drawn, does a full-screen "
"copy to a back-buffer. Subsequent nodes that use it in shaders will not have "
"the screen copied for them, because this ends up being inefficient. In 3D, "
"the screen is copied after the opaque geometry pass, but before the "
"transparent geometry pass, so transparent objects will not be captured in "
"the ``SCREEN_TEXTURE``."
msgstr ""
"Aunque esto parece mágico, no lo es. En 2D, la ``SCREEN_TEXTURE`` "
"incorporada, cuando se encuentra por primera vez en un nodo que está a punto "
"de ser dibujado, hace una copia a pantalla completa a un búfer trasero. Los "
"nodos subsiguientes que lo usan en los shaders no tendrán la pantalla "
"copiada para ellos, porque esto termina siendo ineficiente. En 3D, la "
"pantalla se copia después de la pasada de geometría opaca, pero antes de la "
"pasada de geometría transparente, por lo que los objetos transparentes no "
"serán capturados en la ``SCREEN_TEXTURE``."

msgid ""
"As a result, in 2D, if shaders that use ``SCREEN_TEXTURE`` overlap, the "
"second one will not use the result of the first one, resulting in unexpected "
"visuals:"
msgstr ""
"Como resultado, en 2D, si los shaders que usan ``SCREEN_TEXTURE`` se "
"superponen, el segundo no usará el resultado del primero, resultando en "
"visuales inesperados:"

msgid ""
"In the above image, the second sphere (top right) is using the same source "
"for ``SCREEN_TEXTURE`` as the first one below, so the first one "
"\"disappears\", or is not visible."
msgstr ""
"En la imagen de arriba, la segunda esfera (arriba a la derecha) está usando "
"la misma fuente de ``SCREEN_TEXTURE`` que la primera de abajo, por lo que la "
"primera \"desaparece\", o no es visible."

msgid ""
"In 2D, this can be corrected via the :ref:`BackBufferCopy "
"<class_BackBufferCopy>` node, which can be instantiated between both "
"spheres. BackBufferCopy can work by either specifying a screen region or the "
"whole screen:"
msgstr ""
"En 2D, esto puede ser corregido a través del nodo :ref:`BackBufferCopy "
"<class_BackBufferCopy>`, que puede ser instanciado entre ambas esferas. "
"BackBufferCopy puede funcionar especificando una región de la pantalla o la "
"pantalla completa:"

msgid "With correct back-buffer copying, the two spheres blend correctly:"
msgstr ""
"Con la copia correcta de la memoria intermedia, las dos esferas se mezclan "
"correctamente:"

msgid ""
"In 3D, there is less flexibility to solve this particular issue because the "
"``SCREEN_TEXTURE`` is only captured once. Be careful when using "
"``SCREEN_TEXTURE`` in 3D as it won't capture transparent objects and may "
"capture some opaque objects that are in front of the object."
msgstr ""
"En 3D, hay menos flexibilidad para resolver este problema en particular "
"porque la ``SCREEN_TEXTURE`` sólo se captura una vez. Tenga cuidado al usar "
"\"SCREEN_TEXTURE\" en 3D, ya que no capturará objetos transparentes y puede "
"capturar algunos objetos opacos que están en frente del objeto."

msgid ""
"You can reproduce the back-buffer logic in 3D by creating a :ref:`Viewport "
"<class_Viewport>` with a camera in the same position as your object, and "
"then use the :ref:`Viewport's <class_Viewport>` texture instead of "
"``SCREEN_TEXTURE``."
msgstr ""
"Puedes reproducir la lógica del búfer trasero en 3D creando un :ref:"
"`Viewport <class_Viewport>` con una cámara en la misma posición que tu "
"objeto, y luego usar la textura :ref:`Viewport's <class_Viewport>` en lugar "
"de ``SCREEN_TEXTURE``."

msgid "Back-buffer logic"
msgstr "Lógica del Back-buffer"

msgid ""
"So, to make it clearer, here's how the backbuffer copying logic works in "
"Godot:"
msgstr ""
"Así que, para dejarlo más claro, así es como funciona la lógica de copia del "
"backbuffer en Godot:"

msgid ""
"If a node uses the ``SCREEN_TEXTURE``, the entire screen is copied to the "
"back buffer before drawing that node. This only happens the first time; "
"subsequent nodes do not trigger this."
msgstr ""
"Si un nodo utiliza la ``SCREEN_TEXTURE``, la pantalla entera se copia en el "
"buffer de atrás antes de dibujar ese nodo. Esto sólo ocurre la primera vez; "
"los nodos subsiguientes no lo activan."

msgid ""
"If a BackBufferCopy node was processed before the situation in the point "
"above (even if ``SCREEN_TEXTURE`` was not used), the behavior described in "
"the point above does not happen. In other words, automatic copying of the "
"entire screen only happens if ``SCREEN_TEXTURE`` is used in a node for the "
"first time and no BackBufferCopy node (not disabled) was found before in "
"tree-order."
msgstr ""
"Si un nodo BackBufferCopy fue procesado antes de la situación en el punto "
"anterior (incluso si no se usó ``SCREEN_TEXTURE``), el comportamiento "
"descrito en el punto anterior no ocurre. En otras palabras, el copiado "
"automático de toda la pantalla sólo ocurre si ``SCREEN_TEXTURE`` se usa en "
"un nodo por primera vez y no se encontró antes un nodo BackBufferCopy (no "
"deshabilitado) en el orden del árbol."

msgid ""
"BackBufferCopy can copy either the entire screen or a region. If set to only "
"a region (not the whole screen) and your shader uses pixels not in the "
"region copied, the result of that read is undefined (most likely garbage "
"from previous frames). In other words, it's possible to use BackBufferCopy "
"to copy back a region of the screen and then use ``SCREEN_TEXTURE`` on a "
"different region. Avoid this behavior!"
msgstr ""
"BackBufferCopy puede copiar la pantalla completa o una región. Si se "
"configura sólo una región (no toda la pantalla) y el shader utiliza píxeles "
"que no están en la región copiada, el resultado de esa lectura es indefinido "
"(lo más probable es que sea basura de fotogramas). En otras palabras, es "
"posible usar BackBufferCopy para copiar una región de la pantalla y luego "
"usar \"SCREEN_TEXTURE\" en una región diferente. ¡Evita este comportamiento!"

msgid "DEPTH_TEXTURE"
msgstr "DEPTH_TEXTURE"

msgid ""
"For 3D shaders, it's also possible to access the screen depth buffer. For "
"this, the ``DEPTH_TEXTURE`` built-in is used. This texture is not linear; it "
"must be converted via the inverse projection matrix."
msgstr ""
"Para los shaders 3D, también es posible acceder al búfer de profundidad de "
"la pantalla. Para esto, se utiliza el valor incorporado ``DEPTH_TEXTURE``. "
"Esta textura no es lineal; debe ser convertida a través de la matriz de "
"proyección inversa."

msgid ""
"The following code retrieves the 3D position below the pixel being drawn:"
msgstr ""
"El siguiente código recupera la posición 3D debajo del píxel que se está "
"dibujando:"

msgid "Translation status"
msgstr "Estado de traducción"
