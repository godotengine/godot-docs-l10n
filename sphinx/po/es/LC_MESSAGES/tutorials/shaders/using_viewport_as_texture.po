# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using a Viewport as a texture"
msgstr "Usar un Viewport como textura"

msgid "Introduction"
msgstr "Introducción"

msgid ""
"This tutorial will introduce you to using the :ref:`Viewport "
"<class_Viewport>` as a texture that can be applied to 3D objects. In order "
"to do so, it will walk you through the process of making a procedural planet "
"like the one below:"
msgstr ""
"Este tutorial te introducirá en el uso del :ref:`Viewport <class_Viewport>` "
"como una textura que puede ser aplicada a objetos 3D. Para ello, te guiará a "
"través del proceso de creación de un planeta procedimental como el que se "
"muestra a continuación:"

msgid ""
"This tutorial does not cover how to code a dynamic atmosphere like the one "
"this planet has."
msgstr ""
"Este tutorial no cubre cómo codificar una atmósfera dinámica como la que "
"tiene este planeta."

#, fuzzy
msgid ""
"This tutorial assumes you are familiar with how to set up a basic scene "
"including: a :ref:`Camera3D <class_Camera3D>`, a :ref:`light source "
"<class_OmniLight3D>`, a :ref:`MeshInstance3D <class_MeshInstance3D>` with a :"
"ref:`Primitive Mesh <class_PrimitiveMesh>`, and applying a :ref:"
"`StandardMaterial3D <class_StandardMaterial3D>` to the mesh. The focus will "
"be on using the :ref:`Viewport <class_Viewport>` to dynamically create "
"textures that can be applied to the mesh."
msgstr ""
"Este tutorial asume que usted está familiarizado con la forma de configurar "
"una escena básica, incluyendo: un :ref:`Camera <class_Camera>`, un :ref:"
"`light source <class_OmniLight>`, un :ref:`Mesh Instance "
"<class_MeshInstance>` con un :ref:`Primitive Mesh <class_PrimitiveMesh>`, y "
"la aplicación de un :ref:`SpatialMaterial <class_SpatialMaterial>` a la "
"malla. La atención se centrará en el uso de la :ref:`Viewport "
"<class_Viewport>` para crear dinámicamente texturas que se pueden aplicar a "
"la malla."

msgid "In this tutorial, we'll cover the following topics:"
msgstr "En este tutorial cubriremos los siguientes temas:"

msgid "How to use a :ref:`Viewport <class_Viewport>` as a render texture"
msgstr "Cómo usar un :ref:`Viewports <class_Viewport>` como una render texture"

msgid "Mapping a texture to a sphere with equirectangular mapping"
msgstr "Mapear una textura a una esfera con mapeo equirectangular"

msgid "Fragment shader techniques for procedural planets"
msgstr "Técnicas de sombreado de fragmentos para planetas procedimentales"

msgid ""
"Setting a Roughness map from a :ref:`Viewport Texture "
"<class_ViewportTexture>`"
msgstr ""
"Estableciendo un mapa de rugosidad desde un :ref:`Viewport Texture "
"<class_ViewportTexture>`"

msgid "Setting up the Viewport"
msgstr "Configurando el Viewport"

msgid "First, add a :ref:`Viewport <class_Viewport>` to the scene."
msgstr "Primero, agrega un :ref:`Viewport <class_Viewport>` a la escena."

msgid ""
"Next, set the size of the :ref:`Viewport <class_Viewport>` to ``(1024, "
"512)``. The :ref:`Viewport <class_Viewport>` can actually be any size so "
"long as the width is double the height. The width needs to be double the "
"height so that the image will accurately map onto the sphere, as we will be "
"using equirectangular projection, but more on that later."
msgstr ""
"A continuación, establezca el tamaño del :ref:`Viewport <class_Viewport>` a "
"``(1024, 512)``. El :ref:`Viewport <class_Viewport>` puede ser de cualquier "
"tamaño siempre y cuando el ancho sea el doble de la altura. El ancho debe "
"ser el doble de la altura para que la imagen se asemeje con precisión a la "
"esfera, ya que usaremos la proyección equidireccional, pero más sobre eso "
"más adelante."

msgid ""
"Next, disable HDR and disable 3D. We don't need HDR because our planet's "
"surface will not be especially bright, so values between ``0`` and ``1`` "
"will be fine. And we will be using a :ref:`ColorRect <class_ColorRect>` to "
"render the surface, so we don't need 3D either."
msgstr ""
"A continuación, deshabilite el HDR y deshabilite el 3D. No necesitamos el "
"HDR porque la superficie de nuestro planeta no será especialmente brillante, "
"así que los valores entre ``0`` y ``1`` estarán bien. Y usaremos un :ref:"
"`ColorRect <class_ColorRect>` para renderizar la superficie, así que tampoco "
"necesitamos 3D."

msgid ""
"Select the Viewport and add a :ref:`ColorRect <class_ColorRect>` as a child."
msgstr ""
"Selecciona el Viewport y añade un :ref:`ColorRect <class_ColorRect>` como un "
"hijo."

msgid ""
"Set the anchors \"Right\" and \"Bottom\" to ``1``, then make sure all the "
"margins are set to ``0``. This will ensure that the :ref:`ColorRect "
"<class_ColorRect>` takes up the entire :ref:`Viewport <class_Viewport>`."
msgstr ""
"Ponga los anclajes \"Derecha\" y \"Abajo\" en ``1``, y asegúrese de que "
"todos los márgenes estén en ``0``. Esto asegurará que el :ref:`ColorRect "
"<class_ColorRect>` ocupe todo el :ref:`Viewport <class_Viewport>`."

msgid ""
"Next, we add a :ref:`Shader Material <class_ShaderMaterial>` to the :ref:"
"`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > Material "
"> ``New ShaderMaterial``)."
msgstr ""
"A continuación, añadimos un :ref:`Shader Material <class_ShaderMaterial>` "
"al :ref:`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > "
"Material > ``New ShaderMaterial``)."

msgid ""
"Basic familiarity with shading is recommended for this tutorial. However, "
"even if you are new to shaders, all the code will be provided, so you should "
"have no problem following along."
msgstr ""
"Para este tutorial se recomienda una familiaridad básica con shaders. Sin "
"embargo, incluso si es nuevo en con los shaders, se le proporcionará todo el "
"código, por lo que no debería tener problemas para seguirlo."

msgid ""
"ColorRect > CanvasItem > Material > Material > click / Edit > ShaderMaterial "
"> Shader > ``New Shader`` > click / Edit:"
msgstr ""
"ColorRect > CanvasItem > Material > Material > clic / Edit > ShaderMaterial "
"> Shader > ``New Shader`` > clic / Edit:"

msgid "The above code renders a gradient like the one below."
msgstr "El código de arriba muestra un gradiente como el de abajo."

msgid ""
"Now we have the basics of a :ref:`Viewport <class_Viewport>` that we render "
"to and we have a unique image that we can apply to the sphere."
msgstr ""
"Ahora tenemos lo básico de un :ref:`Viewport <class_Viewport>` al que "
"renderizamos y tenemos una imagen única que podemos aplicar a la esfera."

msgid "Applying the texture"
msgstr "Aplicando la textura"

#, fuzzy
msgid ""
"MeshInstance3D > GeometryInstance > Geometry > Material Override > ``New "
"StandardMaterial3D``:"
msgstr ""
"MeshInstance > GeometryInstance > Geometría > Material Override > ``Nuevo "
"Material Espacial``:"

#, fuzzy
msgid ""
"Now we go into the :ref:`MeshInstance3D <class_MeshInstance3D>` and add a :"
"ref:`StandardMaterial3D <class_StandardMaterial3D>` to it. No need for a "
"special :ref:`Shader Material <class_ShaderMaterial>` (although that would "
"be a good idea for more advanced effects, like the atmosphere in the example "
"above)."
msgstr ""
"Ahora vamos a la :ref:`Mesh Instance <class_MeshInstance>` y añadimos un :"
"ref:`SpatialMaterial <class_SpatialMaterial>` a ella. No es necesario un :"
"ref:`Shader Material <class_ShaderMaterial>` especial (aunque sería una "
"buena idea para efectos más avanzados, como la atmósfera en el ejemplo "
"anterior)."

#, fuzzy
msgid ""
"MeshInstance3D > GeometryInstance > Geometry > Material Override > "
"``click`` / ``Edit``:"
msgstr ""
"MeshInstance > GeometryInstance > Geometry > Material Override > ``Click`` / "
"``Edit``:"

#, fuzzy
msgid ""
"Open the newly created :ref:`StandardMaterial3D <class_StandardMaterial3D>` "
"and scroll down to the \"Albedo\" section and click beside the \"Texture\" "
"property to add an Albedo Texture. Here we will apply the texture we made. "
"Choose \"New ViewportTexture\""
msgstr ""
"Abre la recién creada :ref:`SpatialMaterial <class_SpatialMaterial>` y baja "
"a la sección \"Albedo\" y haz clic al lado de la propiedad \"Texture\" para "
"añadir un Albedo Texture. Aquí aplicaremos la textura que hemos creado. "
"Elige \"New ViewportTexture\""

msgid ""
"Then, from the menu that pops up, select the Viewport that we rendered to "
"earlier."
msgstr ""
"Luego, en el menú que aparece, selecciona el Viewport que hemos renderizado "
"anteriormente."

msgid ""
"Your sphere should now be colored in with the colors we rendered to the "
"Viewport."
msgstr ""
"Su esfera debe ser coloreada con los colores que renderizamos al Viewport."

msgid ""
"Notice the ugly seam that forms where the texture wraps around? This is "
"because we are picking a color based on UV coordinates and UV coordinates do "
"not wrap around the texture. This is a classic problem in 2D map projection. "
"Game developers often have a 2-dimensional map they want to project onto a "
"sphere, but when it wraps around, it has large seams. There is an elegant "
"workaround for this problem that we will illustrate in the next section."
msgstr ""
"¿Notan la fea costura que se forma donde la textura se envuelve? Esto se "
"debe a que estamos eligiendo un color basado en coordenadas UV y las "
"coordenadas UV no envuelven la textura. Este es un problema clásico en la "
"proyección de mapas en 2D. Los desarrolladores de juegos a menudo tienen un "
"mapa bidimensional que quieren proyectar en una esfera, pero cuando se "
"envuelve alrededor, tiene grandes costuras. Hay una solución elegante para "
"este problema que ilustraremos en la siguiente sección."

msgid "Making the planet texture"
msgstr "Haciendo la textura del planeta"

msgid ""
"So now, when we render to our :ref:`Viewport <class_Viewport>`, it appears "
"magically on the sphere. But there is an ugly seam created by our texture "
"coordinates. So how do we get a range of coordinates that wrap around the "
"sphere in a nice way? One solution is to use a function that repeats on the "
"domain of our texture. ``sin`` and ``cos`` are two such functions. Let's "
"apply them to the texture and see what happens."
msgstr ""
"Así que ahora, cuando renderizamos a nuestro :ref:`Viewport "
"<class_Viewport>`, aparece mágicamente en la esfera. Pero hay una fea "
"costura creada por las coordenadas de nuestra textura. Entonces, ¿cómo "
"obtenemos un rango de coordenadas que envuelvan la esfera de una manera "
"agradable? Una solución es usar una función que se repita en el dominio de "
"nuestra textura. ``sin`` y ``cos`` son dos de esas funciones. Apliquémoslas "
"a la textura y veamos qué sucede."

#, fuzzy
msgid ""
"Not too bad. If you look around, you can see that the seam has now "
"disappeared, but in its place, we have pinching at the poles. This pinching "
"is due to the way Godot maps textures to spheres in its :ref:"
"`StandardMaterial3D <class_StandardMaterial3D>`. It uses a projection "
"technique called equirectangular projection, which translates a spherical "
"map onto a 2D plane."
msgstr ""
"No está mal. Si miras alrededor, puedes ver que la costura ha desaparecido, "
"pero en su lugar, tenemos pellizcos en los postes. Este pellizco se debe a "
"la forma en que Godot mapea las texturas a las esferas en su :ref:"
"`SpatialMaterial <class_SpatialMaterial>`. Utiliza una técnica de proyección "
"llamada proyección equidireccional, que traduce un mapa esférico a un plano "
"2D."

msgid ""
"If you are interested in a little extra information on the technique, we "
"will be converting from spherical coordinates into Cartesian coordinates. "
"Spherical coordinates map the longitude and latitude of the sphere, while "
"Cartesian coordinates are, for all intents and purposes, a vector from the "
"center of the sphere to the point."
msgstr ""
"Si le interesa un poco más de información sobre la técnica, convertiremos de "
"coordenadas esféricas a coordenadas cartesianas. Las coordenadas esféricas "
"trazan la longitud y la latitud de la esfera, mientras que las coordenadas "
"cartesianas son, a todos los efectos, un vector desde el centro de la esfera "
"hasta el punto."

msgid ""
"For each pixel, we will calculate its 3D position on the sphere. From that, "
"we will use 3D noise to determine a color value. By calculating the noise in "
"3D, we solve the problem of the pinching at the poles. To understand why, "
"picture the noise being calculated across the surface of the sphere instead "
"of across the 2D plane. When you calculate across the surface of the sphere, "
"you never hit an edge, and hence you never create a seam or a pinch point on "
"the pole. The following code converts the ``UVs`` into Cartesian coordinates."
msgstr ""
"Para cada píxel, calcularemos su posición 3D en la esfera. A partir de eso, "
"usaremos el ruido 3D para determinar un valor de color. Calculando el ruido "
"en 3D, resolvemos el problema del pellizco en los polos. Para entender por "
"qué, imagina que el ruido se calcula a través de la superficie de la esfera "
"en lugar de a través del plano 2D. Cuando se calcula a través de la "
"superficie de la esfera, nunca se golpea un borde, y por lo tanto nunca se "
"crea una costura o un punto de pellizco en el polo. El siguiente código "
"convierte los ``UV``s en coordenadas cartesianas."

msgid "And if we use ``unit`` as an output ``COLOR`` value, we get:"
msgstr "Y si usamos ``unit`` como valor de salida de ``COLOR``, obtenemos:"

msgid ""
"Now that we can calculate the 3D position of the surface of the sphere, we "
"can use 3D noise to make the planet. We will be using this noise function "
"directly from a `Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_:"
msgstr ""
"Ahora que podemos calcular la posición 3D de la superficie de la esfera, "
"podemos usar el ruido 3D para hacer el planeta. Usaremos esta función de "
"ruido directamente de un `Shadertoy <https://www.shadertoy.com/view/"
"Xsl3Dl>`_:"

msgid ""
"All credit goes to the author, Inigo Quilez. It is published under the "
"``MIT`` licence."
msgstr ""
"Todo el crédito es para el autor, Inigo Quilez. Se publica bajo la licencia "
"``MIT``."

msgid ""
"Now to use ``noise``, add the following to the    ``fragment`` function:"
msgstr ""
"Ahora para usar ``noise``, agrega lo siguiente a la función ``fragment``:"

msgid "In order to highlight the texture, we set the material to unshaded."
msgstr "Para resaltar la textura, fijamos el material en sin sombrear."

msgid ""
"You can see now that the noise indeed wraps seamlessly around the sphere. "
"Although this looks nothing like the planet you were promised. So let's move "
"onto something more colorful."
msgstr ""
"Puedes ver ahora que el ruido se envuelve sin problemas alrededor de la "
"esfera. Aunque no se parece en nada al planeta que se les prometió. Así que "
"pasemos a algo más colorido."

msgid "Coloring the planet"
msgstr "Coloreando el planeta"

msgid ""
"Now to make the planet colors. While there are many ways to do this, for "
"now, we will stick with a gradient between water and land."
msgstr ""
"Ahora para hacer que el planeta se coloree. Aunque hay muchas maneras de "
"hacerlo, por ahora, nos quedaremos con un gradiente entre el agua y la "
"tierra."

msgid ""
"To make a gradient in GLSL, we use the ``mix`` function. ``mix`` takes two "
"values to interpolate between and a third argument to choose how much to "
"interpolate between them; in essence, it *mixes* the two values together. In "
"other APIs, this function is often called ``lerp``. However, ``lerp`` is "
"typically reserved for mixing two floats together; ``mix`` can take any "
"values whether it be floats or vector types."
msgstr ""
"Para hacer un gradiente en el GLSL, usamos la función ``mix``. ``mix`` toma "
"dos valores para interpolar entre ellos y un tercer argumento para elegir "
"cuánto interpolar entre ellos; en esencia, *mezcla* los dos valores entre "
"sí. En otras APIs, esta función se llama a menudo ``lerp``. Sin embargo, "
"``lerp`` se reserva típicamente para mezclar dos reales juntos; ``mix`` "
"puede tomar cualquier valor, ya sea reales o tipos de vectores."

msgid ""
"The first color is blue for the ocean. The second color is a kind of reddish "
"color (because all alien planets need red terrain). And finally, they are "
"mixed together by ``n * 0.5 + 0.5``. ``n`` smoothly varies between ``-1`` "
"and ``1``. So we map it into the ``0-1`` range that ``mix`` expects. Now you "
"can see that the colors change between blue and red."
msgstr ""
"El primer color es el azul para el océano. El segundo color es una especie "
"de color rojizo (porque todos los planetas alienígenas necesitan terreno "
"rojo). Y finalmente, se mezclan entre sí por ``n * 0.5 + 0.5``. ``n`` varía "
"suavemente entre ``-1`` y ``1``. Así que lo ubicamos en el rango de ``0-1`` "
"que la ``mix`` espera. Ahora puedes ver que los colores cambian entre el "
"azul y el rojo."

msgid ""
"That is a little more blurry than we want. Planets typically have a "
"relatively clear separation between land and sea. In order to do that, we "
"will change the last term to ``smoothstep(-0.1, 0.0, n)``. And thus the "
"whole line becomes:"
msgstr ""
"Eso es un poco más borroso de lo que queremos. Los planetas suelen tener una "
"separación relativamente clara entre la tierra y el mar. Para ello, "
"cambiaremos el último término a ``smoothstep(-0.1, 0.0, n)``. Y así toda la "
"línea se convierte:"

msgid ""
"What ``smoothstep`` does is return ``0`` if the third argument is below the "
"first and ``1`` if the third argument is larger than the second and smoothly "
"blends between ``0`` and ``1`` if the third number is between the first and "
"the second. So in this line, ``smoothstep`` returns ``0`` whenever ``n`` is "
"less than ``-0.1`` and it returns ``1`` whenever ``n`` is above ``0``."
msgstr ""
"Lo que hace ``Smoothstep`` es devolver ``0`` si el tercer argumento está por "
"debajo del primero y ``1`` si el tercer argumento es más grande que el "
"segundo y se mezcla suavemente entre ``0`` y ``1`` si el tercer número está "
"entre el primero y el segundo. Así que en esta línea, ``smoothstep`` "
"devuelve ``0`` cuando ``n`` es menor que ``-0,1`` y devuelve ``1`` cuando "
"``n`` está por encima de ``0``."

msgid ""
"One more thing to make this a little more planet-y. The land shouldn't be so "
"blobby; let's make the edges a little rougher. A trick that is often used in "
"shaders to make rough looking terrain with noise is to layer levels of noise "
"over one another at various frequencies. We use one layer to make the "
"overall blobby structure of the continents. Then another layer breaks up the "
"edges a bit, and then another, and so on. What we will do is calculate ``n`` "
"with four lines of shader code instead of just one. ``n`` becomes:"
msgstr ""
"Una cosa más para hacer esto un poco más planetario. La tierra no debería "
"ser tan desordenada; hagamos los bordes un poco más ásperos. Un truco que se "
"usa a menudo con los shaders para hacer que el terreno se vea más áspero con "
"el ruido, es poner capas de ruido unas sobre otras a varias frecuencias. "
"Usamos una capa para hacer la estructura general de los continentes. Luego "
"otra capa rompe un poco los bordes, y luego otra, y así sucesivamente. Lo "
"que haremos es calcular ``n`` con cuatro líneas de código de shader en lugar "
"de sólo una. ``n`` se convierte en:"

msgid "And now the planet looks like:"
msgstr "Y ahora el planeta se ve como:"

msgid "And with shading turned back on, it looks like:"
msgstr "Y ahora el planeta parece:"

msgid "Making an ocean"
msgstr "Haciendo un océano"

msgid ""
"One final thing to make this look more like a planet. The ocean and the land "
"reflect light differently. So we want the ocean to shine a little more than "
"the land. We can do this by passing a fourth value into the ``alpha`` "
"channel of our output ``COLOR`` and using it as a Roughness map."
msgstr ""
"Una última cosa para hacer que esto se parezca más a un planeta. El océano y "
"la tierra reflejan la luz de forma diferente. Así que queremos que el océano "
"brille un poco más que la tierra. Podemos hacerlo pasando un cuarto valor al "
"canal ``alfa`` de nuestro ``COLOR`` de salida y usándolo como un mapa de "
"rugosidad."

msgid ""
"This line returns ``0.3`` for water and ``1.0`` for land. This means that "
"the land is going to be quite rough, while the water will be quite smooth."
msgstr ""
"Esta línea devuelve ``0.3`` para el agua y ``1.0`` para la tierra. Esto "
"significa que la tierra va a ser bastante áspera, mientras que el agua será "
"bastante suave."

msgid ""
"And then, in the material, under the \"Metallic\" section, make sure "
"``Metallic`` is set to ``0`` and ``Specular`` is set to ``1``. The reason "
"for this is the water reflects light really well, but isn't metallic. These "
"values are not physically accurate, but they are good enough for this demo."
msgstr ""
"Y luego, en el material, bajo la sección \"Metallic\", asegúrate de que "
"``Metallic`` esté en ``0`` y ``Specular`` en ``1``. La razón de esto es que "
"el agua refleja la luz muy bien, pero no es metálica. Estos valores no son "
"físicamente exactos, pero son lo suficientemente buenos para esta "
"demostración."

msgid ""
"Next, under the \"Roughness\" section, set ``Roughness`` to ``1`` and set "
"the roughness texture to a :ref:`Viewport Texture <class_ViewportTexture>` "
"pointing to our planet texture :ref:`Viewport <class_Viewport>`. Finally, "
"set the ``Texture Channel`` to ``Alpha``. This instructs the renderer to use "
"the ``alpha`` channel of our output ``COLOR`` as the ``Roughness`` value."
msgstr ""
"A continuación, en la sección \"Rugosidad\", pon ``Rugosidad`` en ``1`` y "
"pon la textura de la rugosidad en \"ref:`Textura de Viewport "
"<clase_ViewportTexture>\" apuntando a la textura de nuestro planeta ref:"
"`Viewport <class_Viewport>`. Por último, establece el ``Texture Channel`` en "
"``Alpha``. Esto instruye al renderizador para usar el canal alfa de nuestra "
"salida ``COLOR`` como valor de ``Rugosidad``."

msgid ""
"You'll notice that very little changes except that the planet is no longer "
"reflecting the sky. This is happening because, by default, when something is "
"rendered with an alpha value, it gets drawn as a transparent object over the "
"background. And since the default background of the :ref:`Viewport "
"<class_Viewport>` is opaque, the ``alpha`` channel of the :ref:`Viewport "
"Texture <class_ViewportTexture>` is ``1``, resulting in the planet texture "
"being drawn with slightly fainter colors and a ``Roughness`` value of ``1`` "
"everywhere. To correct this, we go into the :ref:`Viewport <class_Viewport>` "
"and enable the \"Transparent Bg\" property. Since we are now rendering one "
"transparent object on top of another, we want to enable "
"``blend_premul_alpha``:"
msgstr ""
"Notarás que hay muy pocos cambios, excepto que el planeta ya no refleja el "
"cielo. Esto ocurre porque, por defecto, cuando algo se representa con un "
"valor alfa, se dibuja como un objeto transparente sobre el fondo. Y como el "
"fondo por defecto de :ref:`Viewport <class_Viewport>` es opaco, el canal "
"``alfa`` de :ref:`Viewport Texture <class_ViewportTexture>` es ``1``, lo que "
"hace que la textura del planeta se dibuje con colores ligeramente más tenues "
"y un valor ``Rugosidad`` de ``1`` en todas partes. Para corregir esto, vamos "
"a la propiedad :ref:`Viewport <class_Viewport>` y activamos la propiedad "
"\"Transparent Bg\". Ya que ahora estamos renderizando un objeto transparente "
"sobre otro, queremos habilitar ``blend_premul_alpha``:"

msgid ""
"This pre-multiplies the colors by the ``alpha`` value and then blends them "
"correctly together. Typically, when blending one transparent color on top of "
"another, even if the background has an ``alpha`` of ``0`` (as it does in "
"this case), you end up with weird color bleed issues. Setting "
"``blend_premul_alpha`` fixes that."
msgstr ""
"Esto pre-multiplica los colores por el valor ``alfa`` y luego los mezcla "
"correctamente. Típicamente, al mezclar un color tranparente sobre otro, "
"incluso si el fondo tiene un valor ``alfa`` de ``0`` (como en este caso), "
"terminas con extraños problemas de sangrado de color. Poner "
"``blend_premul_alpha`` arregla eso."

#, fuzzy
msgid ""
"Now the planet should look like it is reflecting light on the ocean but not "
"the land. If you haven't done so already, add an :ref:`OmniLight3D "
"<class_OmniLight3D>` to the scene so you can move it around and see the "
"effect of the reflections on the ocean."
msgstr ""
"Ahora el planeta debería parecer que está reflejando luz en el océano pero "
"no en la tierra. Si aún no lo has hecho, añade una :ref:`OmniLight "
"<class_OmniLight>` a la escena para que puedas moverla y ver el efecto de "
"los reflejos en el océano."

msgid ""
"And there you have it. A procedural planet generated using a :ref:`Viewport "
"<class_Viewport>`."
msgstr ""
"Y ahí lo tienes. Un planeta procedimental generado usando un :ref:`Viewport "
"<class_Viewport>`."

msgid "Translation status"
msgstr "Estado de traducción"
