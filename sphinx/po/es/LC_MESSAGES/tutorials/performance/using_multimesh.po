# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Optimization using MultiMeshes"
msgstr "Optimización usando MultiMeshes"

msgid ""
"For large amount of instances (in the thousands), that need to be constantly "
"processed (and certain amount of control needs to be retained), :ref:`using "
"servers directly <doc_using_servers>` is the recommended optimization."
msgstr ""
"Para un gran número de instancias (en miles) que deben ser procesadas "
"constantemente (y se necesita cierto grado de control), se recomienda la "
"optimización de \"usar servidores directamente\". Esto implica utilizar "
"servidores de manera directa y eficiente para gestionar y procesar las "
"instancias, lo cual puede ofrecer un rendimiento mejorado y mayor control "
"sobre el procesamiento. Para obtener más información sobre cómo utilizar "
"servidores directamente, puedes consultar la documentación en el enlace \":"
"ref:`usar servidores directamente <doc_using_servers>`\"."

msgid ""
"When the amount of objects reach the hundreds of thousands or millions, none "
"of these approaches are efficient anymore. Still, depending on the "
"requirements, there is one more optimization possible."
msgstr ""
"Cuando la cantidad de objetos alcanza cientos de miles o millones, ninguno "
"de estos enfoques es eficiente. Sin embargo, dependiendo de los requisitos, "
"existe una optimización adicional posible."

msgid "MultiMeshes"
msgstr "MultiMeshes"

msgid ""
"A :ref:`MultiMesh<class_MultiMesh>` is a single draw primitive that can draw "
"up to millions of objects in one go. It's extremely efficient because it "
"uses the GPU hardware to do this (in OpenGL ES 2.0, it's less efficient "
"because there is no hardware support for it, though)."
msgstr ""
"Un :ref:`MultiMesh<class_MultiMesh>` es una primitiva de dibujo única que "
"puede dibujar hasta millones de objetos de una vez. Es extremadamente "
"eficiente porque utiliza el hardware de la GPU para hacer esto (en OpenGL ES "
"2.0, es menos eficiente porque no hay soporte de hardware para ello)."

msgid ""
"The only drawback is that there is no *screen* or *frustum* culling possible "
"for individual instances. This means, that millions of objects will be "
"*always* or *never* drawn, depending on the visibility of the whole "
"MultiMesh. It is possible to provide a custom visibility rect for them, but "
"it will always be *all-or-none* visibility."
msgstr ""
"La única desventaja es que no es posible realizar un culling de pantalla o "
"de frustum para instancias individuales. Esto significa que millones de "
"objetos siempre se dibujarán o nunca se dibujarán, dependiendo de la "
"visibilidad de todo el MultiMesh. Es posible proporcionar un rectángulo de "
"visibilidad personalizado para ellos, pero siempre será una visibilidad "
"*todo o nada*."

msgid ""
"If the objects are simple enough (just a couple of vertices), this is "
"generally not much of a problem as most modern GPUs are optimized for this "
"use case. A workaround is to create several MultiMeshes for different areas "
"of the world."
msgstr ""
"Si los objetos son lo suficientemente simples (solo un par de vértices), "
"esto generalmente no es un gran problema, ya que la mayoría de las GPUs "
"modernas están optimizadas para este caso de uso. Una solución alternativa "
"es crear varios MultiMeshes para diferentes áreas del mundo."

msgid ""
"It is also possible to execute some logic inside the vertex shader (using "
"the ``INSTANCE_ID`` or ``INSTANCE_CUSTOM`` built-in constants). For an "
"example of animating thousands of objects in a MultiMesh, see the :ref:"
"`Animating thousands of fish <doc_animating_thousands_of_fish>` tutorial. "
"Information to the shader can be provided via textures (there are floating-"
"point :ref:`Image<class_Image>` formats which are ideal for this)."
msgstr ""
"También es posible ejecutar cierta lógica dentro del vertex shader "
"utilizando las constantes integradas \"INSTANCE_ID\" o \"INSTANCE_CUSTOM\". "
"Por ejemplo, para animar miles de objetos en un MultiMesh, puedes consultar "
"el tutorial \":ref:`Animando miles de peces "
"<doc_animating_thousands_of_fish>`\". La información para el shader puede "
"ser proporcionada a través de texturas (hay formatos de imágenes de punto "
"flotante, :ref:`Image<class_Image>`, que son ideales para esto)."

#, fuzzy
msgid ""
"Another alternative is to use a GDExtension and C++, which should be "
"extremely efficient (it's possible to set the entire state for all objects "
"using linear memory via the :ref:`RenderingServer.multimesh_set_buffer() "
"<class_RenderingServer_method_multimesh_set_buffer>` function). This way, "
"the array can be created with multiple threads, then set in one call, "
"providing high cache efficiency."
msgstr ""
"Otra alternativa es utilizar GDNative y C++, lo cual debería ser "
"extremadamente eficiente. Es posible establecer el estado completo para "
"todos los objetos utilizando memoria lineal a través de la función :ref:"
"`VisualServer.multimesh_set_as_bulk_array() "
"<class_VisualServer_method_multimesh_set_as_bulk_array>`. De esta manera, el "
"array puede ser creado con múltiples hilos y luego establecido en una sola "
"llamada, lo que proporciona una alta eficiencia de caché."

msgid ""
"Finally, it's not required to have all MultiMesh instances visible. The "
"amount of visible ones can be controlled with the :ref:`MultiMesh."
"visible_instance_count <class_MultiMesh_property_visible_instance_count>` "
"property. The typical workflow is to allocate the maximum amount of "
"instances that will be used, then change the amount visible depending on how "
"many are currently needed."
msgstr ""
"Finalmente, no es necesario que todas las instancias de MultiMesh sean "
"visibles. La cantidad de instancias visibles se puede controlar con la "
"propiedad :ref:`MultiMesh.visible_instance_count "
"<class_MultiMesh_property_visible_instance_count>`. El flujo de trabajo "
"típico consiste en asignar la cantidad máxima de instancias que se "
"utilizarán y luego cambiar la cantidad visible según la cantidad necesaria "
"en ese momento."

msgid "Multimesh example"
msgstr "Ejemplo de Multimesh"

msgid ""
"Here is an example of using a MultiMesh from code. Languages other than "
"GDScript may be more efficient for millions of objects, but for a few "
"thousands, GDScript should be fine."
msgstr ""
"Aquí tienes un ejemplo de cómo usar un MultiMesh desde el código. Otros "
"lenguajes además de GDScript pueden ser más eficientes para millones de "
"objetos, pero para unos pocos miles, GDScript debería ser suficiente."

msgid "Translation status"
msgstr "Estado de traducción"
