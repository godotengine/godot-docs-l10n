# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GPU optimization"
msgstr "Optimización de GPU"

msgid "Introduction"
msgstr "Introducción"

msgid ""
"The demand for new graphics features and progress almost guarantees that you "
"will encounter graphics bottlenecks. Some of these can be on the CPU side, "
"for instance in calculations inside the Godot engine to prepare objects for "
"rendering. Bottlenecks can also occur on the CPU in the graphics driver, "
"which sorts instructions to pass to the GPU, and in the transfer of these "
"instructions. And finally, bottlenecks also occur on the GPU itself."
msgstr ""
"La demanda de nuevas características y avances gráficos casi garantiza que "
"te encontrarás con cuellos de botella gráficos. Algunos de estos cuellos de "
"botella pueden ocurrir en el lado de la CPU, por ejemplo, en los cálculos "
"dentro del motor Godot para preparar objetos para su renderización. Los "
"cuellos de botella también pueden ocurrir en la CPU en el controlador "
"gráfico, que ordena las instrucciones para pasar al GPU, y en la "
"transferencia de estas instrucciones. Y finalmente, también pueden ocurrir "
"cuellos de botella en el propio GPU."

msgid ""
"Where bottlenecks occur in rendering is highly hardware-specific. Mobile "
"GPUs in particular may struggle with scenes that run easily on desktop."
msgstr ""
"Los cuellos de botella en el renderizado ocurren de manera muy específica "
"según el hardware. Las GPU móviles en particular pueden tener dificultades "
"con escenas que se ejecutan fácilmente en computadoras de escritorio."

msgid ""
"Understanding and investigating GPU bottlenecks is slightly different to the "
"situation on the CPU. This is because, often, you can only change "
"performance indirectly by changing the instructions you give to the GPU. "
"Also, it may be more difficult to take measurements. In many cases, the only "
"way of measuring performance is by examining changes in the time spent "
"rendering each frame."
msgstr ""
"Comprender e investigar los cuellos de botella de la GPU es ligeramente "
"diferente a la situación en la CPU. Esto se debe a que, a menudo, solo "
"puedes cambiar el rendimiento de manera indirecta al modificar las "
"instrucciones que le das a la GPU. Además, puede ser más difícil tomar "
"medidas. En muchos casos, la única forma de medir el rendimiento es "
"examinando los cambios en el tiempo empleado en renderizar cada cuadro."

msgid "Draw calls, state changes, and APIs"
msgstr "Llamadas de dibujo, cambios de estado y APIs"

msgid ""
"The following section is not relevant to end-users, but is useful to provide "
"background information that is relevant in later sections."
msgstr ""
"La siguiente sección no es relevante para los usuarios finales, pero es útil "
"para proporcionar información de fondo que es relevante en secciones "
"posteriores."

#, fuzzy
msgid ""
"Godot sends instructions to the GPU via a graphics API (Vulkan, OpenGL, "
"OpenGL ES or WebGL). The communication and driver activity involved can be "
"quite costly, especially in OpenGL, OpenGL ES and WebGL. If we can provide "
"these instructions in a way that is preferred by the driver and GPU, we can "
"greatly increase performance."
msgstr ""
"Godot envía instrucciones al GPU a través de una API gráfica (OpenGL, OpenGL "
"ES o Vulkan). La comunicación y la actividad del controlador involucradas "
"pueden ser costosas, especialmente en OpenGL y OpenGL ES. Si podemos "
"proporcionar estas instrucciones de una manera que sea preferida por el "
"controlador y el GPU, podemos aumentar significativamente el rendimiento."

msgid ""
"Nearly every API command in OpenGL requires a certain amount of validation "
"to make sure the GPU is in the correct state. Even seemingly simple commands "
"can lead to a flurry of behind-the-scenes housekeeping. Therefore, the goal "
"is to reduce these instructions to a bare minimum and group together similar "
"objects as much as possible so they can be rendered together, or with the "
"minimum number of these expensive state changes."
msgstr ""
"Casi todos los comandos de la API en OpenGL requieren cierta cantidad de "
"validación para asegurarse de que el GPU esté en el estado correcto. Incluso "
"los comandos aparentemente simples pueden generar una serie de tareas de "
"mantenimiento en segundo plano. Por lo tanto, el objetivo es reducir al "
"mínimo estas instrucciones y agrupar objetos similares tanto como sea "
"posible para que puedan ser renderizados juntos o con el menor número "
"posible de cambios costosos de estado."

msgid "2D batching"
msgstr "Procesamiento por lotes 2D"

#, fuzzy
msgid ""
"In 2D, the costs of treating each item individually can be prohibitively "
"high - there can easily be thousands of them on the screen. This is why 2D "
"*batching* is used with OpenGL-based rendering methods. Multiple similar "
"items are grouped together and rendered in a batch, via a single draw call, "
"rather than making a separate draw call for each item. In addition, this "
"means state changes, material and texture changes can be kept to a minimum."
msgstr ""
"En 2D, los costos de tratar cada elemento de forma individual pueden ser "
"prohibitivamente altos, ya que fácilmente puede haber miles de ellos en la "
"pantalla. Por eso se utiliza el *batching* en 2D. Se agrupan múltiples "
"elementos similares y se renderizan en un lote (batch) mediante una única "
"llamada de dibujo, en lugar de realizar una llamada de dibujo separada para "
"cada elemento. Además, esto significa que los cambios de estado, los cambios "
"de material y de textura se mantienen al mínimo."

msgid ""
"Vulkan-based rendering methods do not use 2D batching yet. Since draw calls "
"are much cheaper with Vulkan compared to OpenGL, there is less of a need to "
"have 2D batching (although it can still be beneficial in some cases)."
msgstr ""

msgid "3D batching"
msgstr "Procesamiento por lotes 3D"

#, fuzzy
msgid ""
"In 3D, we still aim to minimize draw calls and state changes. However, it "
"can be more difficult to batch together several objects into a single draw "
"call. 3D meshes tend to comprise hundreds or thousands of triangles, and "
"combining large meshes in real-time is prohibitively expensive. The costs of "
"joining them quickly exceeds any benefits as the number of triangles grows "
"per mesh. A much better alternative is to **join meshes ahead of time** "
"(static meshes in relation to each other). This can be done by artists, or "
"programmatically within Godot using an add-on."
msgstr ""
"En 3D, todavía buscamos minimizar las llamadas de dibujo y los cambios de "
"estado. Sin embargo, puede ser más difícil agrupar varios objetos en una "
"única llamada de dibujo. Las mallas en 3D tienden a estar compuestas por "
"cientos o miles de triángulos, y combinar grandes mallas en tiempo real "
"resulta prohibitivamente costoso. Los costos de unirlas rápidamente superan "
"cualquier beneficio a medida que el número de triángulos crece por malla. "
"Una alternativa mucho mejor es **unir las mallas con anticipación** (mallas "
"estáticas en relación entre sí). Esto puede hacerse ya sea por artistas o "
"programáticamente dentro de Godot."

msgid ""
"There is also a cost to batching together objects in 3D. Several objects "
"rendered as one cannot be individually culled. An entire city that is off-"
"screen will still be rendered if it is joined to a single blade of grass "
"that is on screen. Thus, you should always take objects' location and "
"culling into account when attempting to batch 3D objects together. Despite "
"this, the benefits of joining static objects often outweigh other "
"considerations, especially for large numbers of distant or low-poly objects."
msgstr ""
"También hay un costo asociado al agrupar objetos en 3D. Varios objetos "
"renderizados como uno solo no pueden ser excluidos individualmente. Una "
"ciudad completa que está fuera de la pantalla aún se renderizará si está "
"unida a una única hoja de hierba que se encuentra en la pantalla. Por lo "
"tanto, siempre debes tener en cuenta la ubicación y el culling (descarte) de "
"los objetos al intentar agrupar objetos en 3D. A pesar de esto, los "
"beneficios de unir objetos estáticos a menudo superan otras consideraciones, "
"especialmente para un gran número de objetos distantes o de baja resolución."

msgid ""
"For more information on 3D specific optimizations, see :ref:"
"`doc_optimizing_3d_performance`."
msgstr ""
"Para obtener más información sobre optimizaciones específicas de 3D, "
"consulte :ref:`doc_optimizing_3d_performance`."

#, fuzzy
msgid "Reuse shaders and materials"
msgstr "Reutilizar sombreadores y materiales"

#, fuzzy
msgid ""
"The Godot renderer is a little different to what is out there. It's designed "
"to minimize GPU state changes as much as possible. :ref:`StandardMaterial3D "
"<class_StandardMaterial3D>` does a good job at reusing materials that need "
"similar shaders. If custom shaders are used, make sure to reuse them as much "
"as possible. Godot's priorities are:"
msgstr ""
"El renderizador Godot es un poco diferente a lo que existe. Está diseñado "
"para minimizar los cambios de estado de la GPU tanto como sea posible. :ref:"
"`SpatialMaterial <class_SpatialMaterial>` hace un buen trabajo al reutilizar "
"materiales que necesitan sombreadores similares. Si se utilizan sombreadores "
"personalizados, asegúrese de reutilizarlos tanto como sea posible. Las "
"prioridades de Godot son:"

msgid ""
"**Reusing Materials:** The fewer different materials in the scene, the "
"faster the rendering will be. If a scene has a huge amount of objects (in "
"the hundreds or thousands), try reusing the materials. In the worst case, "
"use atlases to decrease the amount of texture changes."
msgstr ""
"**Reutilización de materiales:** Cuantos menos materiales diferentes haya en "
"la escena, más rápido será el renderizado. Si una escena tiene una gran "
"cantidad de objetos (en cientos o miles), intente reutilizar los materiales. "
"En el peor de los casos, use atlas para disminuir la cantidad de cambios de "
"textura."

#, fuzzy
msgid ""
"**Reusing Shaders:** If materials can't be reused, at least try to reuse "
"shaders. Note: shaders are automatically reused between StandardMaterial3Ds "
"that share the same configuration (features that are enabled or disabled "
"with a check box) even if they have different parameters."
msgstr ""
"**Reutilización de Shaders:** Si los materiales no se pueden reutilizar, al "
"menos intente reutilizar shaders (o SpatialMaterials con diferentes "
"parámetros, pero con la misma configuración)."

#, fuzzy
msgid ""
"If a scene has, for example, 20,000 objects with 20,000 different materials "
"each, rendering will be slow. If the same scene has 20,000 objects, but only "
"uses 100 materials, rendering will be much faster."
msgstr ""
"Si una escena tiene, por ejemplo, ``20.000`` objetos con ``20.000`` "
"materiales diferentes cada uno, el renderizado será lento. Si la misma "
"escena tiene objetos de ``20,000``, pero solo usa materiales de ``100``, el "
"renderizado será mucho más rápido."

msgid "Pixel cost versus vertex cost"
msgstr "Costo de píxeles frente a costo de vértice"

msgid ""
"You may have heard that the lower the number of polygons in a model, the "
"faster it will be rendered. This is *really* relative and depends on many "
"factors."
msgstr ""
"Es posible que haya escuchado que cuanto menor sea el número de polígonos en "
"un modelo, más rápido se renderizará. Esto es *realmente* relativo y depende "
"de muchos factores."

msgid ""
"On a modern PC and console, vertex cost is low. GPUs originally only "
"rendered triangles. This meant that every frame:"
msgstr ""
"En una PC y una consola modernas, el costo de vértice es bajo. Las GPU "
"originalmente solo representaban triángulos. Esto significaba que cada "
"cuadro:"

msgid "All vertices had to be transformed by the CPU (including clipping)."
msgstr ""
"Todos los vértices tuvieron que ser transformados por la CPU (incluido el "
"recorte)."

msgid "All vertices had to be sent to the GPU memory from the main RAM."
msgstr ""
"Todos los vértices debían enviarse a la memoria de la GPU desde la RAM "
"principal."

#, fuzzy
msgid ""
"Nowadays, all this is handled inside the GPU, greatly increasing "
"performance. 3D artists usually have the wrong feeling about polycount "
"performance because 3D modeling software (such as Blender, 3ds Max, etc.) "
"need to keep geometry in CPU memory for it to be edited, reducing actual "
"performance. Game engines rely on the GPU more, so they can render many "
"triangles much more efficiently."
msgstr ""
"Hoy en día, todo esto se maneja dentro de la GPU, aumentando enormemente el "
"rendimiento. Los artistas 3D generalmente tienen la sensación equivocada "
"sobre el rendimiento del multicuenta porque los DCC 3D (como Blender, Max, "
"etc.) necesitan mantener la geometría en la memoria de la CPU para poder "
"editarla, reduciendo el rendimiento real. Los motores de juegos dependen más "
"de la GPU, por lo que pueden representar muchos triángulos de manera mucho "
"más eficiente."

msgid ""
"On mobile devices, the story is different. PC and console GPUs are brute-"
"force monsters that can pull as much electricity as they need from the power "
"grid. Mobile GPUs are limited to a tiny battery, so they need to be a lot "
"more power efficient."
msgstr ""
"En los dispositivos móviles, la historia es diferente. Las GPU de PC y "
"consola son monstruos de fuerza bruta que pueden extraer tanta electricidad "
"como necesiten de la red eléctrica. Las GPU móviles están limitadas a una "
"batería diminuta, por lo que deben ser mucho más eficientes energéticamente."

msgid ""
"To be more efficient, mobile GPUs attempt to avoid *overdraw*. Overdraw "
"occurs when the same pixel on the screen is being rendered more than once. "
"Imagine a town with several buildings. GPUs don't know what is visible and "
"what is hidden until they draw it. For example, a house might be drawn and "
"then another house in front of it (which means rendering happened twice for "
"the same pixel). PC GPUs normally don't care much about this and just throw "
"more pixel processors to the hardware to increase performance (which also "
"increases power consumption)."
msgstr ""
"Para ser más eficientes, las GPU móviles intentan evitar *sobregiro*. El "
"sobregiro se produce cuando el mismo píxel en la pantalla se representa más "
"de una vez. Imagina una ciudad con varios edificios. Las GPU no saben qué es "
"visible y qué está oculto hasta que lo dibujan. Por ejemplo, se puede "
"dibujar una casa y luego otra casa frente a ella (lo que significa que la "
"renderización se realizó dos veces para el mismo píxel). A las GPU de PC "
"normalmente no les importa mucho esto y simplemente lanzan más procesadores "
"de píxeles al hardware para aumentar el rendimiento (lo que también aumenta "
"el consumo de energía)."

msgid ""
"Using more power is not an option on mobile so mobile devices use a "
"technique called *tile-based rendering* which divides the screen into a "
"grid. Each cell keeps the list of triangles drawn to it and sorts them by "
"depth to minimize *overdraw*. This technique improves performance and "
"reduces power consumption, but takes a toll on vertex performance. As a "
"result, fewer vertices and triangles can be processed for drawing."
msgstr ""
"Usar más energía no es una opción en dispositivos móviles, por lo que los "
"dispositivos móviles usan una técnica llamada *renderizado basado en "
"mosaicos* que divide la pantalla en una cuadrícula. Cada celda mantiene la "
"lista de triángulos dibujados en ella y los ordena por profundidad para "
"minimizar *sobredibujar*. Esta técnica mejora el rendimiento y reduce el "
"consumo de energía, pero afecta el rendimiento de los vértices. Como "
"resultado, se pueden procesar menos vértices y triángulos para dibujar."

msgid ""
"Additionally, tile-based rendering struggles when there are small objects "
"with a lot of geometry within a small portion of the screen. This forces "
"mobile GPUs to put a lot of strain on a single screen tile, which "
"considerably decreases performance as all the other cells must wait for it "
"to complete before displaying the frame."
msgstr ""
"Además, el renderizado basado en mosaicos tiene problemas cuando hay objetos "
"pequeños con mucha geometría dentro de una pequeña porción de la pantalla. "
"Esto obliga a las GPU móviles a ejercer mucha presión sobre un mosaico de "
"una sola pantalla, lo que disminuye considerablemente el rendimiento, ya que "
"todas las demás celdas deben esperar a que se complete antes de mostrar el "
"marco."

msgid ""
"To summarize, don't worry about vertex count on mobile, but **avoid "
"concentration of vertices in small parts of the screen**. If a character, "
"NPC, vehicle, etc. is far away (which means it looks tiny), use a smaller "
"level of detail (LOD) model. Even on desktop GPUs, it's preferable to avoid "
"having triangles smaller than the size of a pixel on screen."
msgstr ""
"En resumen, no se preocupe por el recuento de vértices en dispositivos "
"móviles, pero **evite la concentración de vértices en partes pequeñas de la "
"pantalla**. Si un personaje, NPC, vehículo, etc.está lejos (lo que significa "
"que parece pequeño), use un modelo de menor nivel de detalle (LOD). Incluso "
"en las GPU de escritorio, es preferible evitar tener triángulos más pequeños "
"que el tamaño de un píxel en la pantalla."

msgid "Pay attention to the additional vertex processing required when using:"
msgstr ""
"Presta atención al procesamiento adicional de vértices requerido al utilizar:"

msgid "Skinning (skeletal animation)"
msgstr "Skinning (animación esquelética)"

msgid "Morphs (shape keys)"
msgstr "Morphs (claves de forma)"

msgid "Pixel/fragment shaders and fill rate"
msgstr "Los sombreadores de píxeles/fragmentos y la tasa de llenado"

#, fuzzy
msgid ""
"In contrast to vertex processing, the costs of fragment (per-pixel) shading "
"have increased dramatically over the years. Screen resolutions have "
"increased: the area of a 4K screen is 8,294,400 pixels, versus 307,200 for "
"an old 640×480 VGA screen. That is 27 times the area! Also, the complexity "
"of fragment shaders has exploded. Physically-based rendering requires "
"complex calculations for each fragment."
msgstr ""
"A diferencia del procesamiento de vértices, los costos del sombreado de "
"fragmentos (por píxel) han aumentado drásticamente a lo largo de los años. "
"Las resoluciones de pantalla han aumentado (el área de una pantalla 4K es de "
"8,294,400 píxeles, en comparación con los 307,200 de una antigua pantalla "
"VGA de 640×480, es decir, 27 veces el área), pero también la complejidad de "
"los sombreadores de fragmentos ha aumentado considerablemente. El "
"renderizado basado en física requiere cálculos complejos para cada fragmento."

msgid ""
"You can test whether a project is fill rate-limited quite easily. Turn off V-"
"Sync to prevent capping the frames per second, then compare the frames per "
"second when running with a large window, to running with a very small "
"window. You may also benefit from similarly reducing your shadow map size if "
"using shadows. Usually, you will find the FPS increases quite a bit using a "
"small window, which indicates you are to some extent fill rate-limited. On "
"the other hand, if there is little to no increase in FPS, then your "
"bottleneck lies elsewhere."
msgstr ""
"Puedes probar fácilmente si un proyecto tiene limitaciones de tasa de "
"llenado. Desactiva la sincronización vertical (V-Sync) para evitar limitar "
"los cuadros por segundo y luego compara los cuadros por segundo al ejecutar "
"el proyecto en una ventana grande y en una ventana muy pequeña. También "
"puedes beneficiarte de reducir el tamaño del mapa de sombras si estás "
"utilizando sombras. Por lo general, encontrarás que la velocidad de cuadros "
"por segundo aumenta considerablemente al utilizar una ventana pequeña, lo "
"que indica que estás limitado en cierta medida por la tasa de llenado. Por "
"otro lado, si hay poco o ningún aumento en la velocidad de cuadros por "
"segundo, entonces tu cuello de botella se encuentra en otro lugar."

#, fuzzy
msgid ""
"You can increase performance in a fill rate-limited project by reducing the "
"amount of work the GPU has to do. You can do this by simplifying the shader "
"(perhaps turn off expensive options if you are using a :ref:"
"`StandardMaterial3D <class_StandardMaterial3D>`), or reducing the number and "
"size of textures used. Also, when using non-unshaded particles, consider "
"forcing vertex shading in their material to decrease the shading cost."
msgstr ""
"Puedes aumentar el rendimiento en un proyecto limitado por la tasa de "
"llenado al reducir la cantidad de trabajo que debe realizar la GPU. Puedes "
"lograr esto simplificando el sombreador (quizás desactivando opciones "
"costosas si estás utilizando un :ref:`SpatialMaterial "
"<class_SpatialMaterial>`), o reduciendo el número y tamaño de las texturas "
"utilizadas."

msgid ""
"On supported hardware, :ref:`doc_variable_rate_shading` can be used to "
"reduce shading processing costs without impacting the sharpness of edges on "
"the final image."
msgstr ""

msgid ""
"**When targeting mobile devices, consider using the simplest possible "
"shaders you can reasonably afford to use.**"
msgstr ""
"**Cuando te dirijas a dispositivos móviles, considera utilizar los shaders "
"más simples que puedas permitirte razonablemente usar.**"

msgid "Reading textures"
msgstr "Leer texturas"

msgid ""
"The other factor in fragment shaders is the cost of reading textures. "
"Reading textures is an expensive operation, especially when reading from "
"several textures in a single fragment shader. Also, consider that filtering "
"may slow it down further (trilinear filtering between mipmaps, and "
"averaging). Reading textures is also expensive in terms of power usage, "
"which is a big issue on mobiles."
msgstr ""
"Otro factor en los fragment shaders es el costo de leer las texturas. Leer "
"texturas es una operación costosa, especialmente al leer de varias texturas "
"en un solo fragment shader. Además, considera que el filtrado puede "
"ralentizarlo aún más (filtrado trilineal entre mipmaps y promediando). Leer "
"texturas también es costoso en términos de consumo de energía, lo cual es un "
"gran problema en dispositivos móviles."

msgid ""
"**If you use third-party shaders or write your own shaders, try to use "
"algorithms that require as few texture reads as possible.**"
msgstr ""
"**Si utilizas shaders de terceros o escribes tus propios shaders, intenta "
"utilizar algoritmos que requieran la menor cantidad de lecturas de texturas "
"posible.**"

msgid "Texture compression"
msgstr "Compresión de texturas"

msgid ""
"By default, Godot compresses textures of 3D models when imported using video "
"RAM (VRAM) compression. Video RAM compression isn't as efficient in size as "
"PNG or JPG when stored, but increases performance enormously when drawing "
"large enough textures."
msgstr ""
"De forma predeterminada, Godot comprime las texturas de los modelos 3D "
"cuando se importan mediante compresión de RAM de vídeo (VRAM). La compresión "
"de la RAM de video no es tan eficiente en tamaño como PNG o JPG cuando se "
"almacena, pero aumenta enormemente el rendimiento al dibujar texturas lo "
"suficientemente grandes."

msgid ""
"This is because the main goal of texture compression is bandwidth reduction "
"between memory and the GPU."
msgstr ""
"Esto se debe a que el objetivo principal de la compresión de texturas es la "
"reducción del ancho de banda entre la memoria y la GPU."

msgid ""
"In 3D, the shapes of objects depend more on the geometry than the texture, "
"so compression is generally not noticeable. In 2D, compression depends more "
"on shapes inside the textures, so the artifacts resulting from 2D "
"compression are more noticeable."
msgstr ""
"En 3D, la forma de los objetos depende más de la geometría que de la "
"textura, por lo que la compresión generalmente no se nota. En 2D, la "
"compresión depende más de las formas dentro de las texturas, por lo que el "
"resultado de la compresión es más visible."

msgid ""
"As a warning, most Android devices do not support texture compression of "
"textures with transparency (only opaque), so keep this in mind."
msgstr ""
"A modo de advertencia, la mayoría de los dispositivos Android no admiten la "
"compresión de texturas con transparencia (sólo opacas), así que tenlo en "
"cuenta."

msgid ""
"Even in 3D, \"pixel art\" textures should have VRAM compression disabled as "
"it will negatively affect their appearance, without improving performance "
"significantly due to their low resolution."
msgstr ""
"Incluso en entornos 3D, las texturas de \"pixel art\" deberían tener la "
"compresión de VRAM desactivada, ya que esto afectará negativamente su "
"apariencia sin mejorar significativamente el rendimiento debido a su baja "
"resolución."

msgid "Post-processing and shadows"
msgstr "Postprocesamiento y sombras"

msgid ""
"Post-processing effects and shadows can also be expensive in terms of "
"fragment shading activity. Always test the impact of these on different "
"hardware."
msgstr ""
"Los efectos de posprocesamiento y las sombras también pueden ser costosos en "
"términos de actividad de fragment shading. Siempre prueba el impacto de "
"estos en diferentes hardware."

msgid ""
"**Reducing the size of shadowmaps can increase performance**, both in terms "
"of writing and reading the shadowmaps. On top of that, the best way to "
"improve performance of shadows is to turn shadows off for as many lights and "
"objects as possible. Smaller or distant OmniLights/SpotLights can often have "
"their shadows disabled with only a small visual impact."
msgstr ""
"**Reducir el tamaño de los shadowmaps puede aumentar el rendimiento**, tanto "
"en términos de escritura como de lectura de los shadowmaps. Además, la mejor "
"manera de mejorar el rendimiento de las sombras es desactivar las sombras "
"para tantas luces y objetos como sea posible. Las OmniLights/SpotLights más "
"pequeñas o distantes a menudo pueden tener sus sombras desactivadas con un "
"impacto visual mínimo."

msgid "Transparency and blending"
msgstr "Transparencia y mezcla"

msgid ""
"Transparent objects present particular problems for rendering efficiency. "
"Opaque objects (especially in 3D) can be essentially rendered in any order "
"and the Z-buffer will ensure that only the front most objects get shaded. "
"Transparent or blended objects are different. In most cases, they cannot "
"rely on the Z-buffer and must be rendered in \"painter's order\" (i.e. from "
"back to front) to look correct."
msgstr ""
"Los objetos transparentes presentan problemas particulares para la "
"eficiencia del renderizado. Los objetos opacos (especialmente en 3D) pueden "
"ser renderizados básicamente en cualquier orden y el Z-buffer se encargará "
"de asegurar que solo los objetos más cercanos se sombreen. Sin embargo, los "
"objetos transparentes o con mezcla son diferentes. En la mayoría de los "
"casos, no pueden depender del Z-buffer y deben ser renderizados en \"orden "
"de pintor\" (es decir, de atrás hacia adelante) para lucir correctamente."

msgid ""
"Transparent objects are also particularly bad for fill rate, because every "
"item has to be drawn even if other transparent objects will be drawn on top "
"later on."
msgstr ""
"Los objetos transparentes también son particularmente problemáticos en "
"términos de fill rate, ya que cada elemento debe ser dibujado incluso si "
"otros objetos transparentes se dibujarán encima más adelante."

msgid ""
"Opaque objects don't have to do this. They can usually take advantage of the "
"Z-buffer by writing to the Z-buffer only first, then only performing the "
"fragment shader on the \"winning\" fragment, the object that is at the front "
"at a particular pixel."
msgstr ""
"Los objetos opacos no tienen que hacer esto. Por lo general, pueden "
"aprovechar el Z-buffer al escribir en él solo en primer lugar, y luego "
"realizar el fragment shader solo en el fragmento \"ganador\", es decir, en "
"el objeto que se encuentra en primer plano en un píxel en particular."

msgid ""
"Transparency is particularly expensive where multiple transparent objects "
"overlap. It is usually better to use transparent areas as small as possible "
"to minimize these fill rate requirements, especially on mobile, where fill "
"rate is very expensive. Indeed, in many situations, rendering more complex "
"opaque geometry can end up being faster than using transparency to \"cheat\"."
msgstr ""
"La transparencia es particularmente costosa cuando se superponen varios "
"objetos transparentes. Por lo general, es mejor utilizar áreas transparentes "
"lo más pequeñas posible para minimizar los requisitos de fill rate, "
"especialmente en dispositivos móviles, donde el fill rate es muy costoso. De "
"hecho, en muchas situaciones, renderizar geometría opaca más compleja puede "
"resultar más rápido que utilizar transparencia para \"engañar\"."

msgid "Multi-platform advice"
msgstr "Asesoramiento multiplataforma"

msgid ""
"If you are aiming to release on multiple platforms, test *early* and test "
"*often* on all your platforms, especially mobile. Developing a game on "
"desktop but attempting to port it to mobile at the last minute is a recipe "
"for disaster."
msgstr ""
"Si tienes como objetivo lanzar en múltiples plataformas, realiza pruebas "
"*tempranas* y *frecuentes* en todas tus plataformas, especialmente en "
"dispositivos móviles. Desarrollar un juego en escritorio pero intentar "
"realizar el port a móvil en el último momento es una receta para el desastre."

#, fuzzy
msgid ""
"In general, you should design your game for the lowest common denominator, "
"then add optional enhancements for more powerful platforms. For example, you "
"may want to use the Compatibility rendering method for both desktop and "
"mobile platforms where you target both."
msgstr ""
"En general, debes diseñar tu juego para el nivel más bajo de rendimiento y "
"luego agregar mejoras opcionales para plataformas más potentes. Por ejemplo, "
"es posible que desees utilizar el backend de GLES2 tanto para plataformas de "
"escritorio como para dispositivos móviles si estás apuntando a ambos."

msgid "Mobile/tiled renderers"
msgstr "Renderizadores móviles/tileados"

msgid ""
"As described above, GPUs on mobile devices work in dramatically different "
"ways from GPUs on desktop. Most mobile devices use tile renderers. Tile "
"renderers split up the screen into regular-sized tiles that fit into super "
"fast cache memory, which reduces the number of read/write operations to the "
"main memory."
msgstr ""
"Como se describió anteriormente, las GPUs en dispositivos móviles funcionan "
"de manera dramáticamente diferente a las GPUs en computadoras de escritorio. "
"La mayoría de los dispositivos móviles utilizan renderizadores de tipo "
"tileado. Los renderizadores de tipo tileado dividen la pantalla en pequeños "
"azulejos de tamaño regular que se ajustan en la memoria caché súper rápida, "
"lo cual reduce la cantidad de operaciones de lectura/escritura en la memoria "
"principal."

msgid ""
"There are some downsides though. Tiled rendering can make certain techniques "
"much more complicated and expensive to perform. Tiles that rely on the "
"results of rendering in different tiles or on the results of earlier "
"operations being preserved can be very slow. Be very careful to test the "
"performance of shaders, viewport textures and post processing."
msgstr ""
"Sin embargo, existen algunas desventajas. El renderizado tileado puede hacer "
"que ciertas técnicas sean mucho más complicadas y costosas de realizar. Los "
"azulejos que dependen de los resultados del renderizado en diferentes "
"azulejos o de que los resultados de operaciones anteriores se conserven "
"pueden ser muy lentos. Ten mucho cuidado al probar el rendimiento de los "
"shaders, las texturas del viewport y el procesamiento posterior."

msgid "Translation status"
msgstr "Estado de traducción"
