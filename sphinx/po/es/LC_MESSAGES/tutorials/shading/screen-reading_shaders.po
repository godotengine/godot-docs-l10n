# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-19 11:09+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:4
msgid "Screen-reading shaders"
msgstr "Shaders de lectura de pantalla"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:7
msgid "Introduction"
msgstr "Introducción"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:9
#, fuzzy
msgid ""
"It is often desired to make a shader that reads from the same screen to "
"which it's writing. 3D APIs, such as OpenGL or DirectX, make this very "
"difficult because of internal hardware limitations. GPUs are extremely "
"parallel, so reading and writing causes all sorts of cache and coherency "
"problems. As a result, not even the most modern hardware supports this "
"properly."
msgstr ""
"Muy a menudo, se desea hace un shader que lea desde la misma pantalla en la "
"que está escribiendo. Las API de 3D, como OpenGL o DirectX, lo hacen muy "
"difícil debido a las limitaciones internas del hardware. Las GPU son "
"extremadamente paralelas, por lo que la lectura y la escritura causan todo "
"tipo de problemas de caché y coherencia. Como resultado, ni siquiera el "
"hardware más moderno lo soporta adecuadamente."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:16
msgid ""
"The workaround is to make a copy of the screen, or a part of the screen, to "
"a back-buffer and then read from it while drawing. Godot provides a few "
"tools that make this process easy."
msgstr ""
"La solución alternativa es hacer una copia de la pantalla, o una parte de la "
"pantalla, en un búfer de respaldo y luego leer de él mientras dibuja. Godot "
"proporciona algunas herramientas que facilitan este proceso."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:21
msgid "SCREEN_TEXTURE built-in texture"
msgstr "SCREEN_TEXTURE textura incorporada"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:23
msgid ""
"Godot :ref:`doc_shading_language` has a special texture, ``SCREEN_TEXTURE`` "
"(and ``DEPTH_TEXTURE`` for depth, in the case of 3D). It takes as argument "
"the UV of the screen and returns a vec3 RGB with the color. A special built-"
"in varying: SCREEN_UV can be used to obtain the UV for the current fragment. "
"As a result, this simple canvas_item fragment shader:"
msgstr ""
"Godot :ref:`doc_shading_language` tiene una textura especial, "
"``SCREEN_TEXTURE`` (y ``DEPTH_TEXTURE`` para la profundidad, en el caso de "
"3D). Toma como argumento el UV de la pantalla y devuelve un vec3 RGB con el "
"color. Una variación especial incorporada: SCREEN_UV puede ser usado para "
"obtener el UV del fragmento actual. Como resultado, este simple shader de "
"fragmentos de canvas_item:"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:34
msgid "results in an invisible object, because it just shows what lies behind."
msgstr "resulta en un objeto invisible, porque sólo muestra lo que hay detrás."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:36
msgid ""
"The reason why textureLod must be used is because, when Godot copies back a "
"chunk of the screen, it also does an efficient separatable gaussian blur to "
"its mipmaps."
msgstr ""
"La razón por la que debe usarse textureLod es porque, cuando Godot copia un "
"trozo de la pantalla, también hace un eficiente desenfoque gaussiano "
"separable en sus mipmaps."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:39
msgid ""
"This allows for not only reading from the screen, but reading from it with "
"different amounts of blur at no cost."
msgstr ""
"Esto permite no sólo leer de la pantalla, sino leer de ella con diferentes "
"cantidades de borrosidad sin costo alguno."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:44
msgid ""
"Mipmaps are not generated in GLES2 due to poor performance and compatibility "
"with older devices."
msgstr ""
"Los Mipmaps no se generan en GLES2 debido al pobre rendimiento y la "
"compatibilidad con los dispositivos más antiguos."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:48
msgid "SCREEN_TEXTURE example"
msgstr "ejemplo de SCREEN_TEXTURE"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:50
msgid ""
"``SCREEN_TEXTURE`` can be used for many things. There is a special demo for "
"*Screen Space Shaders*, that you can download to see and learn. One example "
"is a simple shader to adjust brightness, contrast and saturation:"
msgstr ""
"``SCREEN_TEXTURE`` puede ser usada para muchas cosas. Hay una demo especial "
"para *Screen Spade Shader*, que puedes descargar para ver y aprender. Un "
"ejemplo es un simple shader para ajustar el brillo, el contraste y la "
"saturación:"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:74
msgid "Behind the scenes"
msgstr "Entre bastidores"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:76
msgid ""
"While this seems magical, it's not. In 2D, the ``SCREEN_TEXTURE`` built-in, "
"when first found in a node that is about to be drawn, does a full-screen "
"copy to a back-buffer. Subsequent nodes that use it in shaders will not have "
"the screen copied for them, because this ends up being inefficient. In 3D, "
"the screen is copied after the opaque geometry pass, but before the "
"transparent geometry pass, so transparent objects will not be captured in "
"the ``SCREEN_TEXTURE``."
msgstr ""
"Aunque esto parece mágico, no lo es. En 2D, la ``SCREEN_TEXTURE`` "
"incorporada, cuando se encuentra por primera vez en un nodo que está a punto "
"de ser dibujado, hace una copia a pantalla completa a un búfer trasero. Los "
"nodos subsiguientes que lo usan en los shaders no tendrán la pantalla "
"copiada para ellos, porque esto termina siendo ineficiente. En 3D, la "
"pantalla se copia después de la pasada de geometría opaca, pero antes de la "
"pasada de geometría transparente, por lo que los objetos transparentes no "
"serán capturados en la ``SCREEN_TEXTURE``."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:84
msgid ""
"As a result, in 2D, if shaders that use ``SCREEN_TEXTURE`` overlap, the "
"second one will not use the result of the first one, resulting in unexpected "
"visuals:"
msgstr ""
"Como resultado, en 2D, si los shaders que usan ``SCREEN_TEXTURE`` se "
"superponen, el segundo no usará el resultado del primero, resultando en "
"visuales inesperados:"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:90
msgid ""
"In the above image, the second sphere (top right) is using the same source "
"for ``SCREEN_TEXTURE`` as the first one below, so the first one \"disappears"
"\", or is not visible."
msgstr ""
"En la imagen de arriba, la segunda esfera (arriba a la derecha) está usando "
"la misma fuente de ``SCREEN_TEXTURE`` que la primera de abajo, por lo que la "
"primera \"desaparece\", o no es visible."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:94
msgid ""
"In 2D, this can be corrected via the :ref:`BackBufferCopy "
"<class_BackBufferCopy>` node, which can be instantiated between both "
"spheres. BackBufferCopy can work by either specifying a screen region or the "
"whole screen:"
msgstr ""
"En 2D, esto puede ser corregido a través del nodo :ref:`BackBufferCopy "
"<class_BackBufferCopy>`, que puede ser instanciado entre ambas esferas. "
"BackBufferCopy puede funcionar especificando una región de la pantalla o la "
"pantalla completa:"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:100
msgid "With correct back-buffer copying, the two spheres blend correctly:"
msgstr ""
"Con la copia correcta de la memoria intermedia, las dos esferas se mezclan "
"correctamente:"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:111
msgid ""
"In 3D, there is less flexibility to solve this particular issue because the "
"``SCREEN_TEXTURE`` is only captured once. Be careful when using "
"``SCREEN_TEXTURE`` in 3D as it won't capture transparent objects and may "
"capture some opaque objects that are in front of the object."
msgstr ""
"En 3D, hay menos flexibilidad para resolver este problema en particular "
"porque la ``SCREEN_TEXTURE`` sólo se captura una vez. Tenga cuidado al usar "
"\"SCREEN_TEXTURE\" en 3D, ya que no capturará objetos transparentes y puede "
"capturar algunos objetos opacos que están en frente del objeto."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:116
msgid ""
"You can reproduce the back-buffer logic in 3D by creating a :ref:`Viewport "
"<class_Viewport>` with a camera in the same position as your object, and "
"then use the :ref:`Viewport's <class_Viewport>` texture instead of "
"``SCREEN_TEXTURE``."
msgstr ""
"Puedes reproducir la lógica del búfer trasero en 3D creando un :ref:"
"`Viewport <class_Viewport>` con una cámara en la misma posición que tu "
"objeto, y luego usar la textura :ref:`Viewport's <class_Viewport>` en lugar "
"de ``SCREEN_TEXTURE``."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:121
msgid "Back-buffer logic"
msgstr "Lógica del Back-buffer"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:123
msgid ""
"So, to make it clearer, here's how the backbuffer copying logic works in "
"Godot:"
msgstr ""
"Así que, para dejarlo más claro, así es como funciona la lógica de copia del "
"backbuffer en Godot:"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:126
msgid ""
"If a node uses the ``SCREEN_TEXTURE``, the entire screen is copied to the "
"back buffer before drawing that node. This only happens the first time; "
"subsequent nodes do not trigger this."
msgstr ""
"Si un nodo utiliza la ``SCREEN_TEXTURE``, la pantalla entera se copia en el "
"buffer de atrás antes de dibujar ese nodo. Esto sólo ocurre la primera vez; "
"los nodos subsiguientes no lo activan."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:129
msgid ""
"If a BackBufferCopy node was processed before the situation in the point "
"above (even if ``SCREEN_TEXTURE`` was not used), the behavior described in "
"the point above does not happen. In other words, automatic copying of the "
"entire screen only happens if ``SCREEN_TEXTURE`` is used in a node for the "
"first time and no BackBufferCopy node (not disabled) was found before in "
"tree-order."
msgstr ""
"Si un nodo BackBufferCopy fue procesado antes de la situación en el punto "
"anterior (incluso si no se usó ``SCREEN_TEXTURE``), el comportamiento "
"descrito en el punto anterior no ocurre. En otras palabras, el copiado "
"automático de toda la pantalla sólo ocurre si ``SCREEN_TEXTURE`` se usa en "
"un nodo por primera vez y no se encontró antes un nodo BackBufferCopy (no "
"deshabilitado) en el orden del árbol."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:135
msgid ""
"BackBufferCopy can copy either the entire screen or a region. If set to only "
"a region (not the whole screen) and your shader uses pixels not in the "
"region copied, the result of that read is undefined (most likely garbage "
"from previous frames). In other words, it's possible to use BackBufferCopy "
"to copy back a region of the screen and then use ``SCREEN_TEXTURE`` on a "
"different region. Avoid this behavior!"
msgstr ""
"BackBufferCopy puede copiar la pantalla completa o una región. Si se "
"configura sólo una región (no toda la pantalla) y el shader utiliza píxeles "
"que no están en la región copiada, el resultado de esa lectura es indefinido "
"(lo más probable es que sea basura de fotogramas). En otras palabras, es "
"posible usar BackBufferCopy para copiar una región de la pantalla y luego "
"usar \"SCREEN_TEXTURE\" en una región diferente. ¡Evita este comportamiento!"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:144
msgid "DEPTH_TEXTURE"
msgstr "DEPTH_TEXTURE"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:146
#, fuzzy
msgid ""
"For 3D shaders, it's also possible to access the screen depth buffer. For "
"this, the ``DEPTH_TEXTURE`` built-in is used. This texture is not linear; it "
"must be converted via the inverse projection matrix."
msgstr ""
"Para los Shaders 3D, también es posible acceder al buffer de profundidad de "
"la pantalla. Para ello, se utiliza la ``DEPTH_TEXTURE`` incorporada. Esta "
"textura no es lineal; debe ser convertida a través de la matriz de "
"proyección inversa."

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:150
msgid ""
"The following code retrieves the 3D position below the pixel being drawn:"
msgstr ""
"El siguiente código recupera la posición 3D debajo del píxel que se está "
"dibujando:"
