# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "VR starter tutorial part 2"
msgstr "Tutorial VR para principiantes parte 2"

msgid "Introduction"
msgstr "Introducción"

msgid ""
"In this part of the VR starter tutorial series, we will be adding a number "
"of special :ref:`RigidBody <class_RigidBody>`-based nodes that can be used "
"in VR."
msgstr ""
"En esta parte de la serie de tutoriales de inicio de la RV, añadiremos una "
"serie de nodos especiales basados en :ref:`RigidBody <class_RigidBody>` que "
"pueden ser utilizados en la RV."

msgid ""
"This continues from where we left on in the last tutorial part, where we "
"just finished getting the VR controllers working and defined a custom class "
"called ``VR_Interactable_Rigidbody``."
msgstr ""
"Esto continúa desde donde lo dejamos en la última parte del tutorial, donde "
"acabamos de terminar de hacer funcionar los controladores de RV y definimos "
"una clase personalizada llamada ``VR_Interactable_Rigidbody``."

msgid ""
"You can find the finished project on the `OpenVR GitHub repository <https://"
"github.com/GodotVR/godot_openvr_fps>`__."
msgstr ""
"Puedes encontrar el proyecto terminado en el repositorio de GitHub de "
"OpenVR: `https://github.com/GodotVR/godot_openvr_fps`__."

msgid "Adding destroyable targets"
msgstr "Añadir objetivos destruibles"

msgid ""
"Before we make any of the special :ref:`RigidBody <class_RigidBody>`-based "
"nodes, we need something for them to do. Let's make a simple sphere target "
"that will break into a bunch of pieces when destroyed."
msgstr ""
"Antes de hacer cualquiera de los nodos especiales :ref:`RigidBody "
"<class_RigidBody>` basados en el cuerpo, necesitamos algo para que hagan. "
"Hagamos una simple esfera objetivo que se rompa en un montón de pedazos "
"cuando sea destruida."

msgid ""
"Open up ``Sphere_Target.tscn``, which is in the ``Scenes`` folder. The scene "
"is fairly simple, with just a :ref:`StaticBody <class_StaticBody>` with a "
"sphere shaped :ref:`CollisionShape <class_CollisionShape>`, a :ref:"
"`MeshInstance <class_MeshInstance>` node displaying a sphere mesh, and an :"
"ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node."
msgstr ""
"Abre \"Sphere_Target.tscn\", que está en la carpeta ``Scenes``. La escena es "
"bastante simple, con sólo un nodo :ref:`StaticBody <class_StaticBody>` con "
"forma de esfera :ref:`CollisionShape <class_CollisionShape>`, un nodo :ref:"
"`MeshInstance <class_MeshInstance>` que muestra una malla de esfera, y un "
"nodo :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>`."

msgid ""
"The special :ref:`RigidBody <class_RigidBody>` nodes will handle damaging "
"the sphere, which is why we are using a :ref:`StaticBody <class_StaticBody>` "
"node instead of something like an :ref:`Area <class_Area>` or :ref:"
"`RigidBody <class_RigidBody>` node. Outside of that, there isn't really a "
"lot to talk about, so let's move straight into writing the code."
msgstr ""
"Los nodos especiales :ref:`RigidBody <class_RigidBody>` se encargarán de "
"dañar la esfera, por lo que estamos usando un nodo :ref:`StaticBody "
"<class_StaticBody>` en lugar de algo como un nodo :ref:`Area <class_Area>` "
"o :ref:`RigidBody <class_RigidBody>`. Fuera de eso, no hay mucho de que "
"hablar, así que vamos a pasar directamente a escribir el código."

msgid ""
"Select the ``Sphere_Target_Root`` node and make a new script called "
"``Sphere_Target.gd``. Add the following code:"
msgstr ""
"Selecciona el nodo ``Sphere_Target_Root`` y haz un nuevo script llamado "
"``Sphere_Target.gd``. Añade el siguiente código:"

msgid "Let's go over how this script works."
msgstr "Repasemos lo que hace este script."

msgid "Explaining the Sphere Target code"
msgstr "Explicación del código del objetivo de la Esfera"

msgid "First, let's go through all the class variables in the script:"
msgstr "Primero, veamos todas las variables de la clase en el script:"

msgid ""
"``destroyed``: A variable to track whether the sphere target has been "
"destroyed."
msgstr ""
"``destroyed``: Una variable para verificar si la esfera usada como blanco "
"fue destruida."

msgid ""
"``destroyed_timer``: A variable to track how long the sphere target has been "
"destroyed."
msgstr ""
"``destroyed_timer``: Una variable usada para verificar cuánto tiempo a "
"transcurrido desde que la esfera fue destruida."

msgid ""
"``DESTROY_WAIT_TIME``: A constant to define the length of time the target "
"can be destroyed for before it frees/deletes itself."
msgstr ""
"``DESTROY_WAIT_TIME``: Una constante para definir el tiempo durante el cual "
"el objetivo puede ser destruido antes de que se libere/elimine."

msgid ""
"``health``: A variable to store the amount of health the sphere target has."
msgstr ""
"``health``: Una variable que guarda la cantidad de salud que tiene el blanco."

msgid ""
"``RIGID_BODY_TARGET``: A constant to hold the scene of the destroyed sphere "
"target."
msgstr ""
"``RIGID_BODY_TARGET``: Una constante para mantener la escena del objetivo de "
"la esfera destruida."

msgid ""
"Feel free to check out the ``RIGID_BODY_TARGET`` scene. It is just a bunch "
"of :ref:`RigidBody <class_RigidBody>` nodes and a broken sphere model."
msgstr ""
"Siéntete libre de ver la escena de `RIGID_BODY_TARGET``. Es sólo un montón "
"de nodos de :ref:`RigidBody <class_RigidBody>` y un modelo de esfera rota."

msgid ""
"We'll be instancing this scene so when the target is destroyed, it looks "
"like it broke into a bunch of pieces."
msgstr ""
"Instalaremos esta escena para que cuando el objetivo sea destruido, parezca "
"que se rompió en un montón de pedazos."

msgid "``_ready`` function step-by-step explanation"
msgstr "``_ready``explicación paso a paso de la función"

msgid ""
"All the ``_ready`` function does is that it stops the ``_physics_process`` "
"from being called by calling ``set_physics_process`` and passing ``false``. "
"The reason we do this is because all the code in ``_physics_process`` is for "
"destroying this node when enough time has passed, which we only want to do "
"when the target has been destroyed."
msgstr ""
"Todo lo que hace la función `_ready` es que evita que el "
"``_physics_process`` sea llamado llamando ``set_physics_process`` y pasando "
"``false``. La razón por la que hacemos esto es porque todo el código en "
"``_physics_process`` es para destruir este nodo cuando ha pasado suficiente "
"tiempo, lo que sólo queremos hacer cuando el objetivo ha sido destruido."

msgid "``_physics_process`` function step-by-step explanation"
msgstr "``_physics_process`` explicación paso a paso de la función"

msgid ""
"First this function adds time, ``delta``, to the ``destroyed_timer`` "
"variable. It then checks to see if ``destroyed_timer`` is greater than or "
"equal to ``DESTROY_WAIT_TIME``. If ``destroyed_timer`` is greater than or "
"equal to ``DESTROY_WAIT_TIME``, then the sphere target frees/deletes itself "
"by calling the ``queue_free`` function."
msgstr ""
"Primero esta función añade tiempo, ``delta``, a la variable "
"``destroyed_timer``. Luego comprueba si el ``destroyed_timer`` es mayor o "
"igual al ``DESTROY_WAIT_TIM``. Si ``destroyed_timer`` es mayor o igual a "
"``DESTROY_WAIT_TIME``, entonces el objetivo de la esfera se libera/borra a "
"sí mismo llamando a la función ``queue_free``."

msgid "``damage`` function step-by-step explanation"
msgstr "explicación paso a paso de la función ``damage``"

msgid ""
"The ``damage`` function will be called by the special :ref:`RigidBody "
"<class_RigidBody>` nodes, which will pass the amount of damage done to the "
"target, which is a function argument variable called ``damage``. The "
"``damage`` variable will hold the amount of damage the special :ref:"
"`RigidBody <class_RigidBody>` node did to the sphere target."
msgstr ""
"La función ``damage`` será llamada por los nodos especiales :ref:`RigidBody "
"<class_RigidBody>`, que pasarán la cantidad de daño hecho al objetivo, que "
"es una variable de argumento de la función llamada ``damage``. La variable "
"``damage`` contendrá la cantidad de daño que el nodo especial :ref:"
"`RigidBody <class_RigidBody>` hizo al objetivo de la esfera."

msgid ""
"First this function checks to make sure the target is not already destroyed "
"by checking if the ``destroyed`` variable is equal to ``true``. If "
"``destroyed`` is equal to ``true``, then the function calls ``return`` so "
"none of the other code is called. This is just a safety check so that if two "
"things damage the target at exactly the same time, the target cannot be "
"destroyed twice."
msgstr ""
"Primero esta función comprueba que el objetivo no esté ya destruido "
"comprobando si la variable ``destroyed`` es igual a ``true``. Si "
"``destroyed`` es igual a ``true``, entonces la función llama ``return`` para "
"que no se llame a ningún otro código. Esto es sólo una comprobación de "
"seguridad para que si dos cosas dañan el objetivo exactamente al mismo "
"tiempo, el objetivo no pueda ser destruido dos veces."

msgid ""
"Next the function removes the amount of damage taken, ``damage``, from the "
"target's health, ``health``. If then checks to see if ``health`` is equal to "
"zero or less, meaning that the target has just been destroyed."
msgstr ""
"A continuación, la función elimina la cantidad de daño tomado, ``damage``, "
"de la salud del objetivo, ``health``. Entonces comprueba si la ``health`` es "
"igual a cero o menos, lo que significa que el objetivo acaba de ser "
"destruido."

msgid ""
"If the target has just been destroyed, then we disable the :ref:"
"`CollisionShape <class_CollisionShape>` by setting it's ``disabled`` "
"property to ``true``. We then make the ``Sphere_Target`` :ref:`MeshInstance "
"<class_MeshInstance>` invisible by setting the ``visible`` property to "
"``false``. We do this so the target can no longer effect the physics world "
"and so the non-broken target mesh is not visible."
msgstr ""
"Si el objetivo acaba de ser destruido, entonces deshabilitamos la :ref:"
"`CollisionShape <class_CollisionShape>` estableciendo su propiedad "
"``disabled`` como ``true``. Luego hacemos que el ``Sphere_Target`` :ref:"
"`MeshInstance <class_MeshInstance>` sea invisible poniendo la propiedad "
"``visible`` a ``false``. Hacemos esto para que el objetivo ya no pueda "
"afectar al mundo de la física y para que la malla del objetivo no rota no "
"sea visible."

msgid ""
"After this the function then instances the ``RIGID_BODY_TARGET`` scene and "
"adds it as a child of the target. It then sets the ``global_transform`` of "
"the newly instanced scene, called ``clone``, to the ``global_transform`` of "
"the non-broken target. This makes it where the broken target starts at the "
"same position as the non-broken target with the same rotation and scale."
msgstr ""
"Después de esto, la función entonces instancia la escena "
"``RIGID_BODY_TARGET`` y la agrega como un hijo del objetivo. Luego establece "
"la ``global_transform`` de la escena recién creada, llamada ``clone``, a la "
"``global_transform`` del objetivo no roto. Esto hace que el objetivo roto "
"comience en la misma posición que el objetivo no roto con la misma rotación "
"y escala."

msgid ""
"Then the function sets the ``destroyed`` variable to ``true`` so the target "
"knows it has been destroyed and calls the ``set_physics_process`` function "
"and passes ``true``. This will start executing the code in "
"``_physics_process`` so that after ``DESTROY_WAIT_TIME`` seconds have "
"passed, the sphere target will free/destroy itself."
msgstr ""
"Luego la función pone la variable ``destroyed``\" en ``true`` para que el "
"objetivo sepa que ha sido destruido y llama a la función "
"``set_physics_process`` y pasa a ``true``. Esto comenzará a ejecutar el "
"código en ``physics_process`` para que después de ``DESTROY_WAIT_TIME`` "
"segundos hayan pasado, el objetivo de la esfera se libere/destruya a sí "
"mismo."

msgid ""
"The function then gets the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node and calls the ``play`` function so it "
"plays its sound."
msgstr ""
"La función entonces obtiene el nodo :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` y llama a la función ``play`` para que "
"reproduzca su sonido."

msgid ""
"Finally, the ``remove_sphere`` function is called in ``Game.gd``. To get "
"``Game.gd``, the code uses the scene tree and works its way from the root of "
"the scene tree to the root of the ``Game.tscn`` scene."
msgstr ""
"Finalmente, la función ``remove_sphere`` es llamada en ``Game.gd``. Para "
"obtener ``Game.gd``, el código usa el árbol de la escena y trabaja desde la "
"raíz del árbol de la escena hasta la raíz de la escena ``Game.tscn``."

msgid "Adding the ``remove_sphere`` function to ``Game.gd``"
msgstr "Añadiendo la función ``remove_sphere`` a ``Game.gd``"

msgid ""
"You may have noticed we are calling a function in ``Game.gd``, called "
"``remove_sphere``, that we have not defined yet. Open up ``Game.gd`` and add "
"the following additional class variables:"
msgstr ""
"Habrás notado que estamos llamando a una función en ``Game.gd``, llamada "
"``remove_sphere``, que aún no hemos definido. Abre ``Game.gd`` y añade las "
"siguientes variables de clase adicionales:"

msgid ""
"``spheres_left``: The amount of sphere targets left in the world. In the "
"provided ``Game`` scene, there are ``10`` spheres, so that is the initial "
"value."
msgstr ""
"``spheres_left``: La cantidad de objetivos de la esfera que quedan en el "
"mundo. En la escena del ``Game``, hay ``10`` esferas, así que ese es el "
"valor inicial."

msgid ""
"``sphere_ui``: A reference to the sphere UI. We will use this later in the "
"tutorial to display the amount of spheres left in the world."
msgstr ""
"``sphere_ui``: Una referencia a la esfera UI. Usaremos esto más adelante en "
"el tutorial para mostrar la cantidad de esferas que quedan en el mundo."

msgid ""
"With these variables defined, we can now add the ``remove_sphere`` function. "
"Add the following code to ``Game.gd``:"
msgstr ""
"Con estas variables definidas, ahora podemos agregar la función "
"``remove_sphere``. Añade el siguiente código a ``Game.gd``:"

msgid "Let's go through what this function does real quick:"
msgstr "Repasemos rápidamente lo que hace esta función:"

msgid ""
"First, it removes one from the ``spheres_left`` variable. It then checks to "
"see if the ``sphere_ui`` variable is not equal to ``null``, and if it is not "
"equal to ``null`` it calls the ``update_ui`` function on ``sphere_ui``, "
"passing in the number of spheres as an argument to the function."
msgstr ""
"Primero, elimina uno de la variable ``spheres_left``. Luego comprueba si la "
"variable ``sphere_ui`` no es igual a ``null``, y si no es igual a ``null`` "
"llama a la función ``update_ui`` en ``sphere_ui``, pasando el número de "
"esferas como un argumento a la función."

msgid "We will add the code for ``sphere_ui`` later in this tutorial!"
msgstr "¡Añadiremos el código de ``sphere_ui`` más adelante en este tutorial!"

msgid ""
"Now the ``Sphere_Target`` is ready to be used, but we don't have any way to "
"destroy it. Let's fix that by adding some special :ref:`RigidBody "
"<class_RigidBody>`-based nodes that can damage the targets."
msgstr ""
"Ahora el ``Sphere_Target`` está listo para ser usado, pero no tenemos "
"ninguna manera de destruirlo. Arreglémoslo añadiendo algunos nodos "
"especiales :ref:`RigidBody <class_RigidBody>` basados en nodos que puedan "
"dañar los objetivos."

msgid "Adding a pistol"
msgstr "Añadir una pistola"

msgid ""
"Let's add a pistol as the first interactable :ref:`RigidBody "
"<class_RigidBody>` node. Open up ``Pistol.tscn``, which you can find in the "
"``Scenes`` folder."
msgstr ""
"Añadamos una pistola como el primer nodo interactivo :ref:`RigidBody "
"<clase_RigidBody>`. Abre \"Pistol.tscn\", que puedes encontrar en la carpeta "
"\"Scenes\"."

msgid ""
"Let's quickly go over a few things of note in ``Pistol.tscn`` real quick "
"before we add the code."
msgstr ""
"Repasemos rápidamente algunas cosas importantes en ``Pistol.tscn`` antes de "
"agregar el código."

msgid ""
"All of the nodes in ``Pistol.tscn`` expect the root node are rotated. This "
"is so the pistol is in the correct rotation relative to the VR controller "
"when it is picked up. The root node is a :ref:`RigidBody <class_RigidBody>` "
"node, which we need because we're going to use the "
"``VR_Interactable_Rigidbody`` class we created in the last part of this "
"tutorial series."
msgstr ""
"Todos los nodos en ``Pistol.tscn`` esperan que el nodo raíz esté rotado. "
"Esto es así para que la pistola esté en la rotación correcta en relación con "
"el controlador VR cuando se recoge. El nodo raíz es un nodo :ref:`RigidBody "
"<class_RigidBody>`, que necesitamos porque vamos a usar la clase "
"``VR_Interactable_Rigidbody`` que creamos en la última parte de esta serie "
"de tutoriales."

msgid ""
"There is a :ref:`MeshInstance <class_MeshInstance>` node called "
"``Pistol_Flash``, which is a simple mesh that we will be using to simulate "
"the muzzle flash on the end of the pistol's barrel. A :ref:`MeshInstance "
"<class_MeshInstance>` node called ``LaserSight`` is used to as a guide for "
"aiming the pistol, and it follows the direction of the :ref:`Raycast "
"<class_Raycast>` node, called ``Raycast``, that the pistol uses to detect if "
"its 'bullet' hit something. Finally, there is an :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node at the end of the pistol that we will use "
"to play the sound of the pistol firing."
msgstr ""
"Hay un nodo :ref:`MeshInstance <class_MeshInstance>` llamado "
"``Pistol_Flash``, que es una simple malla que usaremos para simular el "
"destello de la boca del cañón de la pistola. Un nodo :ref:`MeshInstance "
"<class_MeshInstance>` llamado ``LaserSight`` se usa como guía para apuntar "
"la pistola, y sigue la dirección del nodo :ref:`Raycast <class_Raycast>`, "
"llamado ``Raycast``, que la pistola usa para detectar si su 'bala' golpea "
"algo. Finalmente, hay un nodo :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` al final de la pistola que usaremos para "
"reproducir el sonido del disparo de la pistola."

msgid ""
"Feel free to look at the other parts of the scene if you want. Most of the "
"scene is fairly straightforward, with the major changes mentioned above. "
"Select the :ref:`RigidBody <class_RigidBody>` node called ``Pistol`` and "
"make a new script called ``Pistol.gd``. Add the following code:"
msgstr ""
"Siéntase libre de mirar las otras partes de la escena si quieres. La mayor "
"parte de la escena es bastante sencilla, con los cambios principales "
"mencionados anteriormente. Selecciona el nodo :ref:`RigidBody "
"<class_RigidBody>` llamado ``Pistol`` y haz un nuevo script llamado ``Pistol."
"gd``. Añade el siguiente código:"

msgid "Explaining the pistol code"
msgstr "Explicando el código de la pistola"

msgid ""
"First, notice how instead of ``extends RigidBody``, we instead have "
"``extends VR_Interactable_Rigidbody``. This makes it where the pistol script "
"extends the ``VR_Interactable_Rigidbody`` class so the VR controllers know "
"this object can be interacted with and that the functions defined in "
"``VR_Interactable_Rigidbody`` can be called when this object is held by a VR "
"controller."
msgstr ""
"Primero, noten cómo en lugar de ``extends RigidBody``, tenemos ``extends "
"VR_Interactable_Rigidbody``. Esto hace que el script de la pistola extienda "
"la clase ``VR_Interactable_Rigidbody`` para que los controladores de VR "
"sepan que este objeto puede ser interactuado y que las funciones definidas "
"en ``VR_Interactable_Rigidbody`` pueden ser llamadas cuando este objeto es "
"sostenido por un controlador de VR."

msgid "Next, let's look at the class variables:"
msgstr "A continuación, veamos las variables de la clase:"

msgid ""
"``flash_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that is used to simulate muzzle flash on the "
"pistol."
msgstr ""
"``flash_mesh``: Una variable para mantener el nodo :ref:`MeshInstance "
"<class_MeshInstance>` usado para simular el resplandor del disparo en la "
"pistola."

msgid ""
"``FLASH_TIME``: A constant to define how long the muzzle flash will be "
"visible. This will also define how fast the pistol can fire."
msgstr ""
"``FLASH_TIME``: Una constante para definir cuánto tiempo será visible el "
"destello del cañón. Esto también definirá cuán rápido puede disparar la "
"pistola."

msgid ""
"``flash_timer``: A variable to hold the amount of time the muzzle flash has "
"been visible for."
msgstr ""
"``flash_timer``: Una variable para mantener el tiempo en que estuvo visible "
"el flash de la boca del arma."

msgid ""
"``laser_sight_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that acts as the pistol's 'laser sight'."
msgstr ""
"``laser_sight_mesh``: Una variable que contiene el nodo :ref:`MeshInstance "
"<class_MeshInstance>` que actúa como 'mira láser' de la pistola."

msgid ""
"``pistol_fire_sound``: A variable to hold the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node used for the pistol's firing sound."
msgstr ""
"``pistol_fire_sound``: Una variable para mantener el nodo :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` usado para el sonido de "
"disparo de la pistola."

msgid ""
"``raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` node that "
"is used for calculating the bullet's position and normal when the pistol is "
"fired."
msgstr ""
"``raycast``: Una variable que contiene el nodo :ref:`Raycast "
"<class_Raycast>` que es usado para calcular la posición de la bala y su "
"normal cuando la pistola es disparada."

msgid ""
"``BULLET_DAMAGE``: A constant to define the amount of damage a single bullet "
"from the pistol does."
msgstr ""
"``BULLET_DAMAGE``: Una constante para definir la cantidad de daño que hace "
"una sola bala de la pistola."

msgid ""
"``COLLISION_FORCE``: A constant that defines the amount of force that is "
"applied to :ref:`RigidBody <class_RigidBody>` nodes when the pistol's bullet "
"collides."
msgstr ""
"``COLLISION_FORCE``: Una constante que define la cantidad de fuerza que se "
"aplica a los nodos :ref:`RigidBody <class_RigidBody>` cuando la bala de la "
"pistola colisiona."

msgid ""
"This function gets the nodes and assigns them to their proper variables. For "
"the ``flash_mesh`` and ``laser_sight_mesh`` nodes, both have their "
"``visible`` property set to ``false`` so they are not visible initially."
msgstr ""
"Esta función obtiene los nodos y los asigna a sus propias variables. Para "
"los nodos ``flash_mesh`` y ``laser_sight_mesh``, ambos tienen su propiedad "
"``visible`` puesta en ``false`` por lo que no son visibles inicialmente."

msgid ""
"The ``_physics_process`` function first checks to see if the pistol's muzzle "
"flash is visible by checking if ``flash_timer`` is more than zero. If "
"``flash_timer`` is more than zero, then we remove time, ``delta`` from it. "
"Next we check if the ``flash_timer`` variable is zero or less now that we "
"removed ``delta`` from it. If it is, then the pistol muzzle flash timer just "
"finished and so we need to make ``flash_mesh`` invisible by setting it's "
"``visible`` property to ``false``."
msgstr ""
"La función ``physics_process`` comprueba primero si el flash del cañón de la "
"pistola es visible comprobando si el ``flash_timer`` es máyor de cero. Si "
"``flash_timer`` es máyor de cero, entonces quitamos el tiempo, ``delta`` de "
"él. A continuación, comprobamos si la variable ``flash_timer`` es cero o "
"menor ahora que hemos eliminado ``delta`` de ella. Si es así, entonces el "
"temporizador de la pistola acaba de terminar y tenemos que hacer invisible "
"la ``flash_mesh`` estableciendo su propiedad ``visible`` como ``false``."

msgid "``interact`` function step-by-step explanation"
msgstr "``interact`` explicación paso a paso de la función"

msgid ""
"The interact function first checks to see if the pistol's muzzle flash is "
"invisible by checking to see if ``flash_timer`` is less than or equal to "
"zero. We do this so we can limit the rate of fire of the pistol to the "
"length of time the muzzle flash is visible, which is a simple solution for "
"limiting how fast the player can fire."
msgstr ""
"La función ``interact`` comprueba primero si el flash del cañón de la "
"pistola es invisible comprobando si el ``flash_timer`` es menor o igual a "
"cero. Hacemos esto para poder limitar la velocidad de disparo de la pistola "
"al tiempo en que el flash de la boca es visible, lo cual es una solución "
"simple para limitar la velocidad de disparo del jugador."

msgid ""
"If ``flash_timer`` is zero or less, we then set ``flash_timer`` to "
"``FLASH_TIME`` so there is a delay before the pistol can fire again. After "
"that we set ``flash_mesh.visible`` to ``true`` so the muzzle flash at the "
"end of the pistol is visible while ``flash_timer`` is more than zero."
msgstr ""
"Si ``flash_timer`` es menor o igual a 0, entonces ponemos ``flash_timer`` a "
"``FLASH_TIME`` para que haya un retraso antes de que la pistola pueda "
"disparar de nuevo. Después de eso ponemos ``flash_mesh.visible`` en ``true`` "
"para que el flash del cañón del arma sea visible mientras que "
"``flash_timer`` sea mayor que cero."

msgid ""
"Next we call the ``force_raycast_update`` function on the :ref:`Raycast "
"<class_Raycast>` node in ``raycast`` so that it gets the latest collision "
"info from the physics world. We then check if the ``raycast`` hit something "
"by checking if the ``is_colliding`` function is equal to ``true``."
msgstr ""
"A continuación llamamos a la función ``force_raycast_update`` en el nodo :"
"ref:`Raycast <class_Raycast>` en ``raycast`` para que reciba la última "
"información sobre colisiones del mundo de la física. Luego verificamos si el "
"``raycast`` golpea algo, verificando si la función ``is_colliding`` es igual "
"a ``true``."

msgid ""
"If the ``raycast`` hit something, then we get the :ref:`PhysicsBody "
"<class_PhysicsBody>` it collided with through the ``get_collider`` function. "
"We assign the hit :ref:`PhysicsBody <class_PhysicsBody>` to a variable "
"called ``body``."
msgstr ""
"Si el ``raycast`` golpea algo, entonces obtenemos el :ref:`PhysicsBody "
"<class_PhysicsBody>` con el que colisionó a través de la función "
"``get_collider``. Asignamos el hit :ref:`PhysicsBody <class_PhysicsBody>` a "
"una variable llamada ``body``."

msgid ""
"We then get the direction of the :ref:`Raycast <class_Raycast>` by getting "
"it's positive ``Z`` directional axis from the :ref:`Basis <class_Basis>` on "
"the ``raycast`` node's ``global_transform``. This will give us the direction "
"the raycast is pointing on the Z axis, which is the same direction as the "
"blue arrow on the :ref:`Spatial <class_Spatial>` gizmo when ``Local space "
"mode`` is enabled in the Godot editor. We store this direction in a variable "
"called ``direction_vector``."
msgstr ""
"Entonces obtenemos la dirección del :ref:`Raycast <class_Raycast>` "
"obteniendo su eje direccional positivo ``Z`` de la :ref:`Base <class_Basis>` "
"en la ``global_transform`` del nodo ``raycast``. Esto nos dará la dirección "
"en la que el raycast apunta al eje Z, que es la misma dirección que la "
"flecha azul del gizmo :ref:`Spatial <class_Spatial>` cuando el ``Local space "
"mode`` está habilitado en el editor de Godot. Guardamos esta dirección en "
"una variable llamada ``direction_vector``."

msgid ""
"Next we get the distance from the :ref:`Raycast <class_Raycast>` origin to "
"the :ref:`Raycast <class_Raycast>` collision point by getting the distance "
"from the global position, ``global_transform.origin`` of the ``raycast`` "
"node to the collision point of the :ref:`Raycast <class_Raycast>`, ``raycast."
"get_collision_point``, using the ``distance_to`` function. This will give us "
"the distance the :ref:`Raycast <class_Raycast>` traveled before it collided, "
"which we store in a variable called ``raycast_distance``."
msgstr ""
"A continuación obtenemos la distancia desde el origen :ref:`Raycast "
"<class_Raycast>` hasta el punto de colisión :ref:`Raycast <class_Raycast>` "
"obteniendo la distancia desde la posición global, ``global_transform. "
"origin`` del nodo ``raycast`` al punto de colisión de :ref:`Raycast "
"<class_Raycast>`, ``raycast.get_collision_point``, usando la función "
"``distance_to``. Esto nos dará la distancia que el :ref:`Raycast "
"<class_Raycast>` recorrió antes de colisionar, que guardamos en una variable "
"llamada ``raycast_distance``."

msgid ""
"Then the code checks if the :ref:`PhysicsBody <class_PhysicsBody>`, "
"``body``, has a function/method called ``damage`` using the ``has_method`` "
"function. If the :ref:`PhysicsBody <class_PhysicsBody>` has a function/"
"method called ``damage``, then we call the ``damage`` function and pass "
"``BULLET_DAMAGE`` so it takes damage from the bullet colliding into it."
msgstr ""
"Entonces el código comprueba si el :ref:`PhysicsBody <class_PhysicsBody>`, "
"``body``, tiene una función/método llamado ``damage`` usando la función "
"``has_method``. Si :ref:`PhysicsBody <class_PhysicsBody>` tiene una función/"
"método llamado ``damage``, entonces llamamos a la función ``damage`` y le "
"pasamos ``BULLET_DAMAGE`` para que reciba el daño de la bala que choca "
"contra él."

msgid ""
"Regardless of whether the :ref:`PhysicsBody <class_PhysicsBody>` has a "
"``damage`` function, we then check to see if ``body`` is a :ref:`RigidBody "
"<class_RigidBody>`-based node. If ``body`` is a :ref:`RigidBody "
"<class_RigidBody>`-based node, then we want to push it when the bullet "
"collides."
msgstr ""
"Independientemente de si el :ref:`PhysicsBody <class_PhysicsBody>` tiene una "
"función de ``damage``, entonces comprobamos si ``body`` es un nodo basado "
"en :ref:`RigidBody <class_RigidBody>`. Si ``body`` es un nodo basado en :ref:"
"`RigidBody <class_RigidBody>`, entonces queremos empujarlo cuando la bala "
"colisione."

msgid ""
"To calculate the amount of force applied, we simply take ``COLLISION_FORCE`` "
"and divide it by ``raycast_distance``, then we multiply the whole thing by "
"``body.mass``. We store this calculation in a variable called "
"``collision_force``. This will make collisions over a shorter distance apply "
"move force than those over longer distances, giving a *slightly* more "
"realistic collision response."
msgstr ""
"Para calcular la cantidad de fuerza aplicada, simplemente tomamos "
"``COLLISION_FORCE`` y lo dividimos por``raycast_distance``, a continuación "
"lo multiplicamos todo por ``body.mass``. Guardamos este cálculo en una "
"variable llamada ``collision_force``. Esto hará que las colisiones a una "
"distancia más corta apliquen una fuerza de movimiento que las que se "
"producen a distancias más largas, dando una respuesta de colisión "
"*ligeramente* más realista."

msgid ""
"We then push the :ref:`RigidBody <class_RigidBody>` using the "
"``apply_impulse`` function, where the position is a zero Vector3 so the "
"force is applied from the center, and the collision force is the "
"``collision_force`` variable we calculated."
msgstr ""
"Luego presionamos la :ref:`RigidBody <class_RigidBody>` usando la función "
"``apply_impulse``, donde la posición es un Vector3 cero por lo que la fuerza "
"se aplica desde el centro, y la fuerza de colisión es la variable "
"``collision_force`` que hemos calculado."

msgid ""
"Regardless of whether the ``raycast`` variable hit something or not, we then "
"play the pistol shot sound by calling the ``play`` function on the "
"``pistol_fire_sound`` variable."
msgstr ""
"Independientemente de si la variable ``raycast`` golpeó algo o no, entonces "
"reproducimos el sonido del disparo de la pistola llamando a la función "
"``play`` en la variable ``pistol_fire_sound``."

msgid ""
"Finally, we check to see if the pistol is being held by a VR controller by "
"checking to see if the ``controller`` variable is not equal to ``null``. If "
"it is not equal to ``null``, we then set the ``rumble`` property of the VR "
"controller to ``0.25``, so there is a slight rumble when the pistol fires."
msgstr ""
"Finalmente, comprobamos si la pistola está siendo sostenida por un "
"controlador VR comprobando si la variable ``controller`` no es igual a "
"``null``. Si no es igual a ``null``, entonces ponemos la propiedad "
"``rumble`` del controlador VR en ``0.25``, de modo que haya un ligero "
"temblor cuando la pistola dispare."

msgid "``picked_up`` function step-by-step explanation"
msgstr "explicación paso a paso de la función ``picked_up``"

msgid ""
"This function simply makes the ``laser_sight_mesh`` :ref:`MeshInstance "
"<class_MeshInstance>` visible by setting the ``visible`` property to "
"``true``."
msgstr ""
"Esta función simplemente hace que la ``laser_sight_mesh`` s ref:"
"`MeshInstance <class_MeshInstance>` sea visible estableciendo la propiedad "
"``visible`` a ``true``."

msgid "``dropped`` function step-by-step explanation"
msgstr "explicación paso a paso de la función ``dropped``"

msgid ""
"This function simply makes the ``laser_sight_mesh`` :ref:`MeshInstance "
"<class_MeshInstance>` invisible by setting the ``visible`` property to "
"``false``."
msgstr ""
"Esta función simplemente hace que la ``laser_sight_mesh`` :ref:`MeshInstance "
"<class_MeshInstance>` sea invisible poniendo la propiedad ``visible`` a "
"``false``."

msgid "Pistol finished"
msgstr "Pistola terminada"

msgid ""
"That is all we need to do to have working pistols in the project! Go ahead "
"and run the project. If you climb up the stairs and grab the pistols, you "
"can fire them at the sphere targets in the scene using the trigger button on "
"the VR controller! If you fire at the targets long enough, they will break "
"into pieces."
msgstr ""
"¡Eso es todo lo que necesitamos para tener pistolas que funcionen en el "
"proyecto! Adelante, dirige el proyecto. Si subes las escaleras y coges las "
"pistolas, puedes dispararlas a los objetivos de la esfera en la escena "
"usando el botón de disparo del controlador VR! Si disparas a los objetivos "
"el tiempo suficiente, se romperán en pedazos."

msgid "Adding a shotgun"
msgstr "Añadir una escopeta"

msgid "Next let's add a shotgun to the VR project."
msgstr "A continuación añadiremos una escopeta al proyecto de RV."

msgid ""
"Adding a special shotgun :ref:`RigidBody <class_RigidBody>` should be fairly "
"straightforward, as almost everything with the shotgun is the same as the "
"pistol."
msgstr ""
"Añadir una escopeta especial :ref:`RigidBody <class_RigidBody>` debería ser "
"bastante sencillo, ya que casi todo con la escopeta es lo mismo que la "
"pistola."

msgid ""
"Open up ``Shotgun.tscn``, which you can find in the ``Scenes`` folder and "
"take a look at the scene. Almost everything is the same as in ``Pistol."
"tscn``. The only thing that is different, beyond name changes, is that "
"instead of a single :ref:`Raycast <class_Raycast>`, there are five :ref:"
"`Raycast <class_Raycast>` nodes. This is because a shotgun generally fires "
"in a cone shape, so we are going to emulate that effect by having several :"
"ref:`Raycast <class_Raycast>` nodes that will rotate randomly in a cone "
"shape when the shotgun fires."
msgstr ""
"Abre el archivo ``Shotgun.tscn``, que puedes encontrar en la carpeta "
"``Scenes`` y echa un vistazo a la escena. Casi todo es igual que en "
"``Pistola.tscn``. Lo único que es diferente, más allá de los cambios de "
"nombre, es que en lugar de un solo nodo :ref:`Raycast <class_Raycast>`, hay "
"cinco nodos :ref:`Raycast <class_Raycast>`. Esto se debe a que una escopeta "
"generalmente dispara en forma de cono, por lo que vamos a emular ese efecto "
"teniendo varios nodos :ref:`Raycast <class_Raycast>` que girarán "
"aleatoriamente en forma de cono cuando la escopeta dispare."

msgid ""
"Outside of that, everything is more or less the same as ``Pistol.tscn``."
msgstr "Fuera de eso, todo es más o menos lo mismo que ``Pistol.tscn``."

msgid ""
"Let's write the code for the shotgun. Select the :ref:`RigidBody "
"<class_RigidBody>` node called ``Shotgun`` and make a new script called "
"``Shotgun.gd``. Add the following code:"
msgstr ""
"Escribamos el código de la escopeta. Selecciona el nodo :ref:`RigidBody "
"<class_RigidBody>` llamado ``Shotgun`` y haz un nuevo script llamado "
"``Shotgun.gd``. Añade el siguiente código:"

msgid ""
"The majority of this code is exactly the same as the code for the pistol "
"with just a few *minor* changes that are primarily just different names. Due "
"to how similar these scripts are, let's just focus on the changes."
msgstr ""
"La mayoría de este código es exactamente el mismo que el de la pistola con "
"sólo unos pocos cambios *menos* que son principalmente sólo nombres "
"diferentes. Debido a lo similares que son estos scripts, centrémonos en los "
"cambios."

msgid "Explaining the shotgun code"
msgstr "Explicando el código de la escopeta"

msgid ""
"Like with the pistol, the shotgun extends ``VR_Interactable_Rigidbody`` so "
"the VR controllers know that this object can be interacted with and what "
"functions are available."
msgstr ""
"Al igual que con la pistola, la escopeta se extiende "
"``VR_Interactable_Rigidbody`` para que los controladores de VR sepan que se "
"puede interactuar con este objeto y qué funciones están disponibles."

msgid "There is only one new class variable:"
msgstr "Aquí hay solo una nueva variable en la clase:"

msgid ""
"``raycasts``: A variable to hold the node that has all of the :ref:`Raycast "
"<class_Raycast>` nodes as its children."
msgstr ""
"``raycasts``: Una variable para mantener el nodo que tiene todos los nodos :"
"ref:`Raycast <class_Raycast>` como hijos."

msgid ""
"The new class variable replaces the ``raycast`` variable from ``Pistol.gd``, "
"because with the shotgun we need to process multiple :ref:`Raycast "
"<class_Raycast>` nodes instead of just one. All of the other class variables "
"are the same as ``Pistol.gd`` and function the same way, some just are "
"renamed to be non-pistol specific."
msgstr ""
"La nueva variable de clase reemplaza a la variable ``raycast`` de ``Pistol."
"gd``, porque con la escopeta necesitamos procesar múltiples nodos :ref:"
"`Raycast <class_Raycast>` en lugar de uno solo. Todas las demás variables de "
"clase son iguales a ``Pistol.gd`` y funcionan de la misma manera, algunas "
"sólo se renombran para que no sean específicas de la pistola."

msgid ""
"The interact function first checks to see if the shotgun's muzzle flash is "
"invisible by checking to see if ``flash_timer`` is less than or equal to "
"zero. We do this so we can limit the rate of fire of the shotgun to the "
"length of time the muzzle flash is visible, which is a simple solution for "
"limiting how fast the player can fire."
msgstr ""
"La función de interacción primero comprueba si el flash de la escopeta es "
"invisible comprobando si el ``flash_timer`` es menor o igual a cero. Hacemos "
"esto para poder limitar la velocidad de disparo de la escopeta al tiempo en "
"que el flash de la boca es visible, lo cual es una solución simple para "
"limitar la velocidad de disparo del jugador."

msgid ""
"If ``flash_timer`` is zero or less, we then set ``flash_timer`` to "
"``FLASH_TIME`` so there is a delay before the shotgun can fire again. After "
"that we set ``flash_mesh.visible`` to ``true`` so the muzzle flash at the "
"end of the shotgun is visible while ``flash_timer`` is more than zero."
msgstr ""
"Si ``flash_timer`` es menor o igual a cero, entonces ponemos ``flash_timer`` "
"en ``FLASH_TIME`` para que haya un retraso antes de que la escopeta pueda "
"disparar de nuevo. Después de eso, ponemos ``flash_mesh.visible`` en "
"``true`` para que el flash de la boca del cañón sea visible mientras que el "
"``flash_timer`` sea mayor que cero."

msgid ""
"Next we go through each of the child nodes of the ``raycasts`` variable "
"using a for loop. This way the code will go through each of the :ref:"
"`Raycast <class_Raycast>` nodes that are children of the ``raycasts`` "
"variable."
msgstr ""
"Luego pasamos por cada uno de los nodos hijos de la variable ``raycasts`` "
"usando un bucle \"for\". De esta manera el código pasará por cada uno de los "
"nodos :ref:`Raycast <class_Raycast>` que son hijos de la variable "
"``raycasts``."

msgid ""
"For each node, we check to see if ``raycast`` is *not* a :ref:`Raycast "
"<class_Raycast>` node. If the node is not a :ref:`Raycast <class_Raycast>` "
"node, we simply use ``continue`` to skip it."
msgstr ""
"Para cada nodo, comprobamos si ``raycast`` es *no* un nodo :ref:`Raycast "
"<clase_Raycast>`. Si el nodo no es un nodo :ref:`Raycast <class_Raycast>`, "
"simplemente usamos ``continue`` para saltarlo."

msgid ""
"Next we rotate the ``raycast`` node randomly around a small ``10`` degrees "
"cone by settings the ``rotation_degrees`` variable of the ``raycast`` to a "
"Vector3 where the X and Z axis are a random number from ``-10`` to ``10``. "
"This random number is selected using the ``rand_range`` function."
msgstr ""
"Luego rotamos el nodo ``raycast`` aleatoriamente alrededor de un pequeño "
"cono de ``10`` grados ajustando la variable ``rotation_degrees`` del "
"``raycast`` a un Vector 3 donde los ejes X y Z son un número aleatorio de "
"``-10`` a ``10``. Este número aleatorio se selecciona usando la función "
"``rand_range``."

msgid ""
"Then we call the ``force_raycast_update`` function on the :ref:`Raycast "
"<class_Raycast>` node in ``raycast`` so that it gets the latest collision "
"info from the physics world. We then check if the ``raycast`` hit something "
"by checking if the ``is_colliding`` function is equal to ``true``."
msgstr ""
"Luego llamamos a la función ``force_raycast_update`` en el nodo :ref:"
"`Raycast <class_Raycast>` en ``raycast`` para que reciba la última "
"información sobre colisiones del mundo de la física. Luego verificamos si el "
"``raycast`` golpea algo, verificando si la función ``is_colliding`` es igual "
"a ``true``."

msgid ""
"The rest of the code is exactly the same, but this process is repeated for "
"each :ref:`Raycast <class_Raycast>` node that is a child of the ``raycasts`` "
"variable."
msgstr ""
"El resto del código es exactamente el mismo, pero este proceso se repite "
"para cada nodo :ref:`Raycast <class_Raycast>` que es hijo de la variable "
"``raycasts``."

msgid ""
"We then get the direction of the raycast by getting it's positive ``Z`` "
"directional axis from the :ref:`Basis <class_Basis>` on the ``raycast`` "
"node's ``global_transform``. This will give us the direction the raycast is "
"pointing on the Z axis, which is the same direction as the blue arrow on "
"the :ref:`Spatial <class_Spatial>` gizmo when ``Local space mode`` is "
"enabled in the Godot editor. We store this direction in a variable called "
"``direction_vector``."
msgstr ""
"Luego obtenemos la dirección del raycast obteniendo su eje direccional "
"positivo ``Z`` del :ref:`Basis <class_Basis>` en el nodo ``raycast`` del "
"``global_transform``. Esto nos dará la dirección en la que el raycast apunta "
"al eje Z, que es la misma dirección que la flecha azul del gizmo :ref:"
"`Spatial <class_Spatial>` cuando el ``Local space mode`` está habilitado en "
"el editor de Godot. Guardamos esta dirección en una variable llamada "
"``direction_vector``."

msgid ""
"Next we get the distance from the raycast origin to the raycast collision "
"point by getting the distance from the global position, ``global_transform."
"origin`` of the ``raycast`` node to the collision point of the raycast, "
"``raycast.get_collision_point``, using the ``distance_to`` function. This "
"will give us the distance the :ref:`Raycast <class_Raycast>` traveled before "
"it collided, which we store in a variable called ``raycast_distance``."
msgstr ""
"A continuación obtenemos la distancia desde el origen del raycast al punto "
"de colisión del raycast, obteniendo la distancia desde la posición global, "
"``global_transform.origin`` del nodo ``raycast`` al punto de colisión del "
"raycast, ``raycast.get_collision_point``, usando la función ``distance_to``. "
"Esto nos dará la distancia que el :ref:`Raycast <clase_Raycast>` viajó antes "
"de colisionar, que guardamos en una variable llamada ``raycast_distance``."

msgid ""
"Once all of the :ref:`Raycast <class_Raycast>`\\s in the ``raycast`` "
"variable have been iterated over, we then play the shotgun shot sound by "
"calling the ``play`` function on the ``shotgun_fire_sound`` variable."
msgstr ""
"Una vez que todos los :ref:`Raycast <class_Raycast>` de la variable "
"``raycast`` han sido iterados, entonces reproducimos el sonido del disparo "
"de la escopeta llamando a la función ``play`` en la variable "
"``shotgun_fire_sound``."

msgid ""
"Finally, we check to see if the shotgun is being held by a VR controller by "
"checking to see if the ``controller`` variable is not equal to ``null``. If "
"it is not equal to ``null``, we then set the ``rumble`` property of the VR "
"controller to ``0.25``, so there is a slight rumble when the shotgun fires."
msgstr ""
"Por último, comprobamos si la escopeta está siendo sostenida por un "
"controlador VR comprobando si la variable ``controller`` no es igual a "
"``null``. Si no es igual a ``null``, entonces ponemos la propiedad "
"``rumble`` del controlador VR en ``0.25``, de modo que haya un ligero "
"temblor cuando la escopeta se dispare."

msgid "Shotgun finished"
msgstr "Escopeta terminada"

msgid ""
"Everything else is exactly the same as the pistol, with at most just some "
"simple name changes."
msgstr ""
"Todo lo demás es exactamente igual que la pistola, con algunos cambios de "
"nombre sencillos."

msgid ""
"Now the shotgun is finished! You can find the shotgun in the sample scene by "
"looking around the back of one of the walls (not in the building though!)."
msgstr ""
"¡Ahora la escopeta está terminada! Puedes encontrar la escopeta en la escena "
"de muestra mirando alrededor de la parte de atrás de una de las paredes "
"(¡aunque no en el edificio!)."

msgid "Adding a bomb"
msgstr "Añadir una bomba"

msgid ""
"Okay, let's add a different special :ref:`RigidBody <class_RigidBody>`. "
"Instead of adding something that shoots, let's add something we can throw - "
"a bomb!"
msgstr ""
"Vale, añadamos un especial diferente :ref:`RigidBody <class_RigidBody>`. En "
"lugar de añadir algo que dispare, añadamos algo que podamos lanzar - ¡una "
"bomba!"

msgid "Open up ``Bomb.tscn``, which is in the ``Scenes`` folder."
msgstr "Abre ``Bomb.tscn``, que está en la carpeta ``Scenes``."

msgid ""
"The root node is a :ref:`RigidBody <class_RigidBody>` node that we'll be "
"extending to use ``VR_Interactable_Rigidbody``, which has a :ref:"
"`CollisionShape <class_CollisionShape>` like the other special :ref:"
"`RigidBody <class_RigidBody>` nodes we've made so far. Likewise, there is a :"
"ref:`MeshInstance <class_MeshInstance>` called ``Bomb`` that is used to "
"display the mesh for the bomb."
msgstr ""
"El nodo raíz es un nodo :ref:`RigidBody <class_RigidBody>` que extenderemos "
"para usar ``VR_Interactable_Rigidbody``, que tiene un :ref:`CollisionShape "
"<class_CollisionShape>` como los otros nodos :ref:`RigidBody "
"<class_RigidBody>` especiales que hemos hecho hasta ahora. De la misma "
"manera, hay un :ref:`MeshInstance <class_MeshInstance>` llamado ``Bomb`` que "
"se usa para mostrar la malla de la bomba."

msgid ""
"Then we have an :ref:`Area <class_Area>` node simply called ``Area`` that "
"has a large :ref:`CollisionShape <class_CollisionShape>` as its child. We'll "
"use this :ref:`Area <class_Area>` node to effect anything within it when the "
"bomb explodes. Essentially, this :ref:`Area <class_Area>` node will be the "
"blast radius for the bomb."
msgstr ""
"Entonces tenemos un nodo :ref:`Area <class_Area>` simplemente llamado "
"``Area`` que tiene un gran :ref:`ColisiónShape <class_ColisiónShape>` como "
"tu hijo. Usaremos este nodo :ref:`Area <class_Area>` para afectar cualquier "
"cosa dentro de él cuando la bomba explote. Esencialmente, este nodo :ref:"
"`Area <class_Area>` será el radio de explosión de la bomba."

msgid ""
"There is also a couple :ref:`Particles <class_Particles>` nodes. One of the :"
"ref:`Particles <class_Particles>` nodes are for the smoke coming out of the "
"bomb's fuse, while another is for the explosion. You can take a look at the :"
"ref:`ParticlesMaterial <class_ParticlesMaterial>` resources, which define "
"how the particles work, if you want. We will not be covering how the "
"particles work in this tutorial due to it being outside of the scope of this "
"tutorial."
msgstr ""
"También hay un par de nodos :ref:`Particles <class_Particles>`. Uno de los "
"nodos :ref:`Particles <class_Particles>` es para el humo que sale del "
"fusible de la bomba, mientras que otro es para la explosión. Puedes echar un "
"vistazo a los recursos :ref:`ParticlesMaterial <class_ParticlesMaterial>`, "
"que definen cómo funcionan las partículas, si quieres. No vamos a cubrir "
"cómo funcionan las partículas en este tutorial debido a que está fuera del "
"alcance de este tutorial."

msgid ""
"There is one thing with the :ref:`Particles <class_Particles>` nodes that we "
"need to make note of. If you select the ``Explosion_Particles`` node, you'll "
"find that its ``lifetime`` property is set to ``0.75`` and that the ``one "
"shot`` checkbox is enabled. This means that the particles will only play "
"once, and the particles will last for ``0.75`` seconds. We'll need to know "
"this so we can time the removal of the bomb with the end of the explosion :"
"ref:`Particles <class_Particles>`."
msgstr ""
"Hay una cosa con los nodos :ref:`Particles <class_Particles>` que debemos "
"anotar. Si seleccionas el nodo ``Explosion_Particles``, verás que su "
"propiedad ``lifetime`` está establecida en ``0.75`` y que la casilla ``one "
"shot`` está activada. Esto significa que las partículas sólo se reproducirán "
"una vez, y las partículas durarán ``0.75`` segundos. Necesitamos saber esto "
"para poder cronometrar la eliminación de la bomba con el fin de la "
"explosión :ref:``Particles <class_Particles>`."

msgid ""
"Let's write the code for the bomb. Select the ``Bomb`` :ref:`RigidBody "
"<class_RigidBody>` node and make a new script called ``Bomb.gd``. Add the "
"following code:"
msgstr ""
"Escribamos el código de la bomba. Selecciona el nodo ``Bomb`` :ref:"
"`RigidBody <class_RigidBody>` y haz un nuevo script llamado ``Bomb.gd``. "
"Añade el siguiente código:"

msgid "Explaining the bomb code"
msgstr "Ejemplo de código de bomba"

msgid ""
"Like with the other special :ref:`RigidBody <class_RigidBody>` nodes, the "
"bomb extends ``VR_Interactable_Rigidbody`` so the VR controllers know this "
"object can be interacted with and that the functions defined defined in "
"``VR_Interactable_Rigidbody`` can be called when this object is held by a VR "
"controller."
msgstr ""
"Como con los otros nodos especiales :ref:`RigidBody <class_RigidBody>`, la "
"bomba extiende ``VR_Interactable_Rigidbody`` para que los controladores de "
"VR sepan que este objeto puede interactuar con él y que las funciones "
"definidas en ``VR_Interactable_Rigidbody`` pueden ser llamadas cuando este "
"objeto es sostenido por un controlador de VR."

msgid ""
"``bomb_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that is used for the non-exploded bomb."
msgstr ""
"``bomb_mesh``: Una variable que contiene el nodo :ref:`MeshInstance "
"<class_MeshInstance>` que es utilizado para la bomba que no ha explotado."

msgid ""
"``FUSE_TIME``: A constant to define how long the fuse will 'burn' before the "
"bomb explodes"
msgstr ""
"``FUSE_TIME``: Una constante para definir cuánto tiempo se 'quemará' el "
"fusible antes de que la bomba explote"

msgid ""
"``fuse_timer``: A variable to hold the length of time that has passed since "
"the bomb's fuse has started to burn."
msgstr ""
"``fuse_timer``: Una variable para guardar cuanto tiempo ha pasado desde que "
"la mecha de la bomba se encendió."

msgid ""
"``explosion_area``: A variable to hold the :ref:`Area <class_Area>` node "
"used to detect objects within the bomb's explosion."
msgstr ""
"``explosion_area``: Una variable que contiene el nodo :ref:`Area "
"<class_Area>` utilizado para detectar los objetos que se encuentran dentro "
"de la explosión."

msgid ""
"``EXPLOSION_DAMAGE``: A constant to define how much damage is applied with "
"the bomb explodes."
msgstr ""
"``EXPLOSION_DAMAGE``: Una constante que define cuánto daño es aplicado "
"cuando explota la bomba."

msgid ""
"``EXPLOSION_TIME``: A constant to define how long the bomb will last in the "
"scene after it explodes. This value should be the same as the ``lifetime`` "
"property of the explosion :ref:`Particles <class_Particles>` node."
msgstr ""
"``EXPLOSION_TIME``: Una constante para definir cuánto tiempo durará la bomba "
"en la escena después de que explote. Este valor debe ser el mismo que la "
"propiedad ``lifetime`` del nodo de la explosión :ref:`Particles "
"<class_Particles>`."

msgid ""
"``explosion_timer`` A variable to hold the length of time that has passed "
"since the bomb exploded."
msgstr ""
"``explosion_timer``: Una variable que guarda el tiempo que ha pasado desde "
"que explotó la bomba."

msgid "``exploded``: A variable to hold whether the bomb has exploded or not."
msgstr ""
"``exploded``: Una variable que guarda el estado de la bomba, si ha explotado "
"o no."

msgid ""
"``COLLISION_FORCE``: A constant that defines the amount of force that is "
"applied to :ref:`RigidBody <class_RigidBody>` nodes when the bomb explodes."
msgstr ""
"``COLLISION_FORCE``: Una constante que define la cantidad de fuerza que se "
"aplica a los nodos :ref:`RigidBody <class_RigidBody>` cuando la bomba "
"explota."

msgid ""
"``fuse_particles``: A variable to hold a reference to the :ref:`Particles "
"<class_Particles>` node used for the bomb's fuse."
msgstr ""
"``fuse_particles``: Una variable para mantener el nodo :ref:`Particles "
"<class_Particles>` usado para la mecha de la bomba."

msgid ""
"``explosion_particles``: A variable to hold a reference to the :ref:"
"`Particles <class_Particles>` node used for the bomb's explosion."
msgstr ""
"``explosion_particles``: Una variable para mantener el nodo :ref:`Particles "
"<class_Particles>` usado para la explosión de la bomba."

msgid ""
"``explosion_sound``: A variable to hold a reference to the :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node used for the "
"explosion sound."
msgstr ""
"``explosion_sound``: Una variable para mantener una referencia al nodo :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` utilizado para el sonido "
"de la explosión."

msgid ""
"The ``_ready`` function first gets all of the nodes from the bomb scene and "
"assigns them to their respective class variables for later use."
msgstr ""
"La función ``_ready`` obtiene primero todos los nodos de la escena bomba y "
"los asigna a las respectivas variables para uso posterior."

msgid ""
"Then we call ``set_physics_process`` and pass ``false`` so "
"``_physics_process`` is not executed. We do this because the code in "
"``_physics_process`` will start burning the fuse and exploding the bomb, "
"which we only want to do when the user interacts with the bomb. If we did "
"not disable ``_physics_process``, the bomb's fuse would start before the "
"user has a chance to get to the bomb."
msgstr ""
"Entonces llamamos a ``set_physics_process`` y pasamos ``false`` para que "
"``_physics_process`` no se ejecute. Hacemos esto porque el código en "
"``_physics_process`` comenzará a quemar el fusible y a explotará la bomba, "
"lo que sólo queremos hacer cuando el usuario interactúe con la bomba. Si no "
"desactivamos ``_physics_process``, el fusible de la bomba se encenderá antes "
"de que el usuario tenga la oportunidad de llegar a la bomba."

msgid ""
"The ``_physics_process`` function first checks to see if ``fuse_timer`` is "
"less than ``FUSE_TIME``. If it is, then the bomb's fuse is still burning."
msgstr ""
"La función ``_physics_process`` primero comprueba si el tiempo de fusión es "
"menor que el tiempo de fusión. Si lo es, entonces el fusible de la bomba aún "
"está ardiendo."

msgid ""
"If the bomb's fuse is still burning, we then add time, ``delta``, to the "
"``fuse_timer`` variable. We then check to see if ``fuse_timer`` is more than "
"or equal to ``FUSE_TIME`` now that we have added ``delta`` to it. If "
"``fuse_timer`` is more than or equal to ``FUSE_TIME``, then the fuse has "
"just finished and we need to explode the bomb."
msgstr ""
"Si el fusible de la bomba aún está encendido, añadimos el tiempo, ``delta``, "
"a la variable ``fuse_timer``. Luego comprobamos si el ``fuse_timer`` es "
"mayor o igual que el ``FUSE_TIME`` ahora que le hemos añadido ``delta``. Si "
"``fuse_timer`` es más o igual a ``FUSE_TIME``, entonces el fusible acaba de "
"terminar y necesitamos explotar la bomba."

msgid ""
"To explode the bomb, we first stop emitting particles for the fuse by "
"setting ``emitting`` to ``false`` on ``fuse_particles``. We then tell the "
"explosion :ref:`Particles <class_Particles>` node, ``explosion_particles``, "
"to emit all of its particle in a single shot by setting ``one_shot`` to "
"``true``. After that, we set ``emitting`` to ``true`` on "
"``explosion_particles`` so it looks like the bomb has exploded. To help make "
"it look like the bomb exploded, we hide the bomb :ref:`MeshInstance "
"<class_MeshInstance>` node by setting ``bomb_mesh.visible`` to ``false``."
msgstr ""
"Para explotar la bomba, primero dejamos de emitir partículas para el fusible "
"poniendo ``emitting`` a ``false`` en ``fuse_particles``. Luego le decimos al "
"nodo de explosión :ref:`Particles <class_Particles>`, "
"``explosion_particles``, que emita todas sus partículas en un solo disparo, "
"poniendo ``one_shot`` a ``true``. Después de eso, ponemos ``emitting`` a "
"``true`` en ``explosion_particles`` para que parezca que la bomba ha "
"explotado. Para ayudar a que parezca que la bomba ha explotado, ocultamos la "
"bomba :ref:`MeshInstance <class_MeshInstance>` en el nodo ``bomb_mesh."
"visible`` a ``false``."

msgid ""
"To keep the bomb from colliding with other objects in the physics world, we "
"set the ``collision_layer`` and ``collision_mask`` properties of the bomb to "
"``0``. We also change the :ref:`RigidBody <class_RigidBody>` mode to "
"``MODE_STATIC`` so the bomb :ref:`RigidBody <class_RigidBody>` does not move."
msgstr ""
"Para evitar que la bomba colisione con otros objetos en el mundo de la "
"física, fijamos las propiedades de ``collision_layer`` y ``collision_mask`` "
"de la bomba en ``0``. También cambiamos el modo :ref:`RigidBody "
"<class_RigidBody>` a ``MODE_STATIC`` para que la bomba :ref:`RigidBody "
"<class_RigidBody>` no se mueva."

msgid ""
"Then we need to get all of the :ref:`PhysicsBody <class_PhysicsBody>` nodes "
"within the ``explosion_area`` node. To do this, we use the "
"``get_overlapping_bodies`` in a for loop. The ``get_overlapping_bodies`` "
"function will return an array of :ref:`PhysicsBody <class_PhysicsBody>` "
"nodes within the :ref:`Area <class_Area>` node, which is exactly what we are "
"looking for."
msgstr ""
"Entonces necesitamos conseguir todos los nodos :ref:`PhysicsBody "
"<class_PhysicsBody>` dentro del nodo ``explosion_area``. Para hacer esto, "
"usamos el ``get_overlapping_bodies`` en un bucle for. La función "
"``get_overlapping_bodies`` devolverá un array de nodos :ref:`PhysicsBody "
"<class_PhysicsBody>` dentro del nodo :ref:`Area <class_Area>`, que es "
"exactamente lo que estamos buscando."

msgid ""
"For each :ref:`PhysicsBody <class_PhysicsBody>` node, which we store in a "
"variable called ``body``, we check to see if it is equal to ``self``. We do "
"this so the bomb does not accidentally explode itself, as the "
"``explosion_area`` could potentially detect the ``Bomb`` :ref:`RigidBody "
"<class_RigidBody>` as a PhysicsBody within the explosion area."
msgstr ""
"Para cada nodo :ref:`PhysicsBody <class_PhysicsBody>`, que almacenamos en "
"una variable llamada ``body``, comprobamos si es igual a ``self``. Lo "
"hacemos para que la bomba no explote accidentalmente, ya que el "
"``explosion_area`` podría potencialmente detectar la ``Bomb`` :ref:"
"`RigidBody <class_RigidBody>` como un PhysicsBody dentro del área de "
"explosión."

msgid ""
"If the :ref:`PhysicsBody <class_PhysicsBody>` node, ``body``, is not the "
"bomb, then we first check to see if the :ref:`PhysicsBody "
"<class_PhysicsBody>` node has a function called ``damage``. If the :ref:"
"`PhysicsBody <class_PhysicsBody>` node has a function called ``damage``, we "
"call it and pass ``EXPLOSION_DAMAGE`` to it so it takes damage from the "
"explosion."
msgstr ""
"Si el nodo :ref:`PhysicsBody <class_PhysicsBody>`, ``body``, no es la bomba, "
"entonces primero comprobamos si el nodo :ref:`PhysicsBody "
"<class_PhysicsBody>` tiene una función llamada ``damage``. Si el nodo :ref:"
"`PhysicsBody <class_PhysicsBody>` tiene una función llamada ``damage``, la "
"llamamos y le pasamos ``EXPLOSION_DAMAGE`` para que reciba el daño de la "
"explosión."

msgid ""
"Next we check to see if the :ref:`PhysicsBody <class_PhysicsBody>` node is "
"a :ref:`RigidBody <class_RigidBody>`. If ``body`` is a :ref:`RigidBody "
"<class_RigidBody>`, we want to move it when the bomb explodes."
msgstr ""
"A continuación comprobamos si el nodo :ref:`PhysicsBody <class_PhysicsBody>` "
"es un :ref:`RigidBody <class_RigidBody>`. Si ``body`` es un :ref:`RigidBody "
"<class_RigidBody>`, queremos moverlo cuando la bomba explote."

msgid ""
"To move the :ref:`RigidBody <class_RigidBody>` node when the bomb explodes, "
"we first need to calculate the direction from the bomb to the :ref:"
"`RigidBody <class_RigidBody>` node. To do this we subtract the global "
"position of the bomb, ``global_transform.origin`` from the global position "
"of the :ref:`RigidBody <class_RigidBody>`. This will give us a :ref:`Vector3 "
"<class_Vector3>` that points from the bomb to the :ref:`RigidBody "
"<class_RigidBody>` node. We store this :ref:`Vector3 <class_Vector3>` in a "
"variable called ``direction_vector``."
msgstr ""
"Para mover el nodo :ref:`RigidBody <class_RigidBody>` cuando la bomba "
"explote, primero tenemos que calcular la dirección de la bomba al nodo :ref:"
"`RigidBody <class_RigidBody>`. Para ello, restamos la posición global de la "
"bomba, ``global_transform.origin`` de la posición global del nodo :ref:"
"`RigidBody <class_RigidBody>`. Esto nos dará un :ref:`Vector3 "
"<class_Vector3>` que apunta desde la bomba al nodo :ref:`RigidBody "
"<class_RigidBody>`. Guardamos este :ref:`Vector3 <class_Vector3>` en una "
"variable llamada ``direction_vector``."

msgid ""
"We then calculate the distance the :ref:`RigidBody <class_RigidBody>` is "
"from the bomb by using the ``length`` function on ``direction_vector``. We "
"store the distance in a variable called ``bomb_distance``."
msgstr ""
"Entonces calculamos la distancia que el :ref:`RigidBody <class_RigidBody>` "
"está de la bomba usando la función ``length`` en ``direction_vector``. "
"Guardamos la distancia en una variable llamada ``bomb_distance``."

msgid ""
"We then calculate the amount of force the bomb will be applied to the :ref:"
"`RigidBody <class_RigidBody>` node when the bomb explodes by dividing "
"``COLLISION_FORCE`` by ``bomb_distance``, and multiplying that by "
"``collision_force``. This will make it so if the :ref:`RigidBody "
"<class_RigidBody>` node is closer to the bomb, it will be pushed farther."
msgstr ""
"Entonces calculamos la cantidad de fuerza que la bomba será aplicada al "
"nodo :ref:`RigidBody <class_RigidBody>` cuando la bomba explote dividiendo "
"``COLLISION_FORCE`` por ``bomb_distance``, y multiplicando eso por "
"``collision_force``. Esto hará que si el nodo :ref:`RigidBody "
"<class_RigidBody>` está más cerca de la bomba, será empujado más lejos."

msgid ""
"Finally, we push the :ref:`RigidBody <class_RigidBody>` node using the "
"``apply_impulse`` function, with a :ref:`Vector3 <class_Vector3>` position "
"of zero and ``collision_force`` multiplied by ``direction_vector."
"normalized`` as the force. This will send the :ref:`RigidBody "
"<class_RigidBody>` node flying when the bomb explodes."
msgstr ""
"Finalmente, empujamos el nodo :ref:`RigidBody <class_RigidBody>` usando la "
"función ``apply_impulse``, con una posición :ref:`Vector3 <class_Vector3>` "
"de cero y ``collision_force`` multiplicada por ``direction_vector."
"normalized`` como fuerza. Esto enviará el nodo :ref:`RigidBody "
"<class_RigidBody>` volando cuando la bomba explote."

msgid ""
"After we have looped through all of the :ref:`PhysicsBody "
"<class_PhysicsBody>` nodes within the ``explosion_area``, we set the "
"``exploded`` variable to ``true`` so the code knows the bomb exploded and "
"call ``play`` on ``explosion_sound`` so the sound of an explosion is played."
msgstr ""
"Después de haber pasado por todos los nodos :ref:`PhysicsBody "
"<class_PhysicsBody>` dentro del ``explosion_area``, ponemos la variable "
"``exploded`` a ``true`` para que el código sepa que la bomba ha explotado y "
"llamamos a ``play`` en ``explosion_sound`` para que se reproduzca el sonido "
"de una explosión."

msgid ""
"Alright, the next section of code starts by first checking if ``exploded`` "
"is equal to ``true``."
msgstr ""
"Bien, la siguiente sección del código comienza por comprobar si ``exploded`` "
"es igual a ``true``."

msgid ""
"If ``exploded`` is equal to ``true``, then that means the bomb is waiting "
"for the explosion particles to finish before it frees/destroys itself. We "
"add time, ``delta``, to ``explosion_timer`` so we can track how long it has "
"been since the bomb has exploded."
msgstr ""
"Si ``exploded`` es igual a ``true``, significa que la bomba está esperando "
"que las partículas de la explosión terminen antes de liberarse/destruirse. "
"Añadimos tiempo, ``delta``, al ``explosion_timer`` para que podamos rastrear "
"cuánto tiempo ha pasado desde que la bomba ha explotado."

msgid ""
"If ``explosion_timer`` is greater than or equal to ``EXPLOSION_TIME`` after "
"we added ``delta``, then the explosion timer just finished."
msgstr ""
"Si el ``explosion_timer`` es mayor o igual que el ``EXPLOSION_TIME`` después "
"de añadir ``delta``, entonces el temporizador de explosión acaba de terminar."

msgid ""
"If the explosion timer just finished, we set ``explosion_area.monitoring`` "
"to ``false``. The reason we do this is because there was a bug that would "
"print an error when you freed/deleted an :ref:`Area <class_Area>` node when "
"the ``monitoring`` property was true. To make sure this doesn't happen, we "
"simply set ``monitoring`` to false on ``explosion_area``."
msgstr ""
"Si el temporizador de explosión acaba de terminar, ponemos el "
"``explosion_area.monitoring`` en ``false``. La razón por la que hacemos esto "
"es porque había un error que imprimía un error cuando liberabas/borraste un "
"nodo :ref:``Area <class_Area>` cuando la propiedad ``monitoring`` era "
"verdadera. Para asegurarnos de que esto no suceda, simplemente ponemos "
"``monitoring`` en falso en ``explosion_area``."

msgid ""
"Next we check to see if the bomb is being held by a VR controller by "
"checking to see if the ``controller`` variable is not equal to ``null``. If "
"the bomb is being held by a VR controller, we set the ``held_object`` "
"property of the VR controller, ``controller``, to ``null``. Because the VR "
"controller is no longer holding anything, we make the VR controller's hand "
"mesh visible by setting ``controller.hand_mesh.visible`` to ``true``. Then "
"we check to see if the VR controller grab mode is ``RAYCAST``, and if it is "
"we set ``controller.grab_raycast.visible`` to ``true`` so the 'laser sight' "
"for the grab raycast is visible."
msgstr ""
"A continuación comprobamos si la bomba está siendo sujetada por un "
"controlador VR comprobando si la variable ``controller`` no es igual a "
"``null``. Si la bomba está siendo sujetada por un controlador VR, ponemos la "
"propiedad ``held_object`` del controlador VR, ``controller``, a ``null``. "
"Debido a que el controlador de VR ya no sostiene nada, hacemos visible la "
"malla de mano del controlador de VR estableciendo ``controller.hand_mesh."
"visible`` como ``true``. Luego comprobamos si el modo de agarre del "
"controlador de VR es ``RAYCAST``, y si es así, ponemos ``controller."
"grab_raycast.visible`` en ``true`` para que la 'laser sight' para el raycast "
"de agarre sea visible."

msgid ""
"Finally, regardless if the bomb is being held by a VR controller or not, we "
"call ``queue_free`` so the bomb scene is freed/removed from the scene."
msgstr ""
"Finalmente, independientemente de si la bomba está siendo sujetada por un "
"controlador VR o no, llamamos a ``queue_free`` para que la escena de la "
"bomba sea liberada/eliminada de la escena."

msgid ""
"First the ``interact`` function calls ``set_physics_process`` and passes "
"``true`` so the code in ``_physics_process`` starts executing. This will "
"start the bomb's fuse and eventually lead to the bomb exploding."
msgstr ""
"Primero la función ``interactúa`` llama a ``set_physics_process`` y pasa "
"``true`` para que el código en ``physics_process`` empiece a ejecutarse. "
"Esto iniciará el fusible de la bomba y eventualmente llevará a la explosión "
"de la bomba."

msgid ""
"Finally, we start the fuse particles by setting ``fuse_particles.visible`` "
"to ``true``."
msgstr ""
"Finalmente, empezamos las partículas del fusible poniendo ``fuse_particles."
"visible`` en ``true``."

msgid "Bomb finished"
msgstr "Bomba terminada"

msgid ""
"Now the bomb is ready to go! You can find the bombs in the orange building."
msgstr ""
"¡Ahora la bomba está lista para funcionar! Puedes encontrar las bombas en el "
"edificio naranja."

msgid ""
"Because of how we are calculating the VR controller's velocity, it is "
"easiest to throw the bombs using a thrusting-like motion instead of a more "
"natural throwing-like motion. The smooth curve of a throwing-like motion is "
"harder to track with the code we are using for calculating the velocity of "
"the VR controllers, so it does not always work correctly and can lead "
"inaccurately calculated velocities."
msgstr ""
"Debido a la forma en que calculamos la velocidad del controlador de RV, es "
"más fácil lanzar las bombas utilizando un movimiento de empuje en lugar de "
"un movimiento de lanzamiento más natural. La curva suave de un movimiento de "
"lanzamiento es más difícil de seguir con el código que estamos usando para "
"calcular la velocidad de los controladores de RV, por lo que no siempre "
"funciona correctamente y puede llevar a velocidades calculadas de forma "
"inexacta."

msgid "Adding a sword"
msgstr "Añadir una espada"

msgid ""
"Let's add one last special :ref:`RigidBody <class_RigidBody>`-based node "
"that can destroy targets. Let's add a sword so we can slice through the "
"targets!"
msgstr ""
"Añadamos un último nodo especial :ref:`RigidBody <class_RigidBody>` basado "
"en el nodo que puede destruir objetivos. ¡Añadamos una espada para poder "
"cortar los objetivos!"

msgid "Open up ``Sword.tscn``, which you can find in the ``Scenes`` folder."
msgstr ""
"Abre el archivo ``Sword.tscn``, que puedes encontrar en la carpeta "
"``Scenes``."

msgid ""
"There is not a whole lot going on here. All of the child nodes of the root "
"``Sword`` :ref:`RigidBody <class_RigidBody>` node are rotated to they are "
"positioned correctly when the VR controller picks them up, there is a :ref:"
"`MeshInstance <class_MeshInstance>` node for displaying the sword, and there "
"is an :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node that holds "
"a sound for the sword colliding with something."
msgstr ""
"No hay mucho que hacer aquí. Todos los nodos hijos del nodo raíz ``Sword`` :"
"ref:`RigidBody <class_RigidBody>` se giran hasta que se posicionan "
"correctamente cuando el controlador VR los recoge, hay un :ref: "
"`MeshInstance <class_MeshInstance>` nodo para mostrar la espada, y hay un "
"nodo :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` que contiene un "
"sonido para la espada que colisionando con algo."

msgid ""
"There is one thing that is slightly different though. There is a :ref:"
"`KinematicBody <class_KinematicBody>` node called ``Damage_Body``. If you "
"take a look at it, you'll find that it is not on any collision layers, and "
"is instead only on a single collision mask. This is so the :ref:"
"`KinematicBody <class_KinematicBody>` will not effect other :ref:"
"`PhysicsBody <class_PhysicsBody>` nodes in the scene, but it will still be "
"effected by :ref:`PhysicsBody <class_PhysicsBody>` nodes."
msgstr ""
"Sin embargo, hay una cosa que es ligeramente diferente. Hay un nodo :ref:"
"`KinematicBody <class_KinematicBody>` llamado ``Damage_Body``. Si le echas "
"un vistazo, verás que no está en ninguna capa de colisión, y en su lugar "
"sólo está en una única máscara de colisión. Esto es así porque el :ref:"
"`KinematicBody <class_KinematicBody>` no afectará a otros nodos :ref:"
"`PhysicsBody <class_PhysicsBody>` de la escena, pero aún así se verá "
"afectado por los nodos :ref:`PhysicsBody <class_PhysicsBody>`."

msgid ""
"We are going to use the ``Damage_Body`` :ref:`KinematicBody "
"<class_KinematicBody>` node to detect the collision point and normal when "
"the sword collides with something in the scene."
msgstr ""
"Vamos a usar el nodo ``Damage_Body`` :ref:`KinematicBody "
"<class_KinematicBody>` para detectar el punto de colisión y normal cuando la "
"espada colisiona con algo en la escena."

msgid ""
"While this is perhaps not the best way of getting the collision information "
"from a performance point of view, it does give us a lot of information we "
"can use for post-processing! Using a :ref:`KinematicBody "
"<class_KinematicBody>` this way means we can detect exactly where the sword "
"collided with other :ref:`PhysicsBody <class_PhysicsBody>` nodes."
msgstr ""
"Aunque quizás no sea la mejor manera de obtener la información de la "
"colisión desde el punto de vista del rendimiento, ¡nos da mucha información "
"que podemos usar para el post-procesamiento! Usando un :ref:`KinematicBody "
"<class_KinematicBody>` de esta manera podemos detectar exactamente donde la "
"espada colisionó con otros nodos :ref:`PhysicsBody <class_PhysicsBody>`."

msgid ""
"That is really the only thing note worthy about the sword scene. Select the "
"``Sword`` :ref:`RigidBody <class_RigidBody>` node and make a new script "
"called ``Sword.gd``. Add the following code:"
msgstr ""
"Esa es realmente la única nota digna de mención en la escena de la espada. "
"Selecciona el nodo ``Sword`` :ref:`RigidBody <class_RigidBody>`y haz un "
"nuevo script llamado ``Sword.gd``. Añade el siguiente código:"

msgid "Let's go over how this script works!"
msgstr "¡Repasemos cómo funciona este script!"

msgid "Explaining the sword code"
msgstr "Explicando el código de la espada"

msgid ""
"Like with the other special :ref:`RigidBody <class_RigidBody>` nodes, the "
"sword extends ``VR_Interactable_Rigidbody`` so the VR controllers know this "
"object can be interacted with and that the functions defined defined in "
"``VR_Interactable_Rigidbody`` can be called when this object is held by a VR "
"controller."
msgstr ""
"Como con los otros nodos especiales :ref:`RigidBody <class_RigidBody>`, la "
"espada extiende ``VR_Interactable_Rigidbody`` para que los controladores VR "
"sepan que se puede interactuar con este objeto y que las funciones definidas "
"en ``VR_Interactable_Rigidbody`` pueden ser llamadas cuando este objeto es "
"sujetado por un controlador VR."

msgid ""
"``SWORD_DAMAGE``: A constant to define the amount of damage the sword does. "
"This damage is applied to every object in the sword on every "
"``_physics_process`` call"
msgstr ""
"``SWORD_DAMAGE``: Una constante para definir la cantidad de daño que hace la "
"espada. Este daño se aplica a cada objeto de la espada en cada llamada a "
"``_physics_process``"

msgid ""
"``COLLISION_FORCE``: A constant that defines the amount of force applied to :"
"ref:`RigidBody <class_RigidBody>` nodes when the sword collides with a :ref:"
"`PhysicsBody <class_PhysicsBody>`."
msgstr ""
"``COLLISION_FORCE``: Una constante que define la cantidad de fuerza aplicada "
"a los nodos :ref:`RigidBody <class_RigidBody>` cuando la espada colisiona "
"con un :ref:`PhysicsBody <class_PhysicsBody>`."

msgid ""
"``damage_body``: A variable to hold the :ref:`KinematicBody "
"<class_KinematicBody>` node used to detect whether the sword is stabbing a :"
"ref:`PhysicsBody <class_PhysicsBody>` node or not."
msgstr ""
"``damage_body``: Una variable para mantener el nodo :ref:`KinematicBody "
"<class_KinematicBody>` usado para detectar si la espada está apuñalando un "
"nodo :ref:`PhysicsBody <class_PhysicsBody>` o no."

msgid ""
"``sword_noise``: A variable to hold the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node used to play a sound when the sword "
"collides with something."
msgstr ""
"``sword_noise``: Una variable para mantener el nodo :ref:"
"`AudioStreamPlayer3D <clase_AudioStreamPlayer3D>` usado para reproducir un "
"sonido cuando la espada colisiona con algo."

msgid ""
"All we are doing in the ``_ready`` function is getting the ``Damage_Body`` :"
"ref:`KinematicBody <class_KinematicBody>` node and assigning it to "
"``damage_body``. Because we do not want the sword to detect a collision with "
"the root :ref:`RigidBody <class_RigidBody>` node of the sword, we call "
"``add_collision_exception_with`` on ``damage_body`` and pass ``self`` so the "
"sword will not be detected."
msgstr ""
"Todo lo que hacemos en la función ``_ready`` es obtener el nodo "
"``Damage_Body`` :ref:`KinematicBody <class_KinematicBody>` y asignarlo a "
"``damage_body``. Como no queremos que la espada detecte una colisión con el "
"nodo raíz :ref:`RigidBody <class_RigidBody>` de la espada, llamamos a "
"``add_collision_exception_with`` en ``damage_body`` y se pasa ``self`` para "
"que la espada no sea detectada."

msgid ""
"Finally, we get the :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` "
"node for the sword collision sound and apply it to the ``sword_noise`` "
"variable."
msgstr ""
"Finalmente, obtenemos el nodo :ref:`AudioStreamPlayer3D "
"<clase_AudioStreamPlayer3D>` para el sonido de la colisión de la espada y lo "
"aplicamos a la variable ``sword_noise``."

msgid ""
"First we need to determine whether the sword is colliding with something or "
"not. To do this, we use the ``move_and_collide`` function of the "
"``damage_body`` node. Unlike how ``move_and_collide`` is normally used, we "
"are not passing a velocity and instead are passing an empty :ref:`Vector3 "
"<class_Vector3>`. Because we do not want the ``damage_body`` node to move, "
"we set the ``test_only`` argument (the fourth argument) as ``true`` so the :"
"ref:`KinematicBody <class_KinematicBody>` generates collision info without "
"actually causing any collisions within the collision world."
msgstr ""
"Primero tenemos que determinar si la espada está colisionando con algo o no. "
"Para ello, usamos la función ``move_and_collide`` del nodo ``damage_body``. "
"A diferencia de cómo se usa normalmente ``move_and_collide``, no pasamos una "
"velocidad y en su lugar pasamos un :ref:`Vector3 <class_Vector3>` vacío. "
"Como no queremos que el nodo ``damage_body`` se mueva, establecemos el "
"argumento ``test_only`` (el cuarto argumento) como ``true`` de modo que el :"
"ref:`KinematicBody <class_KinematicBody>` genera la información de la "
"colisión sin causar ninguna colisión dentro del mundo de la colisión."

msgid ""
"The ``move_and_collide`` function will return a :ref:`KinematicCollision "
"<class_KinematicCollision>` class that has all of the information we need "
"for detecting collisions on the sword. We assign the return value of "
"``move_and_collide`` to a variable called ``collision_results``."
msgstr ""
"La función ``move_and_collide`` retorna un objeto de la clase :ref:"
"`KinematicCollision <class_KinematicCollision>` que contiene la información "
"que necesitamos para detectar colisiones con la espada. Asignaremos el valor "
"de retorno de ``move_and_collide`` a una variable llamada "
"``collision_results``."

msgid ""
"Next we check to see if ``collision_results`` is not equal to ``null``. If "
"``collision_results`` is not equal to ``null``, then we know that the sword "
"has collided with something."
msgstr ""
"A continuación comprobamos si los ``collision_results`` no son iguales a "
"``null``. Si ``collision_results`` no es igual a ``null``, entonces sabemos "
"que la espada ha colisionado con algo."

msgid ""
"We then check to see if the :ref:`PhysicsBody <class_PhysicsBody>` the sword "
"collided with has a function/method called ``damage`` using the "
"``has_method`` function. If the :ref:`PhysicsBody <class_PhysicsBody>` has a "
"function called ``damage_body``, we call it and pass the amount of damage "
"the sword does, ``SWORD_DAMAGE``, to it."
msgstr ""
"Entonces comprobamos si el :ref:``PhysicsBody <class_PhysicsBody>` con el "
"que colisionó la espada tiene una función/método llamado ``damage`` usando "
"la función ``has_method``. Si :ref:`PhysicsBody <class_PhysicsBody>` tiene "
"una función llamada ``damage_body``, la llamamos y le pasamos la cantidad de "
"daño que hace la espada, ``SWORD_DAMAGE``."

msgid ""
"Next we check to see if the :ref:`PhysicsBody <class_PhysicsBody>` the sword "
"collided with is a :ref:`RigidBody <class_RigidBody>`. If what the sword "
"collided with is a :ref:`RigidBody <class_RigidBody>` node, we then check to "
"see if the sword is being held by a VR controller or not by checking to see "
"if ``controller`` is equal to ``null``."
msgstr ""
"A continuación comprobamos si el :ref:`PhysicsBody <class_PhysicsBody>` con "
"el que chocó la espada es un :ref:`RigidBody <class_RigidBody>`. Si con lo "
"que la espada colisionó es un nodo :ref:`RigidBody <class_RigidBody>`, "
"entonces comprobamos si la espada está siendo sostenida por un controlador "
"VR o no comprobando si el ``controller`` es igual a ``null``."

msgid ""
"If the sword is not being held by a VR controller, ``controller`` is equal "
"to ``null``, then we move the :ref:`RigidBody <class_RigidBody>` node the "
"sword collided with using the ``apply_impulse`` function. For the "
"``position`` of the ``apply_impulse`` function, we use "
"``collision_position`` variable stored within the :ref:`KinematicCollision "
"<class_KinematicCollision>` class in ``collision_results``. For the "
"``velocity`` of the ``apply_impulse`` function, we use the "
"``collision_normal`` multiplied by the ``linear_velocity`` of the sword's :"
"ref:`RigidBody <class_RigidBody>` node multiplied by ``COLLISION_FORCE``."
msgstr ""
"Si la espada no está siendo sujetada por un controlador VR, ``controller`` "
"es igual a ``null``, entonces movemos el nodo :ref:`RigidBody "
"<class_RigidBody>`con el que colisionó la espada usando la función "
"``apply_impulse``. Para la ``position`` de la función ``apply_impulse``, "
"usamos la variable ``collision_position`` almacenada dentro de la clase :ref:"
"`KinematicCollision <class_KinematicCollision>` en ``collision_results``. "
"Para la velocidad de la función ``apply_impulse``, usamos la colisión normal "
"multiplicada por la velocidad lineal de la espada :ref:`RigidBody "
"<class_RigidBody>` multiplicado por el nodo ``COLLISION_FORCE``."

msgid ""
"If the sword is being held by a VR controller, ``controller`` is not equal "
"to ``null``, then we move the :ref:`RigidBody <class_RigidBody>` node the "
"sword collided with using the ``apply_impulse`` function. For the "
"``position`` of the ``apply_impulse`` function, we use "
"``collision_position`` variable stored within the :ref:`KinematicCollision "
"<class_KinematicCollision>` class in ``collision_results``. For the "
"``velocity`` of the ``apply_impulse`` function, we use the "
"``collision_normal`` multiplied by the VR controller's velocity multiplied "
"by ``COLLISION_FORCE``."
msgstr ""
"Si la espada no está siendo sujetada por un controlador VR, ``controller`` "
"es igual a ``null``, entonces movemos el nodo :ref:`RigidBody "
"<class_RigidBody>`con el que colisionó la espada usando la función "
"``apply_impulse``. Para la ``position`` de la función ``apply_impulse``, "
"usamos la variable ``collision_position`` almacenada dentro de la clase :ref:"
"`KinematicCollision <class_KinematicCollision>` en ``collision_results``. "
"Para la velocidad de la función ``apply_impulse``, usamos la colisión normal "
"multiplicada por la velocidad lineal de la espada :ref:`RigidBody "
"<class_RigidBody>` multiplicado por el nodo ``COLLISION_FORCE``."

msgid ""
"Finally, regardless of whether the :ref:`PhysicsBody <class_PhysicsBody>` is "
"a :ref:`RigidBody <class_RigidBody>` or not, we play the sound of the sword "
"colliding with something by calling ``play`` on ``sword_noise``."
msgstr ""
"Finalmente, sin importar si el :ref:`PhysicsBody <class_PhysicsBody>` es un :"
"ref:`RigidBody <class_RigidBody>` o no, tocamos el sonido de la espada "
"colisionando con algo llamando a ``play`` en ``sword_noise``."

msgid "Sword finished"
msgstr "Espada terminada"

msgid ""
"With that done, you can now slice through the targets! You can find the "
"sword in the corner in between the shotgun and the pistol."
msgstr ""
"¡Con eso hecho, ahora puedes cortar los objetivos! Puedes encontrar la "
"espada en la esquina entre la escopeta y la pistola."

msgid "Updating the target UI"
msgstr "Actualización de la UI de destino"

msgid "Let's update the UI as the sphere targets are destroyed."
msgstr "Actualicemos la UI cuando los objetivos de la esfera sean destruidos."

msgid ""
"Open up ``Main_VR_GUI.tscn``, which you can find in the ``Scenes`` folder. "
"Feel free to look at how the scene is setup if you want, but in an effort to "
"keep this tutorial from becoming too long, we will not be covering the scene "
"setup in this tutorial."
msgstr ""
"Abre el ``Main_VR_GUI.tscn``, que puedes encontrar en la carpeta ``Scenes``. "
"Si quieres, puedes ver cómo se configura la escena, pero en un esfuerzo por "
"evitar que este tutorial se alargue demasiado, no vamos a cubrir la "
"configuración de la escena en este tutorial."

msgid ""
"Expand the ``GUI`` :ref:`Viewport <class_Viewport>` node and then select the "
"``Base_Control`` node. Add a new script called ``Base_Control.gd``, and add "
"the following:"
msgstr ""
"Expande el nodo ``GUI`` :ref:`Viewport <class_Viewport>` y luego selecciona "
"el nodo ``Base_Control``. Añade un nuevo script llamado ``Base_Control.gd``, "
"y añade lo siguiente:"

msgid "Let's go over how this script works real quick."
msgstr "Veamos rápidamente cómo funciona este script."

msgid ""
"First, in ``_ready``, we get the :ref:`Label <class_Label>` that shows how "
"many spheres are left and assign it to the ``sphere_count_label`` class "
"variable. Next, we get ``Game.gd`` by using ``get_tree().root`` and assign "
"``sphere_ui`` to this script."
msgstr ""
"Primero, en ``_ready``, obtenemos la :ref:`Label <class_Label>` que muestra "
"cuántas esferas quedan y las asignamos a la variable de clase "
"``sphere_count_label``. A continuación, obtenemos ``Game.gd`` usando "
"``get_tree().root`` y asignamos ``sphere_ui`` a este script."

msgid ""
"In ``update_ui``, we change the sphere :ref:`Label <class_Label>`'s text. If "
"there is at least one sphere remaining, we change the text to show how many "
"spheres are still left in the world. If there are no more spheres remaining, "
"we change the text and congratulate the player."
msgstr ""
"En ``update_ui``, cambiamos el texto de la esfera :ref:`Label "
"<class_Label>`. Si queda al menos una esfera, cambiamos el texto para "
"mostrar cuántas esferas quedan en el mundo. Si no quedan más esferas, "
"cambiamos el texto y felicitamos al jugador."

msgid "Adding the final special RigidBody"
msgstr "Añadiendo el final especial de RigidBody"

msgid ""
"Finally, before we finish this tutorial, let's add a way to reset the game "
"while in VR."
msgstr ""
"Por último, antes de terminar este tutorial, añadamos una forma de reiniciar "
"el juego mientras está en VR."

msgid ""
"Open up ``Reset_Box.tscn``, which you will find in ``Scenes``. Select the "
"``Reset_Box`` :ref:`RigidBody <class_RigidBody>` node and make a new script "
"called ``Reset_Box.gd``. Add the following code:"
msgstr ""
"Abre ``Reset_Box.tscn``, que encontrarás en ``Scenes``. Selecciona el nodo "
"``Reset_Box`` :ref:`RigidBody <class_RigidBody>` y haz un nuevo script "
"llamado ``Reset_Box.gd``. Añade el siguiente código:"

msgid "Let's quickly go over how this script works."
msgstr "Veamos rápidamente cómo funciona este script."

msgid "Explaining the reset box code"
msgstr "Explicando el código de la caja de reinicio"

msgid ""
"Like with the other special :ref:`RigidBody <class_RigidBody>`-based objects "
"we've created, the reset box extends ``VR_Interactable_Rigidbody``."
msgstr ""
"Como con los otros objetos especiales :ref:`RigidBody <class_RigidBody>` "
"basados que hemos creado, el reset box se extiende "
"``VR_Interactable_Rigidbody``."

msgid ""
"The ``start_transform`` class variable will store the global transform of "
"the reset box when the game starts, the ``reset_timer`` class variable will "
"hold the length of time that has passed since the reset box's position has "
"moved, the ``RESET_TIME`` constant defines the length of time the reset box "
"has to wait before being reset, and the ``RESET_MIN_DISTANCE`` constant "
"defines how far the reset box has to be away from it's initial position "
"before the reset timer starts."
msgstr ""
"La variable de clase ``start_transform`` almacenará la transformación global "
"del reset box cuando comience el juego, la variable de clase ``reset_timer`` "
"mantendrá el tiempo que ha pasado desde que se ha movido la posición del "
"reset box, la constante ``RESET_TIME`` define el tiempo que el reset box "
"tiene que esperar antes de ser reiniciado, y la constante "
"``RESET_MIN_DISTANCE`` define cuán lejos tiene que estar el reset box de su "
"posición inicial antes de que comience el temporizador de reinicio."

msgid ""
"In the ``_ready`` function all we are doing is storing the "
"``global_transform`` of the reset position when the scene starts. This is so "
"we can reset the position, rotation, and scale of the reset box object to "
"this initial transform when enough time has passed."
msgstr ""
"En la función ``_ready`` todo lo que hacemos es almacenar la "
"``global_transform`` de la posición de reinicio cuando comienza la escena. "
"Esto es así para que podamos reajustar la posición, rotación y escala del "
"objeto del cuadro de restablecimiento a esta transformación inicial cuando "
"haya pasado suficiente tiempo."

msgid ""
"In the ``_physics_process`` function, the code checks to see if the reset "
"box's initial position to the reset box's current position is farther than "
"``RESET_MIN_DISTANCE``. If it is farther, then it starts adding time, "
"``delta``, to ``reset_timer``. Once ``reset_timer`` is more than or equal to "
"``RESET_TIME``, we reset the ``global_transform`` to the ``start_transform`` "
"so the reset box is back in its initial position. We then set "
"``reset_timer`` to ``0``."
msgstr ""
"En la función ``_physics_process``, el código comprueba si la posición "
"inicial del reset box a la posición actual del cuadro de restablecimiento "
"está más lejos que ``RESET_MIN_DISTANCE``. Si está más lejos, entonces "
"comienza a agregar tiempo, ``delta``, a ``reset_timer``. Una vez que "
"``reset_timer`` es más o igual a ``RESET_TIME``, reajustamos la "
"``global_transform`` a la ``start_transform`` para que la reset box vuelva a "
"su posición inicial. Luego ponemos ``reset_timer`` a ``0``."

msgid ""
"The ``interact`` function simply reloads the ``Game.tscn`` scene using "
"``get_tree().change_scene``. This will reload the game scene, resetting "
"everything."
msgstr ""
"La función ``interact`` simplemente recarga la escena ``Game.tscn`` usando "
"``get_tree().change_scene``. Esto recargará la escena del juego, reiniciando "
"todo."

msgid ""
"Finally, the ``dropped`` function resets the ``global_transform`` to the "
"initial transform in ``start_transform`` so the reset box has its initial "
"position/rotation. Then ``reset_timer`` is set to ``0`` so the timer is "
"reset."
msgstr ""
"Finalmente, la función ``dropped`` restablece la ``global_transform`` a la "
"transformación inicial en ``start_transform`` para que la reset box tenga su "
"posición/rotación inicial. Entonces ``reset_timer`` se pone en ``0`` para "
"que el temporizador se reinicie."

msgid "Reset box finished"
msgstr "Reset box terminada"

msgid ""
"With that done, when you grab and interact with the reset box, the entire "
"scene will reset/restart and you can destroy all the targets again!"
msgstr ""
"Una vez hecho esto, cuando agarres e interactúes con el cuadro de reinicio, "
"toda la escena se restablecerá/reiniciará y podrás destruir todos los "
"objetivos de nuevo!"

msgid ""
"Resetting the scene abruptly without any sort of transition can lead to "
"discomfort in VR."
msgstr ""
"Reajustar la escena de forma abrupta sin ningún tipo de transición puede "
"llevar a la incomodidad en la RV."

msgid "Final notes"
msgstr "Notas finales"

msgid "Whew! That was a lot of work."
msgstr "¡Wow! Eso fue un montón de trabajo."

msgid ""
"Now you have a fully working VR project with multiple different types of "
"special :ref:`RigidBody <class_RigidBody>`-based nodes that can be used and "
"extended. Hopefully this will help serve as an introduction to making fully-"
"featured VR games in Godot! The code and concepts detailed in this tutorial "
"can be expanded on to make puzzle games, action games, story-based games, "
"and more!"
msgstr ""
"Ahora tienes un proyecto de RV completamente funcional con múltiples tipos "
"diferentes de nodos especiales :ref:`RigidBody <class_RigidBody>`-basados "
"que pueden ser usados y extendidos. Esperemos que esto ayude a servir como "
"una introducción a la creación de juegos de RV con todas las características "
"en Godot! El código y los conceptos detallados en este tutorial pueden ser "
"ampliados para hacer juegos de puzzle, juegos de acción, juegos basados en "
"historia y ¡más!"

msgid ""
"You can download the finished project for this tutorial series on the "
"`OpenVR GitHub repository <https://github.com/GodotVR/godot_openvr_fps>`__, "
"under the releases tab!"
msgstr ""
"¡Puedes descargar el proyecto terminado para esta serie de tutoriales en el "
"repositorio `OpenVR GitHub <https://github.com/GodotVR/godot_openvr_fps>`__, "
"bajo la pestaña de releases!"

msgid "Translation status"
msgstr "Estado de traducción"
