# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "VR starter tutorial part 1"
msgstr "Tutorial VR para principiantes parte 1"

msgid "Introduction"
msgstr "Introducción"

msgid ""
"This tutorial will show you how to make a beginner VR game project in Godot."
msgstr ""
"Este tutorial te mostrará cómo crear un proyecto de juego VR básico en Godot."

msgid ""
"Keep in mind, **one of the most important things when making VR content is "
"getting the scale of your assets correct**! It can take lots of practice and "
"iterations to get this right, but there are a few things you can do to make "
"it easier:"
msgstr ""
"Tenga en cuenta, **una de las cosas más importantes al hacer el contenido de "
"la RV es conseguir la escala de tus recursos correctamente**! Puede requerir "
"mucha práctica e iteraciones para hacerlo bien, pero hay algunas cosas que "
"puedes hacer para hacerlo más fácil:"

msgid ""
"In VR, 1 unit is typically considered 1 meter. If you design your assets "
"around that standard, you can save yourself a lot of headache."
msgstr ""
"En la RV, una unidad se considera típicamente 1 metro. Si diseñas tus "
"activos en torno a ese estándar, puedes ahorrarte muchos dolores de cabeza."

msgid ""
"In your 3D modeling program, see if there is a way to measure and use real "
"world distances. In Blender, you can use the MeasureIt add-on; in Maya, you "
"can use the Measure Tool."
msgstr ""
"En tu programa de modelado 3D, vea si hay una forma de medir y usar las "
"distancias del mundo real. En Blender, puedes usar el complemento MeasureIt; "
"en Maya, puedes usar la Herramienta de Medición."

msgid ""
"You can make rough models using a tool like `Google Blocks <https://vr."
"google.com/blocks/>`__, and then refine in another 3D modelling program."
msgstr ""
"Puedes crear modelos aproximados utilizando una herramienta como `Google "
"Blocks <https://vr.google.com/blocks/>`__, y luego refinarlos en otro "
"programa de modelado 3D."

msgid ""
"Test often, as the assets can look dramatically different in VR than on a "
"flat screen!"
msgstr ""
"¡Pruebe a menudo, ya que los recursos pueden verse dramáticamente diferentes "
"en la RV que en una pantalla plana!"

msgid "Throughout the course of this tutorial, we will cover:"
msgstr "A lo largo del curso de este tutorial, cubriremos:"

msgid "How to tell Godot to run in VR."
msgstr "Cómo decirle a Godot que corra en RV."

msgid ""
"How to make a teleportation locomotion system that uses the VR controllers."
msgstr ""
"Cómo hacer un sistema de locomoción de teletransportación que utilice los "
"controladores VR."

msgid ""
"How to make a artificial movement locomotion system that uses the VR "
"controllers."
msgstr ""
"Cómo hacer un sistema de locomoción de movimiento artificial que utiliza los "
"controladores VR."

msgid ""
"How to create a :ref:`RigidBody <class_RigidBody>`-based system that allows "
"for picking up, dropping, and throwing RigidBody nodes using the VR "
"controllers."
msgstr ""
"Cómo hacer un sistema basado en :ref:`RigidBody <class_RigidBody>` que "
"permita agarrar, soltar y arrojar nodos RigidBody usando controladores VR."

msgid "How to create simple destroyable target."
msgstr "Cómo crear objetos destruibles simples."

msgid ""
"How to create some special :ref:`RigidBody <class_RigidBody>`-based objects "
"that can destroy the targets."
msgstr ""
"Cómo hacer un sistema basado en objetos :ref:`RigidBody "
"<class_RigidBody>`que puedan destruir blancos."

msgid ""
"While this tutorial can be completed by beginners, it is highly advised to "
"complete :ref:`doc_your_first_2d_game`, if you are new to Godot and/or game "
"development."
msgstr ""
"Si bien este tutorial puede ser completado por principiantes, se recomienda "
"encarecidamente completar :ref:`doc_your_first_2d_game` si eres nuevo en "
"Godot y/o en el desarrollo de juegos."

msgid ""
"**Some experience with making 3D games is required** before going through "
"this tutorial series. This tutorial assumes you have experience with the "
"Godot editor, GDScript, and basic 3D game development. A OpenVR-ready "
"headset and two OpenVR-ready controllers are required."
msgstr ""
"**Se requiere cierta experiencia en la creación de juegos 3D** antes de "
"pasar por esta serie de tutoriales. Este tutorial asume que tienes "
"experiencia con el editor de Godot, GDScript, y el desarrollo básico de "
"juegos 3D. Se requieren unos auriculares listos para OpenVR y dos "
"controladores listos para OpenVR."

msgid ""
"This tutorial was written and tested using a Windows Mixed Reality headset "
"and controllers. This project has also been tested on the HTC Vive. Code "
"adjustments may be required for other VR Headsets, such as the Oculus Rift."
msgstr ""
"Este tutorial fue escrito y probado usando un auricular y controladores de "
"Realidad Mixta de Windows. Este proyecto también ha sido probado en el HTC "
"Vive. Es posible que se requieran ajustes de código para otros auriculares "
"de RV, como el Oculus Rift."

msgid ""
"The Godot project for this tutorial is found on the `OpenVR GitHub "
"repository <https://github.com/GodotVR/godot_openvr_fps>`__. The starter "
"assets for this tutorial can be found in the releases section on the GitHub "
"repository. The starter assets contain some 3D models, sounds, scripts, and "
"scenes that are configured for this tutorial."
msgstr ""
"El proyecto de Godot para este tutorial se encuentra en el `repositorio de "
"GitHub de OpenVR <https://github.com/GodotVR/godot_openvr_fps>`__. Los "
"activos iniciales para este tutorial se encuentran en la sección de "
"versiones (releases) del repositorio de GitHub. Los activos iniciales "
"contienen algunos modelos 3D, sonidos, scripts y escenas configuradas para "
"este tutorial."

msgid "**Credits for the assets provided**:"
msgstr "**Créditos por los recursos proporcionados**:"

msgid ""
"The sky panorama was created by `CGTuts <https://cgi.tutsplus.com/articles/"
"freebie-8-awesome-ocean-hdris--cg-5684>`__."
msgstr ""
"El panorama del cielo fue creado por `CGTuts <https://cgi.tutsplus.com/"
"articles/freebie-8-awesome-ocean-hdris--cg-5684>`__."

msgid "The font used is Titillium-Regular"
msgstr "La fuente utilizada es Titillium-Regular"

msgid "The font is licensed under the SIL Open Font License, Version 1.1"
msgstr "La fuente está licenciada bajo la SIL Open Font License, Version 1.1"

msgid ""
"The audio used are from several different sources, all downloaded from the "
"Sonniss #GameAudioGDC Bundle (`License PDF <https://sonniss.com/gdc-bundle-"
"license/>`__)"
msgstr ""
"Los audios utilizados provienen de varias fuentes diferentes, todos "
"descargados del Sonniss #GameAudioGDC Bundle (`Licencia PDF <https://sonniss."
"com/gdc-bundle-license/>`__)"

msgid ""
"The folders where the audio files are stored have the same name as folders "
"in the Sonniss audio bundle."
msgstr ""
"Las carpetas donde se almacenan los archivos de audio tienen el mismo nombre "
"que las carpetas del paquete de audio de Sonniss."

msgid ""
"The OpenVR addon was created by `Bastiaan Olij <https://github.com/"
"BastiaanOlij>`__ and is released under the MIT license. It can be found both "
"on the `Godot Asset Library <https://godotengine.org/asset-library/"
"asset/150>`__ and on `GitHub <https://github.com/GodotVR/godot-openvr-"
"asset>`__. *3rd party code and libraries used in the OpenVR addon may be "
"under a different license.*"
msgstr ""
"El complemento OpenVR fue creado por `Bastiaan Olij <https://github.com/"
"BastiaanOlij>`__ y se distribuye bajo la licencia MIT. Se puede encontrar "
"tanto en la `Biblioteca de Activos de Godot <https://godotengine.org/asset-"
"library/asset/150>`__ como en `GitHub <https://github.com/GodotVR/godot-"
"openvr-asset>`__. *Código y bibliotecas de terceros utilizados en el "
"complemento OpenVR pueden tener una licencia diferente.*"

msgid ""
"The initial project, 3D models, and scripts were created by `TwistedTwigleg "
"<https://github.com/TwistedTwigleg>`__ and is released under the MIT license."
msgstr ""
"El proyecto inicial, los modelos 3D y los scripts fueron creados por "
"`TwistedTwigleg <https://github.com/TwistedTwigleg>`__ y se distribuyen bajo "
"la licencia MIT."

msgid ""
"You can find the finished project on the `OpenVR GitHub repository <https://"
"github.com/GodotVR/godot_openvr_fps>`__."
msgstr ""
"Puedes encontrar el proyecto terminado en el repositorio de GitHub de "
"OpenVR: `https://github.com/GodotVR/godot_openvr_fps`__."

msgid "Getting everything ready"
msgstr "Preparando todo"

msgid ""
"If you have not already, go to the `OpenVR GitHub repository <https://github."
"com/GodotVR/godot_openvr_fps/releases/>`__ and download the \"Starter "
"Assets\" file from the releases. Once you have the starter assets "
"downloaded, open up the project in Godot."
msgstr ""
"Si aún no lo has hecho, ve al repositorio de GitHub de OpenVR: `https://"
"github.com/GodotVR/godot_openvr_fps/releases/` y descarga el archivo "
"\"Starter Assets\" desde las versiones. Una vez que tengas los assets "
"iniciales descargados, abre el proyecto en Godot."

msgid ""
"The starter assets are not required to use the scripts provided in this "
"tutorial. The starter assets include several premade scenes and scripts that "
"will be used throughout the tutorial."
msgstr ""
"Los recursos ofrecidos no son requeridos para usar los scripts provistos en "
"este tutorial. Estos recursos incluyen escenas prefabricadas y scripts que "
"se usarán a lo largo del tutorial."

msgid ""
"When the project is first loaded, the Game.tscn scene will be opened. This "
"will be the main scene used for the tutorial. It includes several nodes and "
"scenes already placed throughout the scene, some background music, and "
"several GUI-related :ref:`MeshInstance <class_MeshInstance>` nodes."
msgstr ""
"Cuando el proyecto se cargue por primera vez, se abrirá la escena de Game."
"tscn. Esta será la escena principal usada para el tutorial. Incluye varios "
"nodos y escenas ya colocadas a lo largo de la escena, algo de música de "
"fondo, y varios nodos relacionados con la interfaz gráfica :ref:"
"`MeshInstance <class_MeshInstance>`."

msgid ""
"The GUI-related :ref:`MeshInstance <class_MeshInstance>` nodes already have "
"scripts attached to them. These scripts will set the texture of a :ref:"
"`Viewport <class_Viewport>` node to the albedo texture of the material of "
"the :ref:`MeshInstance <class_MeshInstance>` node. This is used to display "
"text within the VR project. Feel free to take a look at the script, ``GUI."
"gd``, if you want. We will not be going over how to to use :ref:`Viewport "
"<class_Viewport>` nodes for displaying UI on :ref:`MeshInstance "
"<class_MeshInstance>` nodes in this tutorial ."
msgstr ""
"Los nodos relacionados con el GUI :ref:`MeshInstance <class_MeshInstance>` "
"ya tienen scripts adjuntos. Estos scripts fijarán la textura de un nodo :ref:"
"`Viewport <class_Viewport>` a la textura del albedo del material del nodo :"
"ref:`MeshInstance <class_MeshInstance>`. Esto se utiliza para mostrar el "
"texto dentro del proyecto VR. Siéntete libre de echar un vistazo al script, "
"``GUI.gd``, si quieres. No vamos a repasar cómo usar los nodos :ref:"
"`Viewport <class_Viewport>` para mostrar la interfaz de usuario en los "
"nodos :ref:`MeshInstance <class_MeshInstance>` de este tutorial."

msgid ""
"If you are interested in how to use :ref:`Viewport <class_Viewport>` nodes "
"for displaying UI on :ref:`MeshInstance <class_MeshInstance>` nodes, see "
"the :ref:`doc_viewport_as_texture` tutorial. It covers how to use a :ref:"
"`Viewport <class_Viewport>` as a render texture, along with how to apply "
"that texture onto a :ref:`MeshInstance <class_MeshInstance>` node."
msgstr ""
"Si le interesa cómo usar los nodos :ref:`Viewport <class_Viewport>` para "
"mostrar la interfaz de usuario en los nodos :ref:`MeshInstance "
"<class_MeshInstance>`, vea el tutorial :ref:`doc_viewport_as_texture`. Cubre "
"cómo usar un :ref:`Viewport <class_Viewport>` como una textura de "
"renderizado, junto con cómo aplicar esa textura en un nodo :ref:"
"`MeshInstance <class_MeshInstance>`."

msgid ""
"Before we jump into the tutorial, let's take a moment to talk about how the "
"nodes used for VR work."
msgstr ""
"Antes de comenzar con el tutorial, nos tomaremos un momento paraver cómo "
"funcionan los nodos utilizados para VR."

msgid ""
"The :ref:`ARVROrigin <class_ARVROrigin>` node is the center point of the VR "
"tracking system. The position of the :ref:`ARVROrigin <class_ARVROrigin>` is "
"the position the VR system considers the 'center' point on the floor. The :"
"ref:`ARVROrigin <class_ARVROrigin>` has a `world scale` property that "
"effects the size of the user within the VR scene. For this tutorial, it is "
"set to `1.4`, as the world was originally just a tad to big. As mentioned "
"earlier, keeping the scale relatively consistent is important in VR."
msgstr ""
"El nodo :ref:`ARVROrigin <clase_ARVROrigin>` es el punto central del sistema "
"de seguimiento de la RV. La posición del nodo :ref:`ARVROrigin "
"<class_ARVROrigin>` es la posición que el sistema de RV considera como el "
"punto 'central' en el suelo. El :ref:`ARVROrigin <class_ARVROrigin>` tiene "
"una propiedad de `escala mundial` que afecta al tamaño del usuario dentro de "
"la escena de RV. Para este tutorial, está configurado en `1.4`, ya que el "
"mundo era originalmente un poco más grande. Como se mencionó anteriormente, "
"mantener la escala relativamente consistente es importante en la RV."

msgid ""
"The :ref:`ARVRCamera <class_ARVRCamera>` is the player's headset and view "
"into the scene. The :ref:`ARVRCamera <class_ARVRCamera>` is offset on the Y "
"axis by the VR user's height, which will be important later when we add "
"teleportation locomotoin. If the VR system supports room tracking, then the :"
"ref:`ARVRCamera <class_ARVRCamera>` will move as the player moves. This "
"means that the :ref:`ARVRCamera <class_ARVRCamera>` is not guaranteed to be "
"in the same position as the :ref:`ARVROrigin <class_ARVROrigin>` node."
msgstr ""
"El :ref:`ARVRCamera <clase_ARVRCamera>` es el auricular del jugador y la "
"vista en la escena. El :ref:`ARVRCamera <class_ARVRCamera>` está desplazado "
"en el eje Y por la altura del usuario del VR, lo que será importante más "
"tarde cuando añadamos la locomoción de teletransportación. Si el sistema de "
"RV soporta el rastreo de habitaciones, entonces el :ref:`ARVRCamera "
"<class_ARVRCamera>` se moverá a medida que el jugador se mueva. Esto "
"significa que el :ref:`ARVRCamera <class_ARVRCamera>` no está garantizado "
"que esté en la misma posición que el nodo :ref:`ARVROrigin "
"<class_ARVROrigin>`."

msgid ""
"The :ref:`ARVRController <class_ARVRController>` node represents a VR "
"controller. The :ref:`ARVRController <class_ARVRController>` will follow the "
"position and rotation of the VR controller relative to the :ref:`ARVROrigin "
"<class_ARVROrigin>` node. All of the input for the VR controllers happens "
"through the :ref:`ARVRController <class_ARVRController>` node. An :ref:"
"`ARVRController <class_ARVRController>` node with an ``ID`` of ``1`` "
"represents the left VR controller, while an :ref:`ARVRController "
"<class_ARVRController>` controller with an ``ID`` of ``2`` represents the "
"right VR controller."
msgstr ""
"El nodo :ref:`ARVRController <class_ARVRController>` representa un "
"controlador de RV. El :ref:`ARVRController <class_ARVRController>` seguirá "
"la posición y rotación del controlador VR relativo al nodo :ref:`ARVROrigin "
"<class_ARVROrigin>`. Toda la entrada de los controladores VR pasa por el "
"nodo :ref:`ARVRController <class_ARVRController>`. Un nodo :ref:"
"`ARVRController <class_ARVRController>` con un ``ID`` de ``1`` representa el "
"controlador VR izquierdo, mientras que un :ref:`ARVRController "
"<class_ARVRController>` controlador con un ``ID`` de ``2`` representa el "
"controlador VR derecho."

msgid "To summarize:"
msgstr "Para resumir:"

msgid ""
"The :ref:`ARVROrigin <class_ARVROrigin>` node is the center of the VR "
"tracking system and is positioned on the floor."
msgstr ""
"El nodo :ref:`ARVROrigin <clase_ARVROrigin>` es el centro del sistema de "
"seguimiento de la RV y está situado en el suelo."

msgid ""
"The :ref:`ARVRCamera <class_ARVRCamera>` is the player's VR headset and view "
"into the scene."
msgstr ""
"El :ref:`ARVRCamera <class_ARVRCamera>` es el auricular de RV del jugador y "
"la vista en la escena."

msgid ""
"The :ref:`ARVRCamera <class_ARVRCamera>` node is offset on the Y axis by the "
"user's height."
msgstr ""
"El nodo :ref:`ARVRCamera <class_ARVRCamera>` está desplazado en el eje Y por "
"la altura del usuario."

msgid ""
"If the VR system supports room tracking, then the :ref:`ARVRCamera "
"<class_ARVRCamera>` node may be offset on the X and Z axes as the player "
"moves."
msgstr ""
"Si el sistema de RV soporta el rastreo de habitaciones, entonces el nodo :"
"ref:`ARVRCamera <class_ARVRCamera>` puede ser desplazado en los ejes X y Z a "
"medida que el jugador se mueve."

msgid ""
"The :ref:`ARVRController <class_ARVRController>` nodes represent the VR "
"controllers and handle all of the input from the VR controllers."
msgstr ""
"Los nodos :ref:`ARVRController <class_ARVRController>` representan los "
"controladores de RV y manejan todas las entradas de los controladores de RV."

msgid "Starting VR"
msgstr "Iniciando con la VR"

msgid ""
"Now that we have gone over the VR nodes, let's start working on the project. "
"While in ``Game.tscn``, select the ``Game`` node and make a new script "
"called ``Game.gd``. In the ``Game.gd`` file, add the following code:"
msgstr ""
"Ahora que hemos repasado los nodos VR, empecemos a trabajar en el proyecto. "
"Mientras que en ``Game.tscn``, selecciona el nodo ``Game`` y haz un nuevo "
"script llamado ``Game.gd``. En el archivo ``Game.gd``, añade el siguiente "
"código:"

msgid "Let's go over what this code does."
msgstr "Veamos lo que hace este código."

msgid ""
"In the ``_ready`` function, we first get the OpenVR VR interface using the "
"``find_interface`` function in the :ref:`ARVRServer <class_ARVRServer>` and "
"assign it to a variable called `VR`. If the :ref:`ARVRServer "
"<class_ARVRServer>` finds an interface with the name OpenVR, it will return "
"it, otherwise it will return ``null``."
msgstr ""
"En la función ``_ready``, primero obtenemos la interfaz OpenVR VR usando la "
"función ``find_interface`` en el :ref:`ARVRServer <class_ARVRServer>` y la "
"asignamos a una variable llamada `VR``. Si :ref:`ARVRServer "
"<class_ARVRServer>` encuentra una interfaz con el nombre OpenVR, la "
"devolverá, de lo contrario devolverá ``null``."

msgid ""
"The OpenVR VR interface is not included with Godot by default. You will need "
"to download the OpenVR asset from the `Asset Library <https://godotengine."
"org/asset-library/asset/150>`__ or `GitHub <https://github.com/GodotVR/godot-"
"openvr-asset>`__."
msgstr ""
"La interfaz de realidad virtual de OpenVR no está incluida en Godot por "
"defecto. Necesitarás descargar el complemento de OpenVR desde la `Biblioteca "
"de Activos <https://godotengine.org/asset-library/asset/150>`__ o desde "
"`GitHub <https://github.com/GodotVR/godot-openvr-asset>`__."

msgid ""
"The code then combines two conditionals, one to check if the `VR` variable "
"is NOT null (``if VR``) and another calls the initialize function, which "
"returns a boolean based on whether the OpenVR interface was able to "
"initialize or not. If both of these conditionals return true, then we can "
"turn the main Godot :ref:`Viewport <class_Viewport>` into an ARVR viewport."
msgstr ""
"El código combina entonces dos condicionales, uno para comprobar si la "
"variable `VR` NO es nula (``if VR``) y otro llama a la función de "
"inicialización, que devuelve un booleano basado en si la interfaz OpenVR fue "
"capaz de inicializar o no. Si ambos condicionales devuelven true, entonces "
"podemos convertir el Godot principal :ref:`Viewport <class_Viewport>` en un "
"viewport ARVR."

msgid ""
"If the VR interface initialized successfully, we then get the root :ref:"
"`Viewport <class_Viewport>` and set the `arvr` property to ``true``. This "
"will tell Godot to use the initialized ARVR interface to drive the :ref:"
"`Viewport <class_Viewport>` display."
msgstr ""
"Si la interfaz de RV se inicializa con éxito, entonces obtenemos la raíz :"
"ref:`Viewport <class_Viewport>` y ponemos la propiedad `arvr` como ``true``. "
"Esto le dirá a Godot que use la interfaz ARVR inicializada para manejar la "
"pantalla :ref:`Viewport <class_Viewport>`."

msgid ""
"Finally, we disable VSync so the Frames Per Second (FPS) is not capped by "
"the computer monitor. After this we tell Godot to render at ``90`` frames "
"per second, which is the standard for most VR headsets. Without disabling "
"VSync, the normal computer monitor may limit the frame rate of the VR "
"headset to the frame rate of the computer monitor."
msgstr ""
"Finalmente, desactivamos VSync para que el monitor de la computadora no "
"limite los fotogramas por segundo (FPS). Después de esto le decimos a Godot "
"que renderice a ``90`` fotogramas por segundo, que es el estándar para la "
"mayoría de los auriculares VR. Sin desactivar el VSync, el monitor normal de "
"la computadora puede limitar la velocidad de fotogramas del auricular VR a "
"la velocidad de fotogramas del monitor de la computadora."

msgid ""
"In the project settings, under the ``Physics->Common`` tab, the physics FPS "
"has been set to ``90``. This makes the physics engine run at the same frame "
"rate as the VR display, which makes physics reactions look smoother when in "
"VR."
msgstr ""
"En la configuración del proyecto, en la pestaña ``Physics->Common``, el FPS "
"de física se ha establecido en \"90\". Esto hace que el motor de física "
"funcione a la misma velocidad de fotograma que la pantalla de RV, lo que "
"hace que las reacciones físicas se vean más suaves cuando se está en RV."

msgid ""
"That is all we need to do for Godot to launch OpenVR within the project! Go "
"ahead and give it a try if you want. Assuming everything works, you will be "
"able to look around the world. If you have a VR headset with room tracking, "
"then you will be able to move around the scene within the limits of the room "
"tracking."
msgstr ""
"¡Eso es todo lo que tenemos que hacer para que Godot lance OpenVR dentro del "
"proyecto! Adelante, inténtalo si quieres. Asumiendo que todo funcione, "
"podrás mirar alrededor del mundo. Si tienes unos auriculares de RV con "
"rastreo de habitaciones, entonces podrás moverte por la escena dentro de los "
"límites del rastreo de habitaciones."

msgid "Creating the controllers"
msgstr "Creando los controladores"

msgid ""
"Right now all that the VR user can do is stand around, which isn't really "
"what we are going for unless we are working on a VR film. Lets write the "
"code for the VR controllers. We are going to write all the code for the VR "
"controllers in one go, so the code is rather long. That said, once we are "
"finished you will be able to teleport around the scene, artificially move "
"using the touchpad/joystick on the VR controller, and be able to pick up, "
"drop, and throw :ref:`RigidBody <class_RigidBody>`-based nodes."
msgstr ""
"Ahora mismo todo lo que el usuario de RV puede hacer es quedarse parado, lo "
"cual no es realmente lo que buscamos a menos que estemos trabajando en una "
"película de RV. Escribamos el código para los controladores de RV. Vamos a "
"escribir todo el código para los controladores de RV de una sola vez, por lo "
"que el código es bastante largo. Dicho esto, una vez que hayamos terminado, "
"podrás teletransportarte por la escena, moverte artificialmente usando el "
"touchpad/joystick del controlador VR, y ser capaz de recoger, soltar y "
"lanzar :ref:`RigidBody <class_RigidBody>` nodos basados en la RV."

msgid ""
"First we need to open the scene used for the VR controllers. "
"``Left_Controller.tscn`` or ``Right_Controller.tscn``. Let's briefly go over "
"how the scene is setup."
msgstr ""
"Primero necesitamos abrir la escena usada para los controladores VR. "
"``Left_Controller.tscn`` o ``Right_Controller.tscn``. Repasemos brevemente "
"cómo se configura la escena."

msgid "How the VR controller scene is setup"
msgstr "Cómo se configura la escena del controlador VR"

msgid ""
"In both scenes the root node is a ARVRController node. The only difference "
"is that the ``Left_Controller`` scene has the ``Controller Id`` property set "
"to ``1`` while the ``Right_Controller`` has the ``Controller Id`` property "
"set to ``2``."
msgstr ""
"En ambas escenas el nodo raíz es un nodo ARVRController. La única diferencia "
"es que la escena ``Left_Controller`` tiene la propiedad ``Controller Id`` "
"puesta a ``1`` mientras que la ``Right_Controller`` tiene la propiedad "
"``Controller Id`` puesta a ``2``."

msgid ""
"The :ref:`ARVRServer <class_ARVRServer>` attempts to use these two IDs for "
"the left and right VR controllers. For VR systems that support more than 2 "
"controllers/tracked-objects, these IDs may need adjusting."
msgstr ""
"El :ref:`ARVRServer <class_ARVRServer>` intenta usar estas dos "
"identificaciones para los controladores VR izquierdo y derecho. Para los "
"sistemas de RV que soportan más de 2 controladores/objetos rastreados, estos "
"IDs pueden necesitar un ajuste."

msgid ""
"Next is the ``Hand`` :ref:`MeshInstance <class_MeshInstance>` node. This "
"node is used to display the hand mesh that will be used when the VR "
"controller is not holding onto a :ref:`RigidBody <class_RigidBody>` node. "
"The hand in the ``Left_Controller`` scene is a left hand, while the hand on "
"the ``Right_Controller`` scene is a right hand."
msgstr ""
"El siguiente es el nodo ``Hand`` :ref:`MeshInstance <clase_MeshInstance>`. "
"Este nodo se usa para mostrar la malla de mano que se usará cuando el "
"controlador de VR no esté sosteniendo un nodo :ref:`RigidBody "
"<class_RigidBody>`. La mano en la escena ``Left_Controller`` es una mano "
"izquierda, mientras que la mano en la escena ``Right_Controller`` es una "
"mano derecha."

msgid ""
"The node named ``Raycast`` is a :ref:`Raycast <class_Raycast>` node that is "
"used for aiming where to teleport to when the VR controller is teleporting. "
"The length of the :ref:`Raycast <class_Raycast>` is set to ``-16`` on the Y "
"axis and is rotated so that it points out of the pointer finger of the hand. "
"The ``Raycast`` node has a single child node, ``Mesh``, that is a :ref:"
"`MeshInstance <class_MeshInstance>`. This is used for visually showing where "
"the teleportation :ref:`Raycast <class_Raycast>` is aiming."
msgstr ""
"El nodo llamado ``Raycast`` es un nodo :ref:`Raycast <clase_Raycast>` que se "
"usa para apuntar a dónde teletransportarse cuando el controlador VR se "
"teletransporta. La longitud del :ref:`Raycast <class_Raycast>` se establece "
"en ``-16`` del eje Y y se gira para que apunte con el dedo índice de la "
"mano. El nodo ``Raycast`` tiene un único nodo hijo, ``Mesh``, que es un "
"\"ref:`MeshInstance <class_MeshInstance>`. Esto se usa para mostrar "
"visualmente a dónde apunta la teletransportación :ref:`Raycast "
"<class_Raycast>`."

msgid ""
"The node named ``Area`` is a :ref:`Area <class_Area>` node will be used for "
"grabbing :ref:`RigidBody <class_RigidBody>`-based nodes when the VR "
"controller grab mode is set to ``AREA``. The ``Area`` node has a single "
"child node, ``CollisionShape``, that defines a sphere :ref:`CollisionShape "
"<class_CollisionShape>`. When the VR controller is not holding any objects "
"and the grab button is pressed, the first :ref:`RigidBody <class_RigidBody>`-"
"based node within the ``Area`` node will be picked up."
msgstr ""
"El nodo llamado ``Area`` es un nodo :ref:`Area <class_Area>` que se usará "
"para agarrar :ref:`RigidBody <class_RigidBody>` nodos basados en el modo de "
"agarre del controlador VR cuando el modo de agarre del controlador VR esté "
"configurado en ``AREA``. El nodo ``Area`` tiene un nodo hijo único, "
"``CollisionShape``, que define una esfera :ref:`CollisionShape "
"<class_CollisionShape>`. Cuando el controlador de VR no tiene ningún objeto "
"y se pulsa el botón de agarre, el primer nodo basado en :ref:`RigidBody "
"<class_RigidBody>` dentro del nodo ``Area`` será recogido."

msgid ""
"Next is a :ref:`Position3D <class_Position3D>` node called ``Grab_Pos``. "
"This is used to define the position that grabbed :ref:`RigidBody "
"<class_RigidBody>` nodes will follow then they are held by the VR controller."
msgstr ""
"Lo siguiente es un nodo :ref:`Position3D <clase_Position3D>` llamado "
"``Grab_Pos``. Esto se usa para definir la posición que seguirán los nodos :"
"ref:`RigidBody <class_RigidBody>` que son mantenidos por el controlador VR."

msgid ""
"A large :ref:`Area <class_Area>` node called ``Sleep_Area`` is used to "
"disable sleeping for any RigidBody nodes within its :ref:`CollisionShape "
"<class_CollisionShape>`, simple called ``CollisionShape``. This is needed "
"because if a :ref:`RigidBody <class_RigidBody>` node falls asleep, then the "
"VR controller will be unable to grab it. By using ``Sleep_Area``, we can "
"write code that makes any :ref:`RigidBody <class_RigidBody>` node within it "
"not able to sleep, therefore allowing the VR controller to grab it."
msgstr ""
"Un gran nodo :ref:`Area <clase_Area>` llamado ``SleepArea`` se usa para "
"deshabilitar el dormir para cualquier nodo de RigidBody dentro de su :ref:"
"`ColisionShape <class_ColisionShape>`, simple llamado ``ColisionShape``. "
"Esto es necesario porque si un nodo :ref:`RigidBody <class_RigidBody>` se "
"duerme, entonces el controlador de VR será incapaz de agarrarlo. Usando "
"``Sleep_Area``, podemos escribir código que haga que cualquier nodo :ref:"
"`RigidBody <class_RigidBody>` dentro de él no pueda dormir, permitiendo así "
"que el controlador de VR lo agarre."

msgid ""
"An :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node called "
"``AudioStreamPlayer3D`` has a sound loaded that we will use when an object "
"has been picked up, dropped or thrown by the VR controller. While this is "
"not necessary for the functionality of the VR controller, it makes grabbing "
"and dropping objects feel more natural."
msgstr ""
"Un nodo :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` llamado "
"``AudioStreamPlayer3D`` tiene cargado un sonido que usaremos cuando un "
"objeto haya sido recogido, dejado o lanzado por el controlador VR. Aunque "
"esto no es necesario para la funcionalidad del controlador de VR, hace que "
"el agarrar y soltar objetos se sienta más natural."

msgid ""
"Finally, the last nodes are the ``Grab_Cast`` node and it's only child node, "
"``Mesh``. The ``Grab_Cast`` node will be used for grabbing :ref:`RigidBody "
"<class_RigidBody>`-based nodes when the VR controller grab mode is set to "
"``RAYCAST``. This will allow the VR controller to grab objects that are just "
"slightly out of reach using a Raycast. The ``Mesh`` node is used for "
"visually showing where the teleportation :ref:`Raycast <class_Raycast>` is "
"aiming."
msgstr ""
"Finalmente, los últimos nodos son el nodo ``Grab_Cast`` y el nodo hijo "
"único, ``Mesh``. El nodo ``Grab_Cast`` se usará para los nodos basados en "
"agarrado :ref:`RigidBody <class_RigidBody>` cuando el modo agarrar del "
"controlador VR esté en ``RAYCAST``. Esto permitirá al controlador VR agarrar "
"objetos que están ligeramente fuera de alcance usando un Raycast. El nodo "
"``Mesh`` se utiliza para mostrar visualmente a dónde apunta la "
"teletransportación :ref:`Raycast <class_Raycast>`."

msgid ""
"That is a quick overview of how the VR controller scenes are setup, and how "
"we will be using the nodes to provide the functionality for them. Now that "
"we have looked at the VR controller scene, let's write the code that will "
"drive them."
msgstr ""
"Este es un rápido resumen de cómo se configuran las escenas del controlador "
"VR, y cómo usaremos los nodos para proporcionarles la funcionalidad. Ahora "
"que hemos visto la escena del controlador VR, vamos a escribir el código que "
"los impulsará."

msgid "The code for the VR controllers"
msgstr "El código para los controles VR"

msgid ""
"Select the root node of the scene, either ``Right_Controller`` or "
"``Left_Controller``, and make a new script called ``VR_Controller.gd``. Both "
"scenes will be using the same script, so it doesn't matter which you use "
"first. With ``VR_Controller.gd`` opened, add the following code:"
msgstr ""
"Selecciona el nodo raíz de la escena, ya sea ``Right_Controller`` o "
"``Left_Controller``, y haz un nuevo script llamado ``VR_Controller.gd``. "
"Ambas escenas usarán el mismo script, así que no importa cuál uses primero. "
"Con ``VR_Controller.gd`` abierto, añade el siguiente código:"

msgid ""
"You can copy and paste the code from this page directly into the script "
"editor."
msgstr ""
"Puedes copiar y pegar el código de esta página directamente en el editor de "
"scripts."

msgid ""
"If you do this, all the code copied will be using spaces instead of tabs."
msgstr ""
"Si haces esto, todo el código copiado estará usando espacios en lugar de "
"tabulaciones."

msgid ""
"To convert the spaces to tabs in the script editor, click the ``Edit`` menu "
"and select ``Convert Indent To Tabs``. This will convert all the spaces into "
"tabs. You can select ``Convert Indent To Spaces`` to convert tabs back into "
"spaces."
msgstr ""
"Para convertir los espacios en tabulaciones en el editor de scripts, haz "
"clic en el menú ``Edit`` y selecciona ``Convert Indent To Tabs``. Esto "
"convertirá todos los espacios en pestañas. Puedes seleccionar ``Convert "
"Indent To Spaces`` para convertir las pestañas de nuevo en espacios."

msgid ""
"This is quite a bit of code to go through. Let's go through what the code "
"does step-by-step."
msgstr ""
"Esto es un poco de código para revisar. Repasemos lo que el código hace paso "
"a paso."

msgid "Explaining the VR controller code"
msgstr "Explicando el código de controles VR"

msgid "First, let's go through all the class variables in the script:"
msgstr "Primero, veamos todas las variables de la clase en el script:"

msgid ""
"``controller_velocity``: A variable to hold a rough approximation of the VR "
"controller's velocity."
msgstr ""
"``controller_velocity``: Una variable que contiene una aproximación "
"aproximada de la velocidad del controlador VR."

msgid ""
"``prior_controller_position``: A variable to hold the VR controller's last "
"position in 3D space."
msgstr ""
"``prior_controller_position``: Una variable para mantener la última posición "
"en el espacio del controlador VR."

msgid ""
"``prior_controller_velocities``: An Array to hold the last 30 calculated VR "
"controller velocities. This is used to smooth the velocity calculations over "
"time."
msgstr ""
"``prior_controller_velocities``: Un array para mantener las últimas 30 "
"velocidades calculadas del controlador VR. Esto se utiliza para suavizar los "
"cálculos de velocidad a lo largo del tiempo."

msgid ""
"``held_object``: A variable to hold a reference to the object the VR "
"controller is holding. If the VR controller is not holding any objects, this "
"variable will be ``null``."
msgstr ""
"``held_object``: Una variable para mantener una referencia al objeto que el "
"controlador VR está sosteniendo. Si el controlador VR no está sosteniendo "
"ningún objeto, esta variable será ``null``."

msgid ""
"``held_object_data``: A dictionary to hold data for the :ref:`RigidBody "
"<class_RigidBody>` node being held by the VR controller. This is used to "
"reset the :ref:`RigidBody <class_RigidBody>`'s data when it is no longer "
"held."
msgstr ""
"``held_object_data``: Un diccionario para guardar los datos del nodo :ref:"
"`RigidBody <class_RigidBody>` que está siendo guardado por el controlador de "
"VR. Se utiliza para restablecer los datos de :ref:`RigidBody "
"<class_RigidBody>` cuando ya no están mantenidos."

msgid ""
"``grab_area``: A variable to hold the :ref:`Area <class_Area>` node used to "
"grab objects with the VR controller."
msgstr ""
"``grab_area``: Una variable que contiene el nodo :ref:`Area <class_Area>` "
"usado para agarrar objetos con el controlador VR."

msgid ""
"``grab_raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` node "
"used to grab objects with the VR controller."
msgstr ""
"``grab_raycast``: Una variable que contiene el nodo :ref:`Raycast "
"<class_Raycast>` usado para agarrar objetos con el controlador VR."

msgid ""
"``grab_mode``: A variable to define the grab mode the VR controller is "
"using. There are only two modes for grabbing objects in this tutorial, "
"``AREA`` and ``RAYCAST``."
msgstr ""
"``grab_mode``: Una variable para definir el modo de agarre que el "
"controlador VR está usando. Sólo hay dos modos de agarrar objetos en este "
"tutorial, ``AREA`` y ``RAYCAST``."

msgid ""
"``grab_pos_node``: A variable to hold the node that will be used to update "
"the position and rotation of held objects."
msgstr ""
"\"Agarrar el nodo de la posición\": Una variable para mantener el nodo que "
"se usará para actualizar la posición y rotación de los objetos mantenidos."

msgid ""
"``hand_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that contains the hand mesh for the VR "
"controller. This mesh will be shown when the VR controller is not holding "
"anything."
msgstr ""
"``hand_mesh``: Una variable para mantener el nodo :ref:`MeshInstance "
"<class_MeshInstance>` que contiene la malla de la mano para el controlador "
"VR. Esta malla se mostrará cuando el controlador VR no sujete nada."

msgid ""
"``hand_pickup_drop_sound``: A variable to hold the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node that contains the pickup/drop sound."
msgstr ""
"``hand_pickup_drop_sound``:Una variable para mantener el nodo :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` que contiene el sonido "
"pickup/drop."

msgid ""
"``teleport_pos``: A variable to hold the position the player will be "
"teleported to when the VR controller teleports the player."
msgstr ""
"``teleport_pos``: Una variable para mantener la posición a la que se "
"teletransportará el jugador cuando el controlador VR lo haga."

msgid ""
"``teleport_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node used to show where the player is teleporting to."
msgstr ""
"``teleport_mesh``: Una variable que contiene el nodo :ref:`MeshInstance "
"<class_MeshInstance>` usado para mostrar dónde se está teletransportando el "
"jugador."

msgid ""
"``teleport_button_down``: A variable used to track whether the controller's "
"teleport button is held down. This will be used to detect if this VR "
"controller is trying to teleport the player."
msgstr ""
"``teleport_button_down``:Una variable usada para rastrear si el botón de "
"teleportación del controlador se mantiene pulsado. Esto se utilizará para "
"detectar si este controlador VR está tratando de teleportar al jugador."

msgid ""
"``teleport_raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` "
"node used to calculate the teleport position. This node also has a :ref:"
"`MeshInstance <class_MeshInstance>` that acts as a 'laser sight' for aiming."
msgstr ""
"``teleport_raycast``:Una variable para mantener el nodo :ref:`Raycast "
"<class_Raycast>` usado para calcular la posición de teleportación. Este nodo "
"también tiene un :ref:`MeshInstance <class_MeshInstance>` que actúa como una "
"'mira láser' para apuntar."

msgid ""
"``CONTROLLER_DEADZONE``: A constant to define the deadzone for both the "
"trackpad and the joystick on the VR controller. See the note below for more "
"information."
msgstr ""
"``CONTROLLER_DEADZONE``:Una constante para definir la zona muerta tanto para "
"el trackpad como para el joystick del controlador VR. Vea la nota de abajo "
"para más información."

msgid ""
"``MOVEMENT_SPEED``: A constant to define the speed the player moves at when "
"using the trackpad/joystick to move artificially."
msgstr ""
"``MOVEMENT_SPEED``: Una constante para definir la velocidad a la que se "
"mueve el jugador cuando usa el trackpad/joystick para moverse "
"artificialmente."

msgid ""
"``CONTROLLER_RUMBLE_FADE_SPEED``: A constant to define how fast the VR "
"controller rumble fades."
msgstr ""
"``CONTROLLER_RUMBLE_FADE_SPEED``: Una constante para definir la velocidad "
"con la que se desvanece el temblor del controlador VR."

msgid ""
"``directional_movement``: A variable to hold whether this VR controller is "
"moving the player using the touchpad/joystick."
msgstr ""
"``directional_movement``: Una variable para saber si este controlador VR "
"está moviendo el reproductor con el touchpad/joystick."

msgid ""
"You can find a great article explaining all about how to handle touchpad/"
"joystick dead zones `here <https://web.archive.org/web/20191208161810/http://"
"www.third-helix.com/2013/04/12/doing-thumbstick-dead-zones-right.html>`__."
msgstr ""
"Puedes encontrar un gran artículo explicando todo acerca de cómo manejar las "
"zonas muertas del touchpad/joystick \"aquí\". <https://web.archive.org/"
"web/20191208161810/http://www.third-helix.com/2013/04/12/doing-thumbstick-"
"dead-zones-right.html>`__."

msgid ""
"We are using a translated version of the scaled radial dead zone code "
"provided in that article for the VR controller's joystick/touchpad. The "
"article is a great read, and I highly suggest giving it a look!"
msgstr ""
"Estamos usando una versión traducida del código de la zona muerta radial "
"escalada que se proporciona en ese artículo para el joystick/touchpad del "
"controlador VR. El artículo es una gran lectura, ¡y sugiero encarecidamente "
"que le eches un vistazo!"

msgid ""
"That is quite a few class variables. Most of them are used to hold "
"references to nodes we will need throughout the code. Next let's start "
"looking at the functions, starting with the ``_ready`` function."
msgstr ""
"Son bastantes variables de clase. La mayoría de ellas se utilizan para "
"mantener referencias a los nodos que necesitaremos en todo el código. A "
"continuación vamos a empezar a ver las funciones, empezando por la función "
"``_ready``."

msgid "``_ready`` function step-by-step explanation"
msgstr "``_ready``explicación paso a paso de la función"

msgid ""
"First we tell Godot to silence the warnings about not using the values "
"returned by the ``connect`` function. We will not need the returned values "
"for this tutorial."
msgstr ""
"Primero le decimos a Godot que silencie las advertencias sobre no usar los "
"valores devueltos por la función ``connect``. No necesitaremos los valores "
"devueltos para este tutorial."

msgid ""
"Next we get the :ref:`Raycast <class_Raycast>` node we are going to use for "
"determining the position for teleporting and assign it to the "
"``teleport_raycast`` variable. We then get the :ref:`MeshInstance "
"<class_MeshInstance>` node that we will use to show where the player will be "
"teleporting to. The node we are using for teleporting is a child of the "
"``Game`` scene. We do this so the teleport mesh node is not effected by "
"changes in the VR controller, and so the teleport mesh can be used by both "
"VR controllers."
msgstr ""
"A continuación obtenemos el nodo :ref:`Raycast <class_Raycast>` que vamos a "
"usar para determinar la posición para el teletransporte y lo asignamos a la "
"variable ``teleport_raycast``. Entonces obtenemos el nodo :ref:`MeshInstance "
"<class_MeshInstance>` que usaremos para mostrar a dónde se teletransportará "
"el reproductor. El nodo que usamos para teletransportarnos es un hijo de la "
"escena ``Game``. Hacemos esto para que el nodo malla de teleportación no se "
"vea afectado por los cambios en el controlador VR, y así la malla de "
"teleportación puede ser utilizada por ambos controladores VR."

msgid ""
"Then the ``teleport_button_down`` variable is set to false, ``teleport_mesh."
"visible`` is set to ``false``, and ``teleport_raycast.visible`` is set to "
"``false``. This sets up the variables for teleporting the player into their "
"initial, not teleporting the player, state."
msgstr ""
"Entonces la variable ``teleport_button_down`` se establece como falsa, "
"``teleport_mesh.visible`` se establece como ``false``, y ``teleport_raycast."
"visible`` se establece como ``false``. Esto configura las variables para "
"teleportar el reproductor a su estado inicial, no para teleportar el "
"reproductor."

msgid ""
"The code then gets the ``grab_area`` node, the ``grab_raycast`` node, and "
"the ``grab_pos_node`` node and assigns them all to their respective "
"variables for use later."
msgstr ""
"El código entonces obtiene el nodo ``grab_area``, el nodo ``grab_raycast``, "
"y el nodo ``grab_pos_node`` y los asigna todos a sus respectivas variables "
"para su uso posterior."

msgid ""
"Next the ``grab_mode`` is set to ``AREA`` so the VR controller will attempt "
"to grab objects using the :ref:`Area <class_Area>` node defined in "
"``grab_area`` when the VR controller's grab/grip button is pressed. We also "
"set the ``grab_raycast`` node's ``visible`` property to ``false`` so the "
"'laser sight' child node of ``grab_raycast`` is not visible."
msgstr ""
"A continuación, el ``grab_mode`` se establece en ``AREA`` para que el "
"controlador VR intente agarrar objetos usando el nodo :ref:`Area "
"<class_Area>` definido en ``grab_area`` cuando el botón de agarre del "
"controlador VR sea presionado. También ponemos la propiedad ``grab_raycast`` "
"del nodo ``visible`` en ``false`` para que el nodo hijo de ``grab_raycast`` "
"no sea visible."

msgid ""
"After that we connect the ``body_entered`` and ``body_exited`` signals from "
"the ``Sleep_Area`` node in the VR controller to the ``sleep_area_entered`` "
"and ``sleep_area_exited`` functions. The ``sleep_area_entered`` and "
"``sleep_area_exited`` functions will be used to make :ref:`RigidBody "
"<class_RigidBody>` nodes unable to sleep when nearby the VR controller."
msgstr ""
"Después de eso, conectamos las señales ``body_entered`` y ``body_exited`` "
"del nodo ``Sleep_Area`` en el controlador VR con las funciones "
"``sleep_area_entered`` y ``sleep_area_exited``. Las funciones "
"``sleep_area_entered`` y ``sleep_area_exited`` se usarán para hacer que los "
"nodos :`RigidBody <class_RigidBody>` no puedan dormir cuando estén cerca del "
"controlador VR."

msgid ""
"Then the ``hand_mesh`` and ``hand_pickup_drop_sound`` nodes are gotten and "
"assigned them to their respective variables for use later."
msgstr ""
"Luego los nodos ``hand_mesh`` y ``hand_pickup_drop_sound`` se obtienen y "
"asignan a sus respectivas variables para uso posterior."

msgid ""
"Finally, the ``button_pressed`` and ``button_release`` signals in the :ref:"
"`ARVRController <class_ARVRController>` node, which the VR controller "
"extends, are connected to the ``button_pressed`` and ``button_released`` "
"functions respectively. This means that when a button on the VR controller "
"is pressed or released, the ``button_pressed`` or ``button_released`` "
"functions defined in this script will be called."
msgstr ""
"Finalmente, las señales ``button_pressed`` y ``button_release`` del nodo :"
"ref:`ARVRController <class_ARVRController>`, que extiende el controlador VR, "
"están conectadas a las funciones ``button_pressed`` y ``button_released`` "
"respectivamente. Esto significa que cuando un botón del controlador VR es "
"presionado o liberado, las funciones ``button_pressed`` o "
"``button_released`` definidas en este script serán llamadas."

msgid "``_physics_process`` function step-by-step explanation"
msgstr "``_physics_process`` explicación paso a paso de la función"

msgid ""
"First we check to see if the ``rumble`` variable is more than zero. If the "
"``rumble`` variable, which is a property of the :ref:`ARVRController "
"<class_ARVRController>` node, is more than zero then the VR controller "
"rumbles."
msgstr ""
"Primero comprobamos si la variable ``rumble`` es mayor que cero. Si la "
"variable ``rumble``, que es una propiedad del nodo :ref:`ARVRController "
"<class_ARVRController>`, es más que cero, entonces el controlador VR retumba."

msgid ""
"If the ``rumble`` variable is more than zero, then we reduce the rumble by "
"``CONTROLLER_RUMBLE_FADE_SPEED`` every second by subtracting "
"``CONTROLLER_RUMBLE_FADE_SPEED`` multiplied by delta. There is then a ``if`` "
"condition to check if ``rumble`` is less than zero, which sets ``rumble`` to "
"zero if its value is less than zero."
msgstr ""
"Si la variable ``rumble`` es más que cero, entonces reducimos el rumble por "
"\"CONTROLLER_RUMBLE_FADE_SPEED\" cada segundo restando "
"\"CONTROLLER_RUMBLE_FADE_SPEED\" multiplicado por el delta. Hay entonces una "
"condición ``if`` para comprobar si ``rumble`` es menor que cero, que pone a "
"``rumble`` en cero si su valor es menor que cero."

msgid ""
"This small section of code is all we need for reducing the VR controller's "
"rumble. Now when we set ``rumble`` to a value, this code will automatically "
"make it fade over time."
msgstr ""
"Esta pequeña sección de código es todo lo que necesitamos para reducir el "
"ruido del controlador VR. Ahora cuando ponemos ``rumble`` a un valor, este "
"código hará que se desvanezca automáticamente con el tiempo."

msgid ""
"The first section of code checks to see if the ``teleport_button_down`` "
"variable is equal to ``true``, which means this VR controller is trying to "
"teleport."
msgstr ""
"La primera sección del código comprueba si la variable "
"``teleport_button_down`` es igual a ``true``, lo que significa que este "
"controlador VR está intentando teletransportarse."

msgid ""
"If ``teleport_button_down`` is equal to ``true``, we force the "
"``teleport_raycast`` :ref:`Raycast <class_Raycast>` node to update using the "
"``force_raycast_update`` function. The ``force_raycast_update`` function "
"will update the properties within the :ref:`Raycast <class_Raycast>` node "
"with the latest version of the physics world."
msgstr ""
"Si ``teleport_button_down`` es igual a ``true``, forzamos al nodo "
"``teleport_raycast`` :ref:`Raycast <class_Raycast>` a actualizarse usando la "
"función ``force_raycast_update``. La función ``force_raycast_update`` "
"actualizará las propiedades dentro del nodo :ref:`Raycast <class_Raycast>` "
"con la última versión del mundo de la física."

msgid ""
"The code then checks to see if the ``teleport_raycast`` collided with "
"anything by checking of the ``is_colliding`` function in "
"``teleport_raycast`` is true. If the :ref:`Raycast <class_Raycast>` collided "
"with something, we then check to see if the :ref:`PhysicsBody "
"<class_PhysicsBody>` the raycast collided with is a :ref:`StaticBody "
"<class_StaticBody>` or not. We then check to see if the collision normal "
"vector returned by the raycast is greater than or equal to ``0.85`` on the Y "
"axis."
msgstr ""
"El código entonces comprueba si el ``teleport_raycast`` colisionó con algo "
"comprobando que la función de ``is_colliding`` en el ``teleport_raycast`` es "
"verdadera. Si el :ref:`Raycast <class_Raycast>` colisionó con algo, entonces "
"comprobamos si el :ref:`PhysicsBody <class_PhysicsBody>` con el que "
"colisionó el raycast es un :ref:`StaticBody <class_StaticBody>` o no. "
"Entonces comprobamos si el vector normal de colisión devuelto por el raycast "
"es mayor o igual a ``0.85`` en el eje Y."

msgid ""
"We do this because we do not want the user to be able to teleport onto "
"RigidBody nodes and we only want the player to be able to teleport on floor-"
"like surfaces."
msgstr ""
"Lo hacemos porque no queremos que el usuario pueda teletransportarse a los "
"nodos de RigidBody y sólo queremos que el jugador pueda teletransportarse a "
"superficies similares al suelo."

msgid ""
"If all these conditions are met, then we assign the ``teleport_pos`` "
"variable to the ``get_collision_point`` function in ``teleport_raycast``. "
"This will assign ``teleport_pos`` to the position the raycast collided at in "
"world space. We then move the ``teleport_mesh`` to the world position stored "
"in ``teleport_pos``."
msgstr ""
"Si se cumplen todas estas condiciones, entonces asignamos la variable "
"``teleport_pos`` a la función ``get_collision_point`` en "
"``teleport_raycast``. Esto asignará ``teleport_pos`` a la posición en la que "
"el raycast colisionó en el espacio mundial. Luego movemos la "
"``teleport_mesh`` a la posición del mundo almacenada en ``teleport_pos``."

msgid ""
"This section of code will get the position the player is aiming at with the "
"teleportation raycast and update the teleportation mesh, giving a visual "
"update on where the user will be teleporting to when the release the "
"teleport button."
msgstr ""
"Esta sección del código obtendrá la posición a la que el jugador apunta con "
"el raycast de teletransportación y actualizará la malla de "
"teletransportación, dando una actualización visual sobre a dónde se "
"teletransportará el usuario cuando suelte el botón de teletransportación."

msgid ""
"The next section of code first checks to see if the VR controller is active "
"through the ``get_is_active`` function, which is defined by :ref:"
"`ARVRController <class_ARVRController>`. If the VR controller is active, "
"then it calls the ``_physics_process_update_controller_velocity`` function."
msgstr ""
"La siguiente sección del código primero comprueba si el controlador VR está "
"activo a través de la función ``get_is_active``, que está definida por :ref:"
"`ARVRController <class_ARVRController>`. Si el controlador VR está activo, "
"entonces llama a la función ``physics_process_update_controller_``."

msgid ""
"The ``_physics_process_update_controller_velocity`` function will calculate "
"the VR controller's velocity through changes in position. It is not perfect, "
"but this process gets a rough idea of the velocity of the VR controller, "
"which is fine for the purposes of this tutorial."
msgstr ""
"La función ``physics_process_update_controller_`` calculará la velocidad del "
"controlador VR a través de los cambios de posición. No es perfecta, pero "
"este proceso da una idea aproximada de la velocidad del controlador de la "
"RV, lo cual está bien para los propósitos de este tutorial."

msgid ""
"The next section of code checks to see if the VR controller is holding an "
"object by checking to see if the ``held_object`` variable is not equal to "
"``null``."
msgstr ""
"La siguiente sección del código comprueba si el controlador VR sostiene un "
"objeto comprobando si la variable ``held_object`` no es igual a ``null``."

msgid ""
"If the VR controller is holding an object, we first store it's scale in a "
"temporary variable called ``held_scale``. We then set the "
"``global_transform`` of the held object to the ``global_transform`` of the "
"``held_object`` node. This will make the held object have the same position, "
"rotation, and scale of the ``grab_pos_node`` node in world space."
msgstr ""
"Si el controlador VR sostiene un objeto, primero guardamos su escala en una "
"variable temporal llamada ``held_scale``. Luego ponemos la "
"``global_transform`` del objeto retenido en la ``global_transform`` del nodo "
"``held_object``. Esto hará que el objeto retenido tenga la misma posición, "
"rotación y escala del nodo ``grab_pos_node`` en el espacio mundial."

msgid ""
"However, because we do not want the held object to change in scale when it "
"is grabbed, we need to set the ``scale`` property of the ``held_object`` "
"node back to ``held_scale``."
msgstr ""
"Sin embargo, como no queremos que el objeto retenido cambie de escala cuando "
"es agarrado, necesitamos poner la propiedad ``scale`` del nodo "
"``held_object`` de vuelta a ``held_scale``."

msgid ""
"This section of code will keep the held object in the same position and "
"rotation as the VR controller, keeping it synced with the VR controller."
msgstr ""
"Esta sección del código mantendrá el objeto retenido en la misma posición y "
"rotación que el controlador VR, manteniéndolo sincronizado con el "
"controlador VR."

msgid ""
"Finally, the last section of code simply calls the "
"``_physics_process_directional_movement`` function. This function contains "
"all the code for moving the player when the touchpad/joystick on the VR "
"controller moves."
msgstr ""
"Finalmente, la última sección del código simplemente llama a la función "
"``_physics_process_directional_movement``. Esta función contiene todo el "
"código para mover el reproductor cuando se mueve el touchpad/joystick del "
"controlador VR."

msgid ""
"``_physics_process_update_controller_velocity`` function step-by-step "
"explanation"
msgstr ""
"``_physics_process_update_controller_velocity`` explicación paso a paso de "
"la función"

msgid ""
"First this function resets the ``controller_velocity`` variable to zero :ref:"
"`Vector3 <class_Vector3>`."
msgstr ""
"Primero, esta función resetea la variable ``controller_velocity`` a un :ref:"
"`Vector3 <class_Vector3>` cero."

msgid ""
"Then we check to see if there are any stored/cached VR controller velocities "
"saved in the ``prior_controller_velocities`` array. We do this by checking "
"to see if the ``size()`` function returns a value greater than ``0``. If "
"there are cached velocities within ``prior_controller_velocities``, then we "
"iterate through each of the stored velocities using a ``for`` loop."
msgstr ""
"Entonces comprobamos si hay alguna velocidad de controlador de RV almacenada/"
"en caché guardada en el array ``prior_controller_velocities``. Lo hacemos "
"comprobando si la función ``size()`` devuelve un valor mayor que ``0``. Si "
"hay velocidades en caché dentro de ``prior_controller_velocities``, entonces "
"iteramos a través de cada una de las velocidades almacenadas usando un bucle "
"``for``."

msgid ""
"For each of the cached velocities, we simply add its value to "
"``controller_velocity``. Once the code has gone through all of the cached "
"velocities in ``prior_controller_velocities``, we divide "
"``controller_velocity`` by the size of the ``prior_controller_velocities`` "
"array, which will give us the combined velocity value. This helps take the "
"previous velocities into account, making the direction of the controller's "
"velocity more accurate."
msgstr ""
"Para cada una de las velocidades almacenadas, simplemente añadimos su valor "
"a ``controller_velocity``. Una vez que el código ha pasado por todas las "
"velocidades en ``prior_controller_velocities``, dividimos "
"``controller_velocity`` por el tamaño del array "
"``prior_controller_velocities``, lo que nos dará el valor de la velocidad "
"combinada. Esto ayuda a tener en cuenta las velocidades anteriores, haciendo "
"que la dirección de la velocidad del controlador sea más precisa."

msgid ""
"Next we calculate the change in position the VR controller has taken since "
"the last ``_physics_process`` function call. We do this by subtracting "
"``prior_controller_position`` from the global position of the VR controller, "
"``global_transform.origin``. This will give us a :ref:`Vector3 "
"<class_Vector3>` that points from the position in "
"``prior_controller_position`` to the current position of the VR controller, "
"which we store in a variable called ``relative_controller_position``."
msgstr ""
"A continuación calculamos el cambio de posición que el controlador VR ha "
"tomado desde la última llamada a la función ``physics_process``. Lo hacemos "
"restando ``prior_controller_position`` de la posición global del controlador "
"VR, ``global_transform.origin``. Esto nos dará un :ref:`Vector3 "
"<class_Vector3>` que apunta desde la posición en ``prior_controller_`` a la "
"posición actual del controlador VR, que almacenamos en una variable llamada "
"``relative_controller_position``."

msgid ""
"Next we add the change in position to ``controller_velocity`` so the latest "
"change in position is taken into account in the velocity calculation. We "
"then add ``relative_controller_position`` to ``prior_controller_velocities`` "
"so it can be taken into account on the next calculation of the VR "
"controller's velocity."
msgstr ""
"A continuación, añadimos el cambio de posición a ``controller_velocity`` "
"para que el último cambio de posición se tenga en cuenta en el cálculo de la "
"velocidad. Luego añadimos ``relative_controller_position`` a "
"``prior_controller_velocities`` para que se tenga en cuenta en el siguiente "
"cálculo de la velocidad del controlador de la RV."

msgid ""
"Then ``prior_controller_position`` is updated with the global position of "
"the VR controller, ``global_transform.origin``. We then divide "
"``controller_velocity`` by ``delta`` so the velocity is higher, giving "
"results like those we expect, while still being relative to the amount of "
"time that has passed. It is not a perfect solution, but the results look "
"decent most of the time and for the purposes of this tutorial, it is good "
"enough."
msgstr ""
"Entonces ``prior_controller_position`` se actualiza con la posición global "
"del controlador VR, ``global_transform.origin``. Luego dividimos "
"``controller_velocity`` por ``delta`` para que la velocidad sea más alta, "
"dando resultados como los que esperamos, sin dejar de ser relativos a la "
"cantidad de tiempo que ha pasado. No es una solución perfecta, pero los "
"resultados se ven decentes la mayor parte del tiempo y para los propósitos "
"de este tutorial, es suficientemente bueno."

msgid ""
"Finally, the function checks to see if the ``prior_controller_velocities`` "
"has more than ``30`` velocities cached by checking if the ``size()`` "
"function returns a value greater than ``30``. If there are more than ``30`` "
"cached velocities stored in ``prior_controller_velocities``, then we simply "
"remove the oldest cached velocity by calling the ``remove`` function and "
"passing in a index position of ``0``."
msgstr ""
"Por último, la función comprueba si el ``prior_controller_velocities`` tiene "
"más de ``30`` velocidades en caché comprobando si la función ``size()`` "
"devuelve un valor mayor de ``30``. Si hay más de ``30`` velocidades "
"almacenadas en ``prior_controller_velocities``, entonces simplemente "
"eliminamos la velocidad almacenada más antigua llamando a la función "
"``remove`` y pasando a una posición índice de ``0``."

msgid ""
"What this function ultimately does is that it gets a rough idea of the VR "
"controller's velocity by calculating the VR controller's relative changes in "
"position over the last thirty ``_physics_process`` calls. While this is not "
"perfect, it gives a decent idea of how fast the VR controller is moving in "
"3D space."
msgstr ""
"Lo que esta función hace en última instancia es que obtiene una idea "
"aproximada de la velocidad del controlador VR calculando los cambios "
"relativos de posición del controlador VR en las últimas treinta llamadas al "
"``_physics_process``. Aunque esto no es perfecto, da una idea decente de la "
"rapidez con la que el controlador de RV se mueve en el espacio "
"tridimensional."

msgid ""
"``_physics_process_directional_movement`` function step-by-step explanation"
msgstr ""
"``_physics_process_directional_movement`` explicación paso a paso de la "
"función"

msgid ""
"First this function gets the axes for the trackpad and the joystick and "
"assigns them to :ref:`Vector2 <class_Vector2>` variables called "
"``trackpad_vector`` and ``joystick_vector`` respectively."
msgstr ""
"Primero esta función obtiene los ejes para el trackpad y el joystick y los "
"asigna a las variables :ref:`Vector2 <class_Vector2>` llamadas "
"``trackpad_vector`` y ``joystick_vector`` respectivamente."

msgid ""
"You may need to remap the joystick and/or touchpad index values depending on "
"your VR headset and controller. The inputs in this tutorial are the index "
"values of a Windows Mixed Reality headset."
msgstr ""
"Es posible que tenga que rehacer los valores de índice del joystick y/o del "
"touchpad dependiendo de su auricular y controlador de RV. Las entradas de "
"este tutorial son los valores de índice de unos auriculares Windows Mixed "
"Reality."

msgid ""
"Then ``trackpad_vector`` and ``joystick_vector`` have their deadzones "
"account for. The code for this is detailed in the article below, with slight "
"changes as the code is converted from C# to GDScript."
msgstr ""
"Entonces el ``trackpad_vector`` y ``joystick_vector`` tienen sus zonas "
"muertas. El código para esto se detalla en el artículo a continuación, con "
"ligeros cambios al convertir el código de C# a GDScript."

msgid ""
"Once the ``trackpad_vector`` and ``joystick_vector`` variables have had "
"their deadzones account for, the code then gets the forward and right "
"direction vectors relative to the global transform of the :ref:`ARVRCamera "
"<class_ARVRCamera>`. What this does is that it gives us vectors that point "
"forward and right relative to the rotation of the user camera, the :ref:"
"`ARVRCamera <class_ARVRCamera>`, in world space. These vectors point in the "
"same direction of the blue and red arrows when you select an object in the "
"Godot editor with the ``local space mode`` button enabled. The forward "
"direction vector is stored in a variable called ``forward_direction``, while "
"the right direction vector is stored in a variable called "
"``right_direction``."
msgstr ""
"Una vez que las variables ``trackpad_vector`` y ``joystick_vector`` tienen "
"sus zonas muertas, el código obtiene los vectores de dirección delantera y "
"derecha relativos a la transformación global de la ref:`ARVRCamera "
"<class_ARVRCamera>`. Lo que esto hace es que nos da vectores que apuntan "
"hacia adelante y hacia la derecha relativos a la rotación de la cámara del "
"usuario, la :ref:`ARVRCamera <class_ARVRCamera>`, en el espacio mundial. "
"Estos vectores apuntan en la misma dirección que las flechas azules y rojas "
"cuando seleccionas un objeto en el editor de Godot con el botón ``local "
"space mode`` activado. El vector de dirección hacia adelante se almacena en "
"una variable llamada ``forward_direction``, mientras que el vector de "
"dirección hacia la derecha se almacena en una variable llamada "
"``right_direction``."

msgid ""
"Next the code adds the ``trackpad_vector`` and ``joystick_vector`` variables "
"together and normalizes the results using the ``normalized`` function. This "
"gives us the combined movement direction of both input devices, so we can "
"use a single :ref:`Vector2 <class_Vector2>` for moving the user. We assign "
"the combined direction to a variable called ``movement_vector``."
msgstr ""
"A continuación el código añade las variables ``trackpad_vector`` y "
"``joystick_vector`` juntas y normaliza los resultados usando la función "
"``normalized``. Esto nos da la dirección de movimiento combinada de ambos "
"dispositivos de entrada, por lo que podemos usar una sola :ref:`Vector2 "
"<class_Vector2>` para mover al usuario. Asignamos la dirección combinada a "
"una variable llamada ``movement_vector``."

msgid ""
"Then we calculate the distance the user will move forward, relative to the "
"forward direction stored in ``forward_direction``. To calculate this, we "
"multiply ``forward_direction`` by ``movement_vector.x``, ``delta``, and "
"``MOVEMENT_SPEED``. This will give us the distance the user will move "
"forward when the trackpad/joystick is pushed forward or backwards. We assign "
"this to a variable called ``movement_forward``."
msgstr ""
"Entonces calculamos la distancia que el usuario se moverá hacia adelante, en "
"relación con la dirección de avance almacenada en ``forward_direction``. "
"Para calcular esto, multiplicamos la ``forward_direction`` por "
"``movement_vector.x``, ``delta`` y ``MOVEMENT_SPEED``. Esto nos dará la "
"distancia que el usuario se moverá hacia adelante cuando el trackpad/"
"joystick sea empujado hacia adelante o hacia atrás. Asignamos esto a una "
"variable llamada ``movement_forward``."

msgid ""
"We do a similar calculation for the distance the user will move right, "
"relative to the right direction stored in ``right_direction``. To calculate "
"the distance the user will move right, we multiply ``right_direction`` by "
"``movement_vector.y``, ``delta``, and ``MOVEMENT_SPEED``. This will give us "
"the distance the user will move right when the trackpad/joystick is pushed "
"right or left. We assign this to a variable called ``movement_right``."
msgstr ""
"Hacemos un cálculo similar para la distancia que el usuario se moverá a la "
"derecha, en relación con la dirección correcta almacenada en "
"``right_direction``. Para calcular la distancia que el usuario se moverá a "
"la derecha, multiplicamos ``right_direction`` por ``movement_vector.y``, "
"``delta``, and ``MOVEMENT_SPEED``. Esto nos dará la distancia que el usuario "
"se moverá a la derecha cuando el trackpad/joystick sea empujado a la derecha "
"o a la izquierda. Asignamos esto a una variable llamada ``movement_right``."

msgid ""
"Next we remove any movement on the ``Y`` axis of ``movement_forward`` and "
"``movement_right`` by assigning their ``Y`` values to ``0``. We do this so "
"the user cannot fly/fall simply by moving the trackpad or joystick. Without "
"doing this, the player could fly in the direction they are facing."
msgstr ""
"Luego eliminamos cualquier movimiento en el eje ``Y`` del "
"``movement_forward`` y ``movement_right`` asignando sus valores ``Y`` a "
"``0``. Hacemos esto para que el usuario no pueda volar/caer con sólo mover "
"el trackpad o el joystick. Sin hacer esto, el jugador podría volar en la "
"dirección en la que se encuentra."

msgid ""
"Finally, we check to see if the ``length`` function on ``movement_right`` or "
"``movement_forward`` is greater than ``0``. If it is, then we need to move "
"the user. To move the user, we perform a global translation to the :ref:"
"`ARVROrigin <class_ARVROrigin>` node using ``get_parent().global_translate`` "
"and pass in the ``movement_right`` variable with the ``movement_forward`` "
"variable added to it. This will move the player in the direction the "
"trackpad/joystick is pointing, relative to the rotation of the VR headset. "
"We also set the ``directional_movement`` variable to ``true`` so the code "
"knows this VR controller is moving the player."
msgstr ""
"Por último, comprobamos si la función ``length`` de ``movement_right`` o "
"``movement_forward`` es mayor que ``0``. Si lo es, entonces necesitamos "
"mover al usuario. Para mover el usuario, realizamos una traducción global al "
"nodo :ref:`ARVROrigin <class_ARVROrigin>` usando ``get_parent()."
"global_translate`` y le pasamos la variable ``movement_right`` con la "
"variable ``movement_forward`` añadida. Esto moverá al jugador en la "
"dirección en la que apunta el trackpad/joystick, en relación con la rotación "
"del auricular VR. También ponemos la variable ``directional_movement`` en "
"``true`` para que el código sepa que este controlador VR está moviendo al "
"jugador."

msgid ""
"If the ``length`` function on ``movement_right`` or ``movement_forward`` is "
"less than or equal to ``0``, then we simply set the ``directional_movement`` "
"variable to ``false`` so the code knows this VR controller is not moving the "
"player."
msgstr ""
"Si la función ``length`` en ``movement_right`` o ``movement_forward`` es "
"menor o igual a ``0``, entonces simplemente ponemos la variable "
"``directional_movement`` en ``false`` para que el código sepa que este "
"controlador VR no está moviendo al jugador."

msgid ""
"What this function ultimately does is takes the input from the VR "
"controller's trackpad and joystick and moves the player in the direction the "
"player is pushing them. Movement is relative to the rotation of the VR "
"headset, so if the player pushes forward and turns their head to the left, "
"they will move to the left."
msgstr ""
"Lo que esta función hace en última instancia es tomar la entrada del "
"trackpad y el joystick del controlador VR y mover el reproductor en la "
"dirección en la que lo está empujando. El movimiento es relativo a la "
"rotación de los auriculares VR, así que si el jugador empuja hacia delante y "
"gira la cabeza hacia la izquierda, se moverá hacia la izquierda."

msgid "``button_pressed`` function step-by-step explanation"
msgstr "Explicación paso a paso de la función ``button_pressed``"

msgid ""
"This function checks to see if the VR button that was just pressed is equal "
"to one of the VR buttons used in this project. The ``button_index`` variable "
"is passed in by the ``button_pressed`` signal in :ref:`ARVRController "
"<class_ARVRController>`, which we connected in the ``_ready`` function."
msgstr ""
"Esta función comprueba si el botón VR que se acaba de pulsar es igual a uno "
"de los botones VR utilizados en este proyecto. La variable ``button_index`` "
"se pasa por la señal ``button_pressed`` en :ref:`ARVRController "
"<class_ARVRController>`, que conectamos en la función ``_ready``."

msgid ""
"There are only three buttons we are looking for in this project: the trigger "
"button, the grab/grip button, and the menu button."
msgstr ""
"Sólo hay tres botones que buscamos en este proyecto: el botón de disparo, el "
"botón de agarre y el botón de menú."

msgid ""
"You may need to remap these button index values depending on your VR headset "
"and controller. The inputs in this tutorial are the index values of a "
"Windows Mixed Reality headset."
msgstr ""
"Es posible que tenga que reasignar estos valores de índice de botón "
"dependiendo de su auricular y controlador de RV. Las entradas de este "
"tutorial son los valores de índice de un auricular de Windows Mixed Reality."

msgid ""
"First we check if the ``button_index`` is equal to ``15``, which should map "
"to the trigger button on the VR controller. If the button pressed is the "
"trigger button, then the ``_on_button_pressed_trigger`` function is called."
msgstr ""
"Primero comprobamos si el ``button_index`` es igual a ``15``, lo que debería "
"corresponder al botón de disparo del controlador VR. Si el botón pulsado es "
"el botón de disparo, entonces se llama a la función "
"``on_button_pressed_trigger``."

msgid ""
"If the ``button_index`` is equal to ``2``, then the grab button was just "
"pressed. If the button pressed is the grab button, the "
"``_on_button_pressed_grab`` function is called."
msgstr ""
"Si el ``button_index`` es igual a ``2``, entonces el botón de agarre acaba "
"de ser presionado. Si el botón pulsado es el botón de agarre, se llama a la "
"función ``on_button_pressed_grab``."

msgid ""
"Finally, if the ``button_index`` is equal to ``1``, then the menu button was "
"just pressed. If the button pressed is the menu button, the "
"``_on_button_pressed_menu`` function is called."
msgstr ""
"Finalmente, si el ``button_index`` es igual a ``1``, entonces el botón de "
"menú fue presionado. Si el botón pulsado es el botón de menú, se llama a la "
"función ``on_button_pressed_menu``."

msgid "``_on_button_pressed_trigger`` function step-by-step explanation"
msgstr "explicación paso a paso de la función ``_on_button_pressed_trigger``"

msgid ""
"First this function checks to see if the VR controller is not holding by "
"checking if ``held_object`` is equal to ``null``. If the VR controller is "
"not holding anything, then we assume that the trigger press on the VR "
"controller was for teleporting. We then make sure that ``teleport_mesh."
"visible`` is equal to ``false``. We use this to tell if the other VR "
"controller is trying to teleport or not, as ``teleport_mesh`` will be "
"visible if the other VR controller is teleporting."
msgstr ""
"Primero esta función comprueba si el controlador de VR no se sostiene "
"comprobando si ``held_object`` es igual a ``null``. Si el controlador VR no "
"está sosteniendo nada, entonces asumimos que la pulsación del disparador en "
"el controlador VR fue para teletransportarse. Entonces nos aseguramos de que "
"``teleport_mesh.visible`` es igual a ``false``. Usamos esto para saber si el "
"otro controlador VR está intentando teletransportarse o no, ya que "
"``teleport_mesh`` será visible si el otro controlador VR se está "
"teletransportando."

msgid ""
"If ``teleport_mesh.visible`` is equal to ``false``, then we can teleport "
"with this VR controller. We set the ``teleport_button_down`` variable to "
"``true``, set ``teleport_mesh.visible`` to true, and set ``teleport_raycast."
"visible`` to ``true``. This will tell the code in ``_physics_process`` that "
"this VR controller is going to teleport, it will make the ``teleport_mesh`` "
"visible so the user knows where the are teleporting to, and will make "
"``teleport_raycast`` visible to the player has a 'laser sight' they can use "
"to aim the teleportation pos."
msgstr ""
"Si ``teleport_mesh.visible`` es igual a ``false``, entonces podemos "
"teletransportarnos con este controlador VR. Ponemos la variable "
"``teleport_button_down`` a ``true``, ponemos ``teleport_mesh.visible`` a "
"true, y ponemos ``teleport_raycast.visible`` a ``true``. Esto le dirá al "
"código en ``_physics_process`` que este controlador de VR se va a "
"teleportar, hará la ``teleport_mesh`` visible para que el usuario sepa a "
"dónde se están teleportando, y hará ``teleport_raycast`` visible para que el "
"jugador tenga una 'mira láser' que pueda usar para apuntar la posición de "
"teleportación."

msgid ""
"If ``held_object`` is not equal to ``null``, then the VR controller is "
"holding something. We then check to see if the object that is being held, "
"``held_object``, extends a class called ``VR_Interactable_Rigidbody``. We "
"have not made ``VR_Interactable_Rigidbody`` yet, but "
"``VR_Interactable_Rigidbody`` will be a custom class we will use on all of "
"the special/custom :ref:`RigidBody <class_RigidBody>`-based nodes in the "
"project."
msgstr ""
"Si ``held_object`` no es igual a ``null``, entonces el controlador VR está "
"sosteniendo algo. Entonces comprobamos si el objeto que está siendo "
"retenido, ``held_object``, extiende una clase llamada "
"``VR_Interactable_Rigidbody``. No hemos hecho ``VR_Interactable_Rigidbody`` "
"todavía, pero ``VR_Interactable_Rigidbody`` será una clase personalizada que "
"usaremos en todos los nodos basados en special/custom :ref:`RigidBody "
"<class_RigidBody>` del proyecto."

msgid ""
"Don't worry, we will cover ``VR_Interactable_Rigidbody`` after this section!"
msgstr ""
"¡No te preocupes, cubriremos el ``VR_Interactable_Rigidbody`` después de "
"esta sección!"

msgid ""
"If the ``held_object`` extends ``VR_Interactable_Rigidbody``, then we call "
"the ``interact`` function, so the held object can do whatever it is supposed "
"to do when the trigger is pressed and the object is held by the VR "
"controller."
msgstr ""
"Si el ``held_object`` se extiende ``VR_Interactable_Rigidbody``, entonces "
"llamamos a la función ``interact``, para que el objeto retenido pueda hacer "
"lo que se supone que debe hacer cuando se presiona el disparador y el objeto "
"es retenido por el controlador VR."

msgid "``_on_button_pressed_grab`` function step-by-step explanation"
msgstr "explicación paso a paso de la función ``_on_button_pressed_grab``"

msgid ""
"First this function checks to see if ``teleport_button_down`` is equal to "
"``true``. If it is, then it calls ``return``. We do this because we do not "
"want the user to be able to pick up objects while teleporting."
msgstr ""
"Primero esta función comprueba si ``teleport_button_down`` es igual a "
"``true``. Si lo es, entonces llama a ``return``. Hacemos esto porque no "
"queremos que el usuario pueda recoger objetos mientras se teletransporta."

msgid ""
"Then we check to see if the VR controller is currently not holding anything "
"by checking if ``held_object`` is equal to ``null``. If the VR controller is "
"not holding anything, then the ``_pickup_rigidbody`` function is called. If "
"the VR controller is holding something, ``held_object`` is not equal to "
"``null``, then the ``_throw_rigidbody`` function is called."
msgstr ""
"Luego comprobamos si el controlador de VR no tiene nada actualmente, "
"comprobando si ``held_object`` es igual a ``null``. Si el controlador VR no "
"está sosteniendo nada, entonces se llama a la función ``pickup_rigidbody``. "
"Si el controlador VR está sosteniendo algo, ``held_object`` no es igual a "
"``null``, entonces se llama a la función ``_throw_rigidbody``."

msgid ""
"Finally, the pick-up/drop sound is played by calling the ``play`` function "
"on ``hand_pickup_drop_sound``."
msgstr ""
"Finalmente, el sonido pick up/drop se reproduce llamando a la función "
"``play`` en el sonido ``hand_pickup_drop``."

msgid "``_pickup_rigidbody`` function step-by-step explanation"
msgstr "explicación paso a paso de la función ``_pickup_rigidbody``"

msgid ""
"First the function makes a variable called ``rigid_body``, which we'll be "
"using to store the :ref:`RigidBody <class_RigidBody>` that the VR controller "
"is going to pick up, assuming there is a RigidBody to pick up."
msgstr ""
"Primero la función hace una variable llamada ``rigid_body``, que usaremos "
"para almacenar el :ref:`RigidBody <class_RigidBody>` que el controlador de "
"VR va a recoger, suponiendo que haya un RigidBody para recoger."

msgid ""
"Then the function checks to see if the ``grab_mode`` variable is equal to "
"``AREA``. If it is, then it gets all of the :ref:`PhysicsBody "
"<class_PhysicsBody>` nodes within the ``grab_area`` using the "
"``get_overlapping_bodies`` functions. This function will return an array of :"
"ref:`PhysicsBody <class_PhysicsBody>` nodes. We assign the array of :ref:"
"`PhysicsBody <class_PhysicsBody>` to a new variable called ``bodies``."
msgstr ""
"Entonces la función comprueba si la variable ``grab_mode`` es igual a "
"``AREA``. Si lo es, entonces obtiene todos los nodos :ref:`PhysicsBody "
"<class_PhysicsBody>` dentro del ``grab_area`` usando las funciones "
"``get_overlapping_bodies``. Esta función devolverá un array de nodos :ref:"
"`PhysicsBody <class_PhysicsBody>`. Asignamos el array de :ref:`PhysicsBody "
"<class_PhysicsBody>` a una nueva variable llamada ``bodies``."

msgid ""
"We then check to see if the length of the ``bodies`` variable is more than "
"``0``. If it is, we go through each of the :ref:`PhysicsBody "
"<class_PhysicsBody>` nodes in ``bodies`` using a for loop."
msgstr ""
"Luego comprobamos si la longitud de la variable ``bodies`` es mayor que "
"``0``. Si lo es, pasamos por cada uno de los nodos :ref:`PhysicsBody "
"<class_PhysicsBody>` en ``bodies`` usando un bucle for."

msgid ""
"For each :ref:`PhysicsBody <class_PhysicsBody>` node, we check if it is, or "
"extends, a :ref:`RigidBody <class_RigidBody>` node using ``if body is "
"RigidBody``, which will return ``true`` if the :ref:`PhysicsBody "
"<class_PhysicsBody>` node is or extends the :ref:`RigidBody "
"<class_RigidBody>` node. If the object is a :ref:`RigidBody "
"<class_RigidBody>`, then we check to make sure there is not a variable/"
"constant called ``NO_PICKUP`` defined in the body. We do this because if you "
"want to have :ref:`RigidBody <class_RigidBody>` nodes that cannot be picked "
"up, all you have to do is define a constant/variable called ``NO_PICKUP`` "
"and the VR controller will be unable to pick it up. If the :ref:`RigidBody "
"<class_RigidBody>` node does not have a variable/constant defined with the "
"name ``NO_PICKUP``, then we assign the ``rigid_body`` variable to the :ref:"
"`RigidBody <class_RigidBody>` node and break the for loop."
msgstr ""
"Para cada nodo :ref:`PhysicsBody <class_PhysicsBody>`, comprobamos si es, o "
"extiende, un nodo :ref:`RigidBody <class_RigidBody>` usando ``if body is "
"RigidBody``, que devolverá ``true`` si el : ref:`PhysicsBody "
"<class_PhysicsBody>` es o extiende el nodo :ref:`RigidBody "
"<class_RigidBody>`. Si el objeto es un :ref:`RigidBody <class_RigidBody>`, "
"entonces comprobamos que no hay una variable/constante llamada ``NO_PICKUP`` "
"definida en el cuerpo. Hacemos esto porque si quieres tener :ref:`RigidBody "
"<class_RigidBody>` nodos que no pueden ser recogidos, todo lo que tienes que "
"hacer es definir una constante/variable llamada ``NO_PICKUP`` y el "
"controlador VR será incapaz de recogerla. Si el nodo :ref:`RigidBody "
"<class_RigidBody>` no tiene una variable/constante definida con el nombre "
"``NO_PICKUP``, entonces asignamos la variable ``rigid_body`` al nodo :ref:"
"`RigidBody <class_RigidBody>` y rompemos el bucle for."

msgid ""
"What this section of code does is goes through all of the physics bodies "
"within the ``grab_area`` and grabs the first :ref:`RigidBody "
"<class_RigidBody>` node that does not have a variable/constant named "
"``NO_PICKUP`` and assigns it to the ``rigid_body`` variable so we can do "
"some additional post processing later in this function."
msgstr ""
"Lo que esta sección del código hace es pasar por todos los cuerpos físicos "
"dentro del ``grab_area`` y agarra el primer :ref:`RigidBody "
"<class_RigidBody>` nodo que no tiene una variable/constante llamada "
"``NO_PICKUP`` y la asigna a la variable ``rigid_body`` para que podamos "
"hacer algún postprocesamiento adicional más tarde en esta función."

msgid ""
"If the ``grab_mode`` variable is not equal to ``AREA``, we then check to see "
"if it is equal to ``RAYCAST`` instead. If it is equal to ``RAYCAST``, we "
"force the ``grab_raycast`` node to update using the ``force_raycast_update`` "
"function. The ``force_raycast_update`` function will update the :ref:"
"`Raycast <class_Raycast>` with the latest changes in the physics world. We "
"then check to see if the ``grab_raycast`` node collided with something using "
"the ``is_colliding`` function, which will return true if the :ref:`Raycast "
"<class_Raycast>` hit something."
msgstr ""
"Si la variable ``grab_mode`` no es igual a ``AREA``, entonces comprobamos si "
"es igual a ``RAYCAST`` en su lugar. Si es igual ``RAYCAST``, forzamos al "
"nodo ``grab_raycast`` a actualizarse usando la función "
"``force_raycast_update``. La función ``force_raycast_update`` actualizará "
"el :ref:`Raycast <class_Raycast>` con los últimos cambios en el mundo de la "
"física. Luego comprobamos si el nodo ``grab_raycast`` colisionó con algo "
"usando la función ``is_colliding``, que devolverá true si el :ref:`Raycast "
"<class_Raycast>` golpea algo."

msgid ""
"If the ``grab_raycast`` hit something, we get the :ref:`PhysicsBody "
"<class_PhysicsBody>` node hit using the ``get_collider`` function. The code "
"then checks to see if the node hit is a :ref:`RigidBody <class_RigidBody>` "
"node using ``if body is RigidBody``, which will return ``true`` if the :ref:"
"`PhysicsBody <class_PhysicsBody>` node is or extends the :ref:`RigidBody "
"<class_RigidBody>` node. Then the code checks to see if the :ref:`RigidBody "
"<class_RigidBody>` node does not have a variable named ``NO_PICKUP``, and if "
"it does not, then it assigns the :ref:`RigidBody <class_RigidBody>` node to "
"the ``rigid_body`` variable."
msgstr ""
"Si el ``grab_raycast`` golpea algo, obtenemos el nodo :ref:`PhysicsBody "
"<class_PhysicsBody>` golpeando con la función ``get_collider``. El código "
"entonces comprueba si el nodo golpeado es un nodo :ref:`RigidBody "
"<class_RigidBody>` usando ``if body is RigidBody``, que devolverá ``true`` "
"si el nodo :ref:`PhysicsBody <class_PhysicsBody>` es o extiende el nodo :ref:"
"`RigidBody <class_RigidBody>`. Entonces el código comprueba si el nodo :ref:"
"`RigidBody <class_RigidBody>` no tiene una variable llamada ``NO_PICKUP``, y "
"si no la tiene, entonces asigna el nodo :ref:`RigidBody <class_RigidBody>` a "
"la variable ``rigid_body``."

msgid ""
"What this section of code does is sends the ``grab_raycast`` :ref:`Raycast "
"<class_Raycast>` node out and checks if it collided with a :ref:`RigidBody "
"<class_RigidBody>` node that does not have a variable/constant named "
"``NO_PICKUP``. If it collided with a RigidBody without ``NO_PICKUP``, it "
"assigns the node to the ``rigid_body`` variable so we can do some additional "
"post processing later in this function."
msgstr ""
"Lo que esta sección del código hace es enviar el nodo ``grab_raycast`` :ref:"
"`Raycast <class_Raycast>` y comprueba si ha colisionado con un nodo :ref:"
"`RigidBody <class_RigidBody>` que no tiene una variable/constante llamada "
"``NO_PICKUP``. Si colisiona con un RigidBody sin ``NO_PICKUP``, asigna el "
"nodo a la variable ``rigid_body`` para que podamos hacer algún "
"postprocesamiento adicional más tarde en esta función."

msgid ""
"The final section of code first checks to see if ``rigid_body`` is not equal "
"to ``null``. If ``rigid_body`` is not equal to ``null``, then the VR "
"controller found a :ref:`RigidBody <class_RigidBody>`-based node that can be "
"picked up."
msgstr ""
"La última sección del código primero comprueba si el ``rigid_body`` no es "
"igual al \"null\". Si ``rigid_body`` no es igual a ``null``, entonces el "
"controlador VR encontró un nodo basado en :ref: `RigidBody <class_RigidBody> "
"`que puede ser recogido."

msgid ""
"If there is a VR controller to pickup, we assign ``held_object`` to the :ref:"
"`RigidBody <class_RigidBody>` node stored in ``rigid_body``. We then store "
"the :ref:`RigidBody <class_RigidBody>` node's ``mode``, ``collision_layer``, "
"and ``collision_mask`` in ``held_object_data`` using ``mode``, ``layer``, "
"and ``mask`` as keys for the respective values. This is so we can reapply "
"them later when the object is dropped by the VR controller."
msgstr ""
"Si hay un controlador VR para recoger, asignamos ``held_object`` al nodo :"
"ref:`RigidBody <class_RigidBody>` almacenado en ``rigid_body``. Luego "
"guardamos el nodo :ref:`RigidBody <class_RigidBody>` del nodo ``mode``, "
"``collision_layer``, y ``collision_mask`` en ``held_object_data`` usando "
"``mode``, ``layer``, y ``mask`` como claves para los valores respectivos. "
"Esto es para que podamos volver a aplicarlas más tarde cuando el objeto sea "
"soltado por el controlador de VR."

msgid ""
"We then set the :ref:`RigidBody <class_RigidBody>`'s mode to "
"``MODE_STATIC``, it's ``collision_layer`` to zero, and it's "
"``collision_mask`` to zero. This will make it where the held :ref:`RigidBody "
"<class_RigidBody>` cannot interact with other objects in the physics world "
"when held by the VR controller."
msgstr ""
"Luego ponemos el modo :ref:`RigidBody <class_RigidBody>`'s a "
"``MODE_STATIC``, es ``collision_layer`` a cero, y es ``collision_mask`` a "
"cero. Esto hará que donde el sostenido :ref:`RigidBody <class_RigidBody>` no "
"pueda interactuar con otros objetos del mundo de la física cuando sea "
"sostenido por el controlador de VR."

msgid ""
"Next the ``hand_mesh`` :ref:`MeshInstance <class_MeshInstance>` is made "
"invisible by setting the ``visible`` property to ``false``. This is so the "
"hand does not get in the way of the held object. Likewise, the "
"``grab_raycast`` 'laser sight' is made invisible by setting the ``visible`` "
"property to ``false``."
msgstr ""
"Luego la ``hand_mesh`` :ref:`MeshInstance <clase_MeshInstance>` se hace "
"invisible poniendo la propiedad ``visible`` a ``false``. Esto es para que la "
"mano no se interponga en el camino del objeto sostenido. De la misma manera, "
"la ``gray_raycast`` 'laser sight' se hace invisible poniendo la propiedad "
"``visible`` a ``false``."

msgid ""
"Then the code checks to see if the held object extends a class called "
"``VR_Interactable_Rigidbody``. If it does, then sets a variable called "
"``controller`` on ``held_object`` to ``self``, and calls the ``picked_up`` "
"function on ``held_object``. While we haven't made "
"``VR_Interactable_Rigidbody`` just yet, what this will do is set tell the "
"``VR_Interactable_Rigidbody`` class that it is being held by a VR "
"controller, where the a reference to the controller is stored in the "
"``controller`` variable, through calling the ``picked_up`` function."
msgstr ""
"Entonces el código comprueba si el objeto retenido extiende una clase "
"llamada ``VR_Interactable_Rigidbody``. Si lo hace, entonces establece una "
"variable llamada ``controller`` en ``held_object`` a ``self``, y llama a la "
"función ``picked_up`` en ``held_object``. Aunque todavía no hemos hecho "
"``VR_Interactable_Rigidbody``, lo que esto hará es decirle a la clase "
"``VR_Interactable_Rigidbody`` que está siendo retenida por un controlador "
"VR, donde la referencia al controlador se almacena en la variable "
"``controller``, a través de la llamada a la función ``picked_up``."

msgid ""
"The code should make more sense after completing part 2 of this tutorial "
"series, where we will actually be using ``VR_Interactable_Rigidbody``."
msgstr ""
"El código debería tener más sentido después de completar la parte 2 de esta "
"serie de tutoriales, donde en realidad usaremos "
"``VR_Interactable_Rigidbody``."

msgid ""
"What this section of code does is that if a :ref:`RigidBody "
"<class_RigidBody>` was found using the grab :ref:`Area <class_Area>` or :ref:"
"`Raycast <class_Raycast>`, it sets it up so that it can be carried by the VR "
"controller."
msgstr ""
"Lo que hace esta sección de código es que si se encuentra un :ref:`RigidBody "
"<class_RigidBody>` usando el grab :ref:`Area <class_Area>` o :ref:`Raycast "
"<class_Raycast>`, lo configura para que pueda ser transportado por el "
"controlador de VR."

msgid "``_throw_rigidbody`` function step-by-step explanation"
msgstr "explicación paso a paso de la función ``_throw_rigidbody``"

msgid ""
"First the function checks to see if the VR controller is not holding any "
"object by checking if the ``held_object`` variable is equal to ``null``. If "
"it is, then it simply calls ``return`` so nothing happens. While this "
"shouldn't be possible, the ``_throw_rigidbody`` function should only be "
"called if an object is held, this check helps ensure that if something "
"strange happens, this function will react as expected."
msgstr ""
"Primero la función comprueba si el controlador VR no está sosteniendo ningún "
"objeto, comprobando si la variable ``held_object`` es igual a ``null``. Si "
"lo es, entonces simplemente llama a ``return`` para que no pase nada. Aunque "
"esto no debería ser posible, la función ``throw_rigidbody`` sólo debería ser "
"llamada si un objeto es retenido, esta comprobación ayuda a asegurar que si "
"algo extraño sucede, esta función reaccionará como se espera."

msgid ""
"After checking if the VR controller is holding an object, we assume it is "
"and set the stored :ref:`RigidBody <class_RigidBody>` data back to the held "
"object. We take the ``mode``, ``layer`` and ``mask`` data stored in the "
"``held_object_data`` dictionary and reapply it to the object in "
"``held_object``. This will set the :ref:`RigidBody <class_RigidBody>` back "
"to the state it was prior to being picked up."
msgstr ""
"Después de comprobar si el controlador VR está sosteniendo un objeto, "
"asumimos que lo está y ponemos los datos almacenados :ref:`RigidBody "
"<class_RigidBody>` de vuelta al objeto sostenido. Tomamos los datos "
"``mode``, ``layer`` y ``mask`` almacenados en el diccionario "
"``held_object_data`` y los volvemos a aplicar al objeto en ``held_object``. "
"Esto hará que el :ref:`RigidBody <class_RigidBody>` vuelva al estado que "
"tenía antes de ser recogido."

msgid ""
"Then we call ``apply_impulse`` on the ``held_object`` so that the :ref:"
"`RigidBody <class_RigidBody>` is thrown in the direction of the VR "
"controller's velocity, ``controller_velocity``."
msgstr ""
"Luego llamamos ``apply_impulse`` al ``held_object`` para que el :ref:"
"`RigidBody <class_RigidBody>` sea lanzado en la dirección de la velocidad "
"del controlador VR, ``controller_velocity``."

msgid ""
"We then check to see if the object held extends a class called "
"``VR_Interactable_Rigidbody``. If it does, then we call a function called "
"``dropped`` in ``held_object`` and set ``held_object.controller`` to "
"``null``. While we have not made ``VR_Interactable_Rigidbody`` yet, but what "
"this will do is call the ``droppped`` function so the :ref:`RigidBody "
"<class_RigidBody>` can do whatever it needs to do when dropped, and we set "
"the ``controller`` variable to ``null`` so that the :ref:`RigidBody "
"<class_RigidBody>` knows that it is not being held."
msgstr ""
"Entonces comprobamos si el objeto retenido extiende una clase llamada "
"``VR_Interactable_Rigidbody``. Si lo hace, entonces llamamos a una función "
"llamada ``dropped`` en ``held_object`` y ponemos ``held_object.controller`` "
"en ``null``. Aunque todavía no hemos hecho ``VR_Interactable_Rigidbody``, lo "
"que hará es llamar a la función ``dropped`` para que el :ref:`RigidBody "
"<class_RigidBody>` pueda hacer lo que sea necesario cuando se deje caer, y "
"ponemos la variable ``controller`` en ``null`` para que el :ref:`RigidBody "
"<class_RigidBody>` sepa que no está siendo retenido."

msgid ""
"Regardless of whether ``held_object`` extends ``VR_Interactable_Rigidbody`` "
"or not, we then set ``held_object`` to ``null`` so the VR controller knows "
"it is no longer holding anything. Because the VR controller is no longer "
"holding anything, we make the ``hand_mesh`` visible by setting ``hand_mesh."
"visible`` to true."
msgstr ""
"Independientemente de si ``held_object`` extiende "
"``VR_Interactable_Rigidbody`` o no, entonces ponemos ``held_object`` en "
"``null`` para que el controlador de VR sepa que ya no está sosteniendo nada. "
"Debido a que el controlador de VR ya no está sosteniendo nada, hacemos la "
"``hand_mesh`` visible estableciendo ``hand_mesh.visible`` a true."

msgid ""
"Finally, if the ``grab_mode`` variable is set to ``RAYCAST``, we set "
"``grab_raycast.visible`` to ``true`` so the 'laser sight' for the :ref:"
"`Raycast <class_Raycast>` in ``grab_raycast`` is visible."
msgstr ""
"Finalmente, si la variable ``grab_mode`` está puesta en ``RAYCAST``, ponemos "
"``grab_raycast.visible`` en ``true`` para que la 'mira láser' para el :ref:"
"`Raycast <class_Raycast>` en ``grab_raycast`` sea visible."

msgid "``_on_button_pressed_menu`` function step-by-step explanation"
msgstr "explicación paso a paso de la función ``_on_button_pressed_menu``"

msgid ""
"First this function checks to see if the ``grab_mode`` variable is equal to "
"``AREA``. If it is, then it sets ``grab_mode`` to ``RAYCAST``. It then "
"checks to see if the VR controller is not holding anything by checking to "
"see if ``held_object`` is equal to ``null``. If the VR controller is not "
"holding anything, then ``grab_raycast.visible`` is set to ``true`` so the "
"'laser sight' on the grab raycast is visible."
msgstr ""
"Primero esta función comprueba si la variable ``grab_mode`` es igual a "
"``AREA``. Si lo es, entonces establece \"grab_mode\" en ``RAYCAST``. Luego "
"comprueba si el controlador de VR no está reteniendo nada comprobando si "
"``held_object`` es igual a ``null``. Si el controlador de VR no está "
"sosteniendo nada, entonces ``grab_raycast.visible`` está configurado como "
"``true`` para que la 'mira láser' en el grab raycast sea visible."

msgid ""
"If the ``grab_mode`` variable is not equal to ``AREA``, then it checks to "
"see if it is equal to ``RAYCAST``. If it is, then it sets the ``grab_mode`` "
"to ``AREA`` and sets ``grab_raycast.visible`` to ``false`` so the 'laser "
"sight' on the grab raycast is not visible."
msgstr ""
"Si la variable ``grab_mode`` no es igual a ``AREA``, entonces comprueba si "
"es igual a ``RAYCAST``. Si lo es, entonces establece el ``grab_mode`` en "
"``AREA`` y establece ``grab_raycast.visible`` en ``false`` para que la 'mira "
"laser' en el grab raycast no sea visible."

msgid ""
"This section of code simply changes how the VR controller will grab :ref:"
"`RigidBody <class_RigidBody>`-based nodes when the grab/grip button is "
"pressed. If ``grab_mode`` is set to ``AREA``, then the :ref:`Area "
"<class_Area>` node in ``grab_area`` will be used for detecting :ref:"
"`RigidBody <class_RigidBody>` nodes, while if ``grab_mode`` is set to "
"``RAYCAST`` the :ref:`Raycast <class_Raycast>` node in ``grab_raycast`` will "
"be used for detecting :ref:`RigidBody <class_RigidBody>` nodes."
msgstr ""
"Esta sección de código simplemente cambia como el controlador de VR cogerá "
"nodos basados en :ref:`RigidBody <class_RigidBody>` cuando se pulse el botón "
"de agarrar. Si ``grab_mode`` está establecido como ``AREA``, entonces el "
"nodo :ref:`Area <class_Area>` en ``grab_area`` será usado para detectar "
"nodos :ref:`RigidBody <class_RigidBody>`, mientras que si ``grab_mode`` está "
"establecido a ``RAYCAST``, el nodo :ref:`Raycast <class_Raycast>` en "
"``grab_raycast`` será usado para detectar nodos :ref:`RigidBody "
"<class_RigidBody>`."

msgid "``button_released`` function step-by-step explanation"
msgstr "Explicación paso a paso de la función ``button_released``"

msgid ""
"The only section of code in this function checks to see if the index of the "
"button that was just released, ``button_index``, is equal to ``15``, which "
"should map to the trigger button on the VR controller. The ``button_index`` "
"variable is passed in by the ``button_release`` signal in :ref:"
"`ARVRController <class_ARVRController>`, which we connected in the "
"``_ready`` function."
msgstr ""
"La única sección de código en esta función comprueba si el índice del botón "
"que acaba de ser liberado, ``button_index``, es igual a ``15``, lo que "
"debería mapear al botón de disparo en el controlador VR. La variable "
"``button_index`` se pasa por la señal ``button_release`` en :ref:"
"`ARVRController <class_ARVRController>`, que conectamos en la función "
"``_ready``."

msgid ""
"If the trigger button was just released, then the "
"``_on_button_released_trigger`` function is called."
msgstr ""
"Si el botón accionador se suelta, entonces la función "
"``_on_button_released_trigger`` será llamada."

msgid "``_on_button_released_trigger`` function step-by-step explanation"
msgstr "Explicación paso a paso de la función ``_on_button_released_trigger``"

msgid ""
"The only section of code in this function first checks to see if the VR "
"controller is trying to teleport by checking if the ``teleport_button_down`` "
"variable is equal to ``true``."
msgstr ""
"La única sección de código de esta función primero comprueba si el "
"controlador de VR está intentando teletransportarse, comprobando si la "
"variable ``teleport_button_down`` es igual a ``true``."

msgid ""
"If the ``teleport_button_down`` variable is equal to ``true``, the code then "
"checks if there is a teleport position set and whether the teleport mesh is "
"visible. It does this by checking to see if ``teleport_pos`` is not equal to "
"``null`` and if ``teleport_mesh.visible`` is equal to ``true``."
msgstr ""
"Si la variable ``teleport_button_down`` es igual a ``true``, el código "
"entonces comprueba si hay una posición de teleportación establecida y si la "
"malla de teleportación es visible. Lo hace comprobando si ``teleport_pos`` "
"no es igual a ``null`` y si ``teleport_mesh.visible`` es igual a ``true``."

msgid ""
"If there is a teleport position set and the teleport mesh is visible, the "
"code then calculates the offset from the camera to the :ref:`ARVROrigin "
"<class_ARVROrigin>` node, which is assumed to be the parent node of the VR "
"controller. To calculate the offset, the global position (``global_transform."
"origin``) of the ``Player_Camera`` node has the global position of the :ref:"
"`ARVROrigin <class_ARVROrigin>` subtracted from it. This will result in a "
"vector that points from the :ref:`ARVROrigin <class_ARVROrigin>` to the :ref:"
"`ARVRCamera <class_ARVRCamera>`, which we store in a variable called "
"``camera_offset``."
msgstr ""
"Si hay una posición de teleportación establecida y la malla de teleportación "
"es visible, el código entonces calcula el desplazamiento de la cámara al "
"nodo :ref:`ARVROrigin <class_ARVROrigin>`, que se asume como el nodo padre "
"del controlador VR. Para calcular el desplazamiento, la posición global "
"(``global_transform.origin``) del nodo ``Player_Camera`` tiene la posición "
"global del nodo :ref:`ARVROrigin <class_ARVROrigin>` restada de él. Esto "
"dará como resultado un vector que apunta desde el :ref:`ARVROrigin "
"<class_ARVROrigin>` al :ref:`ARVRCamera <class_ARVRCamera>`, que almacenamos "
"en una variable llamada ``camera_offset``."

msgid ""
"The reason we need to know the offset is because some VR headsets use room "
"tracking, where the player's camera can be offset from the :ref:`ARVROrigin "
"<class_ARVROrigin>` node. Because of this, when we teleport we want to keep "
"the offset created by room tracking so that when the player teleports, the "
"offset created by the room tracking is not applied. Without this, if you "
"moved in a room and then teleported, instead of appearing at the position "
"you wanted to teleport at, your position would be offset by the amount of "
"distance you have from the :ref:`ARVROrigin <class_ARVROrigin>` node."
msgstr ""
"La razón por la que necesitamos saber el desplazamiento es porque algunos "
"auriculares de RV usan el seguimiento de la sala, donde la cámara del "
"jugador puede ser desplazada del nodo :ref:`ARVROrigin <class_ARVROrigin>`. "
"Por eso, cuando nos teletransportamos queremos mantener el offset creado por "
"el room tracking para que cuando el jugador se teletransporte, no se aplique "
"el offset creado por el room tracking. Sin esto, si te movieras en una sala "
"y luego te teletransportaras, en lugar de aparecer en la posición en la que "
"querías teletransportarte, tu posición estaría compensada por la cantidad de "
"distancia que tienes del nodo :ref:`ARVROrigin <class_ARVROrigin>`."

msgid ""
"Now that we know the offset from the VR camera to the VR origin, we need to "
"remove the difference on the ``Y`` axis. We do this because we do not want "
"to offset based on the user's height. If we did not do this, when "
"teleporting the player's head would be level with the ground."
msgstr ""
"Ahora que sabemos el desplazamiento de la cámara VR al origen de la misma, "
"necesitamos eliminar la diferencia en el eje ``Y``. Hacemos esto porque no "
"queremos compensar en base a la altura del usuario. Si no lo hiciéramos, al "
"teletransportar la cabeza del jugador estaría a nivel del suelo."

msgid ""
"Then we can 'teleport' the player by setting the global position "
"(``global_transform.origin``) of the ARVROrigin node to the position stored "
"in ``teleport_pos`` with ``camera_offset`` subtracted from it. This will "
"teleport the player and remove the room tracking offset, so the user appears "
"exactly where they want when teleporting."
msgstr ""
"Entonces podemos \"teletransportar\" al jugador poniendo la posición global "
"(``global_transform.origin``) del nodo ARVROrigin en la posición almacenada "
"en ``teleport_pos`` con ``camera_offset`` restado de ella. Esto "
"teletransportará al jugador y eliminará el offset de seguimiento de la sala, "
"de modo que el usuario aparezca exactamente donde quiere cuando se "
"teletransporte."

msgid ""
"Finally, regardless of whether the VR controller teleported the user or not, "
"we reset the teleport related variables. ``teleport_button_down`` is set to "
"``false``, ``teleport_mesh.visible`` is set to ``false`` so the mesh is "
"invisible, ``teleport_raycast.visible`` is set to ``false``, and "
"``teleport_pos`` is set to ``null``."
msgstr ""
"Finalmente, independientemente de si el controlador VR teleportó al usuario "
"o no, reajustamos las variables relacionadas con el teleporte. "
"``teleport_button_down`` está establecida en ``false``, ``teleport_mesh."
"visible`` está establecida en ``false`` por lo que la malla es invisible, "
"``teleport_raycast.visible`` está establecida en ``false``, y "
"``teleport_pos`` está establecida en ``null``."

msgid "``sleep_area_entered`` function step-by-step explanation"
msgstr "explicación paso a paso de la función ``sleep_area_entered``"

msgid ""
"The only section of code in this function checks to see if the :ref:"
"`PhysicsBody <class_PhysicsBody>` node that entered the ``Sleep_Area`` node "
"has a variable called ``can_sleep``. If it does, then it sets the "
"``can_sleep`` variable to ``false`` and sets the ``sleeping`` variable to "
"``false``."
msgstr ""
"La única sección de código en esta función comprueba si el nodo :ref:"
"`PhysicsBody <class_PhysicsBody>` que entró en el nodo ``Sleep_Area`` tiene "
"una variable llamada ``can_sleep``. Si lo hace, entonces pone la variable "
"``can_sleep`` en ``false`` y pone la variable ``sleeping`` en ``false``."

msgid ""
"Without doing this, sleeping :ref:`PhysicsBody <class_PhysicsBody>` nodes "
"would not be able to be picked up by the VR controller, even if the VR "
"controller is at the same position as the :ref:`PhysicsBody "
"<class_PhysicsBody>` node. To work around this, we simply 'wake up' :ref:"
"`PhysicsBody <class_PhysicsBody>` nodes that are close to the VR controller."
msgstr ""
"Sin hacer esto, los nodos durmientes :ref:`PhysicsBody <class_PhysicsBody>` "
"no podrían ser recogidos por el controlador de VR, incluso si el controlador "
"de VR está en la misma posición que el nodo :ref:`PhysicsBody "
"<class_PhysicsBody>`. Para solucionar esto, simplemente 'despertamos' :ref:"
"`PhysicsBody <class_PhysicsBody>` los nodos que están cerca del controlador "
"de VR."

msgid "``sleep_area_exited`` function step-by-step explanation"
msgstr "explicación paso a paso de la función ``sleep_area_exited``"

msgid ""
"The only section of code in this function checks to see if the :ref:"
"`PhysicsBody <class_PhysicsBody>` node that entered the ``Sleep_Area`` node "
"has a variable called ``can_sleep``. If it does, then it sets the "
"``can_sleep`` variable to ``true``."
msgstr ""
"La única sección de código en esta función comprueba si el nodo :ref:"
"`PhysicsBody <class_PhysicsBody>` que entró en el nodo ``Sleep_Area`` tiene "
"una variable llamada ``can_sleep``. Si lo hace, entonces pone la variable "
"``can_sleep`` en ``true``."

msgid ""
"This allows :ref:`RigidBody <class_RigidBody>` nodes that leave the "
"``Sleep_Area`` to sleep again, saving performance."
msgstr ""
"Esto permite :ref:`RigidBody <class_RigidBody>` nodos que dejan el "
"``Sleep_Area`` para dormir de nuevo, ahorrando rendimiento."

msgid ""
"Okay, whew! That was a lot of code! Add the same script, ``VR_Controller."
"gd`` to the other VR controller scene so both VR controllers have the same "
"script."
msgstr ""
"Bien, ¡wow! ¡Eso fue un montón de código! Añade el mismo script, "
"``VR_Controller.gd`` a la otra escena de controladores VR para que ambos "
"controladores VR tengan el mismo script."

msgid ""
"Now we just need to do one thing before testing the project! Right now we "
"are referencing a class called ``VR_Interactable_Rigidbody``, but we have "
"not defined it yet. While we will not be using ``VR_Interactable_Rigidbody`` "
"in this tutorial, let's create it real quick so the project can be run."
msgstr ""
"¡Ahora sólo tenemos que hacer una cosa antes de probar el proyecto! Ahora "
"mismo estamos haciendo referencia a una clase llamada "
"``VR_Interactable_Rigidbody``, pero aún no la hemos definido. Aunque no "
"usaremos ``VR_Interactable_Rigidbody`` en este tutorial, vamos a crearla "
"rápidamente para que el proyecto pueda ser ejecutado."

msgid "Creating a base class for interactable VR objects"
msgstr "Creando una clase base para objetos VR interactivos"

msgid ""
"With the ``Script`` tab still open, create a new GDScript called "
"``VR_Interactable_Rigidbody.gd``."
msgstr ""
"Con la pestaña ``Script`` aún abierta, crea un nuevo GDScript llamado "
"``VR_Interactable_Rigidbody.gd``."

msgid ""
"You can create GDScripts in the ``Script`` tab by pressing ``File -> New "
"Script...``."
msgstr ""
"Puedes crear GDScripts en la pestaña ``Script`` presionando ``File -> New "
"Script...``."

msgid ""
"Once you have ``VR_Interactable_Rigidbody.gd`` open, add the following code:"
msgstr ""
"Una vez que tengas ``VR_Interactable_Rigidbody.gd`` abierto, agrega el "
"siguiente código:"

msgid "Let's quickly go through what this script."
msgstr "Analicemos rápidamente el script."

msgid ""
"First we start the script with ``class_name VR_Interactable_Rigidbody``. "
"What this does is that it tells Godot that this GDScript is a new class that "
"called ``VR_Interactable_Rigidbody``. This allows us to compare nodes "
"against the ``VR_Interactable_Rigidbody`` class in other script files "
"without having to load the script directly or do anything special. We can "
"compare the class just like all of the built-in Godot classes."
msgstr ""
"Primero empezamos el script con ``class_name VR_Interactable_Rigidbody``. Lo "
"que esto hace es que le dice a Godot que este GDScript es una nueva clase "
"que se llama ``VR_Interactable_Rigidbody``. Esto nos permite comparar nodos "
"con la clase ``VR_Interactable_Rigidbody`` en otros archivos de script sin "
"tener que cargar el script directamente o hacer algo especial. Podemos "
"comparar la clase como todas las clases de Godot incorporadas."

msgid ""
"Next is a class variable called ``controller``. ``controller`` will be used "
"to hold a reference to the VR controller that is currently holding the "
"object. If a VR controller is not holding the object, then the "
"``controller`` variable will be ``null``. The reason we need to have a "
"reference to the VR controller is so held objects can access VR controller "
"specific data, like ``controller_velocity``."
msgstr ""
"Lo siguiente es una variable de clase llamada ``controller``. ``controller`` "
"se usará para mantener una referencia al controlador VR que actualmente "
"sostiene el objeto. Si un controlador VR no está sosteniendo el objeto, "
"entonces la variable ``controller`` será ``null``. La razón por la que "
"necesitamos tener una referencia al controlador de VR es para que los "
"objetos retenidos puedan acceder a los datos específicos del controlador de "
"VR, como ``controller_velocity``."

msgid ""
"Finally, we have four functions. The ``_ready`` function is defined by Godot "
"and all we do is simply have ``pass`` as there is nothing we need to do when "
"the object is added to the scene in ``VR_Interactable_Rigidbody``."
msgstr ""
"Finalmente, tenemos cuatro funciones. La función ``_ready`` está definida "
"por Godot y todo lo que hacemos es simplemente tener un ``pass``, ya que no "
"hay nada que tengamos que hacer cuando el objeto se añade a la escena en "
"``VR_Interactable_Rigidbody``."

msgid ""
"The ``interact`` function is a stub function that will be called when the "
"interact button on the VR controller, the trigger in this case, is pressed "
"while the object is held."
msgstr ""
"La función ``interact`` es una función que se llamará cuando el botón de "
"interacción del controlador VR, el disparador en este caso, sea presionado "
"mientras el objeto es sostenido."

msgid ""
"A stub function is a function that is defined but does not have any code. "
"Stub functions are generally designed to be overwritten or extended. In this "
"project, we are using the stub functions so there is a consistent interface "
"across all interactable :ref:`RigidBody <class_RigidBody>` objects."
msgstr ""
"Una función stub es una función que está definida pero no tiene ningún "
"código. Las funciones de stub generalmente están diseñadas para ser "
"sobrescritas o extendidas. En este proyecto, estamos usando las funciones "
"stub para que haya una interfaz consistente en todos los objetos "
"interactivos :ref:`RigidBody <class_RigidBody>`."

msgid ""
"The ``picked_up`` and ``dropped`` functions are stub functions that will be "
"called when the object is picked up and dropped by the VR controller."
msgstr ""
"Las funciones ``picked_up`` y ``dropped`` son funciones de stub que serán "
"llamadas cuando el objeto sea recogido y soltado por el controlador VR."

msgid ""
"That is all we need to do for now! In the next part of this tutorial series, "
"we'll start making special interactable :ref:`RigidBody <class_RigidBody>` "
"objects."
msgstr ""
"¡Eso es todo lo que tenemos que hacer por ahora! En la próxima parte de esta "
"serie de tutoriales, empezaremos a hacer objetos interactivos especiales :"
"ref:`RigidBody <class_RigidBody>`."

msgid ""
"Now that the base class is defined, the code in the VR controller should "
"work. Go ahead and try the game again, and you should find you can teleport "
"around by pressing the touch pad, and can grab and throw objects using the "
"grab/grip buttons."
msgstr ""
"Ahora que la clase base está definida, el código del controlador VR debería "
"funcionar. Adelante, prueba el juego de nuevo, y deberías encontrar que "
"puedes teletransportarte pulsando el panel táctil, y puedes agarrar y lanzar "
"objetos usando los botones de agarrar/empuñar."

msgid ""
"Now, you may want to try moving using the trackpads and/or joysticks, but "
"**it may make you motion sick!**"
msgstr ""
"Ahora, puede que quieras intentar moverte usando los trackpads y/o "
"joysticks, pero **puede hacerte sentir mal por el movimiento!**"

msgid ""
"One of the main reasons this can make you feel motion sick is because your "
"vision tells you that you are moving, while your body is not moving. This "
"conflict of signals can make the body feel sick. Let's add a vignette shader "
"to help reduce motion sickness while moving in VR!"
msgstr ""
"Una de las principales razones por las que esto puede hacer que te sientas "
"mal del movimiento es porque tu visión te dice que te estás moviendo, "
"mientras que tu cuerpo no se está moviendo. Este conflicto de señales puede "
"hacer que el cuerpo se sienta enfermo. Añadamos un shader de viñetas para "
"ayudar a reducir el mareo mientras se mueve en RV!"

msgid "Reducing motion sickness"
msgstr "Reducir el mareo por movimiento"

msgid ""
"There are plenty of ways to reduce motion sickness in VR, and there is no "
"one perfect way to reduce motion sickness. See `this page on the Oculus "
"Developer Center <https://developer.oculus.com/design/latest/concepts/bp-"
"locomotion/>`__ for more information on how to implement locomotion and "
"reducing motion sickness."
msgstr ""
"Existen muchas formas de reducir el mareo por movimiento en realidad "
"virtual, y no hay una manera perfecta de hacerlo. Consulta `esta página en "
"el Centro de Desarrolladores de Oculus <https://developer.oculus.com/design/"
"latest/concepts/bp-locomotion/>`__ para obtener más información sobre cómo "
"implementar locomoción y reducir el mareo por movimiento."

msgid ""
"To help reduce motion sickness while moving, we are going to add a vignette "
"effect that will only be visible while the player moves."
msgstr ""
"Para ayudar a reducir el mareo al moverse, vamos a añadir un efecto de "
"viñeta que sólo será visible mientras el jugador se mueve."

msgid ""
"First, quickly switch back to ``Game.tscn``. Under the :ref:`ARVROrigin "
"<class_ARVROrigin>` node there is a child node called ``Movement_Vignette``. "
"This node is going to apply a simple vignette to the VR headset when the "
"player is moving using the VR controllers. This should help reduce motion "
"sickness."
msgstr ""
"Primero, cambia rápidamente a ``Game.tscn``. Bajo el nodo :ref:`ARVROrigin "
"<class_ARVROrigin>`, hay un nodo secundario llamado ``Movement_Vignette``. "
"Este nodo aplicará un simple viñeteado al casco de realidad virtual cuando "
"el jugador se esté moviendo utilizando los controladores de VR. Esto debería "
"ayudar a reducir el mareo por movimiento."

msgid ""
"Open up ``Movement_Vignette.tscn``, which you can find in the ``Scenes`` "
"folder. The scene is just a :ref:`ColorRect <class_ColorRect>` node with a "
"custom shader. Feel free to look at the custom shader if you want, it is "
"just a slightly modified version of the vignette shader you can find in the "
"`Godot demo repository <https://github.com/godotengine/godot-demo-"
"projects>`__."
msgstr ""
"Abre ``Movement_Vignette.tscn``, que puedes encontrar en la carpeta "
"``Scenes``. La escena es sólo un nodo :ref:`ColorRect <class_ColorRect>` con "
"un shader personalizado. Siéntete libre de mirar el shader personalizado si "
"quieres, es sólo una versión ligeramente modificada del shader de viñetas "
"que puedes encontrar en el repositorio ``Godot demo <https://github.com/"
"godotengine/godot-demo-projects>`__."

msgid ""
"Let's write the code that will make the vignette shader visible when the "
"player is moving. Select the ``Movement_Vignette`` node and create a new "
"script called ``Movement_Vignette.gd``. Add the following code:"
msgstr ""
"Escribamos el código que hará visible el shader de viñetas cuando el jugador "
"se mueva. Selecciona el nodo ``Movement_Vignette`` y crea un nuevo script "
"llamado ``Movement_Vignette.gd``. Añade el siguiente código:"

msgid ""
"Because this script is fairly brief, let's quickly go over what it does."
msgstr "Como este script es bastante simple, veamos rápidamente lo que hace."

msgid "Explaining the vignette code"
msgstr "Explicando el código de viñeta"

msgid ""
"There are two class variables, ``controller_one`` and ``controller_two``. "
"These variables will hold references to the left and right VR controllers."
msgstr ""
"Hay dos variables de clase, ``controller_one`` y ``controller_two``. Estas "
"variables contendrán referencias a los controladores VR izquierdo y derecho."

msgid ""
"In the ``_ready`` function first waits for four frames using ``yield``. The "
"reason we are waiting four frames is because we want to ensure the VR "
"interface is ready and accessible."
msgstr ""
"En la función ``_ready`` primero espera cuatro fotogramas usando ``yield``. "
"La razón por la que esperamos cuatro fotogramas es porque queremos "
"asegurarnos de que la interfaz de RV está lista y accesible."

msgid ""
"After waiting the primary VR interface is retrieved using ``ARVRServer."
"primary_interface``, which is assigned to a variable called ``interface``. "
"The code then checks to see if ``interface`` is equal to ``null``. If "
"``interface`` is equal to ``null``, then ``_process`` is disabled using "
"``set_process`` with a value of ``false``."
msgstr ""
"Después de esperar, la interfaz primaria de RV se recupera usando "
"``ARVRServer.primary_interface``, que se asigna a una variable llamada "
"``interface``. El código entonces comprueba si ``interfaz`` es igual a "
"``null``. Si ``interfaz`` es igual a ``null``, entonces ``_process`` se "
"deshabilita usando ``set_process`` con un valor de ``false``."

msgid ""
"If ``interface`` is not ``null``, then we set the ``rect_size`` of the "
"vignette shader to the render size of the VR viewport so it takes up the "
"entire screen. We need to do this because different VR headsets have "
"different resolutions and aspect ratios, so we need to resize the node "
"accordingly. We also set the ``rect_position`` of the vignette shader to "
"zero so it is in the correct position relative to the screen."
msgstr ""
"Si la ``interface`` no es ``null``, entonces ponemos el ``rect_size`` del "
"shader de viñetas en el tamaño de renderización de la ventana VR para que "
"ocupe toda la pantalla. Necesitamos hacer esto porque los diferentes "
"auriculares de la RV tienen diferentes resoluciones y relaciones de aspecto, "
"así que tenemos que redimensionar el nodo en consecuencia. También "
"establecemos la ``rect_position`` del shader de viñetas en cero para que "
"esté en la posición correcta con respecto a la pantalla."

msgid ""
"The left and right VR controllers are then retrieved and assigned to "
"``controller_one`` and ``controller_two`` respectively. Finally, the "
"vignette shader is made invisible by default by setting it's ``visible`` "
"property to ``false``."
msgstr ""
"Los controladores de RV izquierdo y derecho se recuperan y se asignan a "
"``controller_one`` y ``controller_two`` respectivamente. Finalmente, el "
"shader de viñetas se hace invisible de forma predeterminada al establecer su "
"propiedad ``visible`` como ``false``."

msgid ""
"In ``_process`` the code first checks if either ``controller_one`` or "
"``controller_two`` are equal to ``null``. If either node is equal to "
"``null``, then ``return`` is called so nothing happens."
msgstr ""
"En ``_process`` el código primero comprueba si ``controller_one`` o "
"``controller_two`` es igual a ``null``. Si cualquiera de los nodos es igual "
"a ``null``, entonces se llama ``return`` para que no pase nada."

msgid ""
"Then the code checks to see if either of the VR controllers are moving the "
"player using the touchpad/joystick by checking if ``directional_movement`` "
"is equal to ``true`` in ``controller_one`` or ``controller_two``. If either "
"of the VR controllers are moving the player, then the vignette shader makes "
"itself visible by setting it's ``visible`` property to ``true``. If neither "
"VR controller is moving the player, so ``directional_movement`` is ``false`` "
"in both VR controllers, than the vignette shader makes itself invisible by "
"setting it's ``visible`` property to ``false``."
msgstr ""
"Luego el código comprueba si alguno de los controladores de RV está moviendo "
"el reproductor usando el touchpad/joystick comprobando si "
"``directional_movement`` es igual a ``true`` en ``controller_one`` o "
"``controller_two``. Si alguno de los controladores de RV está moviendo el "
"reproductor, entonces el shader de viñetas se hace visible estableciendo su "
"propiedad ``visible`` como ``true``. Si ninguno de los controladores de VR "
"está moviendo el reproductor, entonces ``directional_movement`` es ``false`` "
"en ambos controladores de VR, entonces el shader de viñetas se hace "
"invisible ajustando su propiedad ``visible`` a ``false``."

msgid ""
"That is the whole script! Now that we have written the code, go ahead and "
"try moving around with the trackpad and/or joystick. You should find that it "
"is less motion sickness-inducing then before!"
msgstr ""
"¡Ese es todo el script! Ahora que hemos escrito el código, adelante e "
"intenta moverte con el trackpad y/o el joystick. ¡Deberíais descubrir que es "
"menos enfermizo que antes!"

msgid ""
"As previously mentioned, there are plenty of ways to reduce motion sickness "
"in VR. Check out `this page on the Oculus Developer Center <https://"
"developer.oculus.com/design/latest/concepts/bp-locomotion/>`__ for more "
"information on how to implement locomotion and reducing motion sickness."
msgstr ""
"Como se mencionó anteriormente, hay muchas maneras de reducir el mareo en la "
"RV. Revisa \"esta página del Centro de Desarrollo de Oculus\" <https://"
"developer.oculus.com/design/latest/concepts/bp-locomotion/>`_ para más "
"información sobre cómo implementar la locomoción y reducir el mareo."

msgid "Final notes"
msgstr "Notas finales"

msgid ""
"Now you have fully working VR controllers that can move around the "
"environment and interact with :ref:`RigidBody <class_RigidBody>`-based "
"objects. In the next part of this tutorial series, we will be creating some "
"special :ref:`RigidBody <class_RigidBody>`-based objects for the player to "
"use!"
msgstr ""
"Ahora tienes controladores de RV completamente funcionales que pueden "
"moverse por el entorno e interactuar con objetos basados en :ref:`RigidBody "
"<class_RigidBody>`. En la próxima parte de esta serie de tutoriales, "
"crearemos algunos objetos especiales basados en :ref:`RigidBody "
"<class_RigidBody>` para que el jugador los use!"

msgid ""
"You can download the finished project for this tutorial series on the Godot "
"OpenVR GitHub repository, under the releases tab!"
msgstr ""
"Puedes descargar el proyecto terminado para esta serie de tutoriales en el "
"repositorio Godot OpenVR GitHub, en la pestaña de releases!"

msgid "Translation status"
msgstr "Estado de traducción"
