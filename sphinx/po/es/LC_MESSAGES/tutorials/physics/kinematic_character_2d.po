# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Kinematic character (2D)"
msgstr "Personaje cinemático (2D)"

msgid "Introduction"
msgstr "Introducción"

msgid ""
"Yes, the name sounds strange. \"Kinematic Character\". What is that? The "
"reason for the name is that, when physics engines came out, they were called "
"\"Dynamics\" engines (because they dealt mainly with collision responses). "
"Many attempts were made to create a character controller using the dynamics "
"engines, but it wasn't as easy as it seemed. Godot has one of the best "
"implementations of dynamic character controller you can find (as it can be "
"seen in the 2d/platformer demo), but using it requires a considerable level "
"of skill and understanding of physics engines (or a lot of patience with "
"trial and error)."
msgstr ""
"Sí, el nombre suena extraño. \"Personaje Cinemático\". ¿Qué es eso? La razón "
"es que cuando aparecieron los motores de físicas, fueron llamados motores de "
"\"Dinámicas\" (porque tratan principalmente con respuestas de colisiones). "
"Se llevaron a cabo muchos intentos para crear un controlador de personajes "
"utilizando los motores de dinámicas, pero no fue tan fácil como parecía. "
"Godot tiene una de las mejores implementaciones de controlador de personajes "
"dinámicos (como puede verse en la demo 2d/plataformas), pero usarlo requiere "
"un considerable nivel de habilidad y conocimiento de motores de físicas (o "
"mucha paciencia con el ensayo y error)."

msgid ""
"Some physics engines, such as Havok seem to swear by dynamic character "
"controllers as the best option, while others (PhysX) would rather promote "
"the kinematic one."
msgstr ""
"Algunos motores de física como Havok parecen apostar por los controladores "
"de personaje dinámico como la mejor alternativa, mientras que otros (PhysX) "
"prefieren promover los de personaje cinemático."

msgid "So, what is the difference?:"
msgstr "Entonces, ¿cuál es la diferencia?:"

msgid ""
"A **dynamic character controller** uses a rigid body with an infinite "
"inertia tensor. It's a rigid body that can't rotate. Physics engines always "
"let objects move and collide, then solve their collisions all together. This "
"makes dynamic character controllers able to interact with other physics "
"objects seamlessly, as seen in the platformer demo. However, these "
"interactions are not always predictable. Collisions can take more than one "
"frame to be solved, so a few collisions may seem to displace a tiny bit. "
"Those problems can be fixed, but require a certain amount of skill."
msgstr ""
"Un **controlador de personaje dinámico** utiliza un cuerpo rígido con tensor "
"de inercia infinita. Básicamente, es un cuerpo rígido que no puede rotar. "
"Los motores de física siempre dejan que los objetos se muevan y colisionen, "
"después resuelven sus colisiones todas juntas. Esto hace que los "
"controladores de personaje dinámico sean capaces de interactuar con otros "
"objetos físicos sin inconvenientes, como se ve en la demo del juego de "
"plataformas. Sin embargo estas interacciones no son siempre predecibles. Las "
"colisiones pueden tardar más de un frame en ser resueltas, así que unas "
"pocas colisiones pueden verse desplazadas un poquito. Esos problemas pueden "
"solucionarse, pero requieren de cierta habilidad."

msgid ""
"A **kinematic character controller** is assumed to always begin in a non-"
"colliding state, and will always move to a non-colliding state. If it starts "
"in a colliding state, it will try to free itself like rigid bodies do, but "
"this is the exception, not the rule. This makes their control and motion a "
"lot more predictable and easier to program. However, as a downside, they "
"can't directly interact with other physics objects, unless done by hand in "
"code."
msgstr ""
"Un **controlador cinemático de personaje** asume siempre en un estado de no "
"colisión, y siempre se moverá a un estado de no colisión. Si comienza en un "
"estado de colisión, intentará liberarse como lo hacen los cuerpos rígidos, "
"pero esta es la excepción, no la regla. Esto hace que su control y "
"movimiento sean mucho más predecibles y fáciles de programar. Sin embargo, "
"como desventaja, no pueden interactuar directamente con otros objetos de la "
"física, a menos que se haga a mano en código."

#, fuzzy
msgid ""
"This short tutorial focuses on the kinematic character controller. It uses "
"the old-school way of handling collisions, which is not necessarily simpler "
"under the hood, but well hidden and presented as an API."
msgstr ""
"Este breve tutorial se centrará en el controlador cinemático de personajes. "
"Básicamente, la manera de la vieja escuela de manejar las colisiones (que no "
"es necesariamente más simple por debajo, pero bien escondida y presentada "
"como un API agradable y simple)."

msgid "Physics process"
msgstr "Proceso físico"

msgid ""
"To manage the logic of a kinematic body or character, it is always advised "
"to use physics process, because it's called before physics step and its "
"execution is in sync with physics server, also it is called the same amount "
"of times per second, always. This makes physics and motion calculation work "
"in a more predictable way than using regular process, which might have "
"spikes or lose precision if the frame rate is too high or too low."
msgstr ""
"Para manejar la lógica de un personaje o cuerpo cinemático, siempre se "
"aconseja utilizar el proceso de la física, ya que es llamado antes del paso "
"de la física y su ejecución está sincronizada con el servidor de física, "
"también siempre es llamado la misma cantidad de veces por segundo. Esto hace "
"que la física y el cálculo de movimiento funcionen de una manera más "
"predecible que el proceso normal, que puede tener picos o perder precisión "
"si la frecuencia de imagen es demasiado alta o demasiado baja."

msgid "Scene setup"
msgstr "Configuración de la escena"

#, fuzzy
msgid ""
"To have something to test, here's the scene (from the tilemap tutorial): "
"`kinematic_character_2d_starter.zip <https://github.com/godotengine/godot-"
"docs-project-starters/releases/download/latest-4.x/"
"kinematic_character_2d_starter.zip>`_. We'll be creating a new scene for the "
"character. Use the robot sprite and create a scene like this:"
msgstr ""
"Para tener algo que probar, aquí está la escena (del tutorial de tilemap): :"
"download:`kbscene.zip <files/kbscene.zip>`. Vamos a crear una nueva escena "
"para el personaje. Usa el sprite robot y crea una escena como esta:"

msgid ""
"You'll notice that there's a warning icon next to our CollisionShape2D node; "
"that's because we haven't defined a shape for it. Create a new CircleShape2D "
"in the shape property of CollisionShape2D. Click on <CircleShape2D> to go to "
"the options for it, and set the radius to 30:"
msgstr ""
"Notarás que hay un icono de advertencia junto al nodo CollisionShape2D, esto "
"es porque no hemos definido una forma para él. Crea un nuevo CircleShape2D "
"en la propiedad shape de CollisionShape2D. Haz clic en <CircleShape2D> para "
"ir a las opciones correspondientes, y establece el radio en 30:"

msgid ""
"**Note: As mentioned before in the physics tutorial, the physics engine "
"can't handle scale on most types of shapes (only collision polygons, planes "
"and segments work), so always change the parameters (such as radius) of the "
"shape instead of scaling it. The same is also true for the kinematic/rigid/"
"static bodies themselves, as their scale affects the shape scale.**"
msgstr ""
"**Nota: Como se mencionó anteriormente en el tutorial de física, el motor de "
"física no puede manejar la escala en la mayoría de los tipos de formas (sólo "
"funcionan los polígonos de colisión, planos y segmentos), así que cambia "
"siempre los parámetros (como el radio) de la forma en lugar de escalarla. Lo "
"mismo ocurre con los cuerpos cinemáticos/rígidos/estáticos, ya que su escala "
"afecta a la escala de la forma.**"

msgid ""
"Now, create a script for the character, the one used as an example above "
"should work as a base."
msgstr ""
"Ahora crea un script para el personaje, el que se usa como ejemplo anterior "
"debería funcionar como base."

msgid ""
"Finally, instance that character scene in the tilemap, and make the map "
"scene the main one, so it runs when pressing play."
msgstr ""
"Por último, instancia la escena del personaje en el tilemap, y haz que la "
"escena del mapa sea la principal, para que se ejecute al presionar play."

msgid "Moving the kinematic character"
msgstr "Moviendo el personaje cinemático"

#, fuzzy
msgid ""
"Go back to the character scene, and open the script, the magic begins now! "
"Kinematic body will do nothing by default, but it has a useful function "
"called ``CharacterBody2D.move_and_collide()``. This function takes a :ref:"
"`Vector2 <class_Vector2>` as an argument, and tries to apply that motion to "
"the kinematic body. If a collision happens, it stops right at the moment of "
"the collision."
msgstr ""
"Vuelve a la escena del personaje y abre el script ¡la magia comienza ahora! "
"El cuerpo cinemático no hará nada por defecto, pero tiene una función muy "
"útil llamada :ref:`KinematicBody2D.move_and_collide() "
"<class_KinematicBody2D_method_move_and_collide>`. Esta función toma un :ref:"
"`Vector2 <class_Vector2>` como argumento, e intenta aplicar ese movimiento "
"al cuerpo cinemático. Si se produce una colisión, se detiene justo en el "
"momento de la colisión."

msgid "So, let's move our sprite downwards until it hits the floor:"
msgstr "Entonces, movamos nuestro sprite hacia abajo hasta que toque el suelo:"

msgid ""
"The result is that the character will move, but stop right when hitting the "
"floor. Pretty cool, huh?"
msgstr ""
"El resultado es que el personaje se moverá, pero se detendrá justo cuando "
"golpee el suelo. Bastante genial, ¿no?"

msgid ""
"The next step will be adding gravity to the mix, this way it behaves a "
"little more like a regular game character:"
msgstr ""
"El siguiente paso será añadir gravedad a la combinación, de esta manera se "
"comporta de una manera más parecida a la de un personaje real de un juego:"

msgid ""
"Now the character falls smoothly. Let's make it walk to the sides, left and "
"right when touching the directional keys. Remember that the values being "
"used (for speed at least) are pixels/second."
msgstr ""
"Ahora el personaje cae suavemente. Hagamos que camine hacia los lados, "
"izquierda y derecha, cuando se presionen las teclas de dirección. Recuerda "
"que los valores utilizados (al menos para la velocidad) son píxeles/segundo."

#, fuzzy
msgid "This adds basic support for walking when pressing left and right:"
msgstr ""
"Esto añade un sencillo soporte para caminar presionando izquierda y derecha:"

msgid "And give it a try."
msgstr "E inténtalo."

msgid ""
"This is a good starting point for a platformer. A more complete demo can be "
"found in the demo zip distributed with the engine, or in the https://github."
"com/godotengine/godot-demo-projects/tree/master/2d/kinematic_character."
msgstr ""
"Este es un buen punto de partida para un juego de plataformas. Se puede "
"encontrar una demostración más completa en el zip de demostración "
"distribuido con el motor, o en https://github.com/godotengine/godot-demo-"
"projects/tree/master/2d/kinematic_character."

msgid "Translation status"
msgstr "Estado de traducción"
