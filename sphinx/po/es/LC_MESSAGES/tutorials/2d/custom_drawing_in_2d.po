# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom drawing in 2D"
msgstr "Dibujos personalizados en 2D"

msgid "Introduction"
msgstr "Introducción"

msgid ""
"Godot has nodes to draw sprites, polygons, particles, and all sorts of "
"stuff. For most cases, this is enough; but not always. Before crying in "
"fear, angst, and rage because a node to draw that specific *something* does "
"not exist... it would be good to know that it is possible to easily make any "
"2D node (be it :ref:`Control <class_Control>` or :ref:`Node2D "
"<class_Node2D>` based) draw custom commands. It is *really* easy to do it, "
"too."
msgstr ""
"Godot posee nodos para dibujar sprites, polígonos, partículas, etc., para la "
"mayoría de los casos eso es suficiente, pero no siempre. Antes de desesperar "
"al ver que no existe un nodo para dibujar algo *específico*, es bueno saber "
"que es posible hacer que cualquier nodo 2D (ya sea uno basado en :ref:"
"`Control <class_Control>` o :ref:`Node2D <class_Node2D>` ) puede aceptar "
"comandos de dibujo personalizados. Esto es muy fácil de hacer."

msgid ""
"Custom drawing in a 2D node is *really* useful. Here are some use cases:"
msgstr ""
"Dibujar manualmente en un nodo 2D es *realmente* útil, aquí hay algunos "
"casos de uso:"

msgid ""
"Drawing shapes or logic that existing nodes can't do, such as an image with "
"trails or a special animated polygon."
msgstr ""
"Dibujar formas o lógica que los nodos existentes no pueden hacer, como una "
"imagen con estelas o un polígono animado especial."

msgid ""
"Visualizations that are not that compatible with nodes, such as a tetris "
"board. (The tetris example uses a custom draw function to draw the blocks.)"
msgstr ""
"Visualizaciones que no son tan compatibles con los nodos, como un tablero de "
"tetris. (El ejemplo del tetris utiliza una función de dibujo personalizada "
"para dibujar los bloques)"

msgid ""
"Drawing a large number of simple objects. Custom drawing avoids the overhead "
"of using a large number of nodes, possibly lowering memory usage and "
"improving performance."
msgstr ""
"Dibujar un gran número de objetos simples. El dibujo personalizado evita la "
"sobrecarga del uso de nodos lo que lo hace menos intensivo en el uso de "
"memoria y potencialmente más rápido."

msgid ""
"Making a custom UI control. There are plenty of controls available, but when "
"you have unusual needs, you will likely need a custom control."
msgstr ""
"Hacer un control de UI personalizado. Hay muchos nodos Control disponibles, "
"Sin embargo, cuando tienes necesidades poco comunes, es probable que "
"necesites un control personalizado."

msgid "Drawing"
msgstr "Dibujando"

msgid ""
"Add a script to any :ref:`CanvasItem <class_CanvasItem>` derived node, like :"
"ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`. Then override "
"the ``_draw()`` function."
msgstr ""
"Agrega un script a cualquier nodo derivado de :ref:`CanvasItem "
"<class_CanvasItem>`, como :ref:`Control <class_Control>` o :ref:`Node2D "
"<class_Node2D>`. Luego sobreescribe la función ``_draw()``."

msgid ""
"Draw commands are described in the :ref:`CanvasItem <class_CanvasItem>` "
"class reference. There are plenty of them."
msgstr ""
"Los comandos están descriptos en la referencia de la clase :ref:`CanvasItem "
"<class_CanvasItem>`."

msgid "Updating"
msgstr "Actualizando"

msgid ""
"The ``_draw()`` function is only called once, and then the draw commands are "
"cached and remembered, so further calls are unnecessary."
msgstr ""
"La función ``_draw()`` es llamada una vez y los comandos son guardados y "
"recordados, así que no es necesario llamarla continuamente."

msgid ""
"If re-drawing is required because a state or something else changed, call :"
"ref:`CanvasItem.update() <class_CanvasItem_method_update>` in that same node "
"and a new ``_draw()`` call will happen."
msgstr ""
"Si es necesario redibujar porque algo ha cambiado, simplemente llama :ref:"
"`CanvasItem.update() <class_CanvasItem_method_update>` en el nodo y se "
"ejecutará una nueva llamada a ``_draw()``."

msgid ""
"Here is a little more complex example, a texture variable that will be "
"redrawn if modified:"
msgstr ""
"Aquí hay un ejemplo más complejo. Una textura variable que se dibujará "
"nuevamente si es modificada:"

msgid ""
"In some cases, it may be desired to draw every frame. For this, just call "
"``update()`` from the ``_process()`` callback, like this:"
msgstr ""
"En algunos casos, puede ser necesario dibujar en cada frame. Para esto, sólo "
"llama ``update()`` dentro de ``_process()``, así:"

msgid "An example: drawing circular arcs"
msgstr "Un ejemplo: dibujando arcos de curva"

msgid ""
"We will now use the custom drawing functionality of the Godot Engine to draw "
"something that Godot doesn't provide functions for. As an example, Godot "
"provides a ``draw_circle()`` function that draws a whole circle. However, "
"what about drawing a portion of a circle? You will have to code a function "
"to perform this and draw it yourself."
msgstr ""
"Ahora usaremos la funcionalidad de dibujo personalizado de Godot Engine para "
"dibujar algo para lo que Godot no ofrece ninguna función. Por ejemplo, Godot "
"proporciona una función ``draw_circle()`` que dibuja un círculo entero. Sin "
"embargo, ¿qué tal dibujar una porción de un círculo? Tendrás que crear tu "
"mismo una función para realizarlo y dibujarlo."

msgid "Arc function"
msgstr "Función arco"

msgid ""
"An arc is defined by its support circle parameters, that is, the center "
"position and the radius. The arc itself is then defined by the angle it "
"starts from and the angle at which it stops. These are the 4 arguments that "
"we have to provide to our drawing function. We'll also provide the color "
"value, so we can draw the arc in different colors if we wish."
msgstr ""
"Un arco está definido por los parámetros de un círculo de soporte, es decir, "
"posición central y radio. El arco en sí es definido por el ángulo en el que "
"comienza y el ángulo en el que termina. Esos son los 4 parámetros que "
"pasamos a nuestra función de dibujo. Podemos también agregar un valor de "
"color para dibujar el arco en diferentes colores si o deseamos."

msgid ""
"Basically, drawing a shape on the screen requires it to be decomposed into a "
"certain number of points linked from one to the next. As you can imagine, "
"the more points your shape is made of, the smoother it will appear, but the "
"heavier it will also be in terms of processing cost. In general, if your "
"shape is huge (or in 3D, close to the camera), it will require more points "
"to be drawn without it being angular-looking. On the contrary, if your shape "
"is small (or in 3D, far from the camera), you may decrease its number of "
"points to save processing costs; this is known as *Level of Detail (LOD)*. "
"In our example, we will simply use a fixed number of points, no matter the "
"radius."
msgstr ""
"Básicamente, dibujar una figura requiere descomponerla en un cierto número "
"de puntos, vinculados uno al otro. Como puedes imaginar, mientras más puntos "
"posea la figura, más suave que se verá, pero será más \"pesada\" en términos "
"de costo de procesamiento. En general, si la forma de un figura es muy "
"grande (o en 3D, cercana a la cámara), requerirá más puntos para ser "
"dibujada sin verse muy angulosa. Al contrario, si una figura es muy "
"pequeña(o en 3D, lejos de la cámara), se pueden reducir los puntos para "
"ahorrar costo de procesamiento. Esto es conocido *Nivel de Detalle* (LoD, "
"por sus siglas en inglés). En nuestro ejemplo usaremos un número fijo de "
"puntos, sin importar el radio."

msgid ""
"Remember the number of points our shape has to be decomposed into? We fixed "
"this number in the ``nb_points`` variable to a value of ``32``. Then, we "
"initialize an empty ``PoolVector2Array``, which is simply an array of "
"``Vector2``\\ s."
msgstr ""
"¿Recuerdas el número de puntos en el cual fue descompuesta nuestra figura? "
"Fijamos este número en la variable ``nb_points`` a un valor de ``32``. Luego "
"inicializamos un ``PoolVector2Array`` vacío, que es un array de ``Vector2``."

msgid ""
"The next step consists of computing the actual positions of these 32 points "
"that compose an arc. This is done in the first for-loop: we iterate over the "
"number of points for which we want to compute the positions, plus one to "
"include the last point. We first determine the angle of each point, between "
"the starting and ending angles."
msgstr ""
"El siguiente paso consiste en calcular las posiciones reales de estos 32 "
"puntos que componen un arco. Esto se hace en el primer bucle for: iteramos "
"sobre el número de puntos para los que queremos calcular las posiciones, más "
"uno para incluir el último punto. Primero determinamos el ángulo de cada "
"punto, entre el ángulo inicial y el ángulo final."

msgid ""
"The reason why each angle is decreased by 90° is that we will compute 2D "
"positions out of each angle using trigonometry (you know, cosine and sine "
"stuff...). However, to be simple, ``cos()`` and ``sin()`` use radians, not "
"degrees. The angle of 0° (0 radian) starts at 3 o'clock, although we want to "
"start counting at 12 o'clock. So we decrease each angle by 90° in order to "
"start counting from 12 o'clock."
msgstr ""
"La razón por la que cada ángulo se reduce en 90° es que calcularemos las "
"posiciones 2D de cada ángulo usando trigonometría (ya sabes, cosas de coseno "
"y seno...). Sin embargo, para simplificarlo, ``cos()`` y ``sin()`` usan "
"radianes, no grados. El ángulo de 0° (0 radianes) comienza a las 3 en punto, "
"aunque queremos empezar a contar a las 12 en punto. Así que reducimos cada "
"ángulo en 90° para empezar a contar desde las 12 en punto."

msgid ""
"The actual position of a point located on a circle at angle ``angle`` (in "
"radians) is given by ``Vector2(cos(angle), sin(angle))``. Since ``cos()`` "
"and ``sin()`` return values between -1 and 1, the position is located on a "
"circle of radius 1. To have this position on our support circle, which has a "
"radius of ``radius``, we simply need to multiply the position by ``radius``. "
"Finally, we need to position our support circle at the ``center`` position, "
"which is performed by adding it to our ``Vector2`` value. Finally, we insert "
"the point in the ``PoolVector2Array`` which was previously defined."
msgstr ""
"La posición actual de un punto ubicado en un angulo ``angle`` (en radianes) "
"es dada por ``Vector2(cos(angle), sin(angle))``. Como ``cos()`` y ``sin()`` "
"retornan valores entre -1 y 1, la posición es ubicada en un círculo de radio "
"1. Para tener esta posición en nuestro círculo de soporte, que tiene un "
"radio de ``radius``, simplemente tenemos que multiplicar la posición por "
"``radius``. Finalmente, tenemos la posición del círculo de soporte del arco "
"en la posición ``center``, lo que se consigue agregando esto a nuestro valor "
"``Vector2``. Finalmente insertamos el punto en e ``PoolVector2Array`` que "
"fue definido previamente."

msgid ""
"Now, we need to actually draw our points. As you can imagine, we will not "
"simply draw our 32 points: we need to draw everything that is between each "
"of them. We could have computed every point ourselves using the previous "
"method, and drew it one by one. But this is too complicated and inefficient "
"(except if explicitly needed), so we simply draw lines between each pair of "
"points. Unless the radius of our support circle is big, the length of each "
"line between a pair of points will never be long enough to see them. If that "
"were to happen, we would simply need to increase the number of points."
msgstr ""
"Ahora necesitamos dibujar los puntos. Como puedes imaginar, no dibujaremos "
"nuestros 32 puntos solamente, tendremos que dibujar todo lo que está entre "
"ellos. Podríamos haber calculado los puntos nosotros mismos utilizando el "
"método previo y dibujarlos uno a uno, pero esto es muy complicado e "
"ineficiente (a menos que sea necesario). Así que simplemente dibujaremos "
"líneas entre cada par de puntos. A menos que el radio de nuestro círculo de "
"soporte sea muy grande, el largo de la línea entre cada par de puntos nunca "
"será lo suficientemente larga para verlos. Si esto sucede, simplemente "
"aumentamos el número de puntos."

msgid "Draw the arc on the screen"
msgstr "Dibujar el arco en pantalla"

msgid ""
"We now have a function that draws stuff on the screen; it is time to call it "
"inside the ``_draw()`` function:"
msgstr ""
"Ahora tenemos una función que dibuja cosas en la pantalla: Es momento de "
"llamar a la función ``_draw()``:"

msgid "Result:"
msgstr "Resultado:"

msgid "Arc polygon function"
msgstr "Función de polígono arco"

msgid ""
"We can take this a step further and not only write a function that draws the "
"plain portion of the disc defined by the arc, but also its shape. The method "
"is exactly the same as before, except that we draw a polygon instead of "
"lines:"
msgstr ""
"Podemos llevar esto un paso más allá y no sólo escribir una función que "
"dibuje la parte plana del disco definida por el arco, sino también su forma. "
"El método es exactamente el mismo que el anterior, excepto que dibujamos un "
"polígono en lugar de líneas:"

msgid "Dynamic custom drawing"
msgstr "Dibujos personalizados dinámicos"

msgid ""
"All right, we are now able to draw custom stuff on the screen. However, it "
"is static; let's make this shape turn around the center. The solution to do "
"this is simply to change the angle_from and angle_to values over time. For "
"our example, we will simply increment them by 50. This increment value has "
"to remain constant or else the rotation speed will change accordingly."
msgstr ""
"Muy bien, ahora podemos hacer dibujos personalizados en la pantalla. Sin "
"embargo, es estático: Hagamos que esta forma gire alrededor del centro. La "
"solución para hacer esto es simplemente cambiar los valores angle_from y "
"angle_to a lo largo del tiempo. Para nuestro ejemplo, simplemente los "
"incrementaremos en 50. Este valor de incremento tiene que permanecer "
"constante o bien la velocidad de rotación cambiará en consecuencia."

msgid ""
"First, we have to make both angle_from and angle_to variables global at the "
"top of our script. Also note that you can store them in other nodes and "
"access them using ``get_node()``."
msgstr ""
"Primero, tenemos que hacer que ambos, angle_from y angle_to sean variables "
"del ámbito de la instancia (al alcance de cualquier función) al principio "
"del script. También se pueden colocar en otros nodos y accederlas mediante "
"``get_node(\"nombre_nodo\").nombre_variable``."

msgid "We make these values change in the _process(delta) function."
msgstr "Haremos que esos valores cambien en la función _process(delta)."

msgid ""
"We also increment our angle_from and angle_to values here. However, we must "
"not forget to ``wrap()`` the resulting values between 0 and 360°! That is, "
"if the angle is 361°, then it is actually 1°. If you don't wrap these "
"values, the script will work correctly, but the angle values will grow "
"bigger and bigger over time until they reach the maximum integer value Godot "
"can manage (``2^31 - 1``). When this happens, Godot may crash or produce "
"unexpected behavior."
msgstr ""
"También aquí incrementamos nuestros valores angle_from y angle_to. Sin "
"embargo, no debemos olvidarnos de usar una función ``wrap()`` para ajustar "
"los valores resultantes entre 0 y 360°, es decir, si el ángulo es 361°, "
"entonces en realidad es 1°. Si no ajustas estos valores, el script "
"funcionará correctamente, pero los valores de los ángulos crecerán más y más "
"con el tiempo hasta que alcancen el máximo valor entero que Godot puede "
"manejar (``2^31 - 1``). Cuando esto suceda, Godot puede fallar o producir un "
"comportamiento inesperado."

msgid ""
"Finally, we must not forget to call the ``update()`` function, which "
"automatically calls ``_draw()``. This way, you can control when you want to "
"refresh the frame."
msgstr ""
"Finalmente, no debemos olvidar llamar la función ``update()``, la que "
"provoca una llamada a ``_draw()``. De este modo, podrás controlar cuando "
"quieres que se actualice."

msgid ""
"Also, don't forget to modify the ``_draw()`` function to make use of these "
"variables:"
msgstr ""
"Y no olvides modificar la función ``_draw()`` para que haga uso de estas "
"variables:"

msgid ""
"Let's run! It works, but the arc is rotating insanely fast! What's wrong?"
msgstr ""
"Ejecutémoslo y veamos como funciona. Podemos notar que el arco rota "
"demasiado rápido, qué está mal?"

msgid ""
"The reason is that your GPU is actually displaying the frames as fast as it "
"can. We need to \"normalize\" the drawing by this speed; to achieve that, we "
"have to make use of the ``delta`` parameter of the ``_process()`` function. "
"``delta`` contains the time elapsed between the two last rendered frames. It "
"is generally small (about 0.0003 seconds, but this depends on your "
"hardware), so using ``delta`` to control your drawing ensures that your "
"program runs at the same speed on everybody's hardware."
msgstr ""
"La razón es que tu GPU está mostrando frames tan rápido como puede, "
"necesitamos \"estabilizar\" la velocidad de dibujado acorde a esta. Para "
"conseguirlo, nos aseguraremos de utilizar el parámetro ``delta`` de la "
"función ``_process()``. ``delta`` contiene un número que representa el "
"tiempo transcurrido entre dos frames. Generalmente es un valor muy bajo "
"(alrededor de 0.0003 segundos, pero depende del hardware). Así que "
"utilizando ``delta`` se puede asegurar que el programa se ejecutará a la "
"misma velocidad en todo tipo de hardware."

msgid ""
"In our case, we simply need to multiply our ``rotation_angle`` variable by "
"``delta`` in the ``_process()`` function. This way, our 2 angles will be "
"increased by a much smaller value, which directly depends on the rendering "
"speed."
msgstr ""
"En nuestro caso, simplemente multiplicaremos nuestra variable "
"``rotation_angle`` por ``delta`` en la función ``_process()``. De este modo, "
"nuestros 2 ángulos se incrementarán por un valor muy bajo, dependiendo "
"directamente de nuestra velocidad de procesamiento."

msgid "Let's run again! This time, the rotation displays fine!"
msgstr "¡Ejecutémoslo de nuevo! ¡Esta vez, la rotación se muestra bien!"

msgid "Antialiased drawing"
msgstr "Dibujo antialiasing"

msgid ""
"Godot offers method parameters in :ref:"
"`draw_line<class_CanvasItem_method_draw_line>` to enable antialiasing, but "
"it doesn't work reliably in all situations (for instance, on mobile/web "
"platforms, or when HDR is enabled). There is also no ``antialiased`` "
"parameter available in :ref:"
"`draw_polygon<class_CanvasItem_method_draw_polygon>`."
msgstr ""
"Godot ofrece parámetros de método en :ref:`draw_line "
"<class_CanvasItem_method_draw_line>` para habilitar el antialiasing, pero no "
"funciona de manera confiable en todas las situaciones (por ejemplo, en "
"plataformas móviles/web o cuando el HDR está habilitado). Además, no hay un "
"parámetro \"antialiased\" disponible en :ref:`draw_polygon "
"<class_CanvasItem_method_draw_polygon>`."

msgid ""
"As a workaround, install and use the `Antialiased Line2D add-on <https://"
"github.com/godot-extended-libraries/godot-antialiased-line2d>`__ (which also "
"supports antialiased Polygon2D drawing). Note that this add-on relies on "
"high-level nodes, rather than low-level ``_draw()`` functions."
msgstr ""
"Como solución alternativa, puedes instalar y utilizar el complemento "
"\"Antialiased Line2D\" <https://github.com/godot-extended-libraries/godot-"
"antialiased-line2d>, el cual también admite el dibujo antialiasing de "
"Polygon2D. Ten en cuenta que este complemento se basa en nodos de alto nivel "
"en lugar de las funciones \"_draw()\" de bajo nivel."

msgid "Tools"
msgstr "Herramientas"

msgid ""
"Drawing your own nodes might also be desired while running them in the "
"editor. This can be used as a preview or visualization of some feature or "
"behavior. See :ref:`doc_running_code_in_the_editor` for more information."
msgstr ""
"Dibujar tus propios nodos también puede ser conveniente mientras los "
"ejecutas en el editor para usarlos como vista previa o visualización de "
"alguna característica o comportamiento. Consulta :ref:"
"`doc_running_code_in_the_editor` para obtener más información."

msgid "Translation status"
msgstr "Estado de traducción"
