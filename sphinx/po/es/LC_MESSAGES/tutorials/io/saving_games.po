# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Saving games"
msgstr "Guardar partidas"

msgid "Introduction"
msgstr "Introducción"

msgid ""
"Save games can be complicated. For example, it may be desirable to store "
"information from multiple objects across multiple levels. Advanced save game "
"systems should allow for additional information about an arbitrary number of "
"objects. This will allow the save function to scale as the game grows more "
"complex."
msgstr ""
"Guardar partidas puede ser complicado. Por ejemplo, puede ser necesario "
"almacenar información de varios objetos en varios niveles. Los sistemas "
"avanzados de guardado de partidas deberían permitir la obtención de "
"información adicional sobre un número arbitrario de objetos. Esto permitirá "
"que la función de guardado se amplíe a medida que el juego se vuelva más "
"complejo."

msgid ""
"If you're looking to save user configuration, you can use the :ref:"
"`class_ConfigFile` class for this purpose."
msgstr ""
"Si quieres guardar la configuración del usuario, puedes usar la clase :ref:"
"`class_ConfigFile` para este propósito."

msgid "Identify persistent objects"
msgstr "Identificar objetos persistentes"

msgid ""
"Firstly, we should identify what objects we want to keep between game "
"sessions and what information we want to keep from those objects. For this "
"tutorial, we will use groups to mark and handle objects to be saved, but "
"other methods are certainly possible."
msgstr ""
"En primer lugar, debemos identificar qué objetos queremos conservar entre "
"las sesiones de juego y qué información queremos conservar de esos objetos. "
"Para este tutorial, usaremos grupos para marcar y manejar los objetos a "
"guardar, pero desde luego existen otros métodos posibles."

msgid ""
"We will start by adding objects we wish to save to the \"Persist\" group. We "
"can do this through either the GUI or script. Let's add the relevant nodes "
"using the GUI:"
msgstr ""
"Comenzaremos agregando objetos que deseamos guardar al grupo \"Persist\". "
"Podemos hacer esto tanto a través de la GUI como mediante scripts. Añadamos "
"los nodos relevantes utilizando la GUI:"

msgid ""
"Once this is done, when we need to save the game, we can get all objects to "
"save them and then tell them all to save with this script:"
msgstr ""
"Una vez hecho esto, cuando necesitemos guardar la partida, podemos hacer que "
"todos los objetos se salven y luego decirles a todos que se guarden con este "
"script:"

msgid "Serializing"
msgstr "Serialización"

msgid ""
"The next step is to serialize the data. This makes it much easier to read "
"from and store to disk. In this case, we're assuming each member of group "
"Persist is an instanced node and thus has a path. GDScript has helper "
"functions for this, such as :ref:`to_json() "
"<class_@GDScript_method_to_json>` and :ref:`parse_json() "
"<class_@GDScript_method_parse_json>`, so we will use a dictionary. Our node "
"needs to contain a save function that returns this data. The save function "
"will look like this:"
msgstr ""
"El siguiente paso es serializar los datos. Esto hace que sea mucho más fácil "
"de leer y almacenar en el disco. En este caso, asumiremos que cada miembro "
"del grupo Persist es un nodo instanciado y por lo tanto tiene una ruta. "
"GDScript tiene funciones de ayuda para esto, como :ref:`to_json() "
"<class_@GDScript_method_to_json>` y :ref:`parse_json() "
"<class_@GDScript_method_parse_json>`, así que usaremos un diccionario. "
"Nuestro nodo necesita contener una función de guardado que devuelva estos "
"datos. La función de guardar tendrá este aspecto:"

msgid ""
"This gives us a dictionary with the style ``{ \"variable_name\":"
"value_of_variable }``, which will be useful when loading."
msgstr ""
"Esto nos da un diccionario con el estilo ``{ \"variable_name\":"
"value_of_variable }``, que nos será útil al cargar."

msgid "Saving and reading data"
msgstr "Guardar y leer datos"

msgid ""
"As covered in the :ref:`doc_filesystem` tutorial, we'll need to open a file "
"so we can write to it or read from it. Now that we have a way to call our "
"groups and get their relevant data, let's use :ref:`to_json() "
"<class_@GDScript_method_to_json>` to convert it into an easily stored string "
"and store them in a file. Doing it this way ensures that each line is its "
"own object, so we have an easy way to pull the data out of the file as well."
msgstr ""
"Como se explica en el tutorial de :ref:`doc_filesystem`, necesitaremos abrir "
"un archivo para poder escribir en él o leer de él. Ahora que tenemos una "
"forma de llamar a nuestros grupos y obtener sus datos relevantes, usemos :"
"ref:`to_json() <class_@GDScript_method_to_json>` para convertirlo en una "
"cadena que se pueda guardar fácilmente y almacenarla en un archivo. "
"Haciéndolo de esta manera nos aseguramos de que cada línea sea su propio "
"objeto, así que también tenemos una manera fácil de recuperar los datos del "
"archivo."

msgid ""
"Game saved! Loading is fairly simple as well. For that, we'll read each "
"line, use parse_json() to read it back to a dict, and then iterate over the "
"dict to read our values. But we'll need to first create the object and we "
"can use the filename and parent values to achieve that. Here is our load "
"function:"
msgstr ""
"¡Juego guardado! La carga es bastante simple también. Para ello, leeremos "
"cada línea; usaremos parse_json() para volver a leerla hasta un diccionario, "
"y luego iteraremos sobre el diccionario para leer nuestros valores. Pero "
"primero tendremos que crear el objeto y podemos usar el nombre de archivo y "
"los valores del padre para lograrlo. Aquí está nuestra función de carga:"

msgid ""
"Now we can save and load an arbitrary number of objects laid out almost "
"anywhere across the scene tree! Each object can store different data "
"depending on what it needs to save."
msgstr ""
"Ahora podemos guardar y cargar un número arbitrario de objetos dispuestos "
"casi en cualquier lugar del árbol de la escena. Cada objeto puede almacenar "
"diferentes datos dependiendo de lo que necesite guardar."

msgid "Some notes"
msgstr "Algunas notas"

msgid ""
"We have glossed over setting up the game state for loading. It's ultimately "
"up to the project creator where much of this logic goes. This is often "
"complicated and will need to be heavily customized based on the needs of the "
"individual project."
msgstr ""
"Hemos pasado por alto la configuración del estado del juego para la carga. "
"En última instancia, depende del creador del proyecto donde va gran parte de "
"esta lógica. Esto suele ser complicado y tendrá que ser muy personalizado en "
"función de las necesidades del proyecto en particular."

msgid ""
"Additionally, our implementation assumes no Persist objects are children of "
"other Persist objects. Otherwise, invalid paths would be created. To "
"accommodate nested Persist objects, consider saving objects in stages. Load "
"parent objects first so they are available for the :ref:`add_child() "
"<class_node_method_add_child>` call when child objects are loaded. You will "
"also need a way to link children to parents as the :ref:`NodePath "
"<class_nodepath>` will likely be invalid."
msgstr ""
"Además, nuestra implementación asume que ningún objeto persistente es hijo "
"de otro objeto persistente. De lo contrario, se crearían rutas inválidas. "
"Para acomodar los objetos persistentes anidados, considera guardar los "
"objetos en etapas. Cargar primero los objetos padre para que estén "
"disponibles para la llamada :ref:`add_child() <class_node_method_add_child>` "
"cuando se carguen los objetos hijo. También necesitarás una forma de enlazar "
"a los hijos con los padres ya que la llamada :ref:`NodePath "
"<class_nodepath>` probablemente será inválida."

msgid "Translation status"
msgstr "Estado de traducción"
