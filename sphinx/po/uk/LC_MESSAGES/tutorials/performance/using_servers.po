# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Optimization using Servers"
msgstr "Оптимізація за допомогою серверів"

msgid ""
"Engines like Godot provide increased ease of use thanks to their high level "
"constructs and features. Most of them are accessed and used via the :ref:"
"`Scene System<doc_scene_tree>`. Using nodes and resources simplifies project "
"organization and asset management in complex games."
msgstr ""
"Такі рушії, як Godot, забезпечують підвищену простоту використання завдяки "
"їх конструкціям і функціям високого рівня. Більшість із них доступні та "
"використовуються через :ref:`Систему Сцен<doc_scene_tree>`. Використання "
"вузлів і ресурсів спрощує організацію проекту та управління активами в "
"складних іграх."

msgid "There are, of course, always drawbacks:"
msgstr "Звичайно, завжди є недоліки:"

msgid "There is an extra layer of complexity"
msgstr "Є додатковий рівень складності"

msgid "Performance is lower than using simple APIs directly"
msgstr "Продуктивність нижча, ніж безпосереднє використання простих API"

msgid "It is not possible to use multiple threads to control them"
msgstr "Неможливо використовувати кілька потоків для керування ними"

msgid "More memory is needed."
msgstr "Потрібно більше пам'яті."

msgid ""
"In many cases, this is not really a problem (Godot is very optimized, and "
"most operations are handled with signals, so no polling is required). Still, "
"sometimes it can be. For example, dealing with tens of thousands of "
"instances for something that needs to be processed every frame can be a "
"bottleneck."
msgstr ""
"У багатьох випадках це насправді не проблема (Godot дуже оптимізований, і "
"більшість операцій обробляються за допомогою сигналів, тому опитування не "
"потрібне). Проте не завжди. Наприклад, робота з десятками тисяч екземплярів "
"чогось, що потрібно обробити кожен кадр, може бути вузьким місцем."

msgid ""
"This type of situation makes programmers regret they are using a game engine "
"and wish they could go back to a more handcrafted, low level implementation "
"of game code."
msgstr ""
"Така ситуація змушує програмістів шкодувати , що вони використовують ігровий "
"рушій, і бажати повернутися до більш ручної, низькорівневої реалізації "
"ігрового коду."

msgid "Still, Godot is designed to work around this problem."
msgstr "Тим не менш, Godot спроектований так, щоб вирішити цю проблему."

msgid "Servers"
msgstr "Сервери"

msgid ""
"One of the most interesting design decisions for Godot is the fact that the "
"whole scene system is *optional*. While it is not currently possible to "
"compile it out, it can be completely bypassed."
msgstr ""
"Одним з найцікавіших архітектурних рішень Godot є той факт, що вся система "
"сцен є *необов'язковою*. Хоча наразі неможливо скомпілювати його, зате можна "
"повністю обійти."

msgid ""
"At the core, Godot uses the concept of Servers. They are very low-level APIs "
"to control rendering, physics, sound, etc. The scene system is built on top "
"of them and uses them directly. The most common servers are:"
msgstr ""
"По суті, Godot використовує концепцію Серверів. Це API дуже низького рівня "
"для керування рендерингом, фізикою, звуком тощо. Система сцен побудована на "
"їх основі і використовує їх безпосередньо. Найпоширенішими серверами є:"

msgid ""
":ref:`VisualServer <class_VisualServer>`: handles everything related to "
"graphics."
msgstr ""
":ref:`VisualServer <class_VisualServer>`: обробляє все, що стосується "
"графіки."

msgid ""
":ref:`PhysicsServer <class_PhysicsServer>`: handles everything related to 3D "
"physics."
msgstr ""
":ref:`PhysicsServer <class_PhysicsServer>`: обробляє все, що стосується 3D "
"фізики."

msgid ""
":ref:`Physics2DServer <class_Physics2DServer>`: handles everything related "
"to 2D physics."
msgstr ""
":ref:`Physics2DServer <class_Physics2DServer>`: обробляє все, що стосується "
"фізики 2D."

msgid ""
":ref:`AudioServer <class_AudioServer>`: handles everything related to audio."
msgstr ""
":ref:`AudioServer <class_AudioServer>`: обробляє все, що стосується аудіо."

msgid ""
"Explore their APIs and you will realize that all the functions provided are "
"low-level implementations of everything Godot allows you to do."
msgstr ""
"Дослідіть їхні API, і ви зрозумієте, що всі надані функції є низькорівневими "
"реалізаціями всього, що дозволяє Godot."

msgid "RIDs"
msgstr "RID-и"

msgid ""
"The key to using servers is understanding Resource ID (:ref:`RID "
"<class_RID>`) objects. These are opaque handles to the server "
"implementation. They are allocated and freed manually. Almost every function "
"in the servers requires RIDs to access the actual resource."
msgstr ""
"Ключем до використання серверів є розуміння ідентифікатора ресурсу (:ref:"
"`RID <class_RID>`) об'єктів. Це непрозорі дескриптори реалізації сервера. "
"Вони виділяються та звільняються вручну. Майже кожна функція на серверах "
"вимагає RID для доступу до фактичного ресурсу."

msgid ""
"Most Godot nodes and resources contain these RIDs from the servers "
"internally, and they can be obtained with different functions. In fact, "
"anything that inherits :ref:`Resource <class_Resource>` can be directly "
"casted to an RID. Not all resources contain an RID, though: in such cases, "
"the RID will be empty. The resource can then be passed to server APIs as an "
"RID."
msgstr ""
"Більшість вузлів і ресурсів Godot містять ці RID-и із внутрішніх серверів, і "
"їх можна отримати за допомогою різних функцій. Насправді все, що успадковує :"
"ref:`Ресурс <class_Resource>`, може бути безпосередньо передано до RID. "
"Однак не всі ресурси містять RID: у таких випадках RID буде порожнім. Тоді "
"ресурс можна передати API сервера, як RID."

msgid ""
"Resources are reference-counted (see :ref:`Reference <class_Reference>`), "
"and references to a resource's RID are *not* counted when determining "
"whether the resource is still in use. Make sure to keep a reference to the "
"resource outside the server, or else both it and its RID will be erased."
msgstr ""
"Ресурси підраховуються за посиланнями (див. :ref:`Reference "
"<class_Reference>`), а посилання на RID ресурсу *не* враховуються, коли "
"визначається, чи ресурс все ще використовується. Не забудьте зберегти "
"посилання на ресурс за межами сервера, інакше він і його RID будуть стерті."

msgid "For nodes, there are many functions available:"
msgstr "Для вузлів доступно багато функцій:"

msgid ""
"For CanvasItem, the :ref:`CanvasItem.get_canvas_item() "
"<class_CanvasItem_method_get_canvas_item>` method will return the canvas "
"item RID in the server."
msgstr ""
"Для CanvasItem метод :ref:`CanvasItem.get_canvas_item() "
"<class_CanvasItem_method_get_canvas_item>` поверне RID елемента полотна на "
"сервері."

msgid ""
"For CanvasLayer, the :ref:`CanvasLayer.get_canvas() "
"<class_CanvasLayer_method_get_canvas>` method will return the canvas RID in "
"the server."
msgstr ""
"Для CanvasLayer метод :ref:`CanvasLayer.get_canvas() "
"<class_CanvasLayer_method_get_canvas>` поверне RID полотна на сервері."

msgid ""
"For Viewport, the :ref:`Viewport.get_viewport_rid() "
"<class_Viewport_method_get_viewport_rid>` method will return the viewport "
"RID in the server."
msgstr ""
"Для Viewport метод :ref:`Viewport.get_viewport_rid() "
"<class_Viewport_method_get_viewport_rid>` поверне RID області перегляду на "
"сервері."

msgid ""
"For 3D, the :ref:`World <class_World>` resource (obtainable in the :ref:"
"`Viewport <class_Viewport>` and :ref:`Spatial <class_Spatial>` nodes) "
"contains functions to get the *VisualServer Scenario*, and the "
"*PhysicsServer Space*. This allows creating 3D objects directly with the "
"server API and using them."
msgstr ""
"Для 3D, ресурс :ref:`World <class_World>` (доступний у вузлах :ref:`Viewport "
"<class_Viewport>` і :ref:`Spatial <class_Spatial>`) містить функції для "
"отримання *VisualServer Scenario* та *PhysicsServer Space*. Це дозволяє "
"створювати 3D-об’єкти безпосередньо за допомогою API сервера та "
"використовувати їх."

msgid ""
"For 2D, the :ref:`World2D <class_World2D>` resource (obtainable in the :ref:"
"`Viewport <class_Viewport>` and :ref:`CanvasItem <class_CanvasItem>` nodes) "
"contains functions to get the *VisualServer Canvas*, and the "
"*Physics2DServer Space*. This allows creating 2D objects directly with the "
"server API and using them."
msgstr ""
"Для 2D ресурс :ref:`World2D <class_World2D>` (доступний у вузлах :ref:"
"`Viewport <class_Viewport>` і :ref:`CanvasItem <class_CanvasItem>`) містить "
"функції для отримання *VisualServer Canvas* і *Physics2DServer Space*. Це "
"дозволяє створювати 2D-об’єкти безпосередньо за допомогою API сервера та "
"використовувати їх."

msgid ""
"The :ref:`VisualInstance<class_VisualInstance>` class, allows getting the "
"scenario *instance* and *instance base* via the :ref:`VisualInstance."
"get_instance() <class_VisualInstance_method_get_instance>` and :ref:"
"`VisualInstance.get_base() <class_VisualInstance_method_get_base>` "
"respectively."
msgstr ""
"Клас :ref:`VisualInstance<class_VisualInstance>` дозволяє отримати "
"*екземпляр сценарію* та *базу екземплярів* через :ref:`VisualInstance."
"get_instance() <class_VisualInstance_method_get_instance>` та :ref:"
"`VisualInstance.get_base() <class_VisualInstance_method_get_base>` "
"відповідно."

msgid ""
"Try exploring the nodes and resources you are familiar with and find the "
"functions to obtain the server *RIDs*."
msgstr ""
"Спробуйте вивчити вузли та ресурси, з якими ви знайомі, і знайдіть функції "
"для отримання *RID* сервера ."

msgid ""
"It is not advised to control RIDs from objects that already have a node "
"associated. Instead, server functions should always be used for creating and "
"controlling new ones and interacting with the existing ones."
msgstr ""
"Не рекомендується керувати RID від об’єктів, які вже мають пов’язаний вузол. "
"Натомість функції сервера завжди повинні використовуватися для створення та "
"керування новими та взаємодії з наявними."

msgid "Creating a sprite"
msgstr "Створення спрайта"

msgid ""
"This is a simple example of how to create a sprite from code and move it "
"using the low-level :ref:`CanvasItem <class_CanvasItem>` API."
msgstr ""
"Це простий приклад того, як створити спрайт із коду та перемістити його за "
"допомогою низькорівневого API :ref:`CanvasItem <class_CanvasItem>`."

msgid ""
"The Canvas Item API in the server allows you to add draw primitives to it. "
"Once added, they can't be modified. The Item needs to be cleared and the "
"primitives re-added (this is not the case for setting the transform, which "
"can be done as many times as desired)."
msgstr ""
"API Canvas Item *(Елемента Полотна)* на сервері дозволяє додавати до нього "
"намальовані примітиви. Після додавання їх не можна змінити. Елемент потрібно "
"очистити, а примітиви знову додати (це не стосується налаштування "
"перетворення, яке можна виконувати скільки завгодно разів)."

msgid "Primitives are cleared this way:"
msgstr "Примітиви очищаються таким чином:"

msgid "Instantiating a Mesh into 3D space"
msgstr "Створення екземпляра Mesh у 3D просторі"

msgid ""
"The 3D APIs are different from the 2D ones, so the instantiation API must be "
"used."
msgstr ""
"3D API відрізняються від 2D, тому необхідно використовувати API для "
"створення екземплярів."

msgid "Creating a 2D RigidBody and moving a sprite with it"
msgstr "Створення 2D RigidBody і переміщення спрайта за допомогою нього"

msgid ""
"This creates a :ref:`RigidBody2D <class_RigidBody2D>` using the :ref:"
"`Physics2DServer <class_Physics2DServer>` API, and moves a :ref:`CanvasItem "
"<class_CanvasItem>` when the body moves."
msgstr ""
"Тут створений :ref:`RigidBody2D <class_RigidBody2D>` за допомогою API :ref:"
"`Physics2DServer <class_Physics2DServer>`, і його рух призводить до руху :"
"ref:`CanvasItem <class_CanvasItem>`."

msgid ""
"The 3D version should be very similar, as 2D and 3D physics servers are "
"identical (using :ref:`RigidBody <class_RigidBody>` and :ref:`PhysicsServer "
"<class_PhysicsServer>` respectively)."
msgstr ""
"3D версія подібна на 2D, а 3D фізика серверів ідентична (використовує :ref:"
"`RigidBody <class_RigidBody>` та :ref:`PhysicsServer <class_PhysicsServer>` "
"відповідно)."

msgid "Getting data from the servers"
msgstr "Отримання даних із серверів"

msgid ""
"Try to **never** request any information from ``VisualServer``, "
"``PhysicsServer`` or ``Physics2DServer`` by calling functions unless you "
"know what you are doing. These servers will often run asynchronously for "
"performance and calling any function that returns a value will stall them "
"and force them to process anything pending until the function is actually "
"called. This will severely decrease performance if you call them every frame "
"(and it won't be obvious why)."
msgstr ""
"Намагайтеся **ніколи не** запитувати ніякої інформації від ``VisualServer``, "
"``PhysicsServer``, чи ``Physics2DServer`` через виклик функцій, якщо ви не "
"знаєте, що робите. Ці сервери часто для продуктивності працюють асинхронно, "
"і виклик будь-якої функції, яка повертає значення, зупинить їх і змусить "
"обробляти все, на що очікує функція, доки вона буде актуальна. Це значно "
"знизить продуктивність, якщо ви будете викликати такі функції кожен кадр (і "
"не буде очевидно, чому)."

msgid ""
"Because of this, most APIs in such servers are designed so it's not even "
"possible to request information back, until it's actual data that can be "
"saved."
msgstr ""
"Через це більшість API на таких серверах розроблені таким чином, що навіть "
"неможливо надіслати запит на повернення інформації, поки це не будуть "
"фактичні дані, які можна зберегти."

msgid "Translation status"
msgstr "Стан перекладу"
