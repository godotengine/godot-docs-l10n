# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "CPU optimization"
msgstr "Оптимізація Центрального Процесора"

msgid "Measuring performance"
msgstr "Вимірювання продуктивності"

msgid ""
"We have to know where the \"bottlenecks\" are to know how to speed up our "
"program. Bottlenecks are the slowest parts of the program that limit the "
"rate that everything can progress. Focussing on bottlenecks allows us to "
"concentrate our efforts on optimizing the areas which will give us the "
"greatest speed improvement, instead of spending a lot of time optimizing "
"functions that will lead to small performance improvements."
msgstr ""
"Ми повинні знати, де є \"вузькі місця\", щоб знати, як прискорити нашу "
"програму. Вузькі місця – це найповільніші частини програми, які обмежують "
"швидкість роботи програми. Зосередження уваги на вузьких місцях дозволяє нам "
"зосередити свої зусилля на оптимізації областей, що дасть нам найбільше "
"підвищення швидкості, замість того, щоб витрачати багато часу на оптимізацію "
"функцій, що призведе до невеликого підвищення продуктивності."

msgid ""
"For the CPU, the easiest way to identify bottlenecks is to use a profiler."
msgstr ""
"Для ЦП найпростіший спосіб виявити вузькі місця – це використовувати "
"профайлер."

msgid "CPU profilers"
msgstr "Профайлери ЦП"

msgid ""
"Profilers run alongside your program and take timing measurements to work "
"out what proportion of time is spent in each function."
msgstr ""
"Профайлери працюють разом із вашою програмою та проводять вимірювання часу, "
"щоб визначити, яку частку часу витрачається на кожну функцію."

msgid ""
"The Godot IDE conveniently has a built-in profiler. It does not run every "
"time you start your project: it must be manually started and stopped. This "
"is because, like most profilers, recording these timing measurements can "
"slow down your project significantly."
msgstr ""
"Godot IDE має вбудований профайлер. Він не запускається щоразу, коли ви "
"запускаєте проект: його потрібно запускати та зупиняти вручну. Це тому, що, "
"як і більшість профайлерів, запис цих вимірювань часу може значно "
"уповільнити ваш проект."

msgid "After profiling, you can look back at the results for a frame."
msgstr "Після роботи профайлера, ви можете переглянути результати за кадр."

msgid "Screenshot of the Godot profiler"
msgstr "Результати профайлера Godot"

msgid "Results of a profile of one of the demo projects."
msgstr "Результати профайлера для одного з демонстраційних проектів."

msgid ""
"We can see the cost of built-in processes such as physics and audio, as well "
"as seeing the cost of our own scripting functions at the bottom."
msgstr ""
"Ми можемо побачити вартість вбудованих процесів, таких як фізика та аудіо, а "
"також бачимо внизу вартість наших власних функцій зі скрипту."

msgid ""
"Time spent waiting for various built-in servers may not be counted in the "
"profilers. This is a known bug."
msgstr ""
"Час, витрачений на очікування різних вбудованих серверів, може не "
"враховуватися в профайлерах. Це відома помилка."

msgid ""
"When a project is running slowly, you will often see an obvious function or "
"process taking a lot more time than others. This is your primary bottleneck, "
"and you can usually increase speed by optimizing this area."
msgstr ""
"Коли проект працює повільно, ви часто зможете побачите очевидну функцію, або "
"процес, що займає набагато більше часу, ніж інші. Це ваше основне вузьке "
"місце, і ви зазвичай зможете збільшити швидкість, оптимізуючи цю область."

msgid ""
"For more info about using Godot's built-in profiler, see :ref:"
"`doc_debugger_panel`."
msgstr ""
"Щоб отримати додаткові відомості про використання вбудованого профайлера "
"Godot, див. :ref:`doc_debugger_panel`."

msgid "External profilers"
msgstr "Зовнішні профайлери"

msgid ""
"Although the Godot IDE profiler is very convenient and useful, sometimes you "
"need more power, and the ability to profile the Godot engine source code "
"itself."
msgstr ""
"Хоча профайлер Godot IDE дуже зручний і корисний, іноді вам потрібна більша "
"потужність і можливість профілювання самого вихідного коду рушія Godot."

msgid ""
"You can use a number of third party profilers to do this including `Valgrind "
"<https://www.valgrind.org/>`__, `VerySleepy <http://www.codersnotes.com/"
"sleepy/>`__, `HotSpot <https://github.com/KDAB/hotspot>`__, `Visual Studio "
"<https://visualstudio.microsoft.com/>`__ and `Intel VTune <https://software."
"intel.com/content/www/us/en/develop/tools/vtune-profiler.html>`__."
msgstr ""
"Для цього можна використовувати кілька сторонніх профайлерів, включаючи "
"`Valgrind <https://www.valgrind.org/>`__, `VerySleepy <http://www."
"codersnotes.com/sleepy/>`__, `HotSpot <https://github.com/KDAB/hotspot>`__, "
"`Visual Studio <https://visualstudio.microsoft.com/>`__ і `Intel VTune "
"<https://software.intel.com/content/www/us/en/develop/tools/vtune-profiler."
"html>`__."

msgid ""
"You will need to compile Godot from source to use a third-party profiler. "
"This is required to obtain debugging symbols. You can also use a debug "
"build, however, note that the results of profiling a debug build will be "
"different to a release build, because debug builds are less optimized. "
"Bottlenecks are often in a different place in debug builds, so you should "
"profile release builds whenever possible."
msgstr ""
"Вам потрібно буде зібрати Godot з джерела, щоб використовувати сторонній "
"профайлер. Це потрібно для отримання символів налагодження. Ви також можете "
"використовувати налагоджувальну збірку, однак зауважте, що результати "
"профілювання налагоджувальної збірки будуть відрізнятися від збірки випуску, "
"оскільки налагоджувальні збірки менш оптимізовані. Вузькі місця в "
"налагоджувальних збірках часто знаходяться в іншому місці, тому, коли це "
"можливо, слід профілювати випуски збірок."

msgid "Screenshot of Callgrind"
msgstr "Скріншот Callgrind"

msgid "Example results from Callgrind, which is part of Valgrind."
msgstr "Приклад результатів від Callgrind, який є частиною Valgrind."

msgid ""
"From the left, Callgrind is listing the percentage of time within a function "
"and its children (Inclusive), the percentage of time spent within the "
"function itself, excluding child functions (Self), the number of times the "
"function is called, the function name, and the file or module."
msgstr ""
"Зліва Callgrind перераховує відсоток часу у функції та її нащадків "
"(включно), відсоток часу, проведеного в самій функції, за винятком дочірніх "
"функцій (Self), кількість викликів функції, назву функції, а також файл, або "
"модуль."

msgid ""
"In this example, we can see nearly all time is spent under the `Main::"
"iteration()` function. This is the master function in the Godot source code "
"that is called repeatedly. It causes frames to be drawn, physics ticks to be "
"simulated, and nodes and scripts to be updated. A large proportion of the "
"time is spent in the functions to render a canvas (66%), because this "
"example uses a 2D benchmark. Below this, we see that almost 50% of the time "
"is spent outside Godot code in ``libglapi`` and ``i965_dri`` (the graphics "
"driver). This tells us the a large proportion of CPU time is being spent in "
"the graphics driver."
msgstr ""
"У цьому прикладі ми бачимо, що майже весь час витрачається на функцію "
"``Main::iteration()``. Це основна функція у вихідному коді Godot, яка "
"викликається неодноразово. Вона змушує малювати кадри, моделювати фізичні "
"тики, оновлювати вузли та скрипти. Значна частина часу витрачається на "
"виконання функцій для візуалізації полотна (66%), оскільки в цьому прикладі "
"використовується 2D-бенчмарк. Нижче ми бачимо, що майже 50% часу "
"витрачається поза кодом Godot в ``libglapi`` та ``i965_dri`` (графічний "
"драйвер). Це говорить нам про те, що велика частина часу процесора "
"витрачається на графічний драйвер."

msgid ""
"This is actually an excellent example because, in an ideal world, only a "
"very small proportion of time would be spent in the graphics driver. This is "
"an indication that there is a problem with too much communication and work "
"being done in the graphics API. This specific profiling led to the "
"development of 2D batching, which greatly speeds up 2D rendering by reducing "
"bottlenecks in this area."
msgstr ""
"Насправді це чудовий приклад, тому що в ідеальному світі лише дуже мала "
"частина часу витрачалася б на графічний драйвер. Це вказує на те, що існує "
"проблема із занадто великою кількістю зв’язку та роботи, що виконується в "
"графічному API. Це специфічне профілювання призвело до розробки 2D пакетної "
"обробки, яка значно прискорює 2D-рендерінг, зменшуючи вузькі місця в цій "
"області."

msgid "Manually timing functions"
msgstr "Функції визначення часу вручну"

msgid ""
"Another handy technique, especially once you have identified the bottleneck "
"using a profiler, is to manually time the function or area under test. The "
"specifics vary depending on the language, but in GDScript, you would do the "
"following:"
msgstr ""
"Ще одна зручна техніка, особливо коли ви визначили вузьке місце за допомогою "
"профайлера, полягає в тому, щоб вручну визначити час роботи функції або "
"області коду, що тестується. Специфіка залежить від мови, але в GDScript ви "
"повинні зробити наступне:"

msgid ""
"When manually timing functions, it is usually a good idea to run the "
"function many times (1,000 or more times), instead of just once (unless it "
"is a very slow function). The reason for doing this is that timers often "
"have limited accuracy. Moreover, CPUs will schedule processes in a haphazard "
"manner. Therefore, an average over a series of runs is more accurate than a "
"single measurement."
msgstr ""
"Під час ручного визначення часу зазвичай доцільно запускати функцію багато "
"разів (1000 і більше), а не лише один раз (якщо це не дуже повільна "
"функція). Причина цього полягає в тому, що таймери часто мають обмежену "
"точність. Крім того, процесори плануватимуть процеси випадковим чином. Тому "
"середнє значення за серією прогонів є більш точним, ніж одне вимірювання."

msgid ""
"As you attempt to optimize functions, be sure to either repeatedly profile "
"or time them as you go. This will give you crucial feedback as to whether "
"the optimization is working (or not)."
msgstr ""
"Намагаючись оптимізувати функції, обов'язково проводьте повторне "
"профілювання або замір часу виконання. Так ви зрозумієте, чи працює "
"оптимізація (чи ні)."

msgid "Caches"
msgstr "Кеші"

msgid ""
"CPU caches are something else to be particularly aware of, especially when "
"comparing timing results of two different versions of a function. The "
"results can be highly dependent on whether the data is in the CPU cache or "
"not. CPUs don't load data directly from the system RAM, even though it's "
"huge in comparison to the CPU cache (several gigabytes instead of a few "
"megabytes). This is because system RAM is very slow to access. Instead, CPUs "
"load data from a smaller, faster bank of memory called cache. Loading data "
"from cache is very fast, but every time you try and load a memory address "
"that is not stored in cache, the cache must make a trip to main memory and "
"slowly load in some data. This delay can result in the CPU sitting around "
"idle for a long time, and is referred to as a \"cache miss\"."
msgstr ""
"Кеш-пам'ять процесора - це ще одна річ, про яку слід пам'ятати, особливо "
"коли порівнюються результати часу виконання двох різних версій функції. "
"Результати можуть сильно залежати від того, чи є дані в кеші процесора чи "
"ні. Процесори не завантажують дані безпосередньо з системної оперативної "
"пам'яті, навіть якщо вона величезна порівняно з кешем процесора (кілька "
"гігабайт замість кількох мегабайт). Це пов'язано з тим, що системна "
"оперативна пам'ять дуже повільна для доступу. Замість цього процесори "
"завантажують дані з меншого, швидшого банку пам'яті, який називається кеш. "
"Завантаження даних з кешу відбувається дуже швидко, але кожного разу, коли "
"ви намагаєтеся завантажити адресу пам'яті, яка не зберігається в кеші, кеш "
"повинен звертатися до основної пам'яті і повільно завантажувати дані. Ця "
"затримка може призвести до тривалого простою процесора і називається "
"\"промахом кешу\"."

msgid ""
"This means that the first time you run a function, it may run slowly because "
"the data is not in the CPU cache. The second and later times, it may run "
"much faster because the data is in the cache. Due to this, always use "
"averages when timing, and be aware of the effects of cache."
msgstr ""
"Це означає, що при першому запуску функції вона може працювати повільно, "
"оскільки дані не знаходяться в кеші процесора. Вдруге і пізніше вона може "
"працювати набагато швидше, оскільки дані знаходяться в кеші. Через це завжди "
"використовуйте середні значення при визначенні часу і пам'ятайте про вплив "
"кешу."

msgid ""
"Understanding caching is also crucial to CPU optimization. If you have an "
"algorithm (routine) that loads small bits of data from randomly spread out "
"areas of main memory, this can result in a lot of cache misses, a lot of the "
"time, the CPU will be waiting around for data instead of doing any work. "
"Instead, if you can make your data accesses localised, or even better, "
"access memory in a linear fashion (like a continuous list), then the cache "
"will work optimally and the CPU will be able to work as fast as possible."
msgstr ""
"Розуміння кешування також має вирішальне значення для оптимізації процесора. "
"Якщо у вас є алгоритм (підпрограма), який завантажує невеликі біти даних з "
"випадково розподілених ділянок оперативної пам'яті, це може призвести до "
"великої кількості промахів кешу, і процесор більшу частину часу буде чекати "
"на дані замість того, щоб виконувати будь-яку роботу. Натомість, якщо ви "
"можете зробити доступ до даних локалізованим, або, ще краще, звертатися до "
"пам'яті лінійно (як до безперервного списку), то кеш працюватиме оптимально, "
"а процесор зможе працювати якомога швидше."

msgid ""
"Godot usually takes care of such low-level details for you. For example, the "
"Server APIs make sure data is optimized for caching already for things like "
"rendering and physics. Still, you should be especially aware of caching when "
"using :ref:`GDNative <toc-tutorials-gdnative>`."
msgstr ""
"Зазвичай Godot піклується про такі низькорівневі деталі за вас. Наприклад, "
"серверні API гарантують, що дані вже оптимізовано для кешування для таких "
"речей, як рендеринг та фізика. Тим не менш, ви повинні бути особливо "
"уважними до кешування при використанні :ref:`GDNative <toc-tutorials-"
"gdnative>`."

msgid "Languages"
msgstr "Мови"

msgid ""
"Godot supports a number of different languages, and it is worth bearing in "
"mind that there are trade-offs involved. Some languages are designed for "
"ease of use at the cost of speed, and others are faster but more difficult "
"to work with."
msgstr ""
"Godot підтримує кілька різних мов, і варто пам'ятати, що тут є певні "
"компроміси. Деякі мови призначені для простоти використання за рахунок "
"швидкості, а інші - швидші, але з ними складніше працювати."

msgid ""
"Built-in engine functions run at the same speed regardless of the scripting "
"language you choose. If your project is making a lot of calculations in its "
"own code, consider moving those calculations to a faster language."
msgstr ""
"Вбудовані функції рушія працюють з однаковою швидкістю незалежно від обраної "
"вами мови для написання скриптів. Якщо ваш проект виконує багато обчислень у "
"власному коді, подумайте про перенесення цих обчислень на швидшу мову."

msgid "GDScript"
msgstr "Скрипт"

msgid ""
":ref:`GDScript <toc-learn-scripting-gdscript>` is designed to be easy to use "
"and iterate, and is ideal for making many types of games. However, in this "
"language, ease of use is considered more important than performance. If you "
"need to make heavy calculations, consider moving some of your project to one "
"of the other languages."
msgstr ""
":ref:`GDScript <toc-learn-scripting-gdscript>` простим у використанні та "
"ітераціях, і він ідеально підходить для створення багатьох типів ігор. Однак "
"у цій мові простота використання вважається важливішою за продуктивність. "
"Якщо вам потрібно робити важкі обчислення, подумайте про те, щоб перенести "
"частину вашого проекту на одну з інших мов."

msgid "C#"
msgstr "C#"

msgid ""
":ref:`C# <toc-learn-scripting-C#>` is popular and has first-class support in "
"Godot.It offers a good compromise between speed and ease of use. Beware of "
"possible garbage collection pauses and leaks that can occur during gameplay, "
"though. A common approach to workaround issues with garbage collection is to "
"use *object pooling*, which is outside the scope of this guide."
msgstr ""
":ref:`C# <toc-learn-scripting-C#>` є популярним і має першокласну підтримку "
"у Godot. Він пропонує хороший компроміс між швидкістю та простотою "
"використання. Однак остерігайтеся можливих пауз під час збирання сміття та "
"витоків, які можуть виникати під час гри. Поширеним підходом до обходу "
"проблем зі збором сміття є використання *об'єднання об'єктів*, але це "
"виходить за рамки цього посібника."

msgid "Other languages"
msgstr "Інші мови"

msgid ""
"Third parties provide support for several other languages, including `Rust "
"<https://github.com/godot-rust/godot-rust>`_ and `Javascript <https://github."
"com/GodotExplorer/ECMAScript>`_."
msgstr ""
"Сторонні розробники надають підтримку декількох інших мов, зокрема `Rust "
"<https://github.com/godot-rust/godot-rust>`_ та `Javascript <https://github."
"com/GodotExplorer/ECMAScript>`_."

msgid "C++"
msgstr "C++"

msgid ""
"Godot is written in C++. Using C++ will usually result in the fastest code. "
"However, on a practical level, it is the most difficult to deploy to end "
"users' machines on different platforms. Options for using C++ include :ref:"
"`GDNative <toc-tutorials-gdnative>` and :ref:`custom modules "
"<doc_custom_modules_in_c++>`."
msgstr ""
"Godot написано на C++. Використання C++ зазвичай призводить до найшвидшого "
"коду. Однак на практиці його найважче розгортати на комп'ютерах кінцевих "
"користувачів на різних платформах. Варіанти використання C++ включають :ref:"
"`GDNative <toc-tutorials-gdnative>` і :ref:`власні модулі "
"<doc_custom_modules_in_c++>`."

msgid "Threads"
msgstr "Потоки"

msgid ""
"Consider using threads when making a lot of calculations that can run in "
"parallel to each other. Modern CPUs have multiple cores, each one capable of "
"doing a limited amount of work. By spreading work over multiple threads, you "
"can move further towards peak CPU efficiency."
msgstr ""
"Коли ви робите багато обчислень, подумайте про використання потоків, які "
"можуть виконуватися паралельно один з одним. Сучасні процесори мають кілька "
"ядер, кожне з яких здатне виконувати обмежений обсяг роботи. Розподіливши "
"роботу на декілька потоків, ви зможете досягти максимальної ефективності "
"процесора."

msgid ""
"The disadvantage of threads is that you have to be incredibly careful. As "
"each CPU core operates independently, they can end up trying to access the "
"same memory at the same time. One thread can be reading to a variable while "
"another is writing: this is called a *race condition*. Before you use "
"threads, make sure you understand the dangers and how to try and prevent "
"these race conditions."
msgstr ""
"Недоліком потоків є те, що ви повинні бути неймовірно обережними. Оскільки "
"кожне ядро процесора працює незалежно, вони можуть одночасно намагатися "
"отримати доступ до однієї і тієї ж пам'яті. Один потік може читати змінну в "
"той час, як інший записує: це називається *станом перегонів* . Перш ніж "
"використовувати потоки, переконайтеся, що ви розумієте небезпеку і знаєте, "
"як запобігти виникненню цих станів."

msgid ""
"Threads can also make debugging considerably more difficult. The GDScript "
"debugger doesn't support setting up breakpoints in threads yet."
msgstr ""
"Потоки також можуть значно ускладнювати налагодження. Налагоджувач GDScript "
"поки що не підтримує встановлення точок зупинки у потоках."

msgid "For more information on threads, see :ref:`doc_using_multiple_threads`."
msgstr ""
"Для отримання додаткової інформації про потоки див. :ref:"
"`doc_using_multiple_threads`."

msgid "SceneTree"
msgstr "Дерево Сцен"

msgid ""
"Although Nodes are an incredibly powerful and versatile concept, be aware "
"that every node has a cost. Built-in functions such as `_process()` and "
"`_physics_process()` propagate through the tree. This housekeeping can "
"reduce performance when you have very large numbers of nodes (usually in the "
"thousands)."
msgstr ""
"Хоча вузли є неймовірно потужною та універсальною концепцією, пам'ятайте, що "
"кожен вузол має свою ціну. Вбудовані функції, такі як ``_process()`` та "
"``_physics_process()`` поширюються по дереву. Таке ведення домашнього "
"господарства може знизити продуктивність, коли у вас дуже велика кількість "
"вузлів (цілі тисячі)."

msgid ""
"Each node is handled individually in the Godot renderer. Therefore, a "
"smaller number of nodes with more in each can lead to better performance."
msgstr ""
"Кожен вузол обробляється окремо у візуалізаторі Godot. Тому менша кількість "
"вузлів з більшою кількістю даних у кожному з них може призвести до кращої "
"продуктивності."

msgid ""
"One quirk of the :ref:`SceneTree <class_SceneTree>` is that you can "
"sometimes get much better performance by removing nodes from the SceneTree, "
"rather than by pausing or hiding them. You don't have to delete a detached "
"node. You can for example, keep a reference to a node, detach it from the "
"scene tree using :ref:`Node.remove_child(node) "
"<class_Node_method_remove_child>`, then reattach it later using :ref:`Node."
"add_child(node) <class_Node_method_add_child>`. This can be very useful for "
"adding and removing areas from a game, for example."
msgstr ""
"Однією з особливостей :ref:`Дерева Сцен <class_SceneTree>` є те, що іноді ви "
"можете отримати набагато кращу продуктивність, видаливши вузли з Дерева "
"Сцен, а не призупинивши, чи приховавши, їх. Вам не обов'язково видаляти "
"відокремлений вузол. Ви можете, наприклад, зберегти посилання на вузол, "
"вилучити його з дерева сцен за допомогою :ref:`Node.remove_child(вузол) "
"<class_Node_method_remove_child>`, а потім знову приєднати його за "
"допомогою :ref:`Node.add_child(вузол) <class_Node_method_add_child>`. Це "
"може бути дуже корисно, наприклад, для додавання та видалення областей у грі."

msgid ""
"You can avoid the SceneTree altogether by using Server APIs. For more "
"information, see :ref:`doc_using_servers`."
msgstr ""
"Ви можете взагалі відмовитися від Дерева Сцен, скориставшись серверними API. "
"Докладнішу інформацію наведено у :ref:`doc_using_servers`."

msgid "Physics"
msgstr "Фізика"

msgid ""
"In some situations, physics can end up becoming a bottleneck. This is "
"particularly the case with complex worlds and large numbers of physics "
"objects."
msgstr ""
"У деяких ситуаціях вузьким місцем може стати фізика. Особливо це стосується "
"складних світів і великої кількості фізичних об'єктів."

msgid "Here are some techniques to speed up physics:"
msgstr "Ось кілька прийомів для прискорення фізики:"

msgid ""
"Try using simplified versions of your rendered geometry for collision "
"shapes. Often, this won't be noticeable for end users, but can greatly "
"increase performance."
msgstr ""
"Спробуйте використовувати спрощені версії геометрії для форм зіткнення. "
"Часто це буде непомітно для кінцевих користувачів, але може значно підвищити "
"продуктивність."

msgid ""
"Try removing objects from physics when they are out of view / outside the "
"current area, or reusing physics objects (maybe you allow 8 monsters per "
"area, for example, and reuse these)."
msgstr ""
"Спробуйте видаляти об'єкти з фізикою, коли вони знаходяться поза зоною "
"видимості/за межами поточної області, або використовувати фізичні об'єкти "
"повторно (наприклад, ви дозволите 8 монстрів на область, і використаєте їх "
"повторно)."

msgid ""
"Another crucial aspect to physics is the physics tick rate. In some games, "
"you can greatly reduce the tick rate, and instead of for example, updating "
"physics 60 times per second, you may update them only 30 or even 20 times "
"per second. This can greatly reduce the CPU load."
msgstr ""
"Іншим важливим аспектом фізики є частота оновлення фізики. У деяких іграх ви "
"можете значно зменшити частоту оновлення фізики, і замість того, щоб, "
"наприклад, оновлювати фізику 60 разів на секунду, ви можете оновлювати її "
"лише 30, або навіть 20, разів на секунду. Це може значно зменшити "
"навантаження на процесор."

msgid ""
"The downside of changing physics tick rate is you can get jerky movement or "
"jitter when the physics update rate does not match the frames per second "
"rendered. Also, decreasing the physics tick rate will increase input lag. "
"It's recommended to stick to the default physics tick rate (60 Hz) in most "
"games that feature real-time player movement."
msgstr ""
"Недоліком зміни частоти оновлення фізики є те, що ви можете отримати ривкові "
"рухи, або тремтіння, коли частота оновлення фізики не відповідає частоті "
"візуалізації кадрів на секунду. Крім того, зменшення частоти оновлення "
"фізики може призвести до збільшення затримки введення. У більшості ігор, де "
"гравець рухається у реальному часі, рекомендується дотримуватися частоти "
"оновлення фізики за замовчуванням (60 Гц)."

msgid ""
"The solution to jitter is to use *fixed timestep interpolation*, which "
"involves smoothing the rendered positions and rotations over multiple frames "
"to match the physics. You can either implement this yourself or use a `third-"
"party addon <https://github.com/lawnjelly/smoothing-addon>`__. Performance-"
"wise, interpolation is a very cheap operation compared to running a physics "
"tick. It's orders of magnitude faster, so this can be a significant "
"performance win while also reducing jitter."
msgstr ""
"Вирішенням проблеми тремтіння є використання *інтерполяції з фіксованим "
"кроком*, яка передбачає згладжування позицій та обертань зображуваного кадру "
"протягом декількох кадрів, щоб відповідати фізиці. Ви можете реалізувати її "
"самостійно або використати `сторонній аддон<https://github.com/lawnjelly/"
"smoothing-addon>` __. З точки зору продуктивності, інтерполяція є дуже "
"дешевою операцією порівняно зі збільшенням частоти оновлення фізики. Вона на "
"порядки швидша, тож це може дати значний виграш у продуктивності, а також "
"зменшити тремтіння."

msgid "Translation status"
msgstr "Стан перекладу"
