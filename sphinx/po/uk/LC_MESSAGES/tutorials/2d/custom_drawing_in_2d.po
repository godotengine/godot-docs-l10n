# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom drawing in 2D"
msgstr "Власне малювання в 2D"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"Godot has nodes to draw sprites, polygons, particles, and all sorts of "
"stuff. For most cases, this is enough; but not always. Before crying in "
"fear, angst, and rage because a node to draw that specific *something* does "
"not exist... it would be good to know that it is possible to easily make any "
"2D node (be it :ref:`Control <class_Control>` or :ref:`Node2D "
"<class_Node2D>` based) draw custom commands. It is *really* easy to do it, "
"too."
msgstr ""
"Godot має вузли для малювання спрайтів, багатокутників, частинок і всіляких "
"речей. Для більшості випадків цього достатньо; але не завжди. Перш ніж "
"плакати від безсилля, страху і люті, тому що вузла для малювання *чогось "
"конкретного* не існує ... було б добре знати, що можна легко змусити будь-"
"який вузол 2D (на основі :ref:`Control <class_Control>`, або :ref:`Node2D "
"<class_Node2D>`) малювати власні команди. Це насправді дуже легко зробити."

msgid ""
"Custom drawing in a 2D node is *really* useful. Here are some use cases:"
msgstr ""
"Власне малювання в 2D вузлах *дійсно* корисне. Ось деякі випадки "
"використання:"

msgid ""
"Drawing shapes or logic that existing nodes can't do, such as an image with "
"trails or a special animated polygon."
msgstr ""
"Малювання фігур, або логіки, які не можуть зробити існуючі вузли, наприклад, "
"зображення зі слідами, або спеціальний анімований багатокутник."

msgid ""
"Visualizations that are not that compatible with nodes, such as a tetris "
"board. (The tetris example uses a custom draw function to draw the blocks.)"
msgstr ""
"Візуалізації, несумісні з вузлами, наприклад, дошка тетріса. (Для прикладу "
"тетріс використовує спеціальну функцію малювання для малювання блоків.)"

msgid ""
"Drawing a large number of simple objects. Custom drawing avoids the overhead "
"of using a large number of nodes, possibly lowering memory usage and "
"improving performance."
msgstr ""
"Малювання великої кількості простих об'єктів. Власне малюнок дозволяє "
"уникнути використання великої кількості вузлів, можливо, знижуючи "
"використання пам'яті та покращуючи продуктивність."

msgid ""
"Making a custom UI control. There are plenty of controls available, but when "
"you have unusual needs, you will likely need a custom control."
msgstr ""
"Створення власного елемента керування інтерфейсом користувача. Доступно "
"багато елементів керування, але коли у вас є незвичайні потреби, вам, "
"ймовірно, знадобиться власний контроль."

msgid "Drawing"
msgstr "Малюнок"

msgid ""
"Add a script to any :ref:`CanvasItem <class_CanvasItem>` derived node, like :"
"ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`. Then override "
"the ``_draw()`` function."
msgstr ""
"Додайте скрипт до будь-якого похідного вузла :ref:`CanvasItem "
"<class_CanvasItem>`, наприклад :ref:`Control <class_Control>`, або :ref:"
"`Node2D <class_Node2D>`. Потім перевизначте функцію ``_draw()``."

msgid ""
"Draw commands are described in the :ref:`CanvasItem <class_CanvasItem>` "
"class reference. There are plenty of them."
msgstr ""
"Команди малювання описані в посиланні на клас :ref:`CanvasItem "
"<class_CanvasItem>`. Їх багато."

msgid "Updating"
msgstr "Оновлення"

msgid ""
"The ``_draw()`` function is only called once, and then the draw commands are "
"cached and remembered, so further calls are unnecessary."
msgstr ""
"Функція ``_draw()`` викликається тільки один раз, а потім команди малювання "
"кешуються і запам'ятовуються, тому подальші виклики непотрібні."

msgid ""
"If re-drawing is required because a state or something else changed, call :"
"ref:`CanvasItem.update() <class_CanvasItem_method_update>` in that same node "
"and a new ``_draw()`` call will happen."
msgstr ""
"Якщо потрібно повторне малювання, оскільки стан або щось інше змінилося, "
"викличте :ref:`CanvasItem.update() <class_CanvasItem_method_update>` в тому "
"ж вузлі, і відбудеться новий виклик ``_draw()``."

msgid ""
"Here is a little more complex example, a texture variable that will be "
"redrawn if modified:"
msgstr ""
"Ось трохи складніший приклад, змінна текстури, яка буде перемальована при "
"зміні:"

msgid ""
"In some cases, it may be desired to draw every frame. For this, just call "
"``update()`` from the ``_process()`` callback, like this:"
msgstr ""
"У деяких випадках може виникнути бажання намалювати кожен кадр. Для цього "
"просто викличте ``update()`` з ``_process()``, ось так:"

msgid "An example: drawing circular arcs"
msgstr "Приклад: малювання кругових дуг"

msgid ""
"We will now use the custom drawing functionality of the Godot Engine to draw "
"something that Godot doesn't provide functions for. As an example, Godot "
"provides a ``draw_circle()`` function that draws a whole circle. However, "
"what about drawing a portion of a circle? You will have to code a function "
"to perform this and draw it yourself."
msgstr ""
"Тепер ми будемо використовувати спеціальну функціональність малювання Godot "
"Engine, щоб намалювати те, для чого Godot не надає функцій. Як приклад, "
"Godot надає функцію ``draw_circle()``, яка малює ціле коло. Однак, як щодо "
"малювання частини кола? Вам доведеться закодувати функцію, щоб виконати її і "
"намалювати частину кола самостійно."

msgid "Arc function"
msgstr "Функція дуги"

msgid ""
"An arc is defined by its support circle parameters, that is, the center "
"position and the radius. The arc itself is then defined by the angle it "
"starts from and the angle at which it stops. These are the 4 arguments that "
"we have to provide to our drawing function. We'll also provide the color "
"value, so we can draw the arc in different colors if we wish."
msgstr ""
"Дуга визначається її параметрами опорного кола, тобто центральним положенням "
"і радіусом. Сама дуга потім визначається кутом, з якого вона починається, і "
"кутом, під яким вона зупиняється. Це 4 аргументи, які ми повинні надати "
"нашій функції малювання. Ми також надамо значення кольору, щоб ми могли "
"намалювати дугу в різних кольорах, якщо захочемо."

msgid ""
"Basically, drawing a shape on the screen requires it to be decomposed into a "
"certain number of points linked from one to the next. As you can imagine, "
"the more points your shape is made of, the smoother it will appear, but the "
"heavier it will also be in terms of processing cost. In general, if your "
"shape is huge (or in 3D, close to the camera), it will require more points "
"to be drawn without it being angular-looking. On the contrary, if your shape "
"is small (or in 3D, far from the camera), you may decrease its number of "
"points to save processing costs; this is known as *Level of Detail (LOD)*. "
"In our example, we will simply use a fixed number of points, no matter the "
"radius."
msgstr ""
"В основному, малювання фігури на екрані вимагає, щоб вона була розкладена на "
"певну кількість точок, пов'язаних від однієї до іншої. Як розумієте, чим з "
"більшої кількості точок складається ваша форма, тим гладкішою вона виглядає, "
"але тим важча вона з точки зору обробки. Загалом, якщо ваша форма величезна "
"(або в 3D, близько до камери), треба буде намалювати більше точок, щоб "
"досягти гладкості. І навпаки, якщо ваша форма невелика (або в 3D, далеко від "
"камери), ви можете зменшити кількість її точок, щоб заощадити витрати на "
"обробку; це називається *рівень деталізації (LOD)*. У нашому прикладі ми "
"просто будемо використовувати фіксовану кількість точок, незалежно від "
"радіуса."

msgid ""
"Remember the number of points our shape has to be decomposed into? We fixed "
"this number in the ``nb_points`` variable to a value of ``32``. Then, we "
"initialize an empty ``PoolVector2Array``, which is simply an array of "
"``Vector2``\\ s."
msgstr ""
"Пам'ятаєте кількість точок, на які повинна бути розкладена наша форма? Ми "
"виправили це число у змінній ``nb_points`` до значення ``32``. Потім "
"ініціалізуємо порожній ``PoolVector2Array``, який є просто масивом "
"``Vector2``."

msgid ""
"The next step consists of computing the actual positions of these 32 points "
"that compose an arc. This is done in the first for-loop: we iterate over the "
"number of points for which we want to compute the positions, plus one to "
"include the last point. We first determine the angle of each point, between "
"the starting and ending angles."
msgstr ""
"Наступний крок складається з обчислення фактичних позицій цих 32 точок, які "
"складають дугу. Це робиться в першому циклі for: ми ітеруємо кількість "
"точок, для яких хочемо обчислити позиції, плюс одну, щоб включити останню "
"точку. Спочатку визначаємо кут кожної точки, між початковим і кінцевим "
"кутами."

msgid ""
"The reason why each angle is decreased by 90° is that we will compute 2D "
"positions out of each angle using trigonometry (you know, cosine and sine "
"stuff...). However, to be simple, ``cos()`` and ``sin()`` use radians, not "
"degrees. The angle of 0° (0 radian) starts at 3 o'clock, although we want to "
"start counting at 12 o'clock. So we decrease each angle by 90° in order to "
"start counting from 12 o'clock."
msgstr ""
"Причина, по якій кожен кут зменшується на 90°, полягає в тому, що ми будемо "
"обчислювати 2D позиції з кожного кута за допомогою тригонометрії (ви знаєте, "
"косинус і синус...). Однак, щоб бути простим, і використовувати радіани, а "
"не градуси. Кут 0° (0 радіан) починається з 3 години, хоча ми хочемо почати "
"підрахунок з 12 години. Таким чином, ми зменшуємо кожен кут на 90 °, щоб "
"почати відлік з 12 години."

msgid ""
"The actual position of a point located on a circle at angle ``angle`` (in "
"radians) is given by ``Vector2(cos(angle), sin(angle))``. Since ``cos()`` "
"and ``sin()`` return values between -1 and 1, the position is located on a "
"circle of radius 1. To have this position on our support circle, which has a "
"radius of ``radius``, we simply need to multiply the position by ``radius``. "
"Finally, we need to position our support circle at the ``center`` position, "
"which is performed by adding it to our ``Vector2`` value. Finally, we insert "
"the point in the ``PoolVector2Array`` which was previously defined."
msgstr ""
"Фактичне положення точки, розташованої на колі під кутом ``angle`` (у "
"радіанах), задається ``Vector2(cos(angle), sin(angle))``. Оскільки ``cos()`` "
"і ``sin()`` повертають значення між -1 і 1, позиція розташовується на колі "
"радіуса 1. Щоб мати цю позицію на нашому опорному колі, яке має радіус "
"``radius``, нам просто потрібно помножити положення на ``radius``. Нарешті, "
"нам потрібно розташувати наше коло підтримки на позиції ``center``, що "
"виконується шляхом додавання його до нашої змінної ``Vector2``. Нарешті, "
"вставляємо точку в визначений раніше ``PoolVector2Array``."

msgid ""
"Now, we need to actually draw our points. As you can imagine, we will not "
"simply draw our 32 points: we need to draw everything that is between each "
"of them. We could have computed every point ourselves using the previous "
"method, and drew it one by one. But this is too complicated and inefficient "
"(except if explicitly needed), so we simply draw lines between each pair of "
"points. Unless the radius of our support circle is big, the length of each "
"line between a pair of points will never be long enough to see them. If that "
"were to happen, we would simply need to increase the number of points."
msgstr ""
"Тепер ми повинні дійсно намалювати наші точки. Як ви можете здогадатися, ми "
"не просто намалюємо наші 32 точки: нам потрібно намалювати все, що є між "
"кожною з них. Ми могли б обчислити кожну точку самі, використовуючи "
"попередній метод, і намалювати їх одна за одною. Але це занадто складно і "
"неефективно (за винятком випадків, коли це явно необхідно), тому ми просто "
"малюємо лінії між кожною парою точок. Якщо радіус нашого опорного кола не "
"великий, довжина кожної лінії між парою точок ніколи не буде достатньо "
"довгою, щоб побачити її. Якби це сталося, нам би довелося збільшити "
"кількість точок."

msgid "Draw the arc on the screen"
msgstr "Малювання дуги на екрані"

msgid ""
"We now have a function that draws stuff on the screen; it is time to call it "
"inside the ``_draw()`` function:"
msgstr ""
"Тепер у нас є функція, яка малює щось на екрані; настав час викликати її "
"всередині функції ``_draw()``:"

msgid "Result:"
msgstr "Результат:"

msgid "Arc polygon function"
msgstr "Функція полігона дуги"

msgid ""
"We can take this a step further and not only write a function that draws the "
"plain portion of the disc defined by the arc, but also its shape. The method "
"is exactly the same as before, except that we draw a polygon instead of "
"lines:"
msgstr ""
"Ми можемо зробити ще крок далі і не тільки написати функцію, яка малює "
"просту частину диска, визначену дугою, але і його форму. Метод точно такий "
"же, як і раніше, за винятком того, що ми малюємо багатокутник замість ліній:"

msgid "Dynamic custom drawing"
msgstr "Динаміка власного малювання"

msgid ""
"All right, we are now able to draw custom stuff on the screen. However, it "
"is static; let's make this shape turn around the center. The solution to do "
"this is simply to change the angle_from and angle_to values over time. For "
"our example, we will simply increment them by 50. This increment value has "
"to remain constant or else the rotation speed will change accordingly."
msgstr ""
"Гаразд, тепер ми можемо малювати власні речі на екрані. Однак малюнок "
"статичний; давайте зробимо так, щоб ця форма обернулася по центру. Рішення "
"полягає в тому, щоб просто змінити з плином часу значення ``angle_from`` і "
"``angle_to``. Наприклад, ми просто збільшимо їх на ``50``. Це значення "
"приросту має залишатися постійним, інакше швидкість обертання відповідно "
"зміниться."

msgid ""
"First, we have to make both angle_from and angle_to variables global at the "
"top of our script. Also note that you can store them in other nodes and "
"access them using ``get_node()``."
msgstr ""
"По-перше, ми повинні зробити як ``angle_from``, так і ``angle_to`` "
"глобальними змінними у верхній частині нашого скрипта. Також завбачте, що ви "
"можете зберігати їх в інших вузлах і отримати до них доступ за допомогою "
"``get_node()``."

msgid "We make these values change in the _process(delta) function."
msgstr "Ми вносимо ці змінюючі значення в функції ``_process(delta)``."

msgid ""
"We also increment our angle_from and angle_to values here. However, we must "
"not forget to ``wrap()`` the resulting values between 0 and 360°! That is, "
"if the angle is 361°, then it is actually 1°. If you don't wrap these "
"values, the script will work correctly, but the angle values will grow "
"bigger and bigger over time until they reach the maximum integer value Godot "
"can manage (``2^31 - 1``). When this happens, Godot may crash or produce "
"unexpected behavior."
msgstr ""
"Ми також збільшуємо тут наші змінні ``angle_from`` та ``angle_to``. Однак не "
"можна забувати про отримані значення від 0 до 360°! Тобто, якщо кут дорівнює "
"361°, то насправді це 1°. Якщо ви не обернете ці значення, скрипт буде "
"працювати правильно, але кутові значення будуть рости все більше і більше з "
"часом, поки не досягнуть максимального цілого значення, яким Godot може "
"керувати (``2^31 - 1``). Коли це відбудеться, Godot може аварійно зазнати "
"краху або викликати несподівану поведінку."

msgid ""
"Finally, we must not forget to call the ``update()`` function, which "
"automatically calls ``_draw()``. This way, you can control when you want to "
"refresh the frame."
msgstr ""
"Нарешті, не можна забувати викликати функцію ``update()``, яка автоматично "
"викликається ``_draw()``. Таким чином, ви можете керувати, коли хочете "
"оновити кадр."

msgid ""
"Also, don't forget to modify the ``_draw()`` function to make use of these "
"variables:"
msgstr ""
"Крім того, не забудьте змінити функцію ``_draw()``, щоб використовувати ці "
"змінні:"

msgid ""
"Let's run! It works, but the arc is rotating insanely fast! What's wrong?"
msgstr ""
"Давайте запустимо! Це працює, але дуга обертається шалено швидко! Що не так?"

msgid ""
"The reason is that your GPU is actually displaying the frames as fast as it "
"can. We need to \"normalize\" the drawing by this speed; to achieve that, we "
"have to make use of the ``delta`` parameter of the ``_process()`` function. "
"``delta`` contains the time elapsed between the two last rendered frames. It "
"is generally small (about 0.0003 seconds, but this depends on your "
"hardware), so using ``delta`` to control your drawing ensures that your "
"program runs at the same speed on everybody's hardware."
msgstr ""
"Причина в тому, що ваш графічний процесор насправді відображає кадри так "
"швидко, як може. Потрібно \"нормалізувати\" малюнок на цій швидкості; для "
"цього ми повинні використовувати параметр ``delta`` функції ``_process()``. "
"``delta`` містить час, що минув між двома останніми відтвореними кадрами. Як "
"правило, він невеликий (близько 0,0003 секунд, але це залежить від вашого "
"обладнання), тому використання ``delta`` для керування вимальовуванням "
"гарантує, що ваша програма працюватиме з однаковою швидкістю на різному "
"обладнанні."

msgid ""
"In our case, we simply need to multiply our ``rotation_angle`` variable by "
"``delta`` in the ``_process()`` function. This way, our 2 angles will be "
"increased by a much smaller value, which directly depends on the rendering "
"speed."
msgstr ""
"У нашому випадку нам просто потрібно помножити нашу змінну "
"``rotation_angle`` на ``delta`` в функції ``_process()``. Таким чином, наші "
"2 кути будуть збільшені на набагато менші значення, які безпосередньо "
"залежить від швидкості рендеринга."

msgid "Let's run again! This time, the rotation displays fine!"
msgstr ""
"Давайте запустимо ще раз! На цей раз відображення обертання відбувається "
"правильно!"

msgid "Antialiased drawing"
msgstr "Згладжування"

msgid ""
"Godot offers method parameters in :ref:"
"`draw_line<class_CanvasItem_method_draw_line>` to enable antialiasing, but "
"it doesn't work reliably in all situations (for instance, on mobile/web "
"platforms, or when HDR is enabled). There is also no ``antialiased`` "
"parameter available in :ref:"
"`draw_polygon<class_CanvasItem_method_draw_polygon>`."
msgstr ""
"Godot пропонує параметри методу в :ref:"
"`draw_line<class_CanvasItem_method_draw_line>` для ввімкнення згладжування, "
"але він не працює надійно у всіх ситуаціях (наприклад, на мобільних/веб-"
"платформах, або коли HDR включений). Також параметр ``antialiased`` "
"відсутній в :ref:`draw_polygon<class_CanvasItem_method_draw_polygon>`."

msgid ""
"As a workaround, install and use the `Antialiased Line2D add-on <https://"
"github.com/godot-extended-libraries/godot-antialiased-line2d>`__ (which also "
"supports antialiased Polygon2D drawing). Note that this add-on relies on "
"high-level nodes, rather than low-level ``_draw()`` functions."
msgstr ""
"Як варіант, встановіть та використовуйте `додаток Antialiased Line2D "
"<https://github.com/godot-extended-libraries/godot-antialiased-line2d>`__ "
"(який також підтримує згладжене малювання Polygon2D). Зауважте, що цей "
"додаток опирається на вузли високого рівня, а не на функції низького рівня "
"``_draw()``."

msgid "Tools"
msgstr "Інструменти"

msgid ""
"Drawing your own nodes might also be desired while running them in the "
"editor. This can be used as a preview or visualization of some feature or "
"behavior. See :ref:`doc_running_code_in_the_editor` for more information."
msgstr ""
"Малювання власних вузлів також може бути бажаним під час їх запуску в "
"редакторі. Його можна використати в якості попереднього перегляду, або "
"візуалізації певної функції, чи поведінки. Більше про це в :ref:"
"`doc_running_code_in_the_editor`."

msgid "Translation status"
msgstr "Стан перекладу"
