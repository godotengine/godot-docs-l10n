# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "High-level multiplayer"
msgstr "Мультиплеєр високого рівня"

msgid "High-level vs low-level API"
msgstr "API високого та низького рівня"

msgid ""
"The following explains the differences of high- and low-level networking in "
"Godot as well as some fundamentals. If you want to jump in head-first and "
"add networking to your first nodes, skip to `Initializing the network`_ "
"below. But make sure to read the rest later on!"
msgstr ""
"Нижче пояснюються відмінності мереж високого та низького рівня у Godot, а "
"також деякі основи. Якщо ви хочете одразу перейти до справи і додати мережу "
"до своїх перших вузлів, перейдіть до `Ініціалізація мережі`_ нижче. Але "
"пізніше обов’язково прочитайте решту!"

msgid ""
"Godot always supported standard low-level networking via UDP, TCP and some "
"higher level protocols such as SSL and HTTP. These protocols are flexible "
"and can be used for almost anything. However, using them to synchronize game "
"state manually can be a large amount of work. Sometimes that work can't be "
"avoided or is worth it, for example when working with a custom server "
"implementation on the backend. But in most cases, it's worthwhile to "
"consider Godot's high-level networking API, which sacrifices some of the "
"fine-grained control of low-level networking for greater ease of use."
msgstr ""
"Godot завжди підтримував стандартні мережі низького рівня через UDP, TCP і "
"деякі протоколи високого рівня, такі як SSL і HTTP. Ці протоколи є гнучкими "
"і можуть використовуватися практично для чого завгодно. Однак використання "
"їх для ручної синхронізації стану гри може вимагати великого об'єму роботи. "
"Іноді цієї роботи неможливо уникнути, або вона того варта, наприклад, при "
"роботі з власною реалізацією сервера на сервері. Але в більшості випадків "
"варто розглянути в Godot API мережі високого рівня, який нехтує частиною "
"тонкого контролю мережі низького рівня заради простоти використання."

msgid "This is due to the inherent limitations of the low-level protocols:"
msgstr "Це пов'язано з обмеженнями притаманними протоколам низького рівня:"

msgid ""
"TCP ensures packets will always arrive reliably and in order, but latency is "
"generally higher due to error correction. It's also quite a complex protocol "
"because it understands what a \"connection\" is, and optimizes for goals "
"that often don't suit applications like multiplayer games. Packets are "
"buffered to be sent in larger batches, trading less per-packet overhead for "
"higher latency. This can be useful for things like HTTP, but generally not "
"for games. Some of this can be configured and disabled (e.g. by disabling "
"\"Nagle's algorithm\" for the TCP connection)."
msgstr ""
"TCP гарантує, що пакети завжди надходитимуть надійно та в правильному "
"порядку, але затримка, як правило, вища через виправлення помилок. Це також "
"досить складний протокол, оскільки він розуміє, що таке \"з'єднання\", і "
"оптимізується для цілей, які часто не підходять для таких застосунків, як "
"багатокористувацькі ігри. Пакети буферизуються для надсилання більшими "
"пачками, що призводить до менших затрат на пакет, але більшої затримки. Це "
"може бути корисно для таких речей, як HTTP, але, зазвичай, не для ігор. Дещо "
"з цього можна налаштувати та вимкнути (наприклад, відключивши «алгоритм "
"Нейгла» для TCP-з'єднання)."

msgid ""
"UDP is a simpler protocol, which only sends packets (and has no concept of a "
"\"connection\"). No error correction makes it pretty quick (low latency), "
"but packets may be lost along the way or received in the wrong order. Added "
"to that, the MTU (maximum packet size) for UDP is generally low (only a few "
"hundred bytes), so transmitting larger packets means splitting them, "
"reorganizing them and retrying if a part fails."
msgstr ""
"UDP є простішим протоколом, який надсилає лише пакети (і не має поняття "
"\"з’єднання\"). Відсутність виправлення помилок робить його досить швидким "
"(затримка низька), але пакети можуть бути втрачені при передачі, або "
"отримані в неправильному порядку. Крім того, MTU (максимальний розмір "
"пакету) для UDP, як правило, малий (всього кілька сотень байтів), тому "
"передача більших пакетів означає їх розділення, реорганізацію та повторну "
"спробу, якщо частина дає збій."

msgid ""
"In general, TCP can be thought of as reliable, ordered, and slow; UDP as "
"unreliable, unordered and fast. Because of the large difference in "
"performance, it often makes sense to re-build the parts of TCP wanted for "
"games (optional reliability and packet order), while avoiding the unwanted "
"parts (congestion/traffic control features, Nagle's algorithm, etc). Due to "
"this, most game engines come with such an implementation, and Godot is no "
"exception."
msgstr ""
"Загалом, TCP можна вважати надійним, впорядкованим і повільним; UDP — "
"ненадійним, неупорядкованим, але швидким. Через велику різницю в "
"продуктивності часто є сенс перебудувати частини TCP, необхідні для ігор "
"(додаткова надійність і порядок пакетів), уникаючи небажаних частин (функції "
"контролю завантаженості/трафіку, алгоритм Нейгла тощо). Завдяки цьому "
"більшість ігрових рушіїв мають таку реалізацію, і Godot не виняток."

msgid ""
"In summary, you can use the low-level networking API for maximum control and "
"implement everything on top of bare network protocols or use the high-level "
"API based on :ref:`SceneTree <class_SceneTree>` that does most of the heavy "
"lifting behind the scenes in a generally optimized way."
msgstr ""
"Отже, ви можете використовувати API мережі низького рівня для максимального "
"контролю та впроваджувати все поверх відкритих протоколів мережі, або "
"використовувати API високого рівня на основі :ref:`Дерева Сцени "
"<class_SceneTree>`, яке, загалом оптимізовано, виконує більшість важких "
"завдань за лаштунками."

msgid ""
"Most of Godot's supported platforms offer all or most of the mentioned high- "
"and low-level networking features. As networking is always largely hardware "
"and operating system dependent, however, some features may change or not be "
"available on some target platforms. Most notably, the HTML5 platform "
"currently offers WebSockets and WebRTC support but lacks some of the higher-"
"level features, as well as raw access to low-level protocols like TCP and "
"UDP."
msgstr ""
"Більшість платформ, які підтримує Godot, пропонують всі або більшість "
"згаданих мережевих функцій високого та низького рівнів. Оскільки робота в "
"мережі завжди значною мірою залежить від апаратного забезпечення та "
"операційної системи, деякі функції можуть змінюватися або бути недоступними "
"на деяких цільових платформах. Зокрема, платформа HTML5 наразі пропонує "
"підтримку WebSockets і WebRTC, але не має деяких високорівневих функцій, а "
"також необробленого доступу до низькорівневих протоколів, таких як TCP і UDP."

msgid ""
"More about TCP/IP, UDP, and networking: https://gafferongames.com/post/"
"udp_vs_tcp/"
msgstr ""
"Більше про TCP/IP, UDP та мережу: https://gafferongames.com/post/udp_vs_tcp/"

msgid ""
"Gaffer On Games has a lot of useful articles about networking in Games "
"(`here <https://gafferongames.com/categories/game-networking/>`__), "
"including the comprehensive `introduction to networking models in games "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."
msgstr ""
"У Gaffer On Games є багато корисних статей про мережу в іграх (`тут<https://"
"gafferongames.com/categories/game-networking/>`__), включаючи вичерпуюче "
"`введення в мережеві моделі в іграх<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."

msgid ""
"If you want to use your low-level networking library of choice instead of "
"Godot's built-in networking, see here for an example: https://github.com/"
"PerduGames/gdnet3"
msgstr ""
"Якщо ви хочете використовувати свою мережеву бібліотеку низького рівня "
"замість вбудованої мережі Godot, перегляньте тут зразок: https://github.com/"
"PerduGames/gdnet3"

msgid ""
"Adding networking to your game comes with some responsibility. It can make "
"your application vulnerable if done wrong and may lead to cheats or "
"exploits. It may even allow an attacker to compromise the machines your "
"application runs on and use your servers to send spam, attack others or "
"steal your users data if they play your game."
msgstr ""
"Додавання мережі до вашої гри пов'язане з певною відповідальністю. Це може "
"зробити вашу програму вразливою, якщо її зробити неправильно, і може "
"призвести до читів, або експлойтів. Це може навіть дозволити зловмиснику "
"скомпрометувати машини, на яких працює ваша програма, і використовувати ваші "
"сервери для розсилки спаму, нападу на інших, або крадіжки даних ваших "
"користувачів, якщо вони грають у вашу гру."

msgid ""
"This is always the case when networking is involved and has nothing to do "
"with Godot. You can of course experiment, but when you release a networked "
"application, always take care of any possible security concerns."
msgstr ""
"Таке завжди відбувається, коли задіяна мережа і це не має ніякого відношення "
"до Godot. Ви, звичайно, можете експериментувати, але завжди, коли ви "
"випускаєте мережеву програму, подбайте про всі можливі заходи безпеки."

msgid "Mid level abstraction"
msgstr "Абстракція середнього рівня"

msgid ""
"Before going into how we would like to synchronize a game across the "
"network, it can be helpful to understand how the base network API for "
"synchronization works."
msgstr ""
"Перш ніж перейти до того, як ми можемо синхронізувати гру в мережі, може "
"бути корисно зрозуміти, як виконує синхронізацію базовий мережевий API."

msgid ""
"Godot uses a mid-level object :ref:`NetworkedMultiplayerPeer "
"<class_NetworkedMultiplayerPeer>`. This object is not meant to be created "
"directly, but is designed so that several C++ implementations can provide it."
msgstr ""
"Godot використовує об’єкт середнього рівня :ref:"
"`NetworkedMultiplayerPeer<class_NetworkedMultiplayerPeer>`. Цей об’єкт не "
"призначений для безпосереднього створення, він розроблений так, щоб його "
"могли надати кілька реалізацій C++."

msgid ""
"This object extends from :ref:`PacketPeer <class_PacketPeer>`, so it "
"inherits all the useful methods for serializing, sending and receiving data. "
"On top of that, it adds methods to set a peer, transfer mode, etc. It also "
"includes signals that will let you know when peers connect or disconnect."
msgstr ""
"Цей об’єкт поширюється від :ref:`PacketPeer <class_PacketPeer>`, тому він "
"успадковує всі корисні методи для серіалізації, надсилання та отримання "
"даних. Крім того, він додає методи встановлення однорангового вузла, режиму "
"передачі тощо. Він також включає сигнали, які повідомлять вам, коли "
"однорангові вузли підключаються, чи відключаються."

msgid ""
"This class interface can abstract most types of network layers, topologies "
"and libraries. By default, Godot provides an implementation based on ENet (:"
"ref:`NetworkedMultiplayerEnet <class_NetworkedMultiplayerENet>`), one based "
"on WebRTC (:ref:`WebRTCMultiplayer <class_WebRTCMultiplayer>`), and one "
"based on WebSocket (:ref:`WebSocketMultiplayerPeer "
"<class_WebSocketMultiplayerPeer>`), but this could be used to implement "
"mobile APIs (for ad hoc WiFi, Bluetooth) or custom device/console-specific "
"networking APIs."
msgstr ""
"Цей інтерфейс класу може абстрагувати більшість типів мережевих рівнів, "
"топологій і бібліотек. За замовчуванням Godot надає реалізацію на основі "
"ENet (:ref:`NetworkedMultiplayerEnet <class_NetworkedMultiplayerENet>`), "
"одну на основі WebRTC (:ref:`WebRTCMultiplayer <class_WebRTCMultiplayer>`), "
"і одну на основі WebSocket (:ref:`WebSocketMultiplayerPeer "
"<class_WebSocketMultiplayerPeer>`), але її можна використовувати для "
"реалізації мобільних API (для спеціальних WiFi, Bluetooth), або власних "
"мережевих API для пристроїв/консолей."

msgid ""
"For most common cases, using this object directly is discouraged, as Godot "
"provides even higher level networking facilities. Yet it is made available "
"in case a game has specific needs for a lower level API."
msgstr ""
"У більшості випадків не рекомендується використовувати цей об’єкт "
"безпосередньо, оскільки Godot забезпечує мережеві засоби ще більш високого "
"рівня. Проте він доступний на випадок, якщо гра має конкретні потреби в API "
"нижчого рівня."

msgid "Initializing the network"
msgstr "Ініціалізація мережі"

msgid ""
"The object that controls networking in Godot is the same one that controls "
"everything tree-related: :ref:`SceneTree <class_SceneTree>`."
msgstr ""
"Об’єкт, який керує мережею в Godot, є тим самим, що керує всім, що пов’язано "
"з :ref:`Деревом Сцени <class_SceneTree>`."

msgid ""
"To initialize high-level networking, the SceneTree must be provided a "
"NetworkedMultiplayerPeer object."
msgstr ""
"Щоб ініціалізувати мережу високого рівня, Дереву Сцени має бути наданий "
"об’єкт NetworkedMultiplayerPeer."

msgid ""
"To create that object, it first has to be initialized as a server or client."
msgstr ""
"Щоб створити цей об’єкт, його спочатку потрібно ініціалізувати як сервер, "
"або клієнт."

msgid ""
"Initializing as a server, listening on the given port, with a given maximum "
"number of peers:"
msgstr ""
"Ініціалізація в якості сервера, прослуховування на заданому порту з заданою "
"максимальною кількістю однорангових серверів:"

msgid "Initializing as a client, connecting to a given IP and port:"
msgstr ""
"Об'єкт ініціалізується як клієнт, підключається до заданого IP і порту:"

msgid "Get the previously set network peer:"
msgstr "Отримування раніше встановленого однорангового вузла мережі:"

msgid "Checking whether the tree is initialized as a server or client:"
msgstr "Перевірка того, чи дерево ініціалізовано, як сервер, чи як клієнт:"

msgid "Terminating the networking feature:"
msgstr "Закриття функцій мережі:"

msgid ""
"(Although it may make sense to send a message first to let the other peers "
"know you're going away instead of letting the connection close or timeout, "
"depending on your game.)"
msgstr ""
"(Хоча, можливо, варто спочатку надіслати повідомлення, щоб повідомити інші "
"однорангові вузли про свій вихід, замість того, щоб дозволити з’єднанню "
"закритися, чи зробити перерву, залежно від вашої гри.)"

msgid ""
"When exporting to Android, make sure to enable the ``INTERNET`` permission "
"in the Android export preset before exporting the project or using one-click "
"deploy. Otherwise, network communication of any kind will be blocked by "
"Android."
msgstr ""
"Під час експорту в Android обов’язково ввімкніть дозвіл ``INTERNET`` у "
"попередньо налаштованих експортах Android, перш ніж експортувати проект, або "
"використовувати розгортання одним клацанням мишки. Інакше Android заблокує "
"будь-який мережевий зв’язок."

msgid "Managing connections"
msgstr "Управління з'єднаннями"

msgid ""
"Some games accept connections at any time, others during the lobby phase. "
"Godot can be requested to no longer accept connections at any point (see "
"``set_refuse_new_network_connections(bool)`` and related methods on :ref:"
"`SceneTree <class_SceneTree>`). To manage who connects, Godot provides the "
"following signals in SceneTree:"
msgstr ""
"Деякі ігри приймають з'єднання в будь-який час, інші під час фази лобі. "
"Godot, в будь-який момент, можна попросити більше не приймати з’єднання "
"(див. ``set_refuse_new_network_connections(bool)`` і пов’язані методи на :"
"ref:`Дереві Сцени<class_SceneTree>`). Щоб керувати з'єднаннями, Godot надає "
"такі сигнали в Дереві Сцени:"

msgid "Server and Clients:"
msgstr "Сервер і клієнти:"

msgid "``network_peer_connected(int id)``"
msgstr "``network_peer_connected(int id)``"

msgid "``network_peer_disconnected(int id)``"
msgstr "``network_peer_disconnected(int id)``"

msgid ""
"The above signals are called on every peer connected to the server "
"(including on the server) when a new peer connects or disconnects. Clients "
"will connect with a unique ID greater than 1, while network peer ID 1 is "
"always the server. Anything below 1 should be handled as invalid. You can "
"retrieve the ID for the local system via :ref:`SceneTree."
"get_network_unique_id() <class_SceneTree_method_get_network_unique_id>`. "
"These IDs will be useful mostly for lobby management and should generally be "
"stored, as they identify connected peers and thus players. You can also use "
"IDs to send messages only to certain peers."
msgstr ""
"Наведені вище сигнали викликаються на кожному одноранговому вузлі, "
"підключеному до сервера (у тому числі на сервері), коли новий одноранговий "
"вузол підключається, або відключається. Клієнти будуть підключатися з "
"унікальним ідентифікатором, більшим за 1, тоді як сервер завжди має "
"ідентифікатор 1. Все, що нижче 1, слід вважати недійсним. Ви можете отримати "
"ідентифікатор локальної системи за допомогою :ref:`SceneTree."
"get_network_unique_id() <class_SceneTree_method_get_network_unique_id>`. Ці "
"ідентифікатори будуть корисні здебільшого для управління лобі, і зазвичай їх "
"слід зберігати, оскільки вони ідентифікують підключені однорангові вузли і, "
"таким чином, гравців. Ви також можете використовувати ідентифікатори для "
"надсилання повідомлень лише певним одноранговим вузлам."

msgid "Clients:"
msgstr "Клієнти:"

msgid "``connected_to_server``"
msgstr "``connected_to_server``"

msgid "``connection_failed``"
msgstr "``connection_failed``"

msgid "``server_disconnected``"
msgstr ""

msgid ""
"Again, all these functions are mainly useful for lobby management or for "
"adding/removing players on the fly. For these tasks, the server clearly has "
"to work as a server and you have to perform tasks manually such as sending a "
"newly connected player information about other already connected players (e."
"g. their names, stats, etc)."
msgstr ""
"Знову ж таки, всі ці функції в основному корисні для керування лобі, або для "
"додавання/вилучення гравців на льоту. Для цих завдань сервер, безсумнівно, "
"повинен працювати як сервер, і ви повинні виконувати завдання вручну, "
"наприклад надсилати щойно підключеному гравцеві інформацію про інших уже "
"підключених гравців (наприклад, їх імена, статистику тощо)."

msgid ""
"Lobbies can be implemented any way you want, but the most common way is to "
"use a node with the same name across scenes in all peers. Generally, an "
"autoloaded node/singleton is a great fit for this, to always have access to, "
"e.g. \"/root/lobby\"."
msgstr ""
"Лобі можна реалізувати як завгодно, але найпоширенішим способом є "
"використання вузла з однаковою назвою в сценах у всіх однорангових вузлах. "
"Як правило, для цього чудово підходить автоматично завантажений вузол/"
"синглтон, щоб завжди мати доступ, наприклад, \"/root/lobby\"."

msgid "RPC"
msgstr ""

msgid ""
"To communicate between peers, the easiest way is to use RPCs (remote "
"procedure calls). This is implemented as a set of functions in :ref:`Node "
"<class_Node>`:"
msgstr ""
"Для зв'язку між одноранговими вузлами, найпростішим способом є використання "
"RPC (віддалені виклики процедур). Він реалізований як набір функцій у :ref:"
"`Node <class_Node>`:"

msgid "``rpc(\"function_name\", <optional_args>)``"
msgstr ""

msgid "``rpc_id(<peer_id>,\"function_name\", <optional_args>)``"
msgstr ""

msgid "``rpc_unreliable(\"function_name\", <optional_args>)``"
msgstr ""

msgid "``rpc_unreliable_id(<peer_id>, \"function_name\", <optional_args>)``"
msgstr ""

msgid "Synchronizing member variables is also possible:"
msgstr "Також можлива синхронізація членів змінних:"

msgid "``rset(\"variable\", value)``"
msgstr ""

msgid "``rset_id(<peer_id>, \"variable\", value)``"
msgstr ""

msgid "``rset_unreliable(\"variable\", value)``"
msgstr ""

msgid "``rset_unreliable_id(<peer_id>, \"variable\", value)``"
msgstr ""

msgid "Functions can be called in two fashions:"
msgstr "Функції можна викликати двома способами:"

msgid ""
"Reliable: when the function call arrives, an acknowledgement will be sent "
"back; if the acknowledgement isn't received after a certain amount of time, "
"the function call will be re-transmitted."
msgstr ""
"Надійно: коли виклик функції надійде, назад буде надіслано підтвердження; "
"якщо підтвердження не буде отримано через певний час, виклик функції буде "
"передано повторно."

msgid ""
"Unreliable: the function call is sent only once, without checking to see if "
"it arrived or not, but also without any extra overhead."
msgstr ""
"Ненадійно: виклик функції надсилається лише один раз, без перевірки того, чи "
"надійшов він чи ні, але також без зайвих накладних витрат."

msgid ""
"In most cases, reliable is desired. Unreliable is mostly useful when "
"synchronizing object positions (sync must happen constantly, and if a packet "
"is lost, it's not that bad because a new one will eventually arrive and it "
"would likely be outdated because the object moved further in the meantime, "
"even if it was resent reliably)."
msgstr ""
"У більшості випадків потрібен надійний. Ненадійний в основному корисний під "
"час синхронізації позицій об’єктів (синхронізація має відбуватися постійно, "
"і якщо пакет буде втрачено, це не так вже й погано, тому що врешті-решт "
"надійде новий, і втрачений, скоріше за все, буде застарілим, оскільки об’єкт "
"тим часом рухався далі)."

msgid ""
"There is also :ref:`SceneTree.get_rpc_sender_id() "
"<class_SceneTree_method_get_rpc_sender_id>`, which can be used to check "
"which peer (or peer ID) sent an RPC."
msgstr ""
"Існує також :ref:`SceneTree.get_rpc_sender_id() "
"<class_SceneTree_method_get_rpc_sender_id>`, який можна використовувати для "
"перевірки того, який одноранговий вузол (або ідентифікатор однорангового "
"вузла) надіслав RPC."

msgid "Back to lobby"
msgstr "Повернімося до лобі"

msgid ""
"Let's get back to the lobby. Imagine that each player that connects to the "
"server will tell everyone about it."
msgstr ""
"Уявіть, що кожен гравець, який підключається до сервера, розповість про це "
"всім."

msgid ""
"You might have already noticed something different, which is the usage of "
"the ``remote`` keyword on the ``register_player`` function:"
msgstr ""
"Можливо, ви вже помітили щось нове, а саме використання ключа ``remote`` в "
"функції ``register_player``:"

msgid ""
"This keyword is one of many that allow a function to be called by a remote "
"procedure call (RPC). There are six of them total:"
msgstr ""
"Це ключове слово є одним з багатьох, які дозволяють викликати функцію за "
"допомогою віддаленого виклику процедури (RPC). Всього їх є шість:"

msgid "``remote``"
msgstr "``remote``"

msgid "``remotesync``"
msgstr "``remotesync``"

msgid "``puppet``"
msgstr ""

msgid "``puppetsync``"
msgstr "``puppetsync``"

msgid "``master``"
msgstr "``master``"

msgid "``mastersync``"
msgstr "``mastersync``"

msgid ""
"Each of them designate who can call the rpc, and optionally ``sync`` if the "
"RPC can be called locally."
msgstr ""
"Кожен з них вказує, хто може викликати rpc, і додатково ``sync``, якщо RPC "
"можна викликати локально."

msgid ""
"If no rpc keywords are added, Godot will block any attempts to call "
"functions remotely. This makes security work a lot easier (so a client can't "
"call a function to delete a file on another client's system)."
msgstr ""
"Якщо не додати ключові слова rpc, Godot заблокує будь-які спроби віддаленого "
"виклику функцій. Це значно спрощує роботу служби безпеки (так, клієнт не "
"зможе викликати функцію для видалення файлу в системі іншого клієнта)."

msgid ""
"The ``remote`` keyword can be called by any peer, including the server and "
"all clients. The ``puppet`` keyword means a call can be made from the "
"network master to any network puppet. The ``master`` keyword means a call "
"can be made from any network puppet to the network master."
msgstr ""
"Ключове слово ``remote`` може бути викликане будь-яким одноранговим вузлом, "
"включаючи сервер і всіх клієнтів. Ключове слово ``puppet`` означає, що "
"виклик може бути здійснений з головного пристрою мережі до будь-якої "
"мережевої маріонетки. Ключове слово ``master`` означає, що виклик може бути "
"здійснений з будь-якої мережевої маріонетки до головного вузла мережі."

msgid ""
"If ``sync`` is included, the call can also be made locally. For example, to "
"allow the network master to change the player's position on all peers:"
msgstr ""
"Якщо включено ``sync``, виклик також можна здійснювати локально. Наприклад, "
"для того, щоб майстер мережі міг змінювати позицію гравця на всіх "
"однорангових пристроях:"

msgid ""
"You can also use :ref:`SceneTree.get_rpc_sender_id() "
"<class_SceneTree_method_get_rpc_sender_id>` to have more advanced rules on "
"how an rpc can be called."
msgstr ""
"Ви також можете використовувати :ref:`SceneTree.get_rpc_sender_id() "
"<class_SceneTree_method_get_rpc_sender_id>`, щоб мати більш розширені "
"правила виклику rpc."

msgid ""
"These keywords are further explained in :ref:`Synchronizing the game "
"<doc_high_level_multiplayer_synchronizing>`."
msgstr ""
"Ці ключові слова додатково пояснено у :ref:`Синхронізації гри "
"<doc_high_level_multiplayer_synchronizing>`."

msgid ""
"With this, lobby management should be more or less explained. Once you have "
"your game going, you will most likely want to add some extra security to "
"make sure clients don't do anything funny (just validate the info they send "
"from time to time, or before game start). For the sake of simplicity and "
"because each game will share different information, this is not shown here."
msgstr ""
"На цьому управління лобі має бути більш-менш зрозумілим. Коли ви запустите "
"гру, ви, швидше за все, захочете додати додатковий захист, щоб переконатися, "
"що клієнти не роблять нічого сумнівного (просто перевіряйте інформацію, яку "
"вони надсилають час від часу, або перед початком гри). Для простоти та через "
"те, що в кожній грі буде різна інформація, це не показано тут."

msgid "Starting the game"
msgstr "Як розпочати гру"

msgid ""
"Once enough players have gathered in the lobby, the server should probably "
"start the game. This is nothing special in itself, but we'll explain a few "
"nice tricks that can be done at this point to make your life much easier."
msgstr ""
"Після того, як у лобі збереться достатня кількість гравців, сервер повинен "
"почати гру. У цьому немає нічого особливого, але ми пояснимо кілька хороших "
"прийомів, які можна зробити на цьому етапі, щоб значно полегшити ваше життя."

msgid "Player scenes"
msgstr "Сцени гравців"

msgid ""
"In most games, each player will likely have its own scene. Remember that "
"this is a multiplayer game, so in every peer you need to instance **one "
"scene for each player connected to it**. For a 4 player game, each peer "
"needs to instance 4 player nodes."
msgstr ""
"У більшості ігор кожен гравець, так би мовити, буде мати свою власну сцену. "
"Пам’ятайте, що це багатокористувацька гра, тому в кожному однорангові вузлі "
"вам потрібно створити **одну сцену для кожного під’єднаного до нього "
"гравця**. Для гри з 4 гравців кожен одноранговий вузол має створити 4 вузли "
"гравців."

msgid ""
"So, how to name such nodes? In Godot, nodes need to have a unique name. It "
"must also be relatively easy for a player to tell which node represents each "
"player ID."
msgstr ""
"Отже, як назвати такі вузли? У Godot вузли повинні мати унікальну назву. "
"Гравець також повинен відносно легко визначити, який вузол представляє "
"ідентифікатор кожного гравця."

msgid ""
"The solution is to simply name the *root nodes of the instanced player "
"scenes as their network ID*. This way, they will be the same in every peer "
"and RPC will work great! Here is an example:"
msgstr ""
"Рішення полягає в тому, щоб просто називати *кореневі вузли створюваних сцен "
"гравців так само, як ідентифікатор їх мережі*. Таким чином, вони будуть "
"однаковими для всіх однорангових вузлів і RPC працюватиме чудово! Ось "
"приклад:"

msgid ""
"Depending on when you execute pre_configure_game(), you may need to change "
"any calls to ``add_child()`` to be deferred via ``call_deferred()``, as the "
"SceneTree is locked while the scene is being created (e.g. when ``_ready()`` "
"is being called)."
msgstr ""
"Залежно від того, коли ви виконуєте ``pre_configure_game()``, вам може "
"знадобитися відкласти деякі виклики ``add_child()`` за допомогою "
"``call_deferred()``, оскільки Дерево Сцен заблоковано під час створення "
"сцени (наприклад, коли викликається ``_ready()``)."

msgid "Synchronizing game start"
msgstr "Синхронізація початку гри"

msgid ""
"Setting up players might take different amounts of time for every peer due "
"to lag, different hardware, or other reasons. To make sure the game will "
"actually start when everyone is ready, pausing the game until all players "
"are ready can be useful:"
msgstr ""
"Налаштування гравців може зайняти різну кількість часу для кожного "
"однорангового вузла через затримку, різне обладнання, чи інші причини. Щоб "
"переконатися, що гра почнеться, коли всі будуть готові, корисно призупинити "
"гру, доки всі гравці не будуть готові:"

msgid ""
"When the server gets the OK from all the peers, it can tell them to start, "
"as for example:"
msgstr ""
"Коли сервер отримує ДОБРО від усіх однорангових вузлів, він може дати їм "
"вказівку починати, наприклад:"

msgid "Synchronizing the game"
msgstr "Синхронізація гри"

msgid ""
"In most games, the goal of multiplayer networking is that the game runs "
"synchronized on all the peers playing it. Besides supplying an RPC and "
"remote member variable set implementation, Godot adds the concept of network "
"masters."
msgstr ""
"У більшості ігор мета мультиплеєрної мережі полягає в тому, щоб "
"синхронізувати гру по усіх однорангових вузлах, які в неї грають. Окрім "
"реалізації RPC та віддалених змінних членів, Godot додає концепцію майстрів "
"мережі."

msgid "Network master"
msgstr "Майстер мережі"

msgid ""
"The network master of a node is the peer that has the ultimate authority "
"over it."
msgstr ""
"Майстер мережі — це одноранговий вузол, який має атворитетні повноваження."

msgid ""
"When not explicitly set, the network master is inherited from the parent "
"node, which if not changed, is always going to be the server (ID 1). Thus "
"the server has authority over all nodes by default."
msgstr ""
"Якщо його не встановлено явно, майстер мережі успадковується від "
"батьківського вузла, який, якщо його не змінити, завжди є сервером "
"(ідентифікатор 1). Таким чином, за замовчуванням сервер має повноваження над "
"усіма вузлами."

msgid ""
"The network master can be set with the function :ref:`Node."
"set_network_master(id, recursive) <class_Node_method_set_network_master>` "
"(recursive is ``true`` by default and means the network master is "
"recursively set on all child nodes of the node as well)."
msgstr ""
"Майстра мережі можна встановити за допомогою функції :ref:`Node."
"set_network_master(id, recursive) <class_Node_method_set_network_master>` "
"(``recursive`` за замовчуванням рівне ``true`` і означає, що майстер мережі "
"також рекурсивно встановлюється на всіх дочірніх вузлах цього вузла)."

msgid ""
"Checking that a specific node instance on a peer is the network master for "
"this node for all connected peers is done by calling :ref:`Node."
"is_network_master() <class_Node_method_is_network_master>`. This will return "
"``true`` when executed on the server and ``false`` on all client peers."
msgstr ""
"Перевірка того, чи конкретний екземпляр вузла на одноранговому вузлі є "
"майстром мережі, виконується за допомогою виклику :ref:`Node."
"is_network_master() <class_Node_method_is_network_master>`. Виконанні на "
"сервері поверне ``true``, а на однорангових вузлах поверне ``false``."

msgid ""
"If you have paid attention to the previous example, it's possible you "
"noticed that each peer was set to have network master authority for their "
"own player (Node) instead of the server:"
msgstr ""
"Якщо ви звернули увагу на попередній приклад, можливо, ви помітили, що кожен "
"одноранговий вузол був налаштований на повноваження майстра мережі для свого "
"гравця (Вузла) замість сервера:"

msgid ""
"Each time this piece of code is executed on each peer, the peer makes itself "
"master on the node it controls, and all other nodes remain as puppets with "
"the server being their network master."
msgstr ""
"Кожного разу, коли цей фрагмент коду виконується на кожному однорангові "
"вузлі, цей вузол стає сам собі майстром, а всі інші вузли залишаються "
"маріонетками сервера, який є їх майстром мережі."

msgid ""
"To clarify, here is an example of how this looks in the `bomber demo "
"<https://github.com/godotengine/godot-demo-projects/tree/master/networking/"
"multiplayer_bomber>`_:"
msgstr ""
"Щоб уточнити, ось приклад того, як це виглядає в `демо-версії "
"бомбардувальника<https://github.com/godotengine/godot-demo-projects/tree/"
"master/networking/multiplayer_bomber>`_:"

msgid "Master and puppet keywords"
msgstr "Ключові слова master та puppet"

msgid ""
"The real advantage of this model is when used with the ``master``/``puppet`` "
"keywords in GDScript (or their equivalent in C# and Visual Script). "
"Similarly to the ``remote`` keyword, functions can also be tagged with them:"
msgstr ""
"Справжня перевага цієї моделі полягає у використанні ключових слів "
"``master``/``puppet`` у GDScript (або їх еквівалентів у C# та Visual "
"Script). Подібно до ключового слова ``remote``, ними також можна позначати "
"функції:"

msgid "Example bomb code:"
msgstr "Приклад коду бомби:"

msgid "Example player code:"
msgstr "Приклад коду гравця:"

msgid ""
"In the above example, a bomb explodes somewhere (likely managed by whoever "
"is the master of this bomb-node, e.g. the host). The bomb knows the bodies "
"(player nodes) in the area, so it checks that they contain an ``exploded`` "
"method before calling it."
msgstr ""
"У наведеному вище прикладі бомба десь вибухає (імовірно, керована власником "
"цього бомбового вузла, наприклад хостом). Бомба знає тіла (вузли гравців) у "
"цій області, тому вона перевіряє, чи вони містять метод ``exploded``, перш "
"ніж викликати його."

msgid ""
"Recall that each peer has a complete set of instances of player nodes, one "
"instance for each peer (including itself and the host). Each peer has set "
"itself as the master of the instance corresponding to itself, and it has set "
"a different peer as the master for each of the other instances."
msgstr ""
"Нагадаємо, що кожен одноранговий вузол має повний набір екземплярів вузлів "
"гравця, по одному екземпляру для кожного однорангового вузла (включаючи себе "
"та хост). Кожен одноранговий вузол встановив себе як майстра відповідного "
"собі екземпляра, і він встановив іншого однорангового вузла як майстра для "
"кожного іншого екземпляра."

msgid ""
"Now, going back to the call to the ``exploded`` method, the bomb on the host "
"has called it remotely on all bodies in the area that have the method. "
"However, this method is in a player node and has a ``master`` keyword."
msgstr ""
"Тепер повернімося до виклику методу ``exploded``, бомба на хості викликала "
"його віддалено на всіх тілах в області, які мають цей метод. Однак цей метод "
"знаходиться у вузлі гравця і має ключове слово ``master``."

msgid ""
"The ``master`` keyword on the ``exploded`` method in the player node means "
"two things for how this call is made. Firstly, from the perspective of the "
"calling peer (the host), the calling peer will only attempt to remotely call "
"the method on the peer that it has set as the network master of the player "
"node in question. Secondly, from the perspective of the peer the host is "
"sending the call to, the peer will only accept the call if it set itself as "
"the network master of the player node with the method being called (which "
"has the ``master`` keyword). This works well as long as all peers agree on "
"who is the master of what."
msgstr ""
"Ключове слово ``master`` на методі ``exploded`` у вузлі гравця означає дві "
"речі для того, як здійснюється цей виклик. По-перше, з точки зору "
"однорангового вузла, який робить виклик (хост), він лише намагатиметься "
"віддалено викликати метод на однорангових вузлах, які він встановив як "
"майстри мережі відповідного вузла гравця. По-друге, з точки зору "
"однорангового вузла, якому хост надсилає виклик, одноранговий вузол прийме "
"виклик лише в тому випадку, якщо він встановив себе як майстра мережі вузла "
"гравця з методом, який викликається (який має ключове слово ``master``). Це "
"добре працює, якщо всі однорангові вузли погоджуються з тим, хто чому є "
"майстром."

msgid ""
"The above setup means that only the peer who owns the affected body will be "
"responsible for telling all the other peers that its body was stunned, after "
"being remotely instructed to do so by the host's bomb. The owning peer "
"therefore (still in the ``exploded`` method) tells all the other peers that "
"its player node was stunned. The peer does this by remotely calling the "
"``stun`` method on all instances of that player node (on the other peers). "
"Because the ``stun`` method has the ``puppet`` keyword, only peers who did "
"not set themselves as the network master of the node will call it (in other "
"words, those peers are set as puppets for that node by virtue of not being "
"the network master of it)."
msgstr ""
"Вищенаведене налаштування означає, що лише той, хто володіє ураженим тілом, "
"буде відповідати за повідомлення всіх інших однорангових вузлів про те, що "
"його тіло було уражене, після того, як дистанційно отримає вказівку зробити "
"це від бомби хоста. Таким чином, одноранговий вузол-власник (досі в методі "
"``exploded``) повідомляє всім іншим одноранговим вузлам, що його вузол "
"гравця був уражений. Одноранговий вузол робить це шляхом віддаленого виклику "
"методу ``stun`` на всіх екземплярах цього вузла гравця (на інших "
"однорангових вузлах). Оскільки метод ``stun`` має ключове слово ``puppet``, "
"його викликають лише однорангові вузли, які не встановили себе майстрами "
"мережі (іншими словами, ці однорангові вузли встановлюються як маріонетки "
"для цього вузла через те, що вони не є його майстрами мережі)."

msgid ""
"The result of this call to ``stun`` is to make the player look stunned on "
"the screen of all the peers, including the current network master peer (due "
"to the local call to ``stun`` after ``rpc(\"stun\")``)."
msgstr ""
"Виклик ``stun`` змушує гравця виглядати ураженим на екранах всіх "
"однорангових вузлів, включаючи поточний одноранговий вузол майстра мережі "
"(через локальний виклик ``stun`` після ``rpc(\"stun\")``)."

msgid ""
"The master of the bomb (the host) repeats the above steps for each of the "
"bodies in the area, such that all the instances of any player in the bomb "
"area get stunned on the screens of all the peers."
msgstr ""
"Майстер бомби (хост) повторює вищезазначені кроки для кожного тіла в зоні, "
"так що всі екземпляри будь-якого гравця в зоні бомби уражуються на екранах "
"усіх однорангових вузлів."

msgid ""
"Note that you could also send the ``stun()`` message only to a specific "
"player by using ``rpc_id(<id>, \"exploded\", bomb_owner)``. This may not "
"make much sense for an area-of-effect case like the bomb, but might in other "
"cases, like single target damage."
msgstr ""
"Зауважте, що ви також можете надіслати повідомлення ``stun()`` лише певному "
"гравцеві за допомогою ``rpc_id(<id>, \"exploded\", bomb_owner)``. Це може не "
"мати великого сенсу для об'ємних ефектів, як-от бомба, але може мати сенс в "
"інших випадках, наприклад, ушкодження однієї цілі."

msgid "Exporting for dedicated servers"
msgstr "Експорт для виділених серверів"

msgid ""
"Once you've made a multiplayer game, you may want to export it to run it on "
"a dedicated server with no GPU available. See :ref:"
"`doc_exporting_for_dedicated_servers` for more information."
msgstr ""
"Після створення багатокористувацької гри ви можете експортувати її для "
"запуску на виділеному сервері без доступного графічного процесора. Дивіться :"
"ref:`doc_exporting_for_dedicated_servers` для додаткової інформації."

msgid ""
"The code samples on this page aren't designed to run on a dedicated server. "
"You'll have to modify them so the server isn't considered to be a player. "
"You'll also have to modify the game starting mechanism so that the first "
"player who joins can start the game."
msgstr ""
"Зразки коду на цій сторінці не призначені для роботи на виділеному сервері. "
"Вам доведеться змінити їх, щоб сервер не вважався гравцем. Вам також "
"доведеться змінити механізм початку гри, щоб перший гравець, який "
"приєднається, міг почати гру."

msgid ""
"The bomberman example here is largely for illustrational purposes, and does "
"not do anything on the host-side to handle the case where a peer uses a "
"custom client to cheat by for example refusing to stun itself. In the "
"current implementation such cheating is perfectly possible because each "
"client is the network master of its own player, and the network master of a "
"player is the one which decides whether to call the I-was-stunned method "
"(``stun``) on all of the other peers and itself."
msgstr ""
"Приклад Bomberman тут переважно для ілюстративних цілей і не робить нічого "
"на стороні хоста, щоб обробити випадок, коли одноранговий вузол користувача "
"використовує користувацький клієнт для шахрайства, наприклад, відмовляючись "
"оглушити себе. У поточній реалізації такий обман цілком можливий, тому що "
"кожен клієнт є майстром мережі свого власного гравця, а мережевий майстер "
"гравця — це той, хто вирішує, чи викликати метод \"Я-був-"
"уражений\" (``stun``) для всіх інших однорангових вузлів і себе."

msgid "Translation status"
msgstr "Стан перекладу"
