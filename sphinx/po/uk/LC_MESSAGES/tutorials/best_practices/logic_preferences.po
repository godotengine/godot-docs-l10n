# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Logic preferences"
msgstr "Вибір логіки"

msgid ""
"Ever wondered whether one should approach problem X with strategy Y or Z? "
"This article covers a variety of topics related to these dilemmas."
msgstr ""
"Ви ніколи не замислювались, чи слід підходити до проблеми X із стратегією Y "
"чи Z? Ця стаття охоплює різноманітні теми, пов’язані з цими дилемами."

msgid "Adding nodes and changing properties: which first?"
msgstr ""

msgid ""
"When initializing nodes from a script at runtime, you may need to change "
"properties such as the node's name or position. A common dilemma is, when "
"should you change those values?"
msgstr ""

msgid ""
"It is the best practice to change values on a node before adding it to the "
"scene tree. Some property's setters have code to update other corresponding "
"values, and that code can be slow! For most cases, this code has no impact "
"on your game's performance, but in heavy use cases such as procedural "
"generation, it can bring your game to a crawl."
msgstr ""

msgid ""
"For these reasons, it is always a best practice to set the initial values of "
"a node before adding it to the scene tree."
msgstr ""

msgid "Loading vs. preloading"
msgstr "Завантаження та попереднє завантаження"

msgid ""
"In GDScript, there exists the global :ref:`preload "
"<class_@GDScript_method_preload>` method. It loads resources as early as "
"possible to front-load the \"loading\" operations and avoid loading "
"resources while in the middle of performance-sensitive code."
msgstr ""
"У GDScript існує глобальний метод :ref:`попереднє "
"завантаження<class_@GDScript_method_preload>`. Він завантажує ресурси "
"якомога раніше, щоб попередньо завантажити операції \"завантаження\" і "
"уникати завантаження ресурсів, перебуваючи в середині коду, що чутливий до "
"продуктивності."

#, fuzzy
msgid ""
"Its counterpart, the :ref:`load <class_@GDScript_method_load>` method, loads "
"a resource only when it reaches the load statement. That is, it will load a "
"resource in-place which can cause slowdowns when it occurs in the middle of "
"sensitive processes. The ``load()`` function is also an alias for :ref:"
"`ResourceLoader.load(path) <class_ResourceLoader_method_load>` which is "
"accessible to *all* scripting languages."
msgstr ""
"Його аналог, метод :ref:`завантаження<class_@GDScript_method_load>`, "
"завантажує ресурс лише тоді, коли він досягає оператора завантаження. Тобто "
"він буде завантажувати ресурс на місці, що може спричинити уповільнення, "
"коли це відбувається в середині чутливих процесів. Функція ``load`` також є "
"псевдонімом для :ref:`ResourceLoader.load(шлях) "
"<class_ResourceLoader_method_load>`, який доступний для *всіх* скриптових "
"мов."

msgid ""
"So, when exactly does preloading occur versus loading, and when should one "
"use either? Let's see an example:"
msgstr ""
"Отже, коли саме відбувається попереднє завантаження порівняно із простим "
"завантаженням, і коли слід використовувати кожне з них? Подивимось приклад:"

msgid ""
"Preloading allows the script to handle all the loading the moment one loads "
"the script. Preloading is useful, but there are also times when one doesn't "
"wish for it. To distinguish these situations, there are a few things one can "
"consider:"
msgstr ""
"Попереднє завантаження дозволяє скрипту обробляти все завантаження в момент "
"завантаження скрипта. Попереднє завантаження корисно, але бувають випадки, "
"коли ніхто цього не бажає. Щоб розрізнити ці ситуації, можна розглянути "
"кілька ситуацій:"

msgid ""
"If one cannot determine when the script might load, then preloading a "
"resource, especially a scene or script, could result in further loads one "
"does not expect. This could lead to unintentional, variable-length load "
"times on top of the original script's load operations."
msgstr ""
"Якщо не вдається визначити, коли скрипт може завантажитися, то попереднє "
"завантаження ресурсу, особливо сцени чи скрипта, може призвести до подальших "
"завантажень, яких ми не очікуємо. Це може призвести до ненавмисного "
"завантаження змінних поверх операцій завантаження оригінального скрипта."

msgid ""
"If something else could replace the value (like a scene's exported "
"initialization), then preloading the value has no meaning. This point isn't "
"a significant factor if one intends to always create the script on its own."
msgstr ""
"Якщо щось інше може замінити значення (наприклад, ініціалізація "
"експортованої сцени), то попереднє завантаження значення не має сенсу. Цей "
"момент не є суттєвим фактором, якщо кожен має намір завжди створювати скрипт "
"самостійно."

msgid ""
"If one wishes only to 'import' another class resource (script or scene), "
"then using a preloaded constant is often the best course of action. However, "
"in exceptional cases, one may wish not to do this:"
msgstr ""
"Якщо хтось бажає лише 'імпортувати' інший ресурс класу (скрипт, або сцену), "
"то використання попередньо завантаженої константи часто є найкращим "
"рішенням. Однак у виняткових випадках можна не бажати цього робити:"

#, fuzzy
msgid ""
"If the 'imported' class is liable to change, then it should be a property "
"instead, initialized either using an ``export`` or a ``load()`` (and perhaps "
"not even initialized until later)."
msgstr ""
"Якщо 'імпортований' клас може змінитися, тоді він повинен бути властивістю, "
"і ініційованим за допомогою ``export``, або ``load``, (можливо, навіть не "
"ініційованим до певного часу)."

#, fuzzy
msgid ""
"If the script requires a great many dependencies, and one does not wish to "
"consume so much memory, then one may wish to, load and unload various "
"dependencies at runtime as circumstances change. If one preloads resources "
"into constants, then the only way to unload these resources would be to "
"unload the entire script. If they are instead loaded properties, then one "
"can set them to ``null`` and remove all references to the resource entirely "
"(which, as a :ref:`RefCounted <class_RefCounted>`-extending type, will cause "
"the resources to delete themselves from memory)."
msgstr ""
"Якщо скрипт вимагає великої кількості залежностей, і розробник не бажає "
"споживати стільки пам'яті, тоді варто, завантажувати та вивантажувати різні "
"залежності під час виконання, при зміні обставин. Якщо попередньо "
"завантажити ресурси в константи, тоді єдиним способом вивантажити ці ресурси "
"буде вивантажити весь скрипт. Якщо вони замість цього завантажені у "
"властивості, тоді можна встановити їх на ``null`` і повністю видалити всі "
"посилання на ресурс (що, як тип :ref:`Посилання<class_Reference>`, що "
"розширюється, призведе до того, що ресурси видаляться з пам'яті)."

msgid "Large levels: static vs. dynamic"
msgstr "Великі рівні: статичний та динамічний"

msgid ""
"If one is creating a large level, which circumstances are most appropriate? "
"Should they create the level as one static space? Or should they load the "
"level in pieces and shift the world's content as needed?"
msgstr ""
"Якщо хтось створює великий рівень, які обставини є найбільш доречними? Чи "
"повинні вони створювати рівень як один статичний простір? Або вони повинні "
"завантажувати рівень по шматочках і переміщувати вміст світу за потреби?"

#, fuzzy
msgid ""
"Well, the simple answer is, \"when the performance requires it.\" The "
"dilemma associated with the two options is one of the age-old programming "
"choices: does one optimize memory over speed, or vice versa?"
msgstr ""
"Ну, проста відповідь: \"коли виконання цього вимагає\". Дилема, пов’язана з "
"цими двома варіантами, є одним із найстаріших питань програмування: чи "
"оптимізувати пам’ять над швидкістю, чи навпаки?"

msgid ""
"The naive answer is to use a static level that loads everything at once. "
"But, depending on the project, this could consume a large amount of memory. "
"Wasting users' RAM leads to programs running slow or outright crashing from "
"everything else the computer tries to do at the same time."
msgstr ""
"Наївна відповідь полягає у використанні статичного рівня, який завантажує "
"все відразу. Залежно від проєкту, це може зайняти великий обсяг пам'яті. "
"Витрата оперативної пам'яті користувачів призводить до того, що програми "
"працюють повільно або взагалі вилітають."

msgid ""
"No matter what, one should break larger scenes into smaller ones (to aid in "
"reusability of assets). Developers can then design a node that manages the "
"creation/loading and deletion/unloading of resources and nodes in real-time. "
"Games with large and varied environments or procedurally generated elements "
"often implement these strategies to avoid wasting memory."
msgstr ""
"Незважаючи ні на що, слід розбивати великі сцени на менші (для сприяння "
"повторному використанню активів). Потім розробники можуть спроєктувати "
"вузол, який керує створенням/завантаженням та видаленням/вивантаженням "
"ресурсів та вузлів у режимі реального часу. Ігри з великим та різноманітним "
"середовищем, або процедурно сформованими елементами, часто реалізують ці "
"стратегії, щоб уникнути марнотратства пам'яті."

msgid ""
"On the flip side, coding a dynamic system is more complex, i.e. uses more "
"programmed logic, which results in opportunities for errors and bugs. If one "
"isn't careful, they can develop a system that bloats the technical debt of "
"the application."
msgstr ""
"З іншого боку, кодування динамічної системи є складнішим, тобто використовує "
"більше програмованої логіки, що призводить до можливостей для помилок та "
"збоїв. Якщо хтось не буде обережним, вони можуть створити систему, яка "
"роздує технічний борг програми."

msgid "As such, the best options would be..."
msgstr "Таким чином, найкращими варіантами будуть ..."

msgid "To use a static level for smaller games."
msgstr "Використовувати статичний рівень для ігор менших розмірів."

msgid ""
"If one has the time/resources on a medium/large game, create a library or "
"plugin that can code the management of nodes and resources. If refined over "
"time, so as to improve usability and stability, then it could evolve into a "
"reliable tool across projects."
msgstr ""
"Якщо у вас є час/ресурси для середньої/великої гри, створіть бібліотеку або "
"плагін, який може кодувати управління вузлами та ресурсами. Якщо його "
"вдосконалити з часом, щоб покращити зручність використання та стабільність, "
"він міг би стати надійним інструментом для різних проєктів."

msgid ""
"Code the dynamic logic for a medium/large game because one has the coding "
"skills, but not the time or resources to refine the code (game's gotta get "
"done). Could potentially refactor later to outsource the code into a plugin."
msgstr ""
"Кодуйте динамічну логіку для середньої/великої гри, якщо маєте навички "
"кодування, але не час або ресурси для вдосконалення коду (гру потрібно "
"завершити). Пізніше це може потенційно рефакторировать, щоб передати код на "
"плагін."

msgid ""
"For an example of the various ways one can swap scenes around at runtime, "
"please see the :ref:`\"Change scenes manually\" "
"<doc_change_scenes_manually>` documentation."
msgstr ""
"Для прикладу різних способів обміну сценами під час виконання дивіться "
"документацію :ref:`\"Зміна сцен вручну\"<doc_change_scenes_manually>`."

msgid "Translation status"
msgstr "Стан перекладу"
