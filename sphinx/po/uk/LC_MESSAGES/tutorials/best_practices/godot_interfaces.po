# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Godot interfaces"
msgstr "Інтерфейси Godot"

msgid ""
"Often one needs scripts that rely on other objects for features. There are 2 "
"parts to this process:"
msgstr ""
"Часто потрібні скрипти, які покладаються на інші об'єкти для функцій. Цей "
"процес має 2 частини:"

msgid "Acquiring a reference to the object that presumably has the features."
msgstr "Отримання посилання на об’єкт, який, імовірно, має особливості."

msgid "Accessing the data or logic from the object."
msgstr "Доступ до даних або логіки від об’єкта."

msgid "The rest of this tutorial outlines the various ways of doing all this."
msgstr "Решта цього посібника описує різні способи зробити все це."

msgid "Acquiring object references"
msgstr "Отримання посилань на об’єкти"

msgid ""
"For all :ref:`Object <class_Object>`\\s, the most basic way of referencing "
"them is to get a reference to an existing object from another acquired "
"instance."
msgstr ""
"Для всіх :ref:`Об'єктів <class_Object>` основним способом посилання на них, "
"є отримання посилання на існуючий об’єкт з іншого придбаного екземпляра."

msgid ""
"The same principle applies for :ref:`RefCounted <class_RefCounted>` objects. "
"While users often access :ref:`Node <class_Node>` and :ref:`Resource "
"<class_Resource>` this way, alternative measures are available."
msgstr ""
"Той самий принцип застосовується для об'єктів :ref:`RefCounted "
"<клас_RefCounted>`. Хоча користувачі часто отримують доступ до :ref:`Node "
"<class_Node>` та :ref:`Resource <class_Resource>` у такий спосіб, існують "
"альтернативні способи."

msgid ""
"Instead of property or method access, one can get Resources by load access."
msgstr ""
"Замість доступу до властивостей або методів можна отримати Ресурси за "
"допомогою доступу до завантаження."

msgid "Note the following:"
msgstr "Пам'ятайте наступне:"

msgid "There are many ways in which a language can load such resources."
msgstr "Існує багато способів, якими мова може завантажити такі ресурси."

msgid ""
"When designing how objects will access data, don't forget that one can pass "
"resources around as references as well."
msgstr ""
"Розробляючи спосіб доступу об'єктів до даних, не забувайте, що можна "
"передавати ресурси як посилання."

msgid ""
"Keep in mind that loading a resource fetches the cached resource instance "
"maintained by the engine. To get a new object, one must :ref:`duplicate "
"<class_Resource_method_duplicate>` an existing reference or instantiate one "
"from scratch with ``new()``."
msgstr ""
"Майте на увазі, що завантаження ресурсу отримує кешований екземпляр ресурсу, "
"який підтримує движок. Щоб отримати новий об'єкт, потрібно :ref:"
"`продублювати<class_Resource_method_duplicate>` існуюче посилання або "
"створити його з нуля з допомогою ``new()``."

msgid "Nodes likewise have an alternative access point: the SceneTree."
msgstr "Вузли також мають альтернативну точку доступу: Дерево Сцен."

msgid "Accessing data or logic from an object"
msgstr "Доступ до даних або логіки від об’єкта"

msgid ""
"Godot's scripting API is duck-typed. This means that if a script executes an "
"operation, Godot doesn't validate that it supports the operation by "
"**type**. It instead checks that the object **implements** the individual "
"method."
msgstr ""
"API скриптів Godot є качиною типізацією. Це означає, що якщо скрипт виконує "
"операцію, Godot не перевіряє, чи підтримується операція за **типом**. "
"Натомість він перевіряє, чи **реалізує об'єкт** індивідуальний метод."

msgid ""
"For example, the :ref:`CanvasItem <class_CanvasItem>` class has a "
"``visible`` property. All properties exposed to the scripting API are in "
"fact a setter and getter pair bound to a name. If one tried to access :ref:"
"`CanvasItem.visible <class_CanvasItem_property_visible>`, then Godot would "
"do the following checks, in order:"
msgstr ""
"Наприклад, клас :ref:`CanvasItem <class_CanvasItem>` має властивість "
"``visible``. Усі властивості, які піддаються API скриптів, насправді є "
"парами сеттер та геттер, прив'язаними до імені. Якби хтось спробував "
"отримати доступ до :ref:`CanvasItem.visible "
"<class_CanvasItem_property_visible>`, то Godot зробив би наступні перевірки "
"по порядку:"

msgid ""
"If the object has a script attached, it will attempt to set the property "
"through the script. This leaves open the opportunity for scripts to override "
"a property defined on a base object by overriding the setter method for the "
"property."
msgstr ""
"Якщо до об'єкта прикріплений скрипт, він спробує встановити властивість за "
"допомогою скрипта. Це залишає відкритою можливість для скриптів замінити "
"властивість, визначену на базовому об’єкті, замінивши метод сеттера для "
"властивості."

msgid ""
"If the script does not have the property, it performs a HashMap lookup in "
"the ClassDB for the \"visible\" property against the CanvasItem class and "
"all of its inherited types. If found, it will call the bound setter or "
"getter. For more information about HashMaps, see the :ref:`data preferences "
"<doc_data_preferences>` docs."
msgstr ""
"Якщо скрипт не має властивості, він виконує пошук HashMap у ClassDB для "
"властивості \"visible\" класу CanvasItem та всіх його успадкованих типів. "
"При знаходженні, він викличе пов’язаного сетера або геттера. Для отримання "
"додаткової інформації про HashMaps дивіться документи по :ref:`налаштуванні "
"даних<doc_data_preferences>`."

msgid ""
"If not found, it does an explicit check to see if the user wants to access "
"the \"script\" or \"meta\" properties."
msgstr ""
"Якщо пошук буде не вдалий, він явно перевіряє, чи хоче користувач отримати "
"доступ до властивостей \"script\" або \"meta\"."

msgid ""
"If not, it checks for a ``_set``/``_get`` implementation (depending on type "
"of access) in the CanvasItem and its inherited types. These methods can "
"execute logic that gives the impression that the Object has a property. This "
"is also the case with the ``_get_property_list`` method."
msgstr ""
"Якщо ні, то він перевіряє наявність реалізації ``_set``/``_get`` (залежно "
"від типу доступу) у CanvasItem та його успадкованих типах. Ці методи можуть "
"виконувати логіку, яка створює враження, що Об'єкт має властивість. Це також "
"стосується метода ``_get_property_list``."

msgid ""
"Note that this happens even for non-legal symbol names, such as names "
"starting with a digit or containing a slash."
msgstr ""

msgid ""
"As a result, this duck-typed system can locate a property either in the "
"script, the object's class, or any class that object inherits, but only for "
"things which extend Object."
msgstr ""
"Як результат, система качиної типізації, може знаходити властивість або у "
"скрипт, і в класі об’єкта, і в будь-якому класі, який об’єкт успадковує, але "
"лише для речей, які розширюють Об’єкт."

msgid ""
"Godot provides a variety of options for performing runtime checks on these "
"accesses:"
msgstr "Godot пропонує безліч варіантів для виконання таких перевірок:"

msgid ""
"A duck-typed property access. These will be property checks (as described "
"above). If the operation isn't supported by the object, execution will halt."
msgstr ""
"Доступ до властивостей з типом \"качка\". Це будуть перевірки властивостей "
"(як описано вище). Якщо операція не підтримується об'єктом, виконання буде "
"зупинено."

msgid ""
"A method check. In the case of :ref:`CanvasItem.visible "
"<class_CanvasItem_property_visible>`, one can access the methods, "
"``set_visible`` and ``is_visible`` like any other method."
msgstr ""
"Перевірка метода. У випадку з :ref:`CanvasItem.visible "
"<class_CanvasItem_property_visible>`, можна отримати доступ до методів "
"``set_visible`` і ``is_visible`` як до будь-якого іншого методу."

msgid ""
"Outsource the access to a :ref:`Callable <class_Callable>`. These may be "
"useful in cases where one needs the max level of freedom from dependencies. "
"In this case, one relies on an external context to setup the method."
msgstr ""
"Аутсорсинг доступу до :ref:`Callable <class_Callable>`. Це може бути корисно "
"у випадках, коли потрібен максимальний рівень свободи від залежностей. У "
"цьому випадку ви покладаєтесь на зовнішній контекст для налаштування методу."

msgid ""
"These strategies contribute to Godot's flexible design. Between them, users "
"have a breadth of tools to meet their specific needs."
msgstr ""
"Цим стратегіям сприяє гнучка архітектура Godot. Окрім них користувачі мають "
"широкий спектр інструментів для задоволення своїх конкретних потреб."

msgid "Translation status"
msgstr "Стан перекладу"
