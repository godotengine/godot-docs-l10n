# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Scene organization"
msgstr "Організація сцени"

msgid ""
"This article covers topics related to the effective organization of scene "
"content. Which nodes should one use? Where should one place them? How should "
"they interact?"
msgstr ""
"Ця стаття охоплює теми, що стосуються ефективної організації вмісту сцени. "
"Які вузли слід використовувати? Де їх слід розмістити? Як вони повинні "
"взаємодіяти?"

msgid "How to build relationships effectively"
msgstr "Як ефективно будувати залежності"

msgid ""
"When Godot users begin crafting their own scenes, they often run into the "
"following problem:"
msgstr ""
"Коли користувачі Godot починають створювати свої сцени, вони часто "
"стикаються з такою проблемою:"

msgid ""
"They create their first scene and fill it with content only to eventually "
"end up saving branches of their scene into separate scenes as the nagging "
"feeling that they should split things up starts to accumulate. However, they "
"then notice that the hard references they were able to rely on before are no "
"longer possible. Re-using the scene in multiple places creates issues "
"because the node paths do not find their targets and signal connections "
"established in the editor break."
msgstr ""
"Вони створюють свою першу сцену і наповнюють її вмістом лише для того, щоб "
"врешті-решт зберегти гілки своєї сцени в окремі сцени, оскільки починає "
"накопичуватися неприємне відчуття, що сцену потрібно розбити на кілька "
"окремих. Однак тоді вони помічають, що надійні посилання, на які вони могли "
"покластися раніше, стають непрацездатними. Повторне використання сцени в "
"кількох місцях створює проблеми, оскільки шляхи вузлів не знаходять своїх "
"цілей і встановлені сигнальні зв’язки розірвані."

msgid ""
"To fix these problems, one must instantiate the sub-scenes without them "
"requiring details about their environment. One needs to be able to trust "
"that the sub-scene will create itself without being picky about how one uses "
"it."
msgstr ""
"Щоб виправити ці проблеми, потрібно створити екземпляр під-сцени, що не "
"вимагає деталей про своє оточення. Потрібно мати можливість вірити, що під-"
"сцена створить себе, не звертаючи уваги на те, як хтось її використовує."

msgid ""
"One of the biggest things to consider in OOP is maintaining focused, "
"singular-purpose classes with `loose coupling <https://en.wikipedia.org/wiki/"
"Loose_coupling>`_ to other parts of the codebase. This keeps the size of "
"objects small (for maintainability) and improves their reusability."
msgstr ""
"Одна з найбільших речей, яку слід враховувати в ООП, - це підтримка "
"цілеспрямованих класів особливого призначення з `вільним зв'язком <https://"
"en.wikipedia.org/wiki/Loose_coupling>`_ з іншими частинами кодової бази. Це "
"зменшує розмір об’єктів (для ремонтопридатності) та покращує їх повторне "
"використання."

msgid ""
"These OOP best practices have *several* implications for best practices in "
"scene structure and script usage."
msgstr ""
"Ці найкращі практики ООП мають *деяку* причетність до найкращих практик у "
"структурі сцени та використанні скриптів."

msgid ""
"**If at all possible, one should design scenes to have no dependencies.** "
"That is, one should create scenes that keep everything they need within "
"themselves."
msgstr ""
"**Якщо це можливо, слід розробляти незалежні сцени.** Тобто слід створювати "
"сцени, які зберігають усе необхідне в собі."

msgid ""
"If a scene must interact with an external context, experienced developers "
"recommend the use of `Dependency Injection <https://en.wikipedia.org/wiki/"
"Dependency_injection>`_. This technique involves having a high-level API "
"provide the dependencies of the low-level API. Why do this? Because classes "
"which rely on their external environment can inadvertently trigger bugs and "
"unexpected behavior."
msgstr ""
"Якщо сцена повинна взаємодіяти із зовнішнім контекстом, досвідчені "
"розробники рекомендують використовувати `Dependency Injection (Ін'єкцію "
"Залежності)<https://en.wikipedia.org/wiki/Dependency_injection>`_. Ця "
"техніка передбачає наявність API високого рівня, що забезпечує залежності "
"API низького рівня. Навіщо це робити? Просто класи, які покладаються на своє "
"зовнішнє середовище, можуть ненавмисно викликати помилки та несподівану "
"поведінку."

msgid ""
"To do this, one must expose data and then rely on a parent context to "
"initialize it:"
msgstr ""
"Для цього потрібно виставити дані, а потім покластися на батьківський "
"контекст для їх ініціалізації:"

msgid ""
"Connect to a signal. Extremely safe, but should be used only to \"respond\" "
"to behavior, not start it. By convention, signal names are usually past-"
"tense verbs like \"entered\", \"skill_activated\", or \"item_collected\"."
msgstr ""
"Підключення до сигналу. Надзвичайно безпечний, але повинен використовуватися "
"лише для \"реагування\" на поведінку, а не для її запуску. Зазвичай назви "
"сигналів - це дієслова в минулому часі, як-от \"увійшов\", \"уміння "
"активовано\" або \"предмет зібрано\"."

msgid "Call a method. Used to start behavior."
msgstr "Викличте метод. Використовується для початку поведінки."

msgid ""
"Initialize a :ref:`Callable <class_Callable>` property. Safer than a method "
"as ownership of the method is unnecessary. Used to start behavior."
msgstr ""
"Ініціалізувати властивість :ref:`Callable <class_Callable>`. Безпечніше, ніж "
"метод, оскільки володіння методом не є обов'язковим. Використовується для "
"запуску поведінки."

msgid "Initialize a Node or other Object reference."
msgstr "Ініціалізуйте посилання на Вузол або інший Об’єкт."

msgid "Initialize a NodePath."
msgstr "Ініціалізуйте NodePath *(Шлях вузла)*."

msgid ""
"These options hide the points of access from the child node. This in turn "
"keeps the child **loosely coupled** to its environment. One can reuse it in "
"another context without any extra changes to its API."
msgstr ""
"Ці опції приховують точки доступу з дочірнього вузла. Це, в свою чергу, "
"зберігає дочірню вершину **слабко пов'язаною** з її оточенням. Ви можете "
"повторно використовувати його в іншому контексті без будь-яких додаткових "
"змін у його API."

msgid ""
"Although the examples above illustrate parent-child relationships, the same "
"principles apply towards all object relations. Nodes which are siblings "
"should only be aware of their hierarchies while an ancestor mediates their "
"communications and references."
msgstr ""
"Хоча наведені вище приклади ілюструють зв'язок предка-нащадка, однакові "
"принципи застосовуються до всіх об'єктних відносин. Вузли, які є сусідніми, "
"повинні знати лише про їх ієрархію, тоді як предок опосередковує їх зв'язки "
"та посилання."

msgid ""
"The same principles also apply to non-Node objects that maintain "
"dependencies on other objects. Whichever object actually owns the objects "
"should manage the relationships between them."
msgstr ""
"Ті самі принципи також застосовуються до невузлових об'єктів, які "
"підтримують залежності від інших об'єктів. Який би об'єкт насправді не був "
"власником об'єктів, він повинен керувати відносинами між ними."

msgid ""
"One should favor keeping data in-house (internal to a scene) though as "
"placing a dependency on an external context, even a loosely coupled one, "
"still means that the node will expect something in its environment to be "
"true. The project's design philosophies should prevent this from happening. "
"If not, the code's inherent liabilities will force developers to use "
"documentation to keep track of object relations on a microscopic scale; this "
"is otherwise known as development hell. Writing code that relies on external "
"documentation for one to use it safely is error-prone by default."
msgstr ""
"Слід віддавати перевагу збереженню даних *у приміщенні* (всередині сцени), "
"хоча розміщення залежності від зовнішнього контексту, навіть слабо "
"пов'язаної, все одно означає, що вузол буде очікувати, що щось у його "
"середовищі буде точно. Філософія дизайну проєкта повинна запобігти цьому. "
"Якщо ні, властиві коду зобов’язання змусять розробників використовувати "
"документацію для відстеження об’єктних відносин у мікроскопічному масштабі; "
"це ще називають пеклом розвитку. Написання коду, який покладається на "
"зовнішню документацію для безпечного використання, за замовчуванням схильне "
"до помилок."

msgid ""
"To avoid creating and maintaining such documentation, one converts the "
"dependent node (\"child\" above) into a tool script that implements "
"``_get_configuration_warnings()``. Returning a non-empty PackedStringArray "
"from it will make the Scene dock generate a warning icon with the string(s) "
"as a tooltip by the node. This is the same icon that appears for nodes such "
"as the :ref:`Area2D <class_Area2D>` node when it has no child :ref:"
"`CollisionShape2D <class_CollisionShape2D>` nodes defined. The editor then "
"self-documents the scene through the script code. No content duplication via "
"documentation is necessary."
msgstr ""
"Щоб уникнути створення та ведення такої документації, можна перетворити "
"залежний вузол (\"дочірній\" вище) на інструментальний скрипт, який реалізує "
"``_get_configuration_warnings()``. Повернення непорожнього масиву "
"PackedStringArray з нього змусить док Сцени згенерувати піктограму "
"попередження з рядком(ами) у вигляді підказки біля вузла. Це та сама "
"піктограма, яка з'являється для таких вузлів, як вузол :ref:`Area2D "
"<class_Area2D>`, якщо для нього не визначено дочірніх вузлів :ref:"
"`CollisionShape2D <class_CollisionShape2D>`. Після цього редактор самостійно "
"документує сцену за допомогою коду скрипту. Дублювання вмісту за допомогою "
"документування не потрібне."

msgid ""
"A GUI like this can better inform project users of critical information "
"about a Node. Does it have external dependencies? Have those dependencies "
"been satisfied? Other programmers, and especially designers and writers, "
"will need clear instructions in the messages telling them what to do to "
"configure it."
msgstr ""
"Такий графічний інтерфейс може краще інформувати користувачів проєкту про "
"критичну інформацію про Вузол. Чи є у нього зовнішні залежності? Чи були "
"задоволені ці залежності? Іншим програмістам, а особливо дизайнерам і "
"авторам, у повідомленнях будуть потрібні чіткі інструкції, які "
"вказуватимуть, що робити для його налаштування."

msgid ""
"So, why does all this complex switcharoo work? Well, because scenes operate "
"best when they operate alone. If unable to work alone, then working with "
"others anonymously (with minimal hard dependencies, i.e. loose coupling) is "
"the next best thing. Inevitably, changes may need to be made to a class and "
"if these changes cause it to interact with other scenes in unforeseen ways, "
"then things will start to break down. The whole point of all this "
"indirection is to avoid ending up in a situation where changing one class "
"results in adversely effecting other classes dependent on it."
msgstr ""
"Тож, чому вся ця складна система працює? Тому що сцени працюють найкраще, "
"коли вони працюють поодинці. Якщо вони не можуть працювати наодинці, то "
"наступним найкращим варіантом буде анонімна робота з іншими (з мінімальними "
"жорсткими залежностями, тобто слабким зв'язком). Неминуче може знадобитися "
"внести зміни до класу, і якщо ці зміни змусять його взаємодіяти з іншими "
"сценами у непередбачуваний спосіб, то все почне руйнуватися. Весь сенс "
"опосередкованого зв'язку полягає в тому, щоб уникнути ситуації, коли зміна "
"одного класу призводить до негативного впливу на інші класи, залежні від "
"нього."

msgid ""
"Scripts and scenes, as extensions of engine classes, should abide by *all* "
"OOP principles. Examples include..."
msgstr ""
"Скрипти та сцени, як продовження класів движка, повинні дотримуватися *всіх* "
"принципів ООП. Приклади включають ..."

msgid "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"
msgstr "`SOLID <https://uk.wikipedia.org/wiki/SOLID>`_"

msgid "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"
msgstr "`DRY <https://uk.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"

msgid "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"
msgstr ""
"`KISS <https://uk.wikipedia.org/wiki/"
"%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%C2%ABKISS%C2%BB>`_"

msgid "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"
msgstr ""
"`YAGNI <https://uk.wikipedia.org/wiki/"
"%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_YAGNI>`_"

msgid "Choosing a node tree structure"
msgstr "Вибір дерева структури вузла"

msgid ""
"So, a developer starts work on a game only to stop at the vast possibilities "
"before them. They might know what they want to do, what systems they want to "
"have, but *where* to put them all? Well, how one goes about making their "
"game is always up to them. One can construct node trees in countless ways. "
"But, for those who are unsure, this helpful guide can give them a sample of "
"a decent structure to start with."
msgstr ""
"Отже, розробник починає роботу над грою лише для того, щоб зупинитися на "
"величезних можливостях, що стоять перед ним. Він може знати, чим хоче "
"займатися, які системи хоче мати, але *куди* їх усіх розмістити? Що ж, "
"спосіб створення гри завжди залежить від розробника. Дерева вузлів можна "
"побудувати безліччю способів. Але для тих, хто не має певності, цей корисний "
"посібник може дати початковий зразок гідної структури."

msgid ""
"A game should always have a sort of \"entry point\"; somewhere the developer "
"can definitively track where things begin so that they can follow the logic "
"as it continues elsewhere. This place also serves as a bird's eye view of "
"all of the other data and logic in the program. For traditional "
"applications, this would be the \"main\" function. In this case, it would be "
"a Main node."
msgstr ""
"Гра завжди повинна мати своєрідну \"точку входу\"; яку розробник може "
"спокійно знайти, і почати відстежувати логічне продовження в інших місцях. "
"Це місце також виконує функції поверхневого огляду всіх інших даних та "
"логіки програми. Для традиційних додатків це буде функція \"main\" "
"*(головна)*. У цьому випадку це буде вузол Main *(Головний)*."

msgid "Node \"Main\" (main.gd)"
msgstr "Вузол \"Main\" (main.gd)"

msgid ""
"The ``main.gd`` script would then serve as the primary controller of one's "
"game."
msgstr "Скрипт ``main.gd`` тоді буде служити головним контролером гри."

msgid ""
"Then one has their actual in-game \"World\" (a 2D or 3D one). This can be a "
"child of Main. In addition, one will need a primary GUI for their game that "
"manages the various menus and widgets the project needs."
msgstr ""
"Потім, власне, світ гри \"World\" *(Світ)* (2D або 3D). Він може бути "
"нащадком Main. Крім того, для гри потрібен основний графічний інтерфейс, "
"який керує різними меню та віджетами, необхідними проєкту."

msgid "Node2D/Node3D \"World\" (game_world.gd)"
msgstr "Node2D/Node3D \"Світ\" (game_world.gd)"

msgid "Control \"GUI\" (gui.gd)"
msgstr ""

msgid ""
"When changing levels, one can then swap out the children of the \"World\" "
"node. :ref:`Changing scenes manually <doc_change_scenes_manually>` gives "
"users full control over how their game world transitions."
msgstr ""
"Змінюючи рівні, можна міняти місцями нащадків вузла \"World\". :ref:`Зміна "
"сцен вручну<doc_change_scenes_manually>` дає користувачам повний контроль "
"над змінами ігрового світу."

msgid ""
"The next step is to consider what gameplay systems one's project requires. "
"If one has a system that..."
msgstr ""
"Наступним кроком є розгляд того, які ігрові системи вимагає проєкт. Якщо "
"хтось має систему, яка ..."

msgid "tracks all of its data internally"
msgstr "відстежує всі свої дані зсередини"

msgid "should be globally accessible"
msgstr "має бути доступною глобально"

msgid "should exist in isolation"
msgstr "може існувати ізольовано"

msgid ""
"... then one should create an :ref:`autoload 'singleton' node "
"<doc_singletons_autoload>`."
msgstr ""
"... то слід створити :ref:`вузол автозавантаження 'singleton' "
"<doc_singletons_autoload>`."

msgid ""
"For smaller games, a simpler alternative with less control would be to have "
"a \"Game\" singleton that simply calls the :ref:`SceneTree."
"change_scene_to_file() <class_SceneTree_method_change_scene_to_file>` method "
"to swap out the main scene's content. This structure more or less keeps the "
"\"World\" as the main game node."
msgstr ""
"Для невеликих ігор простішою альтернативою з меншим контролем буде синглтон "
"\"Game\", який просто викликає метод :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>`, щоб замінити вміст головної "
"сцени. Ця структура більш-менш зберігає \"Світ\" як основний вузол гри."

msgid ""
"Any GUI would need to also be a singleton; be a transitory part of the "
"\"World\"; or be manually added as a direct child of the root. Otherwise, "
"the GUI nodes would also delete themselves during scene transitions."
msgstr ""
"Будь-який графічний інтерфейс також повинен бути одностороннім; бути "
"тимчасовою частиною \"World\"; або бути доданим вручну як безпосередній "
"нащадок кореня. В іншому випадку вузли графічного інтерфейсу також "
"видаляються під час переходу між сценами."

msgid ""
"If one has systems that modify other systems' data, one should define those "
"as their own scripts or scenes rather than autoloads. For more information "
"on the reasons, please see the :ref:`Autoloads versus regular nodes "
"<doc_autoloads_versus_internal_nodes>` documentation."
msgstr ""
"Якщо у когось є системи, що модифікують дані інших систем, слід визначати їх "
"як власні скрипти, чи сцени, а не як автозавантаження. Для отримання "
"додаткової інформації про причини, будь ласка, дивіться документацію про :"
"ref:`автозавантаження і внутрішні вузли' "
"<doc_autoloads_versus_internal_nodes>`."

msgid ""
"Each subsystem within one's game should have its own section within the "
"SceneTree. One should use parent-child relationships only in cases where "
"nodes are effectively elements of their parents. Does removing the parent "
"reasonably mean that one should also remove the children? If not, then it "
"should have its own place in the hierarchy as a sibling or some other "
"relation."
msgstr ""
"Кожна підсистема в межах гри повинна мати свій розділ у Дереві Сцени. "
"Використовувати зв'язки предків та нащадків слід лише у тих випадках, коли "
"вузли фактично є елементами предків. Чи виправдано, що вилучення предка "
"прибирає його нащадків? Якщо ні, то нащадки повинні мати своє власне місце в "
"ієрархії."

msgid ""
"In some cases, one needs these separated nodes to *also* position themselves "
"relative to each other. One can use the :ref:`RemoteTransform "
"<class_RemoteTransform3D>` / :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>` nodes for this purpose. They will allow a target "
"node to conditionally inherit selected transform elements from the Remote\\* "
"node. To assign the ``target`` :ref:`NodePath <class_NodePath>`, use one of "
"the following:"
msgstr ""
"У деяких випадках потрібно, щоб ці відокремлені вузли *також* позиціонували "
"себе відносно один одного. Для цього можна використати вузли :ref:"
"`RemoteTransform <class_RemoteTransform3D>` / :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>`. Вони дозволять цільовому вузлу умовно "
"успадковувати вибрані елементи трансформації з вузла Remote\\*. Щоб "
"призначити ``target`` :ref:`NodePath <class_NodePath>`, скористайтеся одним "
"з наведених нижче способів:"

msgid ""
"A reliable third party, likely a parent node, to mediate the assignment."
msgstr ""
"Надійну третю сторону, ймовірно, батьківський вузол, який буде посередником "
"у призначенні."

msgid ""
"A group, to easily pull a reference to the desired node (assuming there will "
"only ever be one of the targets)."
msgstr ""
"Групу, яка легко отримує посилання на потрібний вузол (припускаючи, що "
"колись буде лише одна з цілей)."

msgid ""
"When should one do this? Well, this is subjective. The dilemma arises when "
"one must micro-manage when a node must move around the SceneTree to preserve "
"itself. For example..."
msgstr ""
"Коли потрібно це робити? Ну, це суб’єктивно. Виникає дилема, коли потрібно "
"мікрокерувати, коли вузол повинен рухатись по дереву сцени, щоб зберегти "
"себе. Наприклад..."

msgid "Add a \"player\" node to a \"room\"."
msgstr "Додайте вузол \"player\" до \"room\"."

msgid "Need to change rooms, so one must delete the current room."
msgstr ""
"Потрібно поміняти кімнати, тому потрібно видалити поточну кімнату (room)."

msgid ""
"Before the room can be deleted, one must preserve and/or move the player."
msgstr ""
"Перш ніж кімнату можна буде видалити, потрібно зберегти та/або перемістити "
"гравця (player)."

msgid "Is memory a concern?"
msgstr "Є проблеми з пам'яттю?"

msgid ""
"If not, one can just create the two rooms, move the player and delete the "
"old one. No problem."
msgstr ""
"Якщо ні, то можна просто створити дві кімнати, перемістити гравця і видалити "
"стару. Нема проблем."

msgid "If so, one will need to..."
msgstr "Якщо да, то потрібно..."

msgid "Move the player somewhere else in the tree."
msgstr "Перемістити гравця ще кудись на дереві."

msgid "Delete the room."
msgstr "Видалити кімнату."

msgid "Instantiate and add the new room."
msgstr "Створити і додати нову кімнату."

msgid "Re-add the player."
msgstr "Повторно додати гравця."

msgid ""
"The issue is that the player here is a \"special case\"; one where the "
"developers must *know* that they need to handle the player this way for the "
"project. As such, the only way to reliably share this information as a team "
"is to *document* it. Keeping implementation details in documentation however "
"is dangerous. It's a maintenance burden, strains code readability, and "
"bloats the intellectual content of a project unnecessarily."
msgstr ""
"Справа в тому, що гравець тут - це \"особливий випадок\"; такий, де "
"розробники повинні *знати*, що їм потрібно поводитися з гравцем таким чином "
"для проєкту. Таким чином, єдиний спосіб надійно ділитися цією інформацією в "
"команді - це документувати її. Однак зберігати деталі реалізації в "
"документації небезпечно. Це тягар технічного обслуговування, ускладнює "
"читабельність коду та надмірно роздуває інтелектуальний зміст проєкту."

msgid ""
"In a more complex game with larger assets, it can be a better idea to simply "
"keep the player somewhere else in the SceneTree entirely. This results in:"
msgstr ""
"У складнішій грі з великими активами може бути кращою ідеєю просто повністю "
"утримати гравця де-небудь ще в Дереві Сцени. Це призводить до:"

msgid "More consistency."
msgstr "Більшої послідовності."

msgid "No \"special cases\" that must be documented and maintained somewhere."
msgstr ""
"Ніяких \"особливих випадків\", які потрібно десь задокументувати та "
"підтримувати."

msgid ""
"No opportunity for errors to occur because these details are not accounted "
"for."
msgstr "Уникнення помилок, оскільки ці деталі не враховуються."

msgid ""
"In contrast, if one ever needs to have a child node that does *not* inherit "
"the transform of their parent, one has the following options:"
msgstr ""
"На відміну від цього, якщо коли-небудь потрібно мати дочірній вузол, який "
"*не* успадковує перетворення свого предка, у нього є такі варіанти:"

msgid ""
"The **declarative** solution: place a :ref:`Node <class_Node>` in between "
"them. As nodes with no transform, Nodes will not pass along such information "
"to their children."
msgstr ""
"**Декларативне** рішення: помістити :ref:`вузол <class_Node>` між ними. Як "
"вузли без перетворення, Вузли не передаватимуть таку інформацію своїм "
"нащадкам."

msgid ""
"The **imperative** solution: Use the ``top_level`` property for the :ref:"
"`CanvasItem <class_CanvasItem_property_top_level>` or :ref:`Node3D "
"<class_Node3D_property_top_level>` node. This will make the node ignore its "
"inherited transform."
msgstr ""
"Імперативне рішення: Використовуйте властивість ``top_level`` для вузла :ref:"
"`CanvasItem <class_CanvasItem_property_top_level>` або :ref:`Node3D "
"<class_Node3D_property_top_level>`. Це змусить вузол ігнорувати успадковане "
"перетворення."

msgid ""
"If building a networked game, keep in mind which nodes and gameplay systems "
"are relevant to all players versus those just pertinent to the authoritative "
"server. For example, users do not all need to have a copy of every players' "
"\"PlayerController\" logic. Instead, they need only their own. As such, "
"keeping these in a separate branch from the \"world\" can help simplify the "
"management of game connections and the like."
msgstr ""
"Створюючи мережеву гру, майте на увазі, які вузли та ігрові системи мають "
"відношення до всіх гравців проти тих, що стосуються лише авторитетного "
"сервера. Наприклад, не всім користувачам потрібно мати копію логіки кожного "
"гравця \"PlayerController\". Натомість їм потрібно лише своя. Таким чином, "
"утримання їх у відокремленій від \"світу\" гілці може допомогти спростити "
"управління ігровими зв’язками."

msgid ""
"The key to scene organization is to consider the SceneTree in relational "
"terms rather than spatial terms. Are the nodes dependent on their parent's "
"existence? If not, then they can thrive all by themselves somewhere else. If "
"they are dependent, then it stands to reason that they should be children of "
"that parent (and likely part of that parent's scene if they aren't already)."
msgstr ""
"Ключ до організації сцени - розглядати Дерево Сцени в реляційних термінах, а "
"не просторових. Чи залежать вузли від існування предків? Якщо ні, то вони "
"можуть процвітати самі десь в іншому місці. Якщо вони залежать, то цілком "
"зрозуміло, що вони повинні бути нащадками цього предка (і, можливо, частиною "
"сцени цього предка, якщо вони ще не є такими)."

msgid ""
"Does this mean nodes themselves are components? Not at all. Godot's node "
"trees form an aggregation relationship, not one of composition. But while "
"one still has the flexibility to move nodes around, it is still best when "
"such moves are unnecessary by default."
msgstr ""
"Чи означає це, що самі вузли є компонентами? Зовсім ні. Дерево вузлів Godot "
"формує зв'язок агрегації, а не склад. Але незважаючи на те, що людина все ще "
"має гнучкість переміщення вузлів, все-таки краще, коли такі переміщення за "
"замовчуванням непотрібні."

msgid "Translation status"
msgstr "Стан перекладу"
