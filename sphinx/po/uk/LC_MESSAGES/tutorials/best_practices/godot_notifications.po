# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Godot notifications"
msgstr "Сповіщення Godot"

msgid ""
"Every Object in Godot implements a :ref:`_notification "
"<class_Object_method__notification>` method. Its purpose is to allow the "
"Object to respond to a variety of engine-level callbacks that may relate to "
"it. For example, if the engine tells a :ref:`CanvasItem <class_CanvasItem>` "
"to \"draw\", it will call ``_notification(NOTIFICATION_DRAW)``."
msgstr ""
"Кожен об'єкт у Godot реалізує метод :ref:`_notification "
"<class_Object_method__notification>`. Його мета - дозволити Об'єкту "
"реагувати на різноманітні зворотні виклики на рівні движка, які можуть "
"стосуватися його. Наприклад, якщо движок каже :ref:`CanvasItem "
"<class_CanvasItem>` \"малювати\" *(\"draw\")*, він викликає "
"``_notification(NOTIFICATION_DRAW)``."

msgid ""
"Some of these notifications, like draw, are useful to override in scripts. "
"So much so that Godot exposes many of them with dedicated functions:"
msgstr ""
"Деякі з цих сповіщень, наприклад, малювання (draw), корисно замінити у "
"скриптах. Настільки, що Godot поставляє багатьох із них зі спеціальними "
"функціями:"

msgid "``_ready()`` : NOTIFICATION_READY"
msgstr "``_ready()`` : NOTIFICATION_READY"

msgid "``_enter_tree()`` : NOTIFICATION_ENTER_TREE"
msgstr "``_enter_tree()`` : NOTIFICATION_ENTER_TREE"

msgid "``_exit_tree()`` : NOTIFICATION_EXIT_TREE"
msgstr "``_exit_tree()`` : NOTIFICATION_EXIT_TREE"

msgid "``_process(delta)`` : NOTIFICATION_PROCESS"
msgstr "``_process(delta)`` : NOTIFICATION_PROCESS"

msgid "``_physics_process(delta)`` : NOTIFICATION_PHYSICS_PROCESS"
msgstr "``_physics_process(delta)`` : NOTIFICATION_PHYSICS_PROCESS"

msgid "``_draw()`` : NOTIFICATION_DRAW"
msgstr "``_draw()`` : NOTIFICATION_DRAW"

msgid ""
"What users might *not* realize is that notifications exist for types other "
"than Node alone:"
msgstr ""
"Користувачі можуть *не* усвідомлювати, що сповіщення крім Вузлів існують і "
"для інших типів:"

msgid ""
":ref:`Object::NOTIFICATION_POSTINITIALIZE "
"<class_Object_constant_NOTIFICATION_POSTINITIALIZE>`: a callback that "
"triggers during object initialization. Not accessible to scripts."
msgstr ""
":ref:`Object::NOTIFICATION_POSTINITIALIZE "
"<class_Object_constant_NOTIFICATION_POSTINITIALIZE>`: зворотний виклик, який "
"спрацьовує під час ініціалізації об’єкта. Не доступний для скриптів."

msgid ""
":ref:`Object::NOTIFICATION_PREDELETE "
"<class_Object_constant_NOTIFICATION_PREDELETE>`: a callback that triggers "
"before the engine deletes an Object, i.e. a 'destructor'."
msgstr ""
":ref:`Object::NOTIFICATION_PREDELETE "
"<class_Object_constant_NOTIFICATION_PREDELETE>`: зворотний виклик, який "
"спрацьовує до того, як движок видалить Об’єкт, тобто 'деструктор'."

msgid ""
":ref:`MainLoop::NOTIFICATION_WM_MOUSE_ENTER "
"<class_MainLoop_constant_NOTIFICATION_WM_MOUSE_ENTER>`: a callback that "
"triggers when the mouse enters the window in the operating system that "
"displays the game content."
msgstr ""
":ref:`MainLoop::NOTIFICATION_WM_MOUSE_ENTER "
"<class_MainLoop_constant_NOTIFICATION_WM_MOUSE_ENTER>`: зворотний виклик, "
"який спрацьовує, коли мишка потрапляє у вікно операційної системи, що "
"відображає вміст гри."

msgid ""
"And many of the callbacks that *do* exist in Nodes don't have any dedicated "
"methods, but are still quite useful."
msgstr ""
"І багато зворотних викликів, які *існують* у вузлах, не мають спеціальних "
"методів, але все ще є досить корисними."

msgid ""
":ref:`Node::NOTIFICATION_PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>`: a callback that triggers "
"anytime one adds a child node to another node."
msgstr ""
":ref:`Node::NOTIFICATION_PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>`: зворотний виклик, який "
"запускається щоразу, коли один додає дочірній вузол до іншого вузла."

msgid ""
":ref:`Node::NOTIFICATION_UNPARENTED "
"<class_Node_constant_NOTIFICATION_UNPARENTED>`: a callback that triggers "
"anytime one removes a child node from another node."
msgstr ""
":ref:`Node::NOTIFICATION_UNPARENTED "
"<class_Node_constant_NOTIFICATION_UNPARENTED>`: зворотний виклик, який "
"запускається в будь-який час, коли один видаляє дочірній вузол з іншого "
"вузла."

msgid ""
":ref:`Popup::NOTIFICATION_POST_POPUP "
"<class_Popup_constant_NOTIFICATION_POST_POPUP>`: a callback that triggers "
"after a Popup node completes any ``popup*`` method. Note the difference from "
"its ``about_to_show`` signal which triggers *before* its appearance."
msgstr ""
":ref:`Popup::NOTIFICATION_POST_POPUP "
"<class_Popup_constant_NOTIFICATION_POST_POPUP>`: зворотний виклик, який "
"запускається після того, як вузол спливаючого вікна завершує будь-який метод "
"``popup*``. Запримітьте відмінність від сигнала ``about_to_show``, який "
"спрацьовує *до* появи."

msgid ""
"One can access all these custom notifications from the universal "
"``_notification`` method."
msgstr ""
"Доступ до всіх цих спеціальних сповіщень можна отримати за допомогою "
"універсального метода ``_notification``."

msgid ""
"Methods in the documentation labeled as \"virtual\" are also intended to be "
"overridden by scripts."
msgstr ""
"Методи в документації, позначені як \"virtual\" *(віртуальні)*, також "
"призначені для перевизначення у скриптах."

msgid ""
"A classic example is the :ref:`_init <class_Object_method__init>` method in "
"Object. While it has no ``NOTIFICATION_*`` equivalent, the engine still "
"calls the method. Most languages (except C#) rely on it as a constructor."
msgstr ""
"Класичним прикладом є метод :ref:`_init <class_Object_method__init>` в "
"Об'єкті. Хоча він не має еквівалента ``NOTIFICATION_*`` движок все одно "
"викликає метод. Більшість мов (крім C#) покладаються на нього як на "
"конструктор."

msgid ""
"So, in which situation should one use each of these notifications or virtual "
"functions?"
msgstr ""
"Отже, в якій ситуації слід використовувати кожне з цих сповіщень або "
"віртуальні функції?"

msgid "_process vs. _physics_process vs. \\*_input"
msgstr "_process та _physics_process vs. \\*_input"

msgid ""
"Use ``_process`` when one needs a framerate-dependent deltatime between "
"frames. If code that updates object data needs to update as often as "
"possible, this is the right place. Recurring logic checks and data caching "
"often execute here, but it comes down to the frequency at which one needs "
"the evaluations to update. If they don't need to execute every frame, then "
"implementing a Timer-yield-timeout loop is another option."
msgstr ""
"Використовуйте ``_process`` коли потрібна різниця між кадрами, залежна від "
"частоти кадрів. Якщо коду, який оновлює дані об’єктів, потрібно оновлюватися "
"якомога частіше, це правильне місце. Тут часто виконуються повторювані "
"логічні перевірки та кешування даних, але це зводиться до частоти оновлення "
"оцінок. Якщо йому не потрібно виконуватися кожен кадр, то реалізація циклу "
"Timer-yield-timeout - кращий варіант."

msgid ""
"Use ``_physics_process`` when one needs a framerate-independent deltatime "
"between frames. If code needs consistent updates over time, regardless of "
"how fast or slow time advances, this is the right place. Recurring kinematic "
"and object transform operations should execute here."
msgstr ""
"Використовуйте ``_physics_process`` коли потрібен часовий проміжок, "
"незалежний від частоти кадрів, між кадрами. Якщо код потребує постійного "
"оновлення з часом, незалежно від того, наскільки швидко чи повільно "
"просувається час, це правильне місце. Тут слід виконувати повторювані "
"операції кінематичного та об'єктного перетворення."

msgid ""
"While it is possible, to achieve the best performance, one should avoid "
"making input checks during these callbacks. ``_process`` and "
"``_physics_process`` will trigger at every opportunity (they do not \"rest\" "
"by default). In contrast, ``*_input`` callbacks will trigger only on frames "
"in which the engine has actually detected the input."
msgstr ""
"Хоча можливо, щоб досягти найкращої продуктивності, слід уникати перевірки "
"вводу під час цих зворотних викликів. ``_process`` і ``_physics_process`` "
"будуть спрацьовувати при будь-якій нагоді (вони не \"відпочивають\" за "
"замовчуванням). На відміну від них зворотні виклики ``*_input`` будуть "
"спрацьовувати лише на кадрах, в яких двигун фактично виявив ввід."

msgid ""
"One can check for input actions within the input callbacks just the same. If "
"one wants to use delta time, one can fetch it from the related deltatime "
"methods as needed."
msgstr ""
"Можна перевірити наявність введення у зворотних викликах ввода. Якщо ви "
"хочете використовувати дельта-час *(проміжок часу)*, можете за необхідності "
"отримати його із відповідних методів."

msgid "_init vs. initialization vs. export"
msgstr "_init, initialization та export"

msgid ""
"If the script initializes its own node subtree, without a scene, that code "
"should execute here. Other property or SceneTree-independent initializations "
"should also run here. This triggers before ``_ready`` or ``_enter_tree``, "
"but after a script creates and initializes its properties."
msgstr ""
"Якщо скрипт ініціалізує власне піддерево вузла без сцени, цей код повинен "
"виконуватися тут. Інші властивості або незалежні від Дерева Сцен "
"ініціалізації також повинні працювати тут. Це спрацьовує до ``_ready`` або "
"``_enter_tree``, проте після того, як скрипт створює та ініціалізує свої "
"властивості."

msgid ""
"Scripts have three types of property assignments that can occur during "
"instantiation:"
msgstr ""
"Скрипти мають три типи призначення властивостей, які можуть відбуватися під "
"час створення екземпляра:"

msgid ""
"When instantiating a scene, property values will set up according to the "
"following sequence:"
msgstr ""
"При створенні екземпляра сцени значення властивостей встановлюються "
"відповідно до наступної послідовності:"

msgid ""
"**Initial value assignment:** instantiation will assign either the "
"initialization value or the init assignment value. Init assignments take "
"priority over initialization values."
msgstr ""
"**Присвоєння початкового значення:** примірник присвоює або значення "
"ініціалізації, або значення присвоєння init. Призначення Init мають "
"пріоритет над значеннями ініціалізації."

msgid ""
"**Exported value assignment:** If instancing from a scene rather than a "
"script, Godot will assign the exported value to replace the initial value "
"defined in the script."
msgstr ""
"**Присвоєння експортованого значення:** якщо створити екземпляр зі сцени, а "
"не зі скрипта, Godot призначить експортоване значення замінюючи початкове "
"значення, визначене у скрипті."

msgid ""
"As a result, instantiating a script versus a scene will affect both the "
"initialization *and* the number of times the engine calls the setter."
msgstr ""
"Як результат, створення екземпляра скрипта замість сцени вплине як на "
"ініціалізацію, *так і на* кількість разів, коли механізм викликає сеттер."

msgid "_ready vs. _enter_tree vs. NOTIFICATION_PARENTED"
msgstr "_ready, _enter_tree та NOTIFICATION_PARENTED"

msgid ""
"When instantiating a scene connected to the first executed scene, Godot will "
"instantiate nodes down the tree (making ``_init`` calls) and build the tree "
"going downwards from the root. This causes ``_enter_tree`` calls to cascade "
"down the tree. Once the tree is complete, leaf nodes call ``_ready``. A node "
"will call this method once all child nodes have finished calling theirs. "
"This then causes a reverse cascade going up back to the tree's root."
msgstr ""
"При створенні екземпляра сцени, підключеної до першої виконаної сцени, Godot "
"створює екземпляри вузлів по дереву (здійснюючи виклики ``_init`) і будує "
"дерево, що йде вниз від кореня. Це спричиняє виклики ``_enter_tree`` "
"каскадом вниз дерева. Після того, як дерево завершено, викликаються вузли "
"листів ``_ready``. Вузол викликає цей метод, як тільки всі дочірні вузли "
"закінчать виклик свого. Потім це призводить до зворотного каскаду, що "
"повертається до кореня дерева."

msgid ""
"When instantiating a script or a standalone scene, nodes are not added to "
"the SceneTree upon creation, so no ``_enter_tree`` callbacks trigger. "
"Instead, only the ``_init`` call occurs. When the scene is added to the "
"SceneTree, the ``_enter_tree`` and ``_ready`` calls occur."
msgstr ""
"Під час створення скрипта, або автономної сцени, вузли не додаються до "
"Дерева Сцен при створенні, тому жоден зворотний виклик ``_enter_tree`` не "
"запускається. Натомість відбувається лише виклик ``_init``. Коли сцена "
"додається до Дерева Сцен, відбуваються виклики ``_enter_tree`` і ``_ready``."

msgid ""
"If one needs to trigger behavior that occurs as nodes parent to another, "
"regardless of whether it occurs as part of the main/active scene or not, one "
"can use the :ref:`PARENTED <class_Node_constant_NOTIFICATION_PARENTED>` "
"notification. For example, here is a snippet that connects a node's method "
"to a custom signal on the parent node without failing. Useful on data-"
"centric nodes that one might create at runtime."
msgstr ""
"Якщо потрібно ініціювати поведінку, яка виникає як поведінка батьківського "
"вузла до іншого, незалежно від того, відбувається вона як частина основної/"
"активної сцени чи ні, можна використовувати сповіщення :ref:`PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>`. Наприклад, ось фрагмент, який "
"підключає метод вузла до користувацького сигналу на батьківському вузлі без "
"збоїв. Корисно для вузлів, орієнтованих на дані, які можна створити під час "
"виконання."

msgid "Translation status"
msgstr "Стан перекладу"
