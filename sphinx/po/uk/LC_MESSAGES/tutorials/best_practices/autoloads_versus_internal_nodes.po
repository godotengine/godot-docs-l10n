# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Autoloads versus regular nodes"
msgstr "Автоматичне і звичайне завантаження вузлів"

msgid ""
"Godot offers a feature to automatically load nodes at the root of your "
"project, allowing you to access them globally, that can fulfill the role of "
"a Singleton: :ref:`doc_singletons_autoload`. These autoloaded nodes are not "
"freed when you change the scene from code with :ref:`SceneTree."
"change_scene_to_file <class_SceneTree_method_change_scene_to_file>`."
msgstr ""
"Godot пропонує функцію автоматичного завантаження вузлів у корені вашого "
"проекту, що дозволяє отримати до них глобальний доступ, які можуть "
"виконувати роль синглетону: :ref:`doc_singletons_autoload`. Ці "
"автозавантажені вузли не звільняються, коли ви змінюєте сцену з коду за "
"допомогою :ref:`SceneTree.change_scene_to_file "
"<class_SceneTree_method_change_scene_to_file>`."

msgid ""
"In this guide, you will learn when to use the Autoload feature, and "
"techniques you can use to avoid it."
msgstr ""
"У цьому посібнику ви дізнаєтесь, коли слід використовувати функцію "
"автозавантаження, та прийоми уникнення цього."

msgid "The cutting audio issue"
msgstr "Вирішення аудіо проблем"

msgid ""
"Other engines can encourage the use of creating manager classes, singletons "
"that organize a lot of functionality into a globally accessible object. "
"Godot offers many ways to avoid global state thanks to the node tree and "
"signals."
msgstr ""
"Інші движки можуть заохочувати створення класів менеджерів, синглтонів, які "
"організовують багато функціональних можливостей, у доступний глобально "
"об'єкт. Godot пропонує багато способів уникнути глобального стану завдяки "
"дереву вузлів та сигналам."

msgid ""
"For example, let's say we are building a platformer and want to collect "
"coins that play a sound effect. There's a node for that: the :ref:"
"`AudioStreamPlayer <class_AudioStreamPlayer>`. But if we call the "
"``AudioStreamPlayer`` while it is already playing a sound, the new sound "
"interrupts the first."
msgstr ""
"Наприклад, припустимо, ми будуємо платформер і хочемо збирати монети, які "
"відтворюють звуковий ефект. Для цього є вузол: :ref:`AudioStreamPlayer "
"<class_AudioStreamPlayer>`. Проте якщо ми викликаємо ``AudioStreamPlayer`` в "
"час, коли він вже відтворює звук, новий звук перериває перший."

msgid ""
"A solution is to code a global, autoloaded sound manager class. It generates "
"a pool of ``AudioStreamPlayer`` nodes that cycle through as each new request "
"for sound effects comes in. Say we call that class ``Sound``, you can use it "
"from anywhere in your project by calling ``Sound.play(\"coin_pickup."
"ogg\")``. This solves the problem in the short term but causes more problems:"
msgstr ""
"Рішення полягає у написанні глобального, автозавантажуваного класу звукового "
"менеджера. Він генерує пул вузлів ``AudioStreamPlayer``, які циклічно "
"переглядаються при кожному новому запиті на звукові ефекти. Скажімо, ми "
"називаємо цей клас ``Sound``, і ви можете використовувати його з будь-якого "
"місця у вашому проекті, викликавши ``Sound.play(\"coin_pickup.ogg\")``. Це "
"вирішує проблему в короткостроковій перспективі, але створює більше проблем:"

msgid ""
"**Global state**: one object is now responsible for all objects' data. If "
"the ``Sound`` class has errors or doesn't have an AudioStreamPlayer "
"available, all the nodes calling it can break."
msgstr ""
"**Глобальний стан**: один об’єкт тепер відповідає за дані всіх об’єктів. "
"Якщо клас ``Sound`` має помилки, або не має AudioStreamPlayer, усі вузли, що "
"викликають його, можуть зламатися."

msgid ""
"**Global access**: now that any object can call ``Sound.play(sound_path)`` "
"from anywhere, there's no longer an easy way to find the source of a bug."
msgstr ""
"**Глобальний доступ**: тепер, коли будь-який об’єкт може викликати ``Sound."
"play(sound_path)`` з будь-якого місця, більше не існує простого способу "
"знайти джерело помилки."

msgid ""
"**Global resource allocation**: with a pool of ``AudioStreamPlayer`` nodes "
"stored from the start, you can either have too few and face bugs, or too "
"many and use more memory than you need."
msgstr ""
"**Глобальний розподіл ресурсів**: за допомогою пулу вузлів "
"``AudioStreamPlayer``, що зберігається з самого початку, ви можете мати "
"занадто мало помилок і стикатися з ними, або занадто багато і "
"використовувати більше пам'яті, ніж вам потрібно."

msgid ""
"About global access, the problem is that any code anywhere could pass wrong "
"data to the ``Sound`` autoload in our example. As a result, the domain to "
"explore to fix the bug spans the entire project."
msgstr ""
"Щодо глобального доступу, то проблема полягає в тому, що будь-який код в "
"будь-якому місці може передати неправильні дані автозавантаженню ``Sound`` в "
"нашому прикладі. Як наслідок, область, яку потрібно дослідити для "
"виправлення помилки, охоплює весь проект."

msgid ""
"When you keep code inside a scene, only one or two scripts may be involved "
"in audio."
msgstr ""
"Коли ви зберігаєте код всередині сцени, в аудіо можуть бути задіяні лише "
"один або два скрипти."

msgid ""
"Contrast this with each scene keeping as many ``AudioStreamPlayer`` nodes as "
"it needs within itself and all these problems go away:"
msgstr ""
"Порівняйте це з тим, коли кожна сцена зберігає в собі стільки вузлів "
"``AudioStreamPlayer``, скільки їй потрібно, і всі ці проблеми зникають:"

msgid ""
"Each scene manages its own state information. If there is a problem with the "
"data, it will only cause issues in that one scene."
msgstr ""
"Кожна сцена управляє власною інформацією про стан. Якщо є проблема з даними, "
"це спричинить проблеми лише в одній сцені."

msgid ""
"Each scene accesses only its own nodes. Now, if there is a bug, it's easy to "
"find which node is at fault."
msgstr ""
"Кожна сцена має доступ лише до власних вузлів. Тепер, якщо є помилка, легко "
"знайти, який вузол винен."

msgid "Each scene allocates exactly the amount of resources it needs."
msgstr "Кожна сцена розподіляє точно необхідну кількість ресурсів."

msgid "Managing shared functionality or data"
msgstr "Керування спільною функціональністю чи даними"

msgid ""
"Another reason to use an Autoload can be that you want to reuse the same "
"method or data across many scenes."
msgstr ""
"Ще однією причиною використання автозавантаження може бути те, що ви хочете "
"повторно використовувати той самий метод, або дані, для багатьох сцен."

msgid ""
"In the case of functions, you can create a new type of ``Node`` that "
"provides that feature for an individual scene using the :ref:`class_name "
"<doc_gdscript_basics_class_name>` keyword in GDScript."
msgstr ""
"У разі функцій, ви можете створити новий тип ``Node`` *(вузла)*, який "
"забезпечує цю функцію для окремої сцени з допомогою ключового слова :ref:"
"`class_name <doc_scripting_continued_class_name>` в GDScript."

msgid "When it comes to data, you can either:"
msgstr "Що стосується даних, то ви можете:"

msgid ""
"Create a new type of :ref:`Resource <class_Resource>` to share the data."
msgstr ""
"Створити новий тип :ref:`Ресурса <class_Resource>` для спільного "
"використання даних."

msgid ""
"Store the data in an object to which each node has access, for example using "
"the ``owner`` property to access the scene's root node."
msgstr ""
"Зберігати дані в об'єкті, до якого має доступ кожен вузол, наприклад, "
"використовуючи властивість ``owner`` для доступу до кореневого вузла сцени."

msgid "When you should use an Autoload"
msgstr "Коли слід використовувати автозавантаження"

msgid ""
"GDScript supports the creation of ``static`` functions using ``static "
"func``. When combined with ``class_name``, this makes it possible to create "
"libraries of helper functions without having to create an instance to call "
"them. The limitation of static functions is that they can't reference member "
"variables, non-static functions or ``self``."
msgstr ""

msgid ""
"Since Godot 4.1, GDScript also supports ``static`` variables using ``static "
"var``. This means you can now share a variables across instances of a class "
"without having to create a separate autoload."
msgstr ""

msgid ""
"Still, autoloaded nodes can simplify your code for systems with a wide "
"scope. If the autoload is managing its own information and not invading the "
"data of other objects, then it's a great way to create systems that handle "
"broad-scoped tasks. For example, a quest or a dialogue system."
msgstr ""
"Тим не менш, автозавантажувані вузли можуть спростити ваш код для систем з "
"широкою сферою застосування. Якщо автозавантаження керує власною "
"інформацією, а не вторгається в дані інших об'єктів, то це чудовий спосіб "
"створювати системи, які виконують широкомасштабні завдання. Наприклад, квест "
"або діалогову систему."

msgid ""
"An autoload is *not* necessarily a singleton. Nothing prevents you from "
"instantiating copies of an autoloaded node. An autoload is only a tool that "
"makes a node load automatically as a child of the root of your scene tree, "
"regardless of your game's node structure or which scene you run, e.g. by "
"pressing the :kbd:`F6` key."
msgstr ""
"Автозавантаження *не* обов'язково є одиничним. Ніщо не заважає вам "
"створювати копії автозавантажуваного вузла. Автозавантаження - це лише "
"інструмент, за допомогою якого вузол автоматично завантажується як дочірній "
"елемент кореня вашого дерева сцен, незалежно від структури вузлів вашої гри "
"або від того, яку сцену ви запускаєте, наприклад, натисканням клавіш :kbd:"
"`F6`."

msgid ""
"As a result, you can get the autoloaded node, for example an autoload called "
"``Sound``, by calling ``get_node(\"/root/Sound\")``."
msgstr ""
"У результаті ви можете отримати вузол автозавантаження, наприклад, вузол із "
"назвою ``Sound``, за допомогою виклику ``get_node(\"/root/Sound\")``."

msgid "Translation status"
msgstr "Стан перекладу"
