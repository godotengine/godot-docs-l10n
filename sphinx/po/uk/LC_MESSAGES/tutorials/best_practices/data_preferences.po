# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Data preferences"
msgstr "Налаштування даних"

msgid ""
"Ever wondered whether one should approach problem X with data structure Y or "
"Z? This article covers a variety of topics related to these dilemmas."
msgstr ""
"Ніколи не замислювались, чи слід підходити до проблеми X зі структурою даних "
"Y або Z? Ця стаття охоплює різноманітні теми, пов’язані з цими дилемами."

msgid ""
"This article makes references to \"[something]-time\" operations. This "
"terminology comes from algorithm analysis' `Big O Notation <https://rob-bell."
"net/2009/06/a-beginners-guide-to-big-o-notation/>`_."
msgstr ""
"Ця стаття містить посилання на операції \"[щось] -час\". Ця термінологія "
"виходить з алгоритму аналізу `Big O Notation <https://rob-bell.net/2009/06/a-"
"beginners-guide-to-big-o-notation/>`_."

msgid ""
"Long-story short, it describes the worst-case scenario of runtime length. In "
"laymen's terms:"
msgstr ""
"Коротко кажучи, він описує найгірший сценарій тривалості роботи. Якщо "
"говорити неспеціалістами:"

msgid ""
"\"As the size of a problem domain increases, the runtime length of the "
"algorithm...\""
msgstr ""
"\"Зі збільшенням розміру проблемного домену тривалість виконання "
"алгоритму ...\""

msgid "Constant-time, ``O(1)``: \"...does not increase.\""
msgstr "Постійний час, ``O(1)``: \"... не збільшується.\""

msgid "Logarithmic-time, ``O(log n)``: \"...increases at a slow rate.\""
msgstr "Логарифмічний час, ``O(log n)``: \"... збільшується повільно.\""

msgid "Linear-time, ``O(n)``: \"...increases at the same rate.\""
msgstr "Лінійний час, ``O(n)``: \"... збільшується з тією ж швидкістю.\""

msgid "Etc."
msgstr "І так далі."

msgid ""
"Imagine if one had to process 3 million data points within a single frame. "
"It would be impossible to craft the feature with a linear-time algorithm "
"since the sheer size of the data would increase the runtime far beyond the "
"time allotted. In comparison, using a constant-time algorithm could handle "
"the operation without issue."
msgstr ""
"Уявіть, якби потрібно було обробити 3 мільйони точок даних за один кадр. "
"Було б неможливо створити функцію за допомогою алгоритму лінійного часу, "
"оскільки обсяг даних збільшив би час виконання значно більше, ніж відведено "
"часу. Для порівняння, використання алгоритму з постійним часом може "
"впоратися з операцією без проблем."

msgid ""
"By and large, developers want to avoid engaging in linear-time operations as "
"much as possible. But, if one keeps the scale of a linear-time operation "
"small, and if one does not need to perform the operation often, then it may "
"be acceptable. Balancing these requirements and choosing the right "
"algorithm / data structure for the job is part of what makes programmers' "
"skills valuable."
msgstr ""
"За великим рахунком, розробники хочуть якомога більше уникати участі в "
"операціях з лінійним часом. Але якщо масштаб операції з лінійним часом "
"зберігається невеликим, і якщо операції не потрібно часто виконувати, це "
"може бути прийнятним. Балансування цих вимог та вибір правильної алгоритму/"
"структури даних для роботи є частиною того, що робить навички програмістів "
"цінними."

msgid "Array vs. Dictionary vs. Object"
msgstr "Масив, Словник та Об'єкт"

msgid ""
"Godot stores all variables in the scripting API in the `Variant <https://"
"docs.godotengine.org/en/latest/development/cpp/variant_class.html>`_ class. "
"Variants can store Variant-compatible data structures such as :ref:`Array "
"<class_Array>` and :ref:`Dictionary <class_Dictionary>` as well as :ref:"
"`Object <class_Object>` s."
msgstr ""
"Godot зберігає всі змінні в API скриптів у класі `Variant <https://docs."
"godotengine.org/en/latest/development/cpp/variant_class.html>`_. Варіанти "
"можуть зберігати сумісні з варіантами структури даних, такі як :ref:`Масив "
"<class_Array>` and :ref:`Словник <class_Dictionary>` as well as :ref:`Об'єкт "
"<class_Object>`."

msgid ""
"Godot implements Array as a ``Vector<Variant>``. The engine stores the Array "
"contents in a contiguous section of memory, i.e. they are in a row adjacent "
"to each other."
msgstr ""
"Godot реалізує Масив як ``Vector<Variant>``. Механізм зберігає вміст масиву "
"у суміжній частині пам'яті, тобто вони знаходяться в ряду, що прилягають "
"один до одного."

msgid ""
"For those unfamiliar with C++, a Vector is the name of the array object in "
"traditional C++ libraries. It is a \"templated\" type, meaning that its "
"records can only contain a particular type (denoted by angled brackets). So, "
"for example, a :ref:`PoolStringArray <class_PoolStringArray>` would be "
"something like a ``Vector<String>``."
msgstr ""
"Для тих, хто не знайомий з C++, Vector - це ім’я об’єкта масиву в "
"традиційних бібліотеках C++. Це \"шаблонний\" тип, що означає, що його "
"записи можуть містити лише певний тип (позначений кутовими дужками). Так, "
"наприклад, :ref:`PoolStringArray <class_PoolStringArray>` буде чимось типу "
"``Vector<String>``."

msgid "Contiguous memory stores imply the following operation performance:"
msgstr "Суміжні сховища пам’яті передбачають такі характерні операції:"

msgid "**Iterate:** Fastest. Great for loops."
msgstr "**Ітерація:** Найшвидша. Відмінно підходить для циклів."

msgid "Op: All it does is increment a counter to get to the next record."
msgstr ""
"Oп: Все, що вона робить, це збільшує лічильник, щоб перейти до наступного "
"запису."

msgid "**Insert, Erase, Move:** Position-dependent. Generally slow."
msgstr ""
"**Вставка, Стирання, Переміщення:** Залежить від положення. Загалом повільна."

msgid ""
"Op: Adding/removing/moving content involves moving the adjacent records over "
"(to make room / fill space)."
msgstr ""
"Oп: Додавання/видалення/переміщення вмісту включно з переміщенням сусідніх "
"записів (щоб звільнити/заповнити місце)."

msgid "Fast add/remove *from the end*."
msgstr "Швидке додавання/видалення *з кінця*."

msgid "Slow add/remove *from an arbitrary position*."
msgstr "Повільне додавання/видалення *з довільної позиції*."

msgid "Slowest add/remove *from the front*."
msgstr "Найповільніше додавання/видалення *спереду*."

msgid "If doing many inserts/removals *from the front*, then..."
msgstr "Якщо ви робите багато вставок/вилучень *спереду*, тоді ..."

msgid "invert the array."
msgstr "інвертуйте масив."

msgid "do a loop which executes the Array changes *at the end*."
msgstr "виконайте цикл, який виконує зміни масиву *в кінці*."

msgid "re-invert the array."
msgstr "повторно інвертуйте масив."

msgid ""
"This makes only 2 copies of the array (still constant time, but slow) versus "
"copying roughly 1/2 of the array, on average, N times (linear time)."
msgstr ""
"Це дає лише 2 копії масиву (все ще постійний час, хоча й повільний) проти "
"копіювання приблизно 1/2 масиву, в середньому N разів (лінійний час)."

msgid ""
"**Get, Set:** Fastest *by position*. E.g. can request 0th, 2nd, 10th record, "
"etc. but cannot specify which record you want."
msgstr ""
"**Отримання, Встановлення:** Найшвидше *за позицією*. Наприклад, може "
"запитувати 0-й, 2-й, 10-й запис, тощо, але не може вказати, який запис ви "
"хочете."

msgid "Op: 1 addition operation from array start position up to desired index."
msgstr ""
"Oп: 1 операція додавання від початкової позиції масиву до бажаного індексу."

msgid "**Find:** Slowest. Identifies the index/position of a value."
msgstr "**Пошук:** Найповільніша. Визначає індекс/позицію значення."

msgid ""
"Op: Must iterate through array and compare values until one finds a match."
msgstr ""
"Oп: Мусить перебирати масив і порівнювати значення, поки не знайдеться збіг."

msgid ""
"Performance is also dependent on whether one needs an exhaustive search."
msgstr "Ефективність також залежить від того, чи потрібен вичерпний пошук."

msgid ""
"If kept ordered, custom search operations can bring it to logarithmic time "
"(relatively fast). Laymen users won't be comfortable with this though. Done "
"by re-sorting the Array after every edit and writing an ordered-aware search "
"algorithm."
msgstr ""
"Якщо збережено впорядкування, користувацькі пошукові операції можуть "
"привести його до логарифмічного часу (відносно швидко). Непрофесійним "
"користувачам це буде неприємно. Виконується шляхом повторного сортування "
"масиву після кожного редагування та написання впорядкованого алгоритму "
"пошуку."

msgid ""
"Godot implements Dictionary as an ``OrderedHashMap<Variant, Variant>``. The "
"engine stores a small array (initialized to 2^3 or 8 records) of key-value "
"pairs. When one attempts to access a value, they provide it a key. It then "
"*hashes* the key, i.e. converts it into a number. The \"hash\" is used to "
"calculate the index into the array. As an array, the OHM then has a quick "
"lookup within the \"table\" of keys mapped to values. When the HashMap "
"becomes too full, it increases to the next power of 2 (so, 16 records, then "
"32, etc.) and rebuilds the structure."
msgstr ""
"Godot реалізує Словник як ``OrderedHashMap<Variant, Variant>``. Механізм "
"зберігає невеликий масив (ініціалізований до 2^3 чи 8 записів) пар ключ-"
"значення. Коли хтось намагається отримати доступ до значення, вони надають "
"йому ключ. Потім він *хешує* ключ, тобто перетворює його в число. \"Хеш\" "
"використовується для обчислення індексу в масиві. Як масив, OHM має швидкий "
"пошук у \"таблиці\" ключів, зіставлених із значеннями. Коли HashMap стає "
"занадто заповненим, він збільшується до наступної степені 2 (тобто 16 "
"записів, потім 32 тощо) і відновлює структуру."

msgid ""
"Hashes are to reduce the chance of a key collision. If one occurs, the table "
"must recalculate another index for the value that takes the previous "
"position into account. In all, this results in constant-time access to all "
"records at the expense of memory and some minor operational efficiency."
msgstr ""
"Хеші мають зменшити ймовірність зіткнення ключа. Якщо такий трапляється, "
"таблиця повинна перерахувати інший індекс значення, яке враховує попередню "
"позицію. Загалом, це призводить до постійного доступу до всіх записів за "
"рахунок пам'яті та незначної операційної ефективності."

msgid "Hashing every key an arbitrary number of times."
msgstr "Хешування кожного ключа довільну кількість разів."

msgid ""
"Hash operations are constant-time, so even if an algorithm must do more than "
"one, as long as the number of hash calculations doesn't become too dependent "
"on the density of the table, things will stay fast. Which leads to..."
msgstr ""
"Операції хешування є постійними, тому, навіть якщо алгоритм повинен "
"виконувати більше одної операції, до тих пір, поки кількість обчислень хешу "
"не стане занадто залежною від щільності таблиці, все буде залишатися "
"швидким. Що веде до ..."

msgid "Maintaining an ever-growing size for the table."
msgstr "Зберігання постійно зростаючого розміру таблиці."

msgid ""
"HashMaps maintain gaps of unused memory interspersed in the table on purpose "
"to reduce hash collisions and maintain the speed of accesses. This is why it "
"constantly increases in size quadratically by powers of 2."
msgstr ""
"HashMaps підтримують прогалини невикористаної пам’яті, вбудовані в таблицю з "
"метою зменшення колізійних зіткнень і підтримки швидкості доступу. Ось чому "
"вона постійно збільшується в розмірі квадратично на ступінь 2."

msgid ""
"As one might be able to tell, Dictionaries specialize in tasks that Arrays "
"do not. An overview of their operational details is as follows:"
msgstr ""
"Як можна було б зрозуміти, Словники спеціалізуються на завданнях, які Масиви "
"не виконують. Для них характерні такі операції:"

msgid "**Iterate:** Fast."
msgstr "**Ітерація:** Швидка."

msgid ""
"Op: Iterate over the map's internal vector of hashes. Return each key. "
"Afterwards, users then use the key to jump to and return the desired value."
msgstr ""
"Oп: Ітерація внутрішніх векторів карти хешів. Повертає кожен ключ. Потім "
"користувачі використовують ключ, щоб перейти до потрібного значення та "
"повернути його."

msgid "**Insert, Erase, Move:** Fastest."
msgstr "**Вставка, Видалення, Переміщення:** Найшвидша."

msgid ""
"Op: Hash the given key. Do 1 addition operation to look up the appropriate "
"value (array start + offset). Move is two of these (one insert, one erase). "
"The map must do some maintenance to preserve its capabilities:"
msgstr ""
"Oп: Хешує заданий ключ. Виконує 1 операцію додавання, щоб знайти відповідне "
"значення (початок масиву + зміщення). Переміщення включає дві операції (одна "
"вставка, одна видалення). Карта мусить виконати певні дії, щоб зберегти свої "
"можливості:"

msgid "update ordered List of records."
msgstr "оновити впорядкований Список записів."

msgid "determine if table density mandates a need to expand table capacity."
msgstr "визначити, чи вимагає заповненість таблиці розширення ємності таблиці."

msgid ""
"The Dictionary remembers in what order users inserted its keys. This enables "
"it to execute reliable iterations."
msgstr ""
"Словник пам’ятає, в якому порядку користувачі вставляли його ключі. Це "
"дозволяє йому виконувати надійні ітерації."

msgid "**Get, Set:** Fastest. Same as a lookup *by key*."
msgstr "**Отримання, встановлення:** Найшвидша. Як і, що пошук *за ключем*."

msgid "Op: Same as insert/erase/move."
msgstr "Oп: Як і вставлення/видалення/переміщення."

msgid "**Find:** Slowest. Identifies the key of a value."
msgstr "**Пошук:** Найповільніша. Ідентифікує ключ значення."

msgid ""
"Op: Must iterate through records and compare the value until a match is "
"found."
msgstr ""
"Oп: Потрібно перебрати записи та порівняти значення, поки не буде знайдено "
"збіг."

msgid ""
"Note that Godot does not provide this feature out-of-the-box (because they "
"aren't meant for this task)."
msgstr ""
"Зауважте, що Godot не надає цю функцію out-of-the-box *(з коробки)* "
"(оскільки вона не призначена для цього завдання)."

msgid ""
"Godot implements Objects as stupid, but dynamic containers of data content. "
"Objects query data sources when posed questions. For example, to answer the "
"question, \"do you have a property called, 'position'?\", it might ask its :"
"ref:`script <class_Script>` or the :ref:`ClassDB <class_ClassDB>`. One can "
"find more information about what objects are and how they work in the :ref:"
"`doc_what_are_godot_classes` article."
msgstr ""
"Godot реалізує об’єкти як дурні, але динамічні контейнери вмісту даних. "
"Об’єкти запитують джерела даних, коли ставлять запитання. Наприклад, щоб "
"відповісти на запитання \"чи є у вас властивість, що називається, 'position'?"
"\", він може запитати свій :ref:`скрипт<class_Script>` або :ref:"
"`ClassDB<class_ClassDB>`. Більше інформації про те, що таке об’єкти та як "
"вони працюють, можна знайти в статті :ref:`doc_what_are_godot_classes`."

msgid ""
"The important detail here is the complexity of the Object's task. Every time "
"it performs one of these multi-source queries, it runs through *several* "
"iteration loops and HashMap lookups. What's more, the queries are linear-"
"time operations dependent on the Object's inheritance hierarchy size. If the "
"class the Object queries (its current class) doesn't find anything, the "
"request defers to the next base class, all the way up until the original "
"Object class. While these are each fast operations in isolation, the fact "
"that it must make so many checks is what makes them slower than both of the "
"alternatives for looking up data."
msgstr ""
"Важливою деталлю тут є складність завдання Об’єкта. Кожного разу, коли він "
"виконує один із цих запитів із декількома джерелами, він проходить через "
"*кілька* циклів ітерацій та пошук HashMap. Більше того, запити - це операції "
"лінійного часу, що залежать від розміру ієрархії успадкування Об’єкта. Якщо "
"клас, який запитує Об'єкт (його поточний клас), нічого не знаходить, запит "
"переходить до наступного базового класу і так аж до початкового класу "
"Об'єкта. Хоча окремо кожна така операція швидка, той факт, що вона повинна "
"зробити стільки перевірок, робить їх повільнішою, за обидві альтернативи "
"пошуку даних."

msgid ""
"When developers mention how slow the scripting API is, it is this chain of "
"queries they refer to. Compared to compiled C++ code where the application "
"knows exactly where to go to find anything, it is inevitable that scripting "
"API operations will take much longer. They must locate the source of any "
"relevant data before they can attempt to access it."
msgstr ""
"Коли розробники згадують, наскільки повільним є скриптове API, вони мають на "
"увазі саме цей ланцюжок запитів. Порівняно зі скомпільованим кодом С++, де "
"додаток точно знає, куди звернутися, щоб знайти що-небудь, неминуче операції "
"скриптового API займуть набагато більше часу. Вони повинні знайти джерело "
"будь-яких відповідних даних, перш ніж вони зможуть спробувати отримати до "
"них доступ."

msgid ""
"The reason GDScript is slow is because every operation it performs passes "
"through this system."
msgstr ""
"Причиною повільної роботи GDScript є те, що кожна операція, яку він виконує, "
"проходить через цю систему."

msgid ""
"C# can process some content at higher speeds via more optimized bytecode. "
"But, if the C# script calls into an engine class' content or if the script "
"tries to access something external to it, it will go through this pipeline."
msgstr ""
"C# може обробляти деякий вміст на вищих швидкостях за допомогою більш "
"оптимізованого байт-коду. Але якщо скрипт C# викликає вміст класу движка, "
"або якщо скрипт намагається отримати доступ до чогось зовнішнього для нього, "
"він все-одно пройде цей конвеєр."

msgid ""
"NativeScript C++ goes even further and keeps everything internal by default. "
"Calls into external structures will go through the scripting API. In "
"NativeScript C++, registering methods to expose them to the scripting API is "
"a manual task. It is at this point that external, non-C++ classes will use "
"the API to locate them."
msgstr ""
"NativeScript C++ іде ще далі і зберігає все внутрішнє за замовчуванням. "
"Виклики у зовнішні структури будуть проходити через скриптове API. У "
"NativeScript C++ реєстрація методів, щоб піддати їх скриптовому API, є "
"ручним завданням. Саме на цьому етапі зовнішні класи, що не належать C++, "
"використовуватимуть API для їх пошуку."

msgid ""
"So, assuming one extends from Reference to create a data structure, like an "
"Array or Dictionary, why choose an Object over the other two options?"
msgstr ""
"Отже, якщо припустити, що Посилання можна розширити, щоб створити структуру "
"даних, наприклад, Масив чи Словник, навіщо обирати Об’єкт коли є інші два "
"варіанти?"

msgid ""
"**Control:** With objects comes the ability to create more sophisticated "
"structures. One can layer abstractions over the data to ensure the external "
"API doesn't change in response to internal data structure changes. What's "
"more, Objects can have signals, allowing for reactive behavior."
msgstr ""
"**Контроль:** З об’єктами з’являється можливість створювати досконаліші "
"структури. Можна накласти абстракції на дані, щоб переконатися, що зовнішній "
"API не змінюється у відповідь на внутрішні зміни структури даних. Більше "
"того, об’єкти можуть мати сигнали, що дозволяють реагувати на поведінку."

msgid ""
"**Clarity:** Objects are a reliable data source when it comes to the data "
"that scripts and engine classes define for them. Properties may not hold the "
"values one expects, but one doesn't need to worry about whether the property "
"exists in the first place."
msgstr ""
"**Чіткість:** Об’єкти є надійним джерелом даних, коли йдеться про дані, які "
"для них визначають скрипти та класи движка. Можливо, властивості не містять "
"очікуваних значень, але не потрібно турбуватися про те, чи існує властивість "
"взагалі."

msgid ""
"**Convenience:** If one already has a similar data structure in mind, then "
"extending from an existing class makes the task of building the data "
"structure much easier. In comparison, Arrays and Dictionaries don't fulfill "
"all use cases one might have."
msgstr ""
"**Зручність:** Якщо хтось вже має на увазі подібну структуру даних, то "
"розширення з існуючого класу значно полегшує завдання побудови структури "
"даних. Для порівняння, Масиви та Словники придатні не для всіх випадків, які "
"можуть бути."

msgid ""
"Objects also give users the opportunity to create even more specialized data "
"structures. With it, one can design their own List, Binary Search Tree, "
"Heap, Splay Tree, Graph, Disjoint Set, and any host of other options."
msgstr ""
"Об'єкти також дають користувачам можливість створювати ще більш "
"спеціалізовані структури даних. За допомогою них можна створити власний "
"Список, Двійкове Дерево Пошуку, Heap, Дерево Відтворення, Графік, "
"Неперервний Набір та будь-який набір інших варіантів."

msgid ""
"\"Why not use Node for tree structures?\" one might ask. Well, the Node "
"class contains things that won't be relevant to one's custom data structure. "
"As such, it can be helpful to construct one's own node type when building "
"tree structures."
msgstr ""
"Може виникнути запитання: \"Чому б не використовувати Вузли для структур "
"дерева?\". Ну, клас Вузол містить речі, які не будуть стосуватися власної "
"структури даних. Таким чином, може бути корисно побудувати власний тип вузла "
"при побудові структур дерева."

msgid ""
"From here, one can then create their own structures with specific features, "
"limited only by their imagination."
msgstr ""
"Звідси можна створити власні структури зі специфічними особливостями, "
"обмеженими лише уявою."

msgid "Enumerations: int vs. string"
msgstr "Перерахунки: int та string"

msgid ""
"Most languages offer an enumeration type option. GDScript is no different, "
"but unlike most other languages, it allows one to use either integers or "
"strings for the enum values (the latter only when using the ``export`` "
"keyword in GDScript). The question then arises, \"which should one use?\""
msgstr ""
"Більшість мов пропонує перерахунки. GDScript не відрізняється, але на "
"відміну від більшості інших мов, він дозволяє використовувати цілі числа або "
"текст для значень перерахування (останнє лише при використанні ключового "
"слова ``export`` в GDScript). Тоді виникає запитання: \"що використовувати?\""

msgid ""
"The short answer is, \"whichever you are more comfortable with.\" This is a "
"feature specific to GDScript and not Godot scripting in general; The "
"languages prioritizes usability over performance."
msgstr ""
"Коротка відповідь: \"що тобі зручніше\". Це особливість, специфічна для "
"GDScript, а не скриптів Godot загалом; Мови надають перевагу зручності "
"використання порівняно з продуктивністю."

msgid ""
"On a technical level, integer comparisons (constant-time) will happen faster "
"than string comparisons (linear-time). If one wants to keep up other "
"languages' conventions though, then one should use integers."
msgstr ""
"На технічному рівні цілочисельні порівняння (постійний час) відбуватимуться "
"швидше текстових порівнянь (лінійний час). Якщо хтось хоче дотримуватися "
"конвенцій інших мов, тоді слід використовувати цілі числа."

msgid ""
"The primary issue with using integers comes up when one wants to *print* an "
"enum value. As integers, attempting to print MY_ENUM will print ``5`` or "
"what-have-you, rather than something like ``\"MyEnum\"``. To print an "
"integer enum, one would have to write a Dictionary that maps the "
"corresponding string value for each enum."
msgstr ""
"Основна проблема з використанням цілих чисел виникає, коли хочеться "
"*надрукувати* значення перерахунка. При використанні цілих чисел, спроба "
"надрукувати MY_ENUM буде друкувати ``5`` або те, що є у вас, а не щось "
"подібне ``\"MyEnum\"``. Щоб надрукувати ціле число, потрібно написати "
"Словник, який відображає відповідне значення рядка для кожного перерахунку."

msgid ""
"If the primary purpose of using an enum is for printing values and one "
"wishes to group them together as related concepts, then it makes sense to "
"use them as strings. That way, a separate data structure to execute on the "
"printing is unnecessary."
msgstr ""
"Якщо основною метою використання перерахунку є друк значень і хочеться "
"згрупувати їх як пов'язані поняття, то є сенс використовувати для них текст. "
"Таким чином, окрема структура даних для друку непотрібна."

msgid ""
"AnimatedTexture vs. AnimatedSprite vs. AnimationPlayer vs. AnimationTree"
msgstr "AnimatedTexture,. AnimatedSprite, AnimationPlayer та AnimationTree"

msgid ""
"Under what circumstances should one use each of Godot's animation classes? "
"The answer may not be immediately clear to new Godot users."
msgstr ""
"За яких обставин слід користуватися кожним із класів анімації Godot? "
"Відповідь може бути не одразу зрозумілою для нових користувачів Godot."

msgid ""
":ref:`AnimatedTexture <class_AnimatedTexture>` is a texture that the engine "
"draws as an animated loop rather than a static image. Users can manipulate..."
msgstr ""
":ref:`AnimatedTexture <class_AnimatedTexture>` це текстура, яку движок малює "
"як анімований цикл, а не як статичне зображення. Користувачі можуть "
"маніпулювати ..."

msgid "the rate at which it moves across each section of the texture (fps)."
msgstr "швидкістю, з якою цикл відтворює кожну ділянку текстури (fps)."

msgid "the number of regions contained within the texture (frames)."
msgstr "кількість областей, що містяться в текстурі (кадри)."

msgid ""
"Godot's :ref:`VisualServer <class_VisualServer>` then draws the regions in "
"sequence at the prescribed rate. The good news is that this involves no "
"extra logic on the part of the engine. The bad news is that users have very "
"little control."
msgstr ""
"Потім :ref:`VisualServer<class_VisualServer>` Godot малює області послідовно "
"із встановленою швидкістю. Хороша новина полягає в тому, що це не передбачає "
"додаткової логіки з боку движка. Погана новина полягає в тому, що "
"користувачі мають дуже слабкий контроль."

msgid ""
"Also note that AnimatedTexture is a :ref:`Resource <class_Resource>` unlike "
"the other :ref:`Node <class_Node>` objects discussed here. One might create "
"a :ref:`Sprite <class_Sprite>` node that uses AnimatedTexture as its "
"texture. Or (something the others can't do) one could add AnimatedTextures "
"as tiles in a :ref:`TileSet <class_TileSet>` and integrate it with a :ref:"
"`TileMap <class_TileMap>` for many auto-animating backgrounds that all "
"render in a single batched draw call."
msgstr ""
"Також запримітьте, що AnimatedTexture - це :ref:`Ресурс <class_Resource>`, "
"на відміну від інших обговорених тут об'єктів :ref:`Вузол<class_Node>`. "
"Можна створити вузол :ref:`Спрайт <class_Sprite>`, який використовує "
"AnimatedTexture як свою текстуру. Або (те, що інші не можуть зробити), можна "
"додати AnimatedTexture як плитки в :ref:`TileSet <class_TileSet>` та "
"інтегрувати його з :ref:`TileMap<class_TileMap>` для багатьох фонів з "
"автоматичною анімацією, які всі відображаються в одному пакетному виклику "
"малювання."

msgid ""
"The AnimatedSprite node, in combination with the :ref:`SpriteFrames "
"<class_SpriteFrames>` resource, allows one to create a variety of animation "
"sequences through spritesheets, flip between animations, and control their "
"speed, regional offset, and orientation. This makes them well-suited to "
"controlling 2D frame-based animations."
msgstr ""
"Вузол AnimatedSprite у поєднанні з ресурсом :ref:"
"`SpriteFrames<class_SpriteFrames>` дозволяє створювати різноманітні "
"послідовності анімації за допомогою таблиць спрайтів, перебирати між "
"анімаціями та контролювати їх швидкість, регіональний зсув та орієнтацію. Це "
"робить їх чудовими для управління 2D-анімацією на основі кадру."

msgid ""
"If one needs trigger other effects in relation to animation changes (for "
"example, create particle effects, call functions, or manipulate other "
"peripheral elements besides the frame-based animation), then will need to "
"use an :ref:`AnimationPlayer <class_AnimationPlayer>` node in conjunction "
"with the AnimatedSprite."
msgstr ""
"Якщо потрібно викликати інші ефекти щодо змін анімації (наприклад, створити "
"ефекти частинок, викликати функції або маніпулювати іншими периферійними "
"елементами, крім анімації на основі кадру), тоді потрібно буде "
"використовувати вузол :ref:`AnimationPlayer<class_AnimationPlayer>` спільно "
"з AnimatedSprite."

msgid ""
"AnimationPlayers are also the tool one will need to use if they wish to "
"design more complex 2D animation systems, such as..."
msgstr ""
"AnimationPlayers - це також інструмент, який потрібно буде використовувати, "
"якщо ви хочете розробляти складніші 2D-анімаційні системи, такі як ..."

msgid "**Cut-Out animations:** editing sprites' transforms at runtime."
msgstr ""
"**Вирізані анімації:** редагування перетворень спрайтів під час відтворення."

msgid ""
"**2D Mesh animations:** defining a region for the sprite's texture and "
"rigging a skeleton to it. Then one animates the bones which stretch and bend "
"the texture in proportion to the bones' relationships to each other."
msgstr ""
"**Анімація 2D Меша:** визначення області текстури спрайту та встановлення "
"скелета до нього. Потім анімуюються кістки, які розтягують і згинають "
"текстуру пропорційно відношенню кісток між собою."

msgid "A mix of the above."
msgstr "Суміш вищезазначеного."

msgid ""
"While one needs an AnimationPlayer to design each of the individual "
"animation sequences for a game, it can also be useful to combine animations "
"for blending, i.e. enabling smooth transitions between these animations. "
"There may also be a hierarchical structure between animations that one plans "
"out for their object. These are the cases where the :ref:`AnimationTree "
"<class_AnimationTree>` shines. One can find an in-depth guide on using the "
"AnimationTree :ref:`here <doc_animation_tree>`."
msgstr ""
"Хоча для розробки кожної з окремих послідовностей анімації для гри потрібен "
"AnimationPlayer, також може бути корисним поєднання анімації для змішування, "
"тобто забезпечення плавних переходів між цими анімаціями. Також може "
"існувати ієрархічна структура між анімацією, яку планується для свого "
"об’єкта. Це випадки для :ref:`AnimationTree <class_AnimationTree>`. Можна "
"знайти поглиблене керівництво по використанню AnimationTree :ref:"
"`тут<doc_animation_tree>`."

msgid "Translation status"
msgstr "Стан перекладу"
