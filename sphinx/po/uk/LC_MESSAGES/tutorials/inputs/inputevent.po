# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using InputEvent"
msgstr "Використання inputEvent"

msgid "What is it?"
msgstr "Що це таке?"

msgid ""
"Managing input is usually complex, no matter the OS or platform. To ease "
"this a little, a special built-in type is provided, :ref:`InputEvent "
"<class_InputEvent>`. This datatype can be configured to contain several "
"types of input events. Input events travel through the engine and can be "
"received in multiple locations, depending on the purpose."
msgstr ""
"Управління входом, як правило, складне, незалежно від ОС, або платформи. Щоб "
"трохи полегшити це, передбачений спеціальний вбудований тип Вхідних Подій :"
"ref:`InputEvent <class_InputEvent>`. Цей тип даних можна настроїти так, щоб "
"він містив кілька типів вхідних подій. Вхідні події проходять через рушій і "
"можуть бути отримані в декількох місцях, в залежності від мети."

msgid "Here is a quick example, closing your game if the escape key is hit:"
msgstr "Ось короткий приклад, закривання гри при натисканні клавіші Esc:"

msgid ""
"However, it is cleaner and more flexible to use the provided :ref:`InputMap "
"<class_InputMap>` feature, which allows you to define input actions and "
"assign them different keys. This way, you can define multiple keys for the "
"same action (e.g. the keyboard escape key and the start button on a "
"gamepad). You can then more easily change this mapping in the project "
"settings without updating your code, and even build a key mapping feature on "
"top of it to allow your game to change the key mapping at runtime!"
msgstr ""
"Однак чистіше і зручніше використовувати надану функцію Карти Введення :ref:"
"`InputMap <class_InputMap>`, яка дозволяє визначати дії введення і "
"призначати їм різні клавіші. Таким чином, ви можете визначити кілька клавіш "
"для однієї дії (наприклад, клавішу виходу з клавіатури та кнопку пуску на "
"геймпаді). Потім ви зможете легше змінити ці призначення в параметрах "
"проекту, не оновлюючи код, і навіть створити функцію перепризначення клавіш, "
"щоб дозволити гравцям призначати зручні для них клавіші!"

msgid ""
"You can set up your InputMap under **Project > Project Settings > Input "
"Map** and then use those actions like this:"
msgstr ""
"Карту вводу можна настроїти в розділі **Проект > Параметри проекту > Input "
"Map**, а потім використати ці дії, наприклад, так:"

msgid "How does it work?"
msgstr "Як усе це працює?"

msgid ""
"Every input event is originated from the user/player (though it's possible "
"to generate an InputEvent and feed them back to the engine, which is useful "
"for gestures). The OS object for each platform will read events from the "
"device, then feed them to MainLoop. As :ref:`SceneTree <class_SceneTree>` is "
"the default MainLoop implementation, events are fed to it. Godot provides a "
"function to get the current SceneTree object : **get_tree()**."
msgstr ""
"Кожна вхідна подія походить від користувача/гравця (хоча можна згенерувати "
"InputEvent і подати її назад в рушій, що корисно для жестів). Об'єкт ОС для "
"кожної платформи буде читати події з пристрою, а потім подавати їх в "
"MainLoop *(Головний Цикл)*. Оскільки SceneTree *(Дерево сцени)* є "
"реалізацією MainLoop за замовчуванням, події подаються до нього. Godot надає "
"функцію отримання поточного об'єкта SceneTree: **get_tree()**."

msgid ""
"But SceneTree does not know what to do with the event, so it will give it to "
"the viewports, starting by the \"root\" :ref:`Viewport <class_Viewport>` "
"(the first node of the scene tree). Viewport does quite a lot of stuff with "
"the received input, in order:"
msgstr ""
"Але SceneTree не знає, що робити з подією, тому віддає її на вікна "
"перегляду, починаючи з \"root\" *(кореневого)* :ref:`Viewport (Вікна "
"перегляду) <class_Viewport>` (першого вузла дерева сцени). Вікно перегляду "
"робить з отриманим входом досить багато речей, по порядку:"

msgid ""
"First of all, the standard :ref:`Node._input() <class_Node_method__input>` "
"function will be called in any node that overrides it (and hasn't disabled "
"input processing with :ref:`Node.set_process_input() "
"<class_Node_method_set_process_input>`). If any function consumes the event, "
"it can call :ref:`SceneTree.set_input_as_handled() "
"<class_SceneTree_method_set_input_as_handled>`, and the event will not "
"spread any more. This ensures that you can filter all events of interest, "
"even before the GUI. For gameplay input, :ref:`Node._unhandled_input() "
"<class_Node_method__unhandled_input>` is generally a better fit, because it "
"allows the GUI to intercept the events."
msgstr ""
"Перш за все, буде викликатися стандартна функція :ref:`Node._input() "
"<class_Node_method__input>` в будь-якому вузлі, який її перевизначає (і не "
"відключив обробку вводу з :ref:`Node.set_process_input() "
"<class_Node_method_set_process_input>`). Якщо якась функція використовує "
"подію, вона може викликати :ref:`SceneTree.set_input_as_handled() "
"<class_SceneTree_method_set_input_as_handled>`, і подія більше не буде "
"поширюватися. Це гарантує, що ви можете фільтрувати всі потрібні події, ще "
"до графічного інтерфейсу. Для ігрового введення, як правило, краще "
"підходить :ref:`Node._unhandled_input() "
"<class_Node_method__unhandled_input>`, оскільки дозволяє графічному "
"інтерфейсу перехоплювати події."

msgid ""
"Second, it will try to feed the input to the GUI, and see if any control can "
"receive it. If so, the :ref:`Control <class_Control>` will be called via the "
"virtual function :ref:`Control._gui_input() "
"<class_Control_method__gui_input>` and the signal \"gui_input\" will be "
"emitted (this function is re-implementable by script by inheriting from it). "
"If the control wants to \"consume\" the event, it will call :ref:`Control."
"accept_event() <class_Control_method_accept_event>` and the event will not "
"spread any more. Use the :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>` property to control whether a :ref:"
"`Control <class_Control>` is notified of mouse events via :ref:`Control."
"_gui_input() <class_Control_method__gui_input>` callback, and whether these "
"events are propagated further."
msgstr ""
"По-друге, він спробує подати вхід в графічний інтерфейс, і подивитися, чи "
"може будь-який вузол керування :ref:`Control <class_Control>` отримати його. "
"Якщо так, то вузол буде викликаний через віртуальну функцію :ref:`Control."
"_gui_input() <class_Control_method__gui_input>` і видасть сигнал "
"\"gui_input\" (ця функція повторно реалізується скриптом шляхом успадкування "
"від нього). Якщо елемент керування хоче використати подію, він викличе :ref:"
"`Control.accept_event() <class_Control_method_accept_event>` і подія більше "
"не поширюватиметься. Використовуйте властивість :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>`, щоб контролювати, чи :ref:`Control "
"<class_Control>` отримав сповіщення про події мишки за допомогою зворотного "
"виклику :ref:`Control._gui_input() <class_Control_method__gui_input>`, і чи "
"поширюються ці події далі."

msgid ""
"If so far no one consumed the event, the unhandled input callback will be "
"called if overridden (and not disabled with :ref:`Node."
"set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>`). If any function consumes "
"the event, it can call :ref:`SceneTree.set_input_as_handled() "
"<class_SceneTree_method_set_input_as_handled>`, and the event will not "
"spread any more. The unhandled input callback is ideal for full-screen "
"gameplay events, so they are not received when a GUI is active."
msgstr ""
"Якщо досі подія ніде не була використана, буде викликаний необроблений "
"вхідний зворотний виклик, якщо вона перевизначена (і не відключена за "
"допомогою :ref:`Node.set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>`). Якщо якась функція "
"використовує подію, вона може викликати :ref:`SceneTree."
"set_input_as_handled() <class_SceneTree_method_set_input_as_handled>`, і "
"подія більше не буде поширюватися. Необроблений вхідний зворотний виклик "
"ідеально підходить для повноекранних ігрових подій, тому вони не "
"отримуються, коли графічний інтерфейс активний."

msgid ""
"If no one wanted the event so far, and a :ref:`Camera <class_Camera>` is "
"assigned to the Viewport with :ref:`Object Picking "
"<class_viewport_property_physics_object_picking>` turned on, a ray to the "
"physics world (in the ray direction from the click) will be cast. (For the "
"root viewport, this can also be enabled in :ref:`Project Settings "
"<class_ProjectSettings_property_physics/common/enable_object_picking>`) If "
"this ray hits an object, it will call the :ref:`CollisionObject."
"_input_event() <class_CollisionObject_method__input_event>` function in the "
"relevant physics object (bodies receive this callback by default, but areas "
"do not. This can be configured through :ref:`Area <class_Area>` properties)."
msgstr ""
"Якщо досі ніхто не захотів цієї події, і камера призначена для Вікна "
"перегляду має включений :ref:`Object Picking "
"<class_viewport_property_physics_object_picking>` *(призначений для "
"вибирання об'єктів у вікні мишкою)*, у фізичний світ (в місці клацання) буде "
"кинутий промінь. (Для кореневого вікна перегляду цю функцію також можна "
"ввімкнути в :ref:`Параметрах проекта<class_ProjectSettings_property_physics/"
"common/enable_object_picking>`) Якщо цей промінь натикається на об'єкт, він "
"викличе функцію :ref:`CollisionObject._input_event() "
"<class_CollisionObject_method__input_event>` у відповідному фізичному "
"об'єкті (тіла отримують цей зворотний виклик за замовчуванням, але області - "
"ні, проте це можна налаштувати за допомогою властивостей :ref:"
"`області<class_Area>`)."

msgid ""
"Finally, if the event was unhandled, it will be passed to the next Viewport "
"in the tree, otherwise it will be ignored."
msgstr ""
"Нарешті, якщо подія так і не була оброблена, вона буде передана на наступне "
"в дереві вікно перегляду, в противному випадку вона буде проігнорована."

msgid ""
"When sending events to all listening nodes within a scene, the viewport will "
"do so in a reverse depth-first order: Starting with the node at the bottom "
"of the scene tree, and ending at the root node:"
msgstr ""
"При відправці подій на всі вузли прослуховування в межах сцени, вікно "
"перегляду буде робити це в зворотному порядку глибини: Починаючи з вузла в "
"нижній частині дерева сцени, і закінчуючи на кореневим вузлом:"

msgid ""
"GUI events also travel up the scene tree but, since these events target "
"specific Controls, only direct ancestors of the targeted Control node "
"receive the event."
msgstr ""
"Події графічного інтерфейсу також переміщуються вгору по дереву сцени, але, "
"оскільки ці події націлені на конкретні елементи керування *(вузли "
"Control)*, то події отримують лише прямі предки цільового вузла керування."

msgid ""
"In accordance with Godot's node-based design, this enables specialized child "
"nodes to handle and consume particular events, while their ancestors, and "
"ultimately the scene root, can provide more generalized behavior if needed."
msgstr ""
"Відповідно до архітектури Godot, яка заснована на вузлах, це дозволяє "
"спеціалізованим дочірнім вузлам обробляти і споживати певні події, в той час "
"як їх предки, і в кінцевому підсумку корінь сцени, можуть забезпечити більш "
"узагальнену поведінку, якщо це необхідно."

msgid "Anatomy of an InputEvent"
msgstr "Анатомія InputEvent"

msgid ""
":ref:`InputEvent <class_InputEvent>` is just a base built-in type, it does "
"not represent anything and only contains some basic information, such as "
"event ID (which is increased for each event), device index, etc."
msgstr ""
":ref:`InputEvent <class_InputEvent>` - це просто базовий вбудований тип "
"вхідної події, він нічого не представляє і містить лише деяку основну "
"інформацію, таку як ідентифікатор події (який збільшується для кожної "
"події), індекс пристрою, тощо."

msgid ""
"There are several specialized types of InputEvent, described in the table "
"below:"
msgstr ""
"Існує кілька спеціалізованих типів InputEvent, описаних в таблиці нижче:"

msgid "Event"
msgstr "Подія"

msgid "Type Index"
msgstr "Індекс типа"

msgid "Description"
msgstr "Опис"

msgid ":ref:`InputEvent <class_InputEvent>`"
msgstr ""

msgid "NONE"
msgstr "НІЧОГО"

msgid "Empty Input Event."
msgstr "Порожня вхідна подія."

msgid ":ref:`InputEventKey <class_InputEventKey>`"
msgstr ""

msgid "KEY"
msgstr ""

msgid "Contains a scancode and Unicode value, as well as modifiers."
msgstr "Містить сканкод і значення Юнікоду, а також модифікатори."

msgid ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"
msgstr ""

msgid "MOUSE_BUTTON"
msgstr ""

msgid "Contains click information, such as button, modifiers, etc."
msgstr ""
"Містить інформацію про кліки мишкою, таку як клавіша, модифікатори тощо."

msgid ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"
msgstr ""

msgid "MOUSE_MOTION"
msgstr ""

msgid ""
"Contains motion information, such as relative, absolute positions and speed."
msgstr ""
"Містить інформацію про рух мишки, таку як відносні, абсолютні позиції та "
"швидкість."

msgid ":ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"
msgstr ""

msgid "JOYSTICK_MOTION"
msgstr ""

msgid "Contains Joystick/Joypad analog axis information."
msgstr "Містить інформацію про аналогову вісь Джойстика/Джойпада."

msgid ":ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"
msgstr ""

msgid "JOYSTICK_BUTTON"
msgstr ""

msgid "Contains Joystick/Joypad button information."
msgstr "Містить інформацію про джойстик/джойпад."

msgid ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"
msgstr ""

msgid "SCREEN_TOUCH"
msgstr ""

msgid ""
"Contains multi-touch press/release information. (only available on mobile "
"devices)"
msgstr ""
"Містить інформацію про натискання/відтискання кількох дотиків. (доступно "
"тільки на мобільних пристроях)"

msgid ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"
msgstr ""

msgid "SCREEN_DRAG"
msgstr ""

msgid ""
"Contains multi-touch drag information. (only available on mobile devices)"
msgstr ""
"Містить відомості про переміщення кількох дотиків. (доступно тільки на "
"мобільних пристроях)"

msgid ":ref:`InputEventAction <class_InputEventAction>`"
msgstr ""

msgid "SCREEN_ACTION"
msgstr ""

msgid ""
"Contains a generic action. These events are often generated by the "
"programmer as feedback. (more on this below)"
msgstr ""
"Містить загальну дію. Ці події часто генеруються програмістом як зворотний "
"зв'язок. (Докладніше про це нижче)"

msgid "Actions"
msgstr "Дії"

msgid ""
"An InputEvent may or may not represent a pre-defined action. Actions are "
"useful because they abstract the input device when programming the game "
"logic. This allows for:"
msgstr ""
"InputEvent може, або не може, представляти попередньо визначену дію. Дії "
"корисні тим, що вони абстрагують пристрій введення при програмуванні логіки "
"гри. Це дозволяє:"

msgid ""
"The same code to work on different devices with different inputs (e.g., "
"keyboard on PC, Joypad on console)."
msgstr ""
"Один і той же код для роботи на різних пристроях з різними входами "
"(наприклад, клавіатура на ПК, Joypad на консолі)."

msgid "Input to be reconfigured at run-time."
msgstr "Переналаштування вводу під час виконання."

msgid ""
"Actions can be created from the Project Settings menu in the Actions tab."
msgstr "Дії можна створити з меню **Параметри проекту** на вкладці **Дії**."

msgid ""
"Any event has the methods :ref:`InputEvent.is_action() "
"<class_InputEvent_method_is_action>`, :ref:`InputEvent.is_pressed() "
"<class_InputEvent_method_is_pressed>` and :ref:`InputEvent "
"<class_InputEvent>`."
msgstr ""
"Будь-яка подія має методи :ref:`InputEvent.is_action() "
"<class_InputEvent_method_is_action>`, :ref:`InputEvent.is_pressed() "
"<class_InputEvent_method_is_pressed>` та :ref:`InputEvent "
"<class_InputEvent>`."

msgid ""
"Alternatively, it may be desired to supply the game back with an action from "
"the game code (a good example of this is detecting gestures). The Input "
"singleton has a method for this: :ref:`Input.parse_input_event() "
"<class_input_method_parse_input_event>`. You would normally use it like this:"
msgstr ""
"Крім того, може знадобитися надати грі дію з коду гри (хорошим прикладом "
"цього є виявлення жестів). Синглтон Input має для цього метод: :ref:`Input."
"parse_input_event() <class_input_method_parse_input_event>`. Зазвичай ви "
"використовуєте його так:"

msgid "InputMap"
msgstr "InputMap (карта введення)"

msgid ""
"Customizing and re-mapping input from code is often desired. If your whole "
"workflow depends on actions, the :ref:`InputMap <class_InputMap>` singleton "
"is ideal for reassigning or creating different actions at run-time. This "
"singleton is not saved (must be modified manually) and its state is run from "
"the project settings (project.godot). So any dynamic system of this type "
"needs to store settings in the way the programmer best sees fit."
msgstr ""
"Часто потрібне налаштування та повторне зіставлення вхідних даних з коду. "
"Якщо весь робочий процес залежить від дій, синглтон :ref:`InputMap "
"<class_InputMap>` ідеально підходить для перепризначення, або створення, "
"різних дій під час виконання. Цей синглтон не зберігається (потрібно "
"змінювати вручну), а його стан запускається з параметрів проекту (project."
"godot). Таким чином, будь-яка динамічна система такого типу повинна "
"зберігати налаштування так, як програміст найкраще вважає за потрібне."

msgid "Translation status"
msgstr "Стан перекладу"
