# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "First steps with Rooms and Portals"
msgstr "Перші кроки Кімнатами та Порталами"

msgid "The RoomManager"
msgstr "Керівник кімнат RoomManager"

msgid ""
"Anytime you want to use the portal system, you need to include a special "
"node in your scene tree, called the :ref:`RoomManager<class_RoomManager>`. "
"The RoomManager is responsible for the runtime maintenance of the system, "
"especially converting the objects in your rooms into a *room graph* which is "
"used at runtime to perform occlusion culling and other tasks."
msgstr ""
"Завжди, коли ви хочете використовувати систему порталів, вам потрібно "
"включити спеціальний вузол у своє дерево сцени, який називається :ref:"
"`RoomManager<class_RoomManager>` *(Керівник Кімнат)*. RoomManager відповідає "
"за технічне обслуговування системи, особливо перетворення об'єктів у ваших "
"кімнатах всередині *кімнатної діаграми*, яке використовується під час "
"виконання вибракування оклюзії та інших завдань."

msgid "Room Conversion"
msgstr "Перетворення кімнати"

msgid ""
"This conversion must take place every time you want to activate the system. "
"It does not store the *room graph* in your project (for flexibility and to "
"save memory). You can either trigger it by pressing the **Convert Rooms** "
"button in the editor toolbar (which also has a keyboard shortcut) or by "
"calling the ``rooms_convert()`` method in the RoomManager. The latter method "
"will be what you use in-game. Note that for safety, best practice is to call "
"``rooms_clear()`` before unloading or changing levels."
msgstr ""
"Перетворення має відбуватися щоразу, коли ви хочете активувати систему. Воно "
"не зберігає *графік кімнати* у вашому проекті (для гнучкості та збереження "
"пам'яті). Ви можете, або запустити його, натиснувши кнопку **Перетворити "
"кімнати** на панелі інструментів редактора (яка також має комбінацію "
"клавіш), або, ви можете, викликати метод ``rooms_convert()`` у RoomManager. "
"Останній спосіб дасть ігровий результат. Зверніть увагу, що, для безпеки, "
"найкраще викликати ``rooms_clear()`` перед вивантаженням, або зміною рівнів."

msgid ""
"If you convert the level while the editor is running, the portal culling "
"system will take over from the normal Godot frustum culling, potentially "
"interfering with editor features. To get around this, you can turn portal "
"culling on and off using either the **View Portal Culling** toggle in the "
"**View** menu on the editor toolbar (which also has a keyboard shortcut) or "
"the **Active** setting in the RoomManager node."
msgstr ""
"Якщо ви перетворите рівень під час роботи редактора, система вибракування "
"порталів перейме звичайне вибракування Godot. Це може вплинути на деякі "
"функції редактора. Для уникнення ускладнень ви можете ввімкнути та вимкнути "
"вибракування порталів, використовуючи перемикач **Переглянути "
"відбраковування Portal** в меню **Перегляд** на панелі інструментів "
"редактора (який також має сполучення клавіш), або через параметр **Active** "
"на вузлі RoomManager."

msgid ""
"To use the RoomManager, you have to tell it where the rooms are in your "
"scene tree, or, more specifically, where the RoomList node is. This RoomList "
"is the parent of your rooms - see below. If the RoomList is not set, "
"conversion will fail, and you will see a warning dialog box."
msgstr ""
"Щоб використовувати RoomManager, ви повинні вказати йому, де знаходяться "
"кімнати у вашому дереві сцени, а точніше, де знаходиться вузол RoomList "
"*(Список Кімнат)*. RoomList є батьком ваших кімнат - дивіться нижче. Якщо "
"його не встановлено, перетворення не вдасться, і з'явиться діалогове вікно з "
"попередженням."

msgid "The RoomList"
msgstr "RoomList (Список Кімнат)"

msgid ""
"Before we create any rooms, we must first create a node to be the parent of "
"all the static objects, rooms, roomgroups, and so on in our level. This node "
"is referred to as the the ``RoomList``."
msgstr ""
"Перш ніж створювати будь-які кімнати, ми повинні створити вузол, який буде "
"батьком всіх статичних об'єктів, кімнат, груп кімнат і так далі на нашому "
"рівні. Цей вузол називається ``RoomList`` *(Список Кімнат)*."

msgid ""
"The roomlist is **not** a special node type – it can just be a regular "
"Spatial."
msgstr ""
"RoomList - це **не є** якийсь особливий тип вузла, це може бути звичайний "
"просторовий вузол."

msgid ""
"You will need to assign the roomlist node in the RoomManager so that it "
"knows where to find the rooms."
msgstr ""
"Вам потрібно буде помістити вузол RoomList в RoomManager, щоб RoomManager "
"знав, де знайти кімнати."

msgid ""
"Why do we use a specific branch of the scene tree and not the scene root? "
"The answer is that there are many internal details of the system which are "
"easier to manage if the rooms are placed on their own branch."
msgstr ""
"Чому ми використовуємо певну гілку дерева сцени, а не використовуємо корінь "
"сцени? Відповідь полягає в тому, що є багато внутрішніх деталей системи, "
"якими легше керувати, якщо кімнати розміщені на власній гілці."

msgid ""
"Often you will end up completely replacing the roomlist branch at runtime in "
"your game as you load and unload levels."
msgstr ""
"Часто ви в кінцевому підсумку повністю змінюєте гілку списку кімнат під час "
"роботи гри, коли завантажуєте та вивантажуєте рівні."

msgid "Rooms"
msgstr "Кімнати"

msgid "What is a room?"
msgstr "Що таке кімната?"

msgid ""
":ref:`Room<class_Room>`\\ s are a way of spatially partitioning your level "
"into areas that make sense in terms of level design. Rooms often quite "
"literally *are* rooms (like in a building). Ultimately though, as far as the "
"engine is concerned, a room represents a **non-overlapping** convex volume "
"in which you typically place most of your objects that fall within that area."
msgstr ""
":ref:`Кімнати<class_Room>`- це спосіб просторового розподілу вашого рівня на "
"області, які мають сенс з точки зору дизайну рівня. Кімнати часто *є* "
"буквальними кімнатами (наприклад, в будівлі). Зрештою, для рушія, кімната "
"являє собою опуклий об’єм, який **не перетинається з іншим**, і в якому ви, "
"зазвичай, розміщуєте більшість своїх об’єктів, які потрапляють в цю область."

msgid ""
"A room doesn't need to correspond to a literal room. It could, for example, "
"also be a canyon in an outdoor area or a smaller part of a concave room. "
"With a little imagination, you can use the system in almost any scenario."
msgstr ""
"Кімната не повинна буквально бути приміщенням. Наприклад, це може бути "
"каньйон на відкритій території, або менша частина увігнутої кімнати. Маючи "
"невелику фантазію, ви можете використовувати систему практично в будь-якому "
"сценарії."

msgid "Why convex?"
msgstr "Чому опукла?"

msgid ""
"Rooms are defined as convex volumes (or *convex hulls*) because it's trivial "
"to mathematically determine whether a point is within a convex hull. A "
"simple plane check will tell you the distance of a point from a plane. If a "
"point is behind all the planes bounding the convex hull, then by definition "
"it is inside the room. This makes all kinds of things easier in the "
"internals of the system, such as checking which room a camera is within."
msgstr ""
"Кімнати визначаються як опуклі об'єми (або *опуклі корпуси*), тому, що "
"математично дуже легко визначити, чи знаходиться точка в опуклому корпусі. "
"Проста перевірка площини підкаже вам відстань від точки до площини. Якщо "
"точка знаходиться позаду всіх площин, що обмежують опуклий корпус, то за "
"визначенням вона знаходиться всередині приміщення. Це полегшує сортування "
"речей по внутрішніх частинах системи, зокрема, легко виявити, в якій кімнаті "
"знаходиться камера."

msgid ""
"*A convex hull. The hull is defined as a series of planes facing outward. If "
"a point is behind all the planes, it is within the hull.*"
msgstr ""
"*Опуклий корпус. Корпус визначається як серія площин, повернутих назовні. "
"Якщо точка знаходиться позаду всіх площин, вона знаходиться в корпусі.*"

msgid "Why non-overlapping?"
msgstr "Чому недопустимі перетини?"

msgid ""
"If two rooms overlap, and a camera or player is in this overlapping zone, "
"then there is no way to tell which room the object should be in (and hence "
"render from), or be rendered in. This requirement for non-overlapping rooms "
"does have implications for level design."
msgstr ""
"Якщо дві кімнати перетинаються, і камера, або гравець, знаходиться в зоні "
"перетину, то немає ніякого способу вказати, в якій кімнаті повинен "
"знаходитися (і відтворюватися) об'єкт. Вимога для кімнат не перетинатися, "
"має наслідки для проектування рівня."

msgid ""
"If you accidentally create overlapping rooms, the editor will warn you when "
"you convert the rooms, indicating any overlapping zones in red."
msgstr ""
"Якщо ви випадково створили кімнати, що перетинаються, редактор попередить "
"вас під час перетворення кімнат і позначить червоним зони перетину."

msgid ""
"The system does attempt to cope with overlapping rooms as best as possible "
"by making the current room *\"sticky\"*. Each object remembers which room it "
"was in during the previous frame and stays within it as long as it does not "
"move outside the convex hull room bound. This can result in some hysteresis "
"in these overlapping zones."
msgstr ""
"Система намагається впоратися з перетином кімнат якомога краще, роблячи "
"поточну кімнату *\"липкою\"*. Кожен об'єкт пам'ятає, в якій кімнаті він "
"знаходився в останньому кадрі, і залишається в ній до тих пір, поки не вийде "
"за межі опуклого корпусу кімнати. Це може призвести до невеликого "
"гістерезису в зонах перетину."

msgid ""
"There is one exception, however, for :ref:`internal "
"rooms<doc_rooms_and_portals_internal_rooms>`. You do not have to worry about "
"these to start with."
msgstr ""
"Однак є один виняток для :ref:`внутрішніх "
"кімнат<doc_rooms_and_portals_internal_rooms>`. Вам не доведеться турбуватися "
"про них на початку."

msgid "How do I create a room?"
msgstr "Як створити кімнату?"

msgid ""
"A :ref:`Room<class_Room>` is a node type that can be added to the scene tree "
"like any other. You can place objects within the room by making them "
"children and grand-children of the Room node."
msgstr ""
":ref:`Кімната<class_Room>` - це тип вузла під назвою Room, який можна додати "
"до дерева сцени, як і будь-який інший. Ви можете розмістити об'єкти "
"всередині кімнати, зробивши їх дітьми та онуками вузла Room."

msgid "How do I define the shape and position of my room convex hull?"
msgstr "Як визначити форму і положення опуклого корпусу моєї кімнати?"

msgid ""
"Because defining the room bound is the most important aspect of the system, "
"there are THREE methods available to define the shape of a room in Godot:"
msgstr ""
"Оскільки визначення меж кімнати є найважливішим аспектом системи, є ТРИ "
"методи, доступні для визначення форми кімнати в Godot:"

msgid ""
"Use the geometry of the objects contained within the room to automatically "
"create an approximate bound."
msgstr ""
"Використовуйте геометрію об'єктів, що містяться в кімнаті, щоб автоматично "
"створити приблизну межу."

msgid ""
"Manually edit the points that define the convex hull in the room inspector "
"or drag the points around using the editor gizmo (see :ref:"
"`doc_room_point_editing`)."
msgstr ""
"Вручну редагуйте точки, які визначають опуклий корпус кімнати, в інспекторі, "
"або перетягуючи точки за допомогою редактора gizmo (див. :ref:"
"`doc_room_point_editing`)."

msgid ""
"Provide a manual bound. This is a MeshInstance in the room that has geometry "
"in the shape of the desired bound, with a name with the postfix ``-bound``. "
"This is something you might choose to do if you create your levels in "
"Blender or similar (see :ref:`doc_rooms_and_portals_blender`)."
msgstr ""
"Надайте прив'язку вручну. Це MeshInstance в кімнаті, який має геометрію у "
"формі потрібної межі, з назвою, що закінчується на ``-bound`` *(межа)*. Таке "
"ви можете зробити, якщо створюєте свої рівні в Blender або аналогічних "
"програмах (див. :ref:`doc_rooms_and_portals_blender`)."

msgid ""
"While the first option can be all that is required, particularly with simple "
"rooms or for pre-production, using manual bounds gives you ultimate control "
"at the expense of a small amount of editing. You can also combine the two "
"approaches, perhaps using automatic bounds for most rooms but manually "
"editing problem areas."
msgstr ""
"Хоча першого варіанту може стати на все, що потрібно, особливо з простими "
"кімнатами, або для попереднього виробництва, потужність ручного налаштування "
"меж дає вам остаточний контроль (за рахунок невеликої кількості "
"редагування). Ви також можете поєднати два підходи, можливо, використовуючи "
"автоматичні межі для більшості кімнат, але вручну редагуючи проблемні "
"області."

msgid "The automatic method is used whenever a manual bound is not supplied."
msgstr ""
"Автоматичний метод використовується щоразу, коли не надається ручна "
"прив'язка."

msgid ""
"*A simple pair of rooms. The portal margin is shown with translucent red, "
"and the room hulls are shown with green wireframe.*"
msgstr ""
"*Проста пара кімнат. Поле порталу показано напівпрозорим червоним кольором, "
"а корпуси приміщення показані зеленим каркасом.*"

msgid "Portals"
msgstr "Портали"

msgid ""
"If you create some rooms, place objects within them, then convert the level "
"in the editor, you will see the objects in the rooms appearing and showing "
"as you move between rooms. There is one problem, however! Although you can "
"see the objects within the room that the camera is in, you can't see to any "
"neighbouring rooms! For that we need portals."
msgstr ""
"Якщо ви створите деякі кімнати, розмістите в них об'єкти, а потім "
"перетворите рівень в редакторі, ви побачите об'єкти в кімнатах, що "
"з'являються і зникають, по мірі вашого переміщення між кімнатами. Але є одна "
"проблема! Хоча ви можете побачити об'єкти в кімнаті, в якій знаходиться "
"камера, ви не можете бачити об'єкти в будь-яких сусідніх кімнатах! Для цього "
"потрібні портали."

msgid ""
":ref:`Portal<class_Portal>`\\ s are special convex polygons that you "
"position over the openings between rooms in order to allow the system to see "
"between them. You can create a portal node directly in the editor. The "
"default portal has 4 points and behaves much like a ``plane`` :ref:"
"`MeshInstance<class_MeshInstance>`. You can add or remove points using the "
"inspector. A portal requires at least 3 points to work - this is because it "
"needs to form a polygon rather than a point or line."
msgstr ""
":ref:`Портали<class_Portal>` - це спеціальні опуклі багатокутники, які ви "
"вішаєте на отвори між кімнатами, щоб дозволити системі бачити крізь них. Ви "
"можете створити вузол порталу Portal безпосередньо в редакторі. Портал за "
"замовчуванням має 4 точки і поводиться так само, як ``plane`` *(площина)* :"
"ref:`MeshInstance<class_MeshInstance>`. Ви можете додавати, або видаляти, "
"точки за допомогою інспектора. Для роботи порталу знадобиться не менше 3 "
"точок - це тому, що йому потрібно сформувати багатокутник, а не точку, чи "
"лінію."

msgid ""
"To save editing effort, **only one Portal is required between each pair of "
"Rooms**. You *do not need* to (and indeed should not) create two Portals "
"that overlap in opposite directions. Portals default to being two-way, but "
"you can make them one-way in the Portal inspector."
msgstr ""
"Бережіть зусилля при редагуванні, **між кожною парою Кімнат потрібен лише "
"один Портал**. Вам *не потрібно* (і не слід) створювати два Портали, які "
"перетинаються в протилежних напрямках. Портали за замовчуванням є "
"двосторонніми (але ви можете зробити їх односторонніми в Інспекторі порталу)."

msgid ""
"You should therefore place a portal in only one of each pair of neighbouring "
"rooms - this is the portal's *\"source room\"*. Generally it doesn't matter "
"which you choose as the source room. The portal normal (the arrow in the "
"gizmo) should face *outward* from the source room."
msgstr ""
"Тому ви повинні розмістити портал тільки в одній з кожної пари сусідніх "
"кімнат - це *\"вихідна кімната\"* порталу. Як правило, не має значення, яку "
"кімнату ви виберете в якості вихідної. Нормаль порталу (стрілка в gizmo) "
"повинна бути спрямована *назовні* від вихідної кімнати."

msgid ""
"Do not be confused by the arrow. Although the arrow shows which direction "
"the portal faces, most portals will be *two-way*, and can be seen through "
"from both directions. The arrow is more important for ensuring that the "
"portal links to the correct neighbouring room."
msgstr ""
"Не плутайтеся зі стрілкою. Хоча стрілка показує, в якому напрямку "
"спрямований портал, більшість порталів будуть *двосторонніми*, крізь них "
"можна дивитися з обох напрямків. Стрілка важливіша для забезпечення того, "
"щоб портал посилався на правильну сусідню кімнату."

msgid "Portal linking"
msgstr "Прив'язка Порталу"

msgid "There are two ways to specify which room the portal should link to:"
msgstr "Є два способи вказати, на яку кімнату повинен посилатися портал:"

msgid ""
"Leave the **Linked Room** in the inspector blank. The system will attempt to "
"*autolink* the portal to the nearest neighbour room during conversion. This "
"works fine in most cases."
msgstr ""
"Залиште **Linked Room** *(Пов'язану Кімнату)* в інспекторі порожнім. Система "
"спробує автоматично зв'язати портал з найближчою сусідньою кімнатою під час "
"перетворення. У більшості випадків це добре працює."

msgid ""
"Explicitly specify the room by setting the **Linked Room** in the inspector."
msgstr "Чітко вкажіть кімнату, встановивши **Linked Room** в інспекторі."

msgid ""
"Portals are defined as a set of 2D points. This ensures that the polygon "
"formed is in a single plane. The transform determines the portal "
"orientation. The points must also form a *convex* polygon. This is enforced "
"by validating the points you specify, ignoring any that do not form a convex "
"shape. This makes editing easier while making it difficult to break the "
"system."
msgstr ""
"Портали визначаються як набір 2D-точок. Це гарантує, що утворений "
"багатокутник знаходиться в одній площині. Перетворення визначає орієнтацію "
"порталу. Точки також повинні утворювати опуклий багатокутник. Це "
"застосовується шляхом перевірки вказаних точок, ігноруючи будь-які, які не "
"утворюють опуклу фігуру. Це полегшує редагування, зменшуючи помилки системи."

msgid "Trying it out"
msgstr "Тепер спробуйте"

msgid ""
"By now you should be able to create a couple of rooms, add some nodes such "
"as MeshInstances within the rooms, and add a portal between the rooms. Try "
"converting the rooms in the editor and see if you can now view the objects "
"in neighbouring rooms through the portal."
msgstr ""
"На даний момент ви можете створити пару кімнат, додати деякі вузли, такі як "
"MeshInstances до кімнат, і додати портал між кімнатами. Спробуйте "
"перетворити кімнати в редакторі, і перевірити, чи можете ви тепер побачити "
"об'єкти в сусідніх кімнатах, через портал."

msgid "You have now mastered the basic principles of the system."
msgstr "Тепер ви освоїли основні принципи системи."

msgid ""
"The next step is to look at the different types of objects that can be "
"managed by the system."
msgstr ""
"Наступним кроком є вивчення різних типів об'єктів, якими може керувати "
"система."

msgid "Translation status"
msgstr "Стан перекладу"
