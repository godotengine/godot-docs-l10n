# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced Room and Portal usage"
msgstr "Розширене використання Кімнати та Порталу"

msgid "Gameplay callbacks"
msgstr "Зворотні виклики геймплея"

msgid ""
"Although occlusion culling greatly reduces the number of objects that need "
"to be rendered, there are other costs to maintaining objects in a game "
"besides the final rendering. For instance, in Godot, animated objects will "
"still be animated whether they appear on screen or not. This can take up a "
"lot of processing power, especially for objects that use software skinning "
"(where skinning is calculated on the CPU)."
msgstr ""
"Хоча вибракування оклюзії значно зменшує кількість об'єктів, які потрібно "
"рендерити, є й інші витрати на підтримку об'єктів у грі, крім остаточного "
"рендеринга. Наприклад, у Godot анімовані об'єкти все ще будуть анімуватися "
"незалежно від того, з'являються вони на екрані, чи ні. Це може зайняти "
"багато обчислювальної потужності, особливо для об'єктів, які використовують "
"програмне забезпечення для покриття *(наприклад шкіри)* (і це покриття "
"розраховується на процесорі)."

msgid "Fear not, rooms and portals can solve these problems, and more."
msgstr ""
"Не бійтеся, кімнати і портали можуть вирішити ці проблеми, і багато іншого."

msgid ""
"By building our system of rooms for our game level, not only do we have the "
"information needed for occlusion culling, we also have handily created the "
"information required to know which rooms are in the local \"gameplay area\" "
"of the player (or camera). If you think about it, in a lot of cases, there "
"is no need to do a lot of simulation on objects that have nothing to do with "
"gameplay."
msgstr ""
"Будуючи систему кімнат для нашого ігрового рівня, ми не тільки маємо "
"інформацію, необхідну для вибракування оклюзії, ми також легко створили "
"інформацію, необхідну для того, щоб знати, які кімнати знаходяться в "
"місцевій \"ігровій зоні\" гравця (або камери). Якщо задуматися про це, то в "
"багатьох випадках немає необхідності робити багато симуляцій на об'єктах, "
"які не мають нічого спільного з ігровим процесом."

msgid ""
"The gameplay area is not confined to just the objects you can see in front "
"of you. AI monsters behind you still need to attack you when your back is "
"turned! In Godot the gameplay area is defined as the *potentially visible "
"set* (PVS) of rooms, from the room you are currently within. That is, if "
"there is any part of a room that can possibly be viewed from any part of the "
"room you are in (even from a corner), it is considered within the PVS, and "
"hence the gameplay area."
msgstr ""
"Ігрова зона не обмежується лише об'єктами, які ви можете побачити перед "
"собою. Монстри з ШІ позаду вас все ще повинні атакувати вас, коли ви "
"повернуті до них спиною! У Godot ігрова зона визначається як *потенційно "
"видимий набір* (*potentially visible set* (PVS)) кімнат, з кімнати, в якій "
"ви зараз перебуваєте. Тобто, якщо є якась частина кімнати, яку можна "
"подивитися з будь-якої частини кімнати, в якій ви перебуваєте (навіть з "
"кута), вона розглядається в межах PVS, а значить і ігрової зони."

msgid ""
"This works because if a monster is in an area that is completely out of view "
"for yourself or the monster, you are less likely to care what it is doing."
msgstr ""
"Це працює, тому що якщо монстр знаходиться в області, яка повністю поза "
"полем зору вашим, чи монстра, ви не будете перейматися ним."

msgid "How does a monster know whether it is within the gameplay area?"
msgstr "Як монстр знає, чи знаходиться він в ігровій зоні?"

msgid ""
"This problem is solved because the portal system contains a subsystem called "
"the **Gameplay Monitor** that can be turned on and off from the :ref:"
"`RoomManager<class_RoomManager>`. When switched on, any roaming objects that "
"move inside or outside the gameplay area (whether by moving themselves, or "
"the camera moving) will receive callbacks to let them know of this change."
msgstr ""
"Ця проблема вирішується тому, що система порталів містить підсистему під "
"назвою **Монітор гри** (**Gameplay Monitor**), яку можна вмикати і вимикати "
"з :ref:`RoomManager<class_RoomManager>` *(Керівника кімнат)*. Коли "
"ввімкнено, будь-які переміщувані об'єкти, які переміщуються всередину, або "
"назовні, ігрової зони (будь то їх переміщення, або переміщення камери), "
"відтворюватимуть зворотні виклики, щоб повідомити про цю зміну."

msgid ""
"You can choose to either receive these callbacks as ``signals``, or as "
"``notifications``."
msgstr ""
"Ви можете отримати ці зворотні виклики як сигнали ``signals``, або як "
"сповіщення ``notifications``."

msgid "Notifications can be handled in GDScript or other scripting languages:"
msgstr "Сповіщення можна обробляти на GDScript, або інших скриптових мовах:"

msgid ""
"Signals are sent just as any other signal. They can be attached to functions "
"using the editor inspector. The signals are called ``gameplay_entered`` and "
"``gameplay_exited``."
msgstr ""
"Сигнали посилаються так само, як і будь-який інший сигнал. Вони можуть бути "
"приєднані до функцій за допомогою інспектора редактора. Сигнали називаються "
"``gameplay_entered`` і ``gameplay_exited``."

msgid ""
"In fact, you don't just receive these callbacks for ``ROAMING`` objects. In "
"addition Rooms and RoomGroups (which can be used to form groups of rooms) "
"can also receive callbacks. For example, you can use this to trigger AI "
"behaviour when the player reaches certain points in a level."
msgstr ""
"Насправді, ви не просто отримуєте ці зворотні виклики для об'єктів "
"``ROAMING``. Крім того, кімнати та групи кімнат також можуть отримувати "
"зворотні виклики. Наприклад, ви можете використовувати це, щоб викликати "
"певну поведінку ШІ, коли гравець досягає певних точок на рівні."

msgid "VisbilityNotifiers / VisibilityEnablers"
msgstr "Вузли VisbilityNotifier та VisibilityEnabler"

msgid ""
"Gameplay callbacks have one more useful function. By default in Godot, "
"animation and physics are still processed regardless of whether an object is "
"within view. This can sap performance, especially when using software "
"skinning."
msgstr ""
"Зворотні виклики гри мають ще одну корисну функцію. За замовчуванням "
"анімація та фізика у Godot продовжує обробляються незалежно від того, чи є "
"об'єкт у полі зору. Це може погіршити продуктивність."

msgid ""
"The engine's solution to this problem is the :ref:"
"`VisibilityNotifier<class_VisibilityNotifier>` node, and its slightly easier "
"to use variation, the :ref:`VisibilityEnabler<class_VisibilityEnabler>` "
"node. VisibilityEnabler can be used to switch off animation and sleep "
"physics when an object is outside the view frustum. You do this by simply "
"placing a VisibilityEnabler node in your subscene (for e.g. a monster). It "
"will do the rest. Consult the :ref:"
"`VisibilityEnabler<class_VisibilityEnabler>` documentation for full details."
msgstr ""
"Можна оптимізувати цю проблему за допомогою вузла :ref:"
"`VisibilityNotifier<class_VisibilityNotifier>` *(Сповіщення про видимість)*, "
"або його, трохи простішої у використанні, версії - вузла :ref:"
"`VisibilityEnabler<class_VisibilityEnabler>` *(Увімкнена видимість)*. "
"VisibilityEnabler можна використовувати для вимкнення анімації та "
"присипляння фізики, коли об'єкт знаходиться за межами поля зору. Для цього "
"ви просто поміщаєте вузол VisibilityEnabler у вашу під-сцену (наприклад, в "
"монстра). Решту зробить вузол. Щоб отримати повну інформацію, зверніться до "
"документації вузла :ref:` VisibilityEnabler<class_VisibilityEnabler>`."

msgid ""
"What if the VisibilityEnabler could turn off objects when they were "
"occlusion culled? Well it turns out VisibilityEnabler can. All you have to "
"do is enable the **Gameplay Monitor** in the RoomManager and the rest "
"happens automatically."
msgstr ""
"Чи може VisibilityEnabler вимкнути об'єкти вибракувані оклюзією? Насправді "
"може. Все, що вам потрібно зробити, це включити **Монітор гри** в "
"RoomManager *(Керівнику Кімнат)*, а решта відбудеться само."

msgid "RoomGroups"
msgstr "Вузол RoomGroup"

msgid ""
"A :ref:`RoomGroup<class_RoomGroup>` is a special node which allows you to "
"deal with a group of rooms at once, instead of having write code for them "
"individually. This is especially useful in conjunction with gameplay "
"callbacks. The most important use for RoomGroups is to delineate between "
"\"inside\" and \"outside\" areas."
msgstr ""
":ref:`RoomGroup<class_RoomGroup>` *(Група Кімнат)* - це спеціальний вузол, "
"який дозволяє мати справу відразу з групою кімнат, замість того, щоб писати "
"код для кожної індивідуально. Це особливо корисно в поєднанні з ігровими "
"зворотними викликами. Найважливішу роль вузли RoomGroup відіграють у "
"розмежуванні \"внутрішніх\" та \"зовнішніх\" областей."

msgid ""
"For instance, when outside you may wish to use a :ref:"
"`DirectionalLight<class_DirectionalLight>` to represent the sun. When the "
"outside RoomGroup receives an ``enter gameplay`` callback, you can turn the "
"light on, and you can turn it off when the RoomGroup exits gameplay. With "
"the light off, performance will increase as there is no need to render it "
"indoors."
msgstr ""
"Наприклад, коли ви знаходитесь на вулиці, ви можете використовувати для "
"освітлення :ref:`Спрямоване Світло<class_DirectionalLight>`. Коли зовнішній "
"вузол RoomGroup отримає зворотний виклик ``enter gameplay``, ви можете "
"ввімкнути світло, і можете вимкнути його, коли RoomGroup вийде з ігрового "
"процесу. З вимкненим світлом продуктивність буде збільшуватися, оскільки "
"немає необхідності використовувати його у приміщенні."

msgid ""
"This is an example of a simple RoomGroup script to turn on and off a "
"DirectionalLight. Note that you can also use signals for callbacks (the "
"choice is up to you):"
msgstr ""
"Це простий приклад використання RoomGroup для ввімкнення та вимкнення "
"Спрямованого Світла. Завбачте, що ви також можете використовувати сигнали "
"для зворотних викликів (вибір залежить від вас):"

msgid ""
"You can apply the same technique for switching on and off weather effects, "
"skyboxes and much more."
msgstr ""
"Ви можете застосувати ту ж техніку для включення і виключення погодних "
"ефектів, коробки неба і багато іншого."

msgid "Internal Rooms"
msgstr "Внутрішні кімнати"

msgid ""
"There is one more trick that RoomGroups have up their sleeve. A very common "
"desire is to have a game level with a mixed outdoor and indoor environment. "
"We have already mentioned that rooms can be used to represent both rooms in "
"a building, and areas of landscape, such as a canyon."
msgstr ""
"Існує ще один трюк з використанням вузлів RoomGroup. Дуже поширене бажання - "
"мати ігровий рівень зі змішаним відкритим і закритим середовищем. Ми вже "
"згадували, що кімнати можуть бути використані для представлення як кімнат в "
"будівлі, так і районів ландшафту, таких як каньйон."

msgid "What happens if you wish to have a house in a terrain 'room'?"
msgstr "Що станеться, якщо ви забажаєте мати будинок в 'кімнаті' місцевості?"

msgid ""
"With the functionality described so far you *can* do it - you would need to "
"place portals around the exterior of the house though, forming needless "
"rooms above the house. This has been done in many games. But what if there "
"was a simpler way?"
msgstr ""
"З функціональністю, описаною до цих пір, ви *можете* це зробити - вам "
"потрібно буде зовні навколо будинку розмістити портали, утворюючи непотрібні "
"кімнати над будинком. Так було зроблено в багатьох іграх. Але що якщо був "
"простіший спосіб?"

msgid ""
"It turns out there is a simpler way of handling this scenario. Godot "
"supports *rooms **within** rooms* (we will call them **\"internal "
"rooms\"**). That is, you can place a house within a terrain room, or even a "
"building, or set of buildings, and even have exit portals in different "
"terrain rooms!"
msgstr ""
"Виявляється, простіший спосіб є. Godot підтримує *кімнати \"всередині\" "
"кімнат* (ми будемо називати їх **\"внутрішні кімнати\"**). Тобто ви можете "
"розмістити будинок в кімнаті місцевості, або навіть будівлю, або набір "
"будівель, і навіть мати вихідні портали в різних кімнатах місцевості!"

msgid ""
"To create internal rooms, you don't need to place a room within another room "
"in the scene tree - in fact you will get a warning if you try this. Instead, "
"create them as regular rooms. The internal rooms should be grouped together "
"with a RoomGroup as parent. If you look in the inspector for the RoomGroup, "
"there is a **Room Group Priority** which defaults to ``0``."
msgstr ""
"Щоб створити внутрішні кімнати, вам не потрібно розміщувати кімнату в іншій "
"кімнаті в дереві сцени - насправді ви отримаєте попередження, якщо спробуєте "
"це зробити. Натомість створіть їх як звичайні кімнати. Внутрішні кімнати "
"мають бути згруповані разом у вузлі RoomGroup. В інспекторі RoomGroup має "
"параметр **Room Group Priority** (*Пріоритет групи кімнат*), який за "
"замовчуванням дорівнює ``0``."

msgid ""
"If you want a room or set of rooms to be internal, set the priority to a "
"higher value than the outer (enclosing) room, using the RoomGroup."
msgstr ""
"Якщо ви хочете, щоб кімната, або набір кімнат, були внутрішніми, встановіть "
"пріоритет на вищі значення, ніж зовнішня (огороджувальна) кімната, "
"використовуючи RoomGroup."

msgid ""
"The system uses the priority setting to give priority to the internal room "
"when deciding which room a camera or object is within. Higher priority "
"*always* wins. Everything else works in a mostly similar way."
msgstr ""
"Система використовує параметр пріоритету, щоб надати пріоритет внутрішній "
"кімнаті при вирішенні того, в якій кімнаті знаходиться камера, або об'єкт. "
"Вищий пріоритет *завжди* перемагає. Все інше, в основному, працює подібним "
"чином."

msgid "The only differences:"
msgstr "Деякі відмінності:"

msgid ""
"Portals between internal rooms and outer rooms should always *be placed in "
"the inner (internal) room*."
msgstr ""
"Портали між внутрішніми кімнатами і зовнішніми кімнатами завжди *повинні "
"розташовуватися у внутрішній кімнаті*."

msgid ""
"Portals of internal rooms are not considered as part of the bound of outer "
"rooms."
msgstr ""
"Портали внутрішніх кімнат не розглядаються як частина зв'язок зовнішніх "
"кімнат."

msgid ""
"``STATIC`` and ``DYNAMIC`` objects from outer rooms will not sprawl into "
"internal rooms. If you want objects to cross these portals, place them in "
"the internal room. This is to prevent large objects like terrain sections "
"sprawling into entire buildings, and rendering when not necessary."
msgstr ""
"``STATIC`` та ``DYNAMIC`` розлогі об'єкти з зовнішніх кімнат не будуть "
"проникати у внутрішні кімнати. Якщо ви хочете, щоб об'єкти перетинали ці "
"портали, помістіть їх у внутрішню кімнату. Це робиться для запобігання "
"проникненню в будівлі великих об'єктів, таких як ділянки місцевості."

msgid "Internal room example"
msgstr "Зразок внутрішньої кімнати:"

msgid ""
"The tent is a simple room inside a terrain room (which contains the ground, "
"the trees etc)."
msgstr ""
"Намет - це проста кімната всередині кімнати місцевості (яка містить землю, "
"дерева і т. д.)."

msgid ""
"To use internal rooms for buildings, it is usually a good idea to split the "
"*interior* mesh of the building from the *exterior*. The exterior can be "
"placed in the outer room (so it can be seen from outside, but not from the "
"inside), and the interior should be placed in the interior room (so it only "
"visible inside, or through the portal)."
msgstr ""
"Щоб використовувати внутрішні кімнати для будівель, зазвичай непогано "
"відокремити *внутрішній* меш будівлі від *зовнішнього*. Зовнішній меш можна "
"розмістити в зовнішній кімнаті (так його можна побачити ззовні, але не "
"зсередини), а внутрішній повинен розташовуватися у внутрішній кімнаті (так "
"його видно тільки всередині, або через портал)."

msgid ""
"This is perfect for improving performance in open world games. Often your "
"buildings can be scenes (including the rooms and portals) that can be "
"reused. When viewed from the outside, interiors will mostly be culled, and "
"when viewing from the inside other buildings and most of the outside will be "
"culled. The same goes for other players and objects that are inside and "
"outside the buildings."
msgstr ""
"Це ідеально підходить для підвищення продуктивності в іграх з відкритим "
"світом. Часто ваші будівлі можуть бути сценами (з кімнатами та порталами), "
"які можна повторно використовувати. При погляді ззовні інтер'єри будуть, в "
"основному, вибраковані, а при погляді зсередини, інші будівлі і більша "
"частина зовнішньої частини будуть вибраковані. Те ж саме стосується інших "
"гравців і об'єктів, які знаходяться всередині і за межами будівель."

msgid ""
"*Scene is 'Diorama Eco scene' by Odo, with slight changes for illustration "
"purposes.* `CC Attribution <https://creativecommons.org/licenses/by/4.0/>`_"
msgstr ""
"*Сцена з \"Діорама Еко сцена\" від Одо, з невеликими змінами для ілюстрації "
"цілей.* `CC Attribution <https://creativecommons.org/licenses/by/4.0/>`_"

msgid "Internal room scenes"
msgstr "Сцени внутрішніх кімнат"

msgid ""
"Let us look in detail at another practical example for an open world. We "
"want to place houses (as internal rooms) on an island, but have each house "
"as a self-contained scene containing both the interior *and* the external "
"mesh of the house."
msgstr ""
"Давайте детально розглянемо ще один практичний приклад відкритого світу. Ми "
"хочемо розмістити будинки (як внутрішні кімнати) на острові, але кожен "
"будинок є самостійною сценою, що містить *як інтер'єр, так і екстер'єр* "
"будинку."

msgid ""
"We have created a Room node (which will become the internal room) into which "
"we have placed the interior meshes. We have also created a Portal with no "
"links (so autolinking will be used). The exterior mesh is *not* within the "
"room. It will be autoplaced, and we are intending for it to be placed within "
"the outer room."
msgstr ""
"Ми створили вузол Кімнати (який стане внутрішньою кімнатою), в який "
"помістили меші інтер'єру. Ми також створили Портал без посилань (тому буде "
"використовуватися автоматичне посилання). Зовнішній меш екстер'єру *не* "
"знаходиться в кімнаті. Він буде автоматично розміщений, і ми сподіваємося, "
"що він буде розміщений у зовнішній кімнаті."

msgid ""
"However there is a problem. The naive autoplace algorithm will look at the "
"center of the exterior mesh, and attempt to place it *within* the internal "
"room. We want to avoid this somehow, as the idea of the exterior mesh is to "
"have something rendered from the outside, so it must be in the outer room "
"for everything to work."
msgstr ""
"Однак є проблема. Наївний алгоритм автоматичного розміщення буде дивитися на "
"центр меша екстер'єру, і намагатися розмістити його *всередині* внутрішньої "
"кімнати. Ми хочемо уникнути цього якимось чином, оскільки ідея зовнішнього "
"меша полягає в тому, щоб знаходився назовні, тому, щоб все працювало, він "
"повинен бути у зовнішній кімнаті."

msgid ""
"To get around this problem, there is a special setting to enable you to "
"express a preference for autoplacing in an outer room. Each object has an "
"**Autoplace Priority** setting. When set to ``0``, there is no preference "
"(the object will be placed in the highest priority room)."
msgstr ""
"Для обходу цієї проблеми, існує спеціальна настройка, яка дозволяє виставити "
"перевагу автоматичного розміщення у зовнішній кімнаті. Кожен об'єкт має "
"параметр **Autoplace Priority** *(Пріоритет авто-розміщення)*. При значенні "
"``0``, немає переваги (об'єкт буде розміщений в кімнаті з найвищим "
"пріоритетом)."

msgid ""
"However, if we set this autoplace priority to ``-1`` for example, the "
"autoplace will always choose a ``-1`` priority room (if one is present at "
"that location). So if we set the outer room priority to ``-1``, it will "
"always place our exterior into our \"outside\" room."
msgstr ""
"Однак, якщо ми встановили цей пріоритет, наприклад на ``-1``, автоматичне "
"розміщення завжди вибиратиме пріоритетну кімнату ``-1`` (якщо вона присутня "
"в цій локації). Отже, якщо ми поставимо пріоритет зовнішньої кімнати ``-1``, "
"він завжди поміщатиме наш екстер'єр у нашу \"зовнішню\" кімнату."

msgid ""
"This gives us a helpful extra bit of control for these kinds of situations, "
"and makes the entire system much more flexible."
msgstr ""
"Це дає нам корисний додатковий контроль для подібних ситуацій і робить всю "
"систему набагато гнучкішою."

msgid ""
"As the default autoplace priority is ``0``, you can't effectively force "
"objects into RoomGroups with priority ``0``. However there are plenty of "
"priority values available so this should not be a problem in practice."
msgstr ""
"Оскільки пріоритет авто-розміщення за замовчуванням дорівнює ``0``, ви не "
"можете ефективно вставляти об’єкти в вузли RoomGroup з пріоритетом ``0``. "
"Однак є багато доступних значень пріоритету, тому це не повинно бути "
"проблемою на практиці."

msgid ""
"The final scene looks something like this, with houses instanced wherever "
"you want them on a giant outer room."
msgstr ""
"Фінальна сцена виглядає приблизно так, з будинками, розташованими скрізь, де "
"ви хочете їх бачити на гігантській зовнішній кімнаті."

msgid ""
"The house exteriors will be placed in the outer room, and therefore can "
"always be seen when looking from the outside. The interiors will only be "
"rendered when a view into the entry portals is visible."
msgstr ""
"Екстер'єри будинку будуть розміщені в зовнішньому приміщенні, а тому їх "
"завжди можна побачити при погляді ззовні. Інтер'єри відображатимуться лише "
"тоді, коли буде видно портали входу."

msgid "Translation status"
msgstr "Стан перекладу"
