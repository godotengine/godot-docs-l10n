# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using 3D transforms"
msgstr "Використання 3D перетворень"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"If you have never made 3D games before, working with rotations in three "
"dimensions can be confusing at first. Coming from 2D, the natural way of "
"thinking is along the lines of *\"Oh, it's just like rotating in 2D, except "
"now rotations happen in X, Y and Z\"*."
msgstr ""
"Якщо ви досі ніколи не розробляли 3D ігор, то обертання у трьох вимірах, "
"спершу, може вам здатись незрозумілим. Після 2D вам може здатись: *„О! Це "
"прямо як в 2D, але з додатковими осями!“*."

msgid ""
"At first, this seems easy. For simple games, this way of thinking may even "
"be enough. Unfortunately, it's often incorrect."
msgstr ""
"Спочатку це здається легким. Для простих ігор такого способу мислення може "
"бути навіть достатньо. Але, на жаль, це враження зазвичай оманливе."

msgid ""
"Angles in three dimensions are most commonly referred to as \"Euler Angles\"."
msgstr "Кути у три-вимірному просторі найчастіше називають \"Кутами Ейлера\"."

msgid ""
"Euler angles were introduced by mathematician Leonhard Euler in the early "
"1700s."
msgstr ""
"Кути Ейлера були описані математиком Леонардом Ейлером на початку 18ст."

msgid ""
"This way of representing 3D rotations was groundbreaking at the time, but it "
"has several shortcomings when used in game development (which is to be "
"expected from a guy with a funny hat). The idea of this document is to "
"explain why, as well as outlining best practices for dealing with transforms "
"when programming 3D games."
msgstr ""
"Такий підхід до опису 3D орієнтації був проривним для свого часу, але він "
"має декілька недоліків коли використовується при розробці ігор (чого ще "
"очікувати від чоловіка у смішному капелюсі). Ця стаття покликана пояснити "
"чому так, а також описати найкращі шляхи роботи з перетвореннями 3D об'єктів."

msgid "Problems of Euler angles"
msgstr "Проблеми кутів Ейлера"

msgid ""
"While it may seem intuitive that each axis has a rotation, the truth is that "
"it's just not practical."
msgstr ""
"Хоча й здається, що об'єкт можна просто обертати навколо кожної з осей, на "
"ділі це практично."

msgid "Axis order"
msgstr "Порядок осей"

msgid ""
"The main reason for this is that there isn't a *unique* way to construct an "
"orientation from the angles. There isn't a standard mathematical function "
"that takes all the angles together and produces an actual 3D rotation. The "
"only way an orientation can be produced from angles is to rotate the object "
"angle by angle, in an *arbitrary order*."
msgstr ""
"Головна причина цього в тому, що не існує *єдиного* способу отримати "
"орієнтацію з кутів. Немає стандартної математичної функції, яка приймає всі "
"кути й повертає реальне положення об'єкта. Єдиний спосіб отримати це "
"положення — обертати об'єкт за цими кутами в *певному порядку*."

msgid ""
"This could be done by first rotating in *X*, then *Y* and then in *Z*. "
"Alternatively, you could first rotate in *Y*, then in *Z* and finally in "
"*X*. Anything works, but depending on the order, the final orientation of "
"the object will *not necessarily be the same*. Indeed, this means that there "
"are several ways to construct an orientation from 3 different angles, "
"depending on *the order of the rotations*."
msgstr ""
"Це можна зробити, покрутивши об'єкт спершу по осі *X*, потім — по *Y* і "
"потім — по *Z*. Або ж, ви можете спершу покрутити по осі *Y*, а потім — по "
"*Z* і нарешті — по *X*. Будь-який спосіб підходить, але кінцевий результат "
"*не обов'язково буде однаковим*. А значить — існує декілька способів "
"знаходження обертання за трьома кутами, залежно від *порядку обертань*."

msgid ""
"Following is a visualization of rotation axes (in X, Y, Z order) in a gimbal "
"(from Wikipedia). As you can see, the orientation of each axis depends on "
"the rotation of the previous one:"
msgstr ""
"Нижче наведене зображення осей обертання (в порядку X, Y, Z) у вигляді "
"карданного підвісу (з Вікіпедії). Як бачите, положення кожної з осей "
"залежить від повороту попередньої осі:"

msgid ""
"You may be wondering how this affects you. Let's look at a practical example:"
msgstr ""
"У вас може виникнути питання: „Як це може вплинути на мене?“. Погляньмо на "
"приклад з практики:"

msgid ""
"Imagine you are working on a first-person controller (e.g. an FPS game). "
"Moving the mouse left and right controls your view angle parallel to the "
"ground, while moving it up and down moves the player's view up and down."
msgstr ""
"Уявіть, що ви працюєте над управлінням від першої особи (як в шутерах). Рух "
"курсора в ліво-право повинен контролювати той кут огляду, що паралельний до "
"землі. Натомість, рухаючи курсор вгору й вниз гравець переміщує свій огляд "
"відповідно вгору та вниз."

msgid ""
"In this case to achieve the desired effect, rotation must be applied first "
"in the *Y* axis (\"up\" in this case, since Godot uses a \"Y-Up\" "
"orientation), followed by rotation in the *X* axis."
msgstr ""
"В такому разі, щоб досягти необхідного результату, обертати спершу потрібно "
"вісь *Y* (в нашому випадку вісь „вгору“, так як Godot використовує "
"орієнтацію „Y-Up“), а потім — вісь *X*."

msgid ""
"If we were to apply rotation in the *X* axis first, and then in *Y*, the "
"effect would be undesired:"
msgstr ""
"Якби ми спершу повернули вісь *X*, а потім — *Y*, то ми отримали б небажаний "
"результат:"

msgid ""
"Depending on the type of game or effect desired, the order in which you want "
"axis rotations to be applied may differ. Therefore, applying rotations in X, "
"Y, and Z is not enough: you also need a *rotation order*."
msgstr ""
"Залежно від типу гри й результату, якого ви хочете досягти, порядок, в якому "
"потрібно обертати об'єкт, може відрізнятись. Тому, застосовувати обертання в "
"порядку X, Y, Z не достатньо: потрібно також знати й *порядок обертання*."

msgid "Interpolation"
msgstr "Інтерполяція"

msgid ""
"Another problem with using Euler angles is interpolation. Imagine you want "
"to transition between two different camera or enemy positions (including "
"rotations). One logical way to approach this is to interpolate the angles "
"from one position to the next. One would expect it to look like this:"
msgstr ""
"Ще одна проблема, яка виникає при роботі з кутами Ейлера — це інтерполяція. "
"Уявіть, що ви хочете зробити плавний перехід між двома різними камерами чи "
"положеннями ворогів (включно з їх орієнтаціями). Найпростіший спосіб — "
"інтерполювати значення кута по кожній з осей незалежно. Отриманий результат "
"повинен бути ось таким:"

msgid "But this does not always have the expected effect when using angles:"
msgstr "Але кути не завжди працюють так, як повинні:"

msgid "The camera actually rotated the opposite direction!"
msgstr "Насправді, камера крутиться у протилежний бік!"

msgid "There are a few reasons this may happen:"
msgstr "Є декілька причин, чому могло так трапитись:"

msgid ""
"Rotations don't map linearly to orientation, so interpolating them does not "
"always result in the shortest path (i.e., to go from ``270`` to ``0`` "
"degrees is not the same as going from ``270`` to ``360``, even though the "
"angles are equivalent)."
msgstr ""
"Обертання не були лінійно прив'язані до орієнтації, а тому інтерполяція не "
"завжди обирає найкоротший шлях (як-от шлях від ``270`` до ``0`` градусів — "
"це не те ж саме що шлях від ``270`` до ``360`` хоч це й однакові кути)."

msgid ""
"Gimbal lock is at play (first and last rotated axis align, so a degree of "
"freedom is lost). See `Wikipedia's page on Gimbal Lock <https://en.wikipedia."
"org/wiki/Gimbal_lock>`_ for a detailed explanation of this problem."
msgstr ""
"Сталось блокування обертання (перша вісь обертання вирівнялась з останньою й "
"система втратила одну степінь свободи). Подивіться статтю по блокування "
"обертання <https://uk.wikipedia.org/wiki/Блокування_обертання>` _ якщо "
"хочете дізнатися більше."

msgid "Say no to Euler angles"
msgstr "Скажіть „Ні“ кутам Ейлера"

#, fuzzy
msgid ""
"The result of all this is that you should **not use** the ``rotation`` "
"property of :ref:`class_Node3D` nodes in Godot for games. It's there to be "
"used mainly in the editor, for coherence with the 2D engine, and for simple "
"rotations (generally just one axis, or even two in limited cases). As much "
"as you may be tempted, don't use it."
msgstr ""
"Виходячи з усього вище сказаного, вам **не варто** використовувати "
"властивість ``rotation`` вузла :ref:`class_Spatial` у своїх іграх. Вони "
"призначені для використання в редакторі, для відповідності з 2D рушієм. А "
"також для простих обертань (зазвичай по одній осі, рідше — по двох). Тому, "
"як би сильно вам не хотілось, не використовуйте його."

msgid "Instead, there is a better way to solve your rotation problems."
msgstr "Натомість, існує кращий спосіб вирішити проблему обертання."

msgid "Introducing transforms"
msgstr "Знайомство з перетвореннями"

#, fuzzy
msgid ""
"Godot uses the :ref:`class_Transform3D` datatype for orientations. Each :ref:"
"`class_Node3D` node contains a ``transform`` property which is relative to "
"the parent's transform, if the parent is a Node3D-derived type."
msgstr ""
"Godot використовує тип :ref:`class_Transform` для опису орієнтації. Кожен "
"вузол типу :ref:`class_Spatial` має властивість ``transform`` яка описує "
"його положення відносно батьківського вузла, в тому разі, якщо батьківський "
"вузол належить до класу, що походить від ``Spatial``."

msgid ""
"It is also possible to access the world coordinate transform via the "
"``global_transform`` property."
msgstr ""
"Також, можна отримати глобальне положення об'єкта у властивості "
"``global_transform``."

msgid ""
"A transform has a :ref:`class_Basis` (transform.basis sub-property), which "
"consists of three :ref:`class_Vector3` vectors. These are accessed via the "
"``transform.basis`` property and can be accessed directly by ``transform."
"basis.x``, ``transform.basis.y``, and ``transform.basis.z``. Each vector "
"points in the direction its axis has been rotated, so they effectively "
"describe the node's total rotation. The scale (as long as it's uniform) can "
"also be inferred from the length of the axes. A *basis* can also be "
"interpreted as a 3x3 matrix and used as ``transform.basis[x][y]``."
msgstr ""
"Перетворення має базис :ref:`class_Basis` (підвластивість transform.basis), "
"який складається з трьох векторів ref:`class_Vector3`. Доступ до них можна "
"отримати через властивість ``transform.basis`` і напряму, через ``transform."
"basis.x``, ``transform.basis.y``, and ``transform.basis.z``. Кожен з "
"векторів напрямлений так само, як і його вісь після обертання, таким чином "
"описуючи сумарний поворот об'єкта. Масштабування ж (якщо воно рівномірне) "
"можна визначити з довжин осей. *Базис* також можна описати як матрицю 3x3 та "
"використовувати як ``transform.basis[x][y]``."

msgid "A default basis (unmodified) is akin to:"
msgstr "Початковий базис (незмінений) виглядає десь так:"

msgid "This is also an analog of a 3x3 identity matrix."
msgstr "Також він являється аналогом одиничної матриці 3x3."

msgid ""
"Following the OpenGL convention, ``X`` is the *Right* axis, ``Y`` is the "
"*Up* axis and ``Z`` is the *Forward* axis."
msgstr ""
"Відповідно до стандарту OpenGL, ``X`` це *Права* вісь, ``Y`` — це вісь "
"*Вгору* й ``Z`` — це вісь *Уперед*."

msgid ""
"Together with the *basis*, a transform also has an *origin*. This is a "
"*Vector3* specifying how far away from the actual origin ``(0, 0, 0)`` this "
"transform is. Combining the *basis* with the *origin*, a *transform* "
"efficiently represents a unique translation, rotation, and scale in space."
msgstr ""
"Разом з *базисом* перетворення також має *початкову точку*. Це *Vector3* "
"який описує як далеко об'єкт знаходиться від початку координат ``(0, 0, "
"0)``. З *базисом* та *початковою точкою*, *перетворення* повністю описує "
"переміщення, обертання та масштабування у просторі."

msgid ""
"One way to visualize a transform is to look at an object's 3D gizmo while in "
"\"local space\" mode."
msgstr ""
"Щоб побачити, як працюють перетворення можна поглянути на 3D ґізмо об'єкта, "
"перемкнуте в режим локального простору."

msgid ""
"The gizmo's arrows show the ``X``, ``Y``, and ``Z`` axes (in red, green, and "
"blue respectively) of the basis, while the gizmo's center is at the object's "
"origin."
msgstr ""
"Стрілочки на ґізмо вказують на осі базису ``X``, ``Y`` і ``Z`` (червоного, "
"зеленого та синього кольорів відповідно). А центр же ґізмо вказує на "
"початкову точку об'єкта."

msgid ""
"For more information on the mathematics of vectors and transforms, please "
"read the :ref:`doc_vector_math` tutorials."
msgstr ""
"Якщо хочете дізнатись більше про векторну математику та перетворення, "
"прочитайте статтю :ref:`doc_vector_math`."

msgid "Manipulating transforms"
msgstr "Використання перетворень"

msgid ""
"Of course, transforms are not as straightforward to manipulate as angles and "
"have problems of their own."
msgstr ""
"Звісно, використовувати перетворення не так просто як кути. Та й свої "
"проблеми вони також мають."

msgid ""
"It is possible to rotate a transform, either by multiplying its basis by "
"another (this is called accumulation), or by using the rotation methods."
msgstr ""
"Повернути об'єкт можна перемноживши базис його перетворення на базис іншого "
"(це називається композицією) або використавши методи обертання."

#, fuzzy
msgid "A method in Node3D simplifies this:"
msgstr "Метод у ``Spatial`` спрощує це:"

msgid "This rotates the node relative to the parent node."
msgstr "Він обертає вузол відносно батьківського вузла."

msgid ""
"To rotate relative to object space (the node's own transform), use the "
"following:"
msgstr ""
"Щоб обертатись відносно власного простору об'єкта потрібно використати "
"наступний код:"

msgid "Precision errors"
msgstr "Помилки пов'язані з точністю"

msgid ""
"Doing successive operations on transforms will result in a loss of precision "
"due to floating-point error. This means the scale of each axis may no longer "
"be exactly ``1.0``, and they may not be exactly ``90`` degrees from each "
"other."
msgstr ""
"Виконання перетворень, з часом, спричиняє втрату точності у зв'язку з "
"обмеженнями чисел з рухомою комою. Через це, довжини осей можуть не "
"дорівнювати точно ``1.0`` та кути між ними можуть не дорівнювати точно "
"``90`` градусів."

msgid ""
"If a transform is rotated every frame, it will eventually start deforming "
"over time. This is unavoidable."
msgstr ""
"Якщо перетворення відбуваються в кожному кадрі, то вони в решті-решт почнуть "
"деформуватись. Уникнути цього неможливо."

msgid ""
"There are two different ways to handle this. The first is to "
"*orthonormalize* the transform after some time (maybe once per frame if you "
"modify it every frame):"
msgstr ""
"Існують два способи справитись з цим. Перший — *ортонормалізувати* "
"перетворення об'єкта час від часу (можливо раз на кадр, якщо воно змінюється "
"в кожному кадрі):"

msgid ""
"This will make all axes have ``1.0`` length again and be ``90`` degrees from "
"each other. However, any scale applied to the transform will be lost."
msgstr ""
"Це зробить довжини всіх осей знову рівними ``1.0`` а кути між ними — рівними "
"``90`` градусів. Хоч в такому випадку масштабування об'єкта буде втрачено."

#, fuzzy
msgid ""
"It is recommended you not scale nodes that are going to be manipulated; "
"scale their children nodes instead (such as MeshInstance3D). If you "
"absolutely must scale the node, then re-apply it at the end:"
msgstr ""
"Краще не масштабувати вузли, які ви хочете обертати. Натомість, "
"відмасштабуйте їх дочірні вузли (як-от MeshInstance). Якщо вам конче "
"необхідно відмасштабувати вузол, то перезадайте масштаб після "
"ортонормалізації:"

msgid "Obtaining information"
msgstr "Як отримати дані"

msgid ""
"You might be thinking at this point: **\"Ok, but how do I get angles from a "
"transform?\"**. The answer again is: you don't. You must do your best to "
"stop thinking in angles."
msgstr ""
"Ви можете подумати: **„Добре, а як мені отримати кути з матриці перетворення?"
"**. Якщо стисло — то ніяк. Вам потрібно перестати думати про кути."

msgid ""
"Imagine you need to shoot a bullet in the direction your player is facing. "
"Just use the forward axis (commonly ``Z`` or ``-Z``)."
msgstr ""
"Уявімо, вам потрібно вистрілити кулю в напрямку, куди дивиться ваш персонаж. "
"Просто використайте його вісь уперед (зазвичай це ``Z`` або ``-Z``)."

msgid ""
"Is the enemy looking at the player? Use the dot product for this (see the :"
"ref:`doc_vector_math` tutorial for an explanation of the dot product):"
msgstr ""
"А чи дивиться ворог на гравця? Використайте скалярний добуток щоб дізнатись "
"(про скалярний добуток можете почитати у статті :ref:`doc_vector_math`):"

msgid "Strafe left:"
msgstr "Зміщення вліво:"

msgid "Jump:"
msgstr "Стрибок:"

msgid "All common behaviors and logic can be done with just vectors."
msgstr ""
"Загалом, усі дії з об'єктом можна здійснити використовуючи одні лише вектори."

msgid "Setting information"
msgstr "Як задати дані"

msgid ""
"There are, of course, cases where you want to set information to a "
"transform. Imagine a first person controller or orbiting camera. Those are "
"definitely done using angles, because you *do want* the transforms to happen "
"in a specific order."
msgstr ""
"Звісно, є ситуації, коли вам необхідно задати параметри перетворення. Уявімо "
"контролер від першої особи чи камеру, що обертається. Вони точно повинні "
"використовувати кути, адже вам **треба** щоб перетворення відбувалось у "
"певному порядку."

#, fuzzy
msgid ""
"For such cases, keep the angles and rotations *outside* the transform and "
"set them every frame. Don't try to retrieve and reuse them because the "
"transform is not meant to be used this way."
msgstr ""
"Тоді, тримайте кути *окремо* від матриці перетворення об'єкта та задавайте "
"їх у кожному кадрі. Не намагайтесь зчитувати їх з об'єкта бо це неправильний "
"спосіб використовувати перетворення."

msgid "Example of looking around, FPS style:"
msgstr "Приклад, який дозволяє озиратись в стилі шутерів від першої особи:"

msgid ""
"As you can see, in such cases it's even simpler to keep the rotation "
"outside, then use the transform as the *final* orientation."
msgstr ""
"Як бачите, в таких випадках, простіше працювати з кутами, і застосовувати до "
"перетворення лише їх *кінцевий* результат."

msgid "Interpolating with quaternions"
msgstr "Інтерполяція з кватерніонами"

msgid ""
"Interpolating between two transforms can efficiently be done with "
"quaternions. More information about how quaternions work can be found in "
"other places around the Internet. For practical use, it's enough to "
"understand that pretty much their main use is doing a closest path "
"interpolation. As in, if you have two rotations, a quaternion will smoothly "
"allow interpolation between them using the closest axis."
msgstr ""
"Здійснити інтерполяцію між двома перетвореннями можна використавши "
"кватерніони. Дізнатись, як працюють кватерніони можна деінде, в інтернеті. "
"Зараз же, вам достатньо знати, що їх основна ціль — забезпечувати "
"інтерполяцію найкоротшим шляхом. І якщо у вас є два обертання: кватерніон "
"може плавно переходити від одного, до іншого, по найкоротшій з осей."

msgid "Converting a rotation to quaternion is straightforward."
msgstr "Кути обертання можна з легкістю перетворити в кватерніон."

#, fuzzy
msgid ""
"The :ref:`class_Quaternion` type reference has more information on the "
"datatype (it can also do transform accumulation, transform points, etc., "
"though this is used less often). If you interpolate or apply operations to "
"quaternions many times, keep in mind they need to be eventually normalized. "
"Otherwise, they will also suffer from numerical precision errors."
msgstr ""
"Документація типу :ref:`class_Quat` має більше інформації про цей тип даних "
"(він також може накопичувати перетворення, переміщувати точки тощо, хоч це й "
"не так часто використовують). Пам'ятайте, якщо ви проінтерполюєте або "
"застосуєте кватерніон до об'єкта багато разів, то його потрібно буде "
"нормалізувати. Інакше, він почне втрачати точність."

msgid ""
"Quaternions are useful when doing camera/path/etc. interpolations, as the "
"result will always be correct and smooth."
msgstr ""
"Кватерніони корисні, якщо потрібно здійснити інтерполяцію камери, вздовж "
"шляху, тощо. Вони дадуть правильний та гладенький результат."

msgid "Transforms are your friend"
msgstr "Перетворення — це ваші найкращі друзі"

msgid ""
"For most beginners, getting used to working with transforms can take some "
"time. However, once you get used to them, you will appreciate their "
"simplicity and power."
msgstr ""
"Для більшості початківців, має пройти певний час, доки вони не звикнуть "
"працювати з перетвореннями. Проте, щойно ви призвичаїтесь до них, ви оціните "
"їх простоту та корисність."

msgid ""
"Don't hesitate to ask for help on this topic in any of Godot's `online "
"communities <https://godotengine.org/community>`_ and, once you become "
"confident enough, please help others!"
msgstr ""
"Не соромтесь задавати питання на цю тему в `будь-якій інтернет-спільноті "
"Godot<https://godotengine.org/community>`_ . І, коли ви наберетесь достатньо "
"знань, будь ласка, допоможіть іншим!"

msgid "Translation status"
msgstr "Стан перекладу"
