# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Vector math"
msgstr "Векторна математика"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"This tutorial is a short and practical introduction to linear algebra as it "
"applies to game development. Linear algebra is the study of vectors and "
"their uses. Vectors have many applications in both 2D and 3D development and "
"Godot uses them extensively. Developing a good understanding of vector math "
"is essential to becoming a strong game developer."
msgstr ""
"Ця стаття — це короткий вступ до лінійної алгебри та опис способів її "
"використання в розробці ігор. Лінійна алгебра — це наука про вектори та їх "
"використання. Використовувати їх можна як в 2D, так і в 3D й Godot робить це "
"дуже часто. Для того, щоб бути добрим програмістом, розуміти векторну "
"математику просто необхідно."

msgid ""
"This tutorial is **not** a formal textbook on linear algebra. We will only "
"be looking at how it is applied to game development. For a broader look at "
"the mathematics, see https://www.khanacademy.org/math/linear-algebra"
msgstr ""
"Ця стаття — це **не підручник з лінійної алгебри**. Ми лише розглянемо, як "
"їх можна використовувати в прив'язці до розробки ігор. Для ширшого розуміння "
"математики, погляньте на https://www.khanacademy.org/math/linear-algebra"

msgid "Coordinate systems (2D)"
msgstr "Система координат (2D)"

msgid ""
"In 2D space, coordinates are defined using a horizontal axis (``x``) and a "
"vertical axis (``y``). A particular position in 2D space is written as a "
"pair of values such as ``(4, 3)``."
msgstr ""
"У двовимірному просторі, координати описуються за допомогою горизонтальної "
"(``x``) та вертикальної (``y``) осей. Певна точка в просторі описується як "
"пара чисел. Наприклад: ``(4,3)``."

msgid ""
"If you're new to computer graphics, it might seem odd that the positive "
"``y`` axis points **downwards** instead of upwards, as you probably learned "
"in math class. However, this is common in most computer graphics "
"applications."
msgstr ""
"Якщо ви раніше не працювали з комп'ютерною графікою, то вам може здатись "
"дивним, що вісь ``y`` напрямлена **вниз** а не вгору, як зазвичай, в "
"підручниках з математики. Проте, такий підхід поширений серед більшости "
"графічних комп'ютерних програм."

msgid ""
"Any position in the 2D plane can be identified by a pair of numbers in this "
"way. However, we can also think of the position ``(4, 3)`` as an **offset** "
"from the ``(0, 0)`` point, or **origin**. Draw an arrow pointing from the "
"origin to the point:"
msgstr ""
"Будь-яка точка на площині може бути визначена як пара чисел у такий спосіб. "
"А ще, ми можемо уявляти точку ``(4,3)`` як **зміщення** від точки ``(0,0)``, "
"або **початкової точки**. Намалюймо стрілку, яка тягнеться від початкової "
"точки до нашої:"

#, fuzzy
msgid ""
"This is a **vector**. A vector represents a lot of useful information. As "
"well as telling us that the point is at ``(4, 3)``, we can also think of it "
"as an angle ``θ`` (theta) and a length (or magnitude) ``m``. In this case, "
"the arrow is a **position vector** - it denotes a position in space, "
"relative to the origin."
msgstr ""
"Це — **вектор**. Багато важливої інформації можна зобразити як вектор. Так, "
"точку ``(4, 3)`` ми можемо також розглядати як кут ``θ`` і довжину (або "
"модуль) ``m``. У цьому разі, стрілка — це **радіус-вектор**: вона описує "
"положення точки у просторі відносно початку координат."

msgid ""
"A very important point to consider about vectors is that they only represent "
"**relative** direction and magnitude. There is no concept of a vector's "
"position. The following two vectors are identical:"
msgstr ""
"Варто зазначити, що вектор описує лише **відносний** напрямок та "
"**відносне** зміщення. Вектори не мають такої штуки, як положення. Дві "
"стрілки на зображенні нижче — це той самий вектор:"

msgid ""
"Both vectors represent a point 4 units to the right and 3 units below some "
"starting point. It does not matter where on the plane you draw the vector, "
"it always represents a relative direction and magnitude."
msgstr ""
"Обидва вектори позначають точку яка лежить на 4 одиниці вправо та на 3 "
"одиниці вниз від деякої початкової точки. Не важливо де ви намалюєте вектор, "
"він завжди буде позначати відносний напрямок та зміщення."

msgid "Vector operations"
msgstr "Дії над векторами"

msgid ""
"You can use either method (x and y coordinates or angle and magnitude) to "
"refer to a vector, but for convenience, programmers typically use the "
"coordinate notation. For example, in Godot, the origin is the top-left "
"corner of the screen, so to place a 2D node named ``Node2D`` 400 pixels to "
"the right and 300 pixels down, use the following code:"
msgstr ""
"Ви можете описувати вектор як пару координат x та y, або як пару з кута й "
"модуля. Але, зазвичай, програмісти використовують координатну форму. "
"Наприклад, в Godot, початок координат знаходиться в верхньому лівому куті "
"екрану. А тому, щоб розмістити 2D вузол під назвою ``Node2D`` на 400 "
"пікселів правіше й на 300 пікселів нижче, потрібно використати такий код:"

#, fuzzy
msgid ""
"Godot supports both :ref:`Vector2 <class_Vector2>` and :ref:`Vector3 "
"<class_Vector3>` for 2D and 3D usage, respectively. The same mathematical "
"rules discussed in this article apply to both types, and wherever we link to "
"``Vector2`` methods in the class reference, you can also check out their "
"``Vector3`` counterparts."
msgstr ""
"Godot працює як з :ref:`двовимірними<class_Vector2>`, так і з :ref:"
"`тривимірними<class_Vector3>` векторами. Математичні принципи, описані в цій "
"статті підходять до обох типів."

msgid "Member access"
msgstr "Доступ до компонентів"

msgid ""
"The individual components of the vector can be accessed directly by name."
msgstr "Окремі компоненти вектора можна отримати напряму, по назві."

msgid "Adding vectors"
msgstr "Додавання векторів"

msgid ""
"When adding or subtracting two vectors, the corresponding components are "
"added:"
msgstr ""
"Коли додаються або віднімаються два вектори, додаються і їхні відповідні "
"компоненти:"

msgid ""
"We can also see this visually by adding the second vector at the end of the "
"first:"
msgstr "Суму векторів можна зобразити додавши один вектор, до кінця іншого:"

msgid "Note that adding ``a + b`` gives the same result as ``b + a``."
msgstr "Сума ``a + b`` дає такий же результат як і ``b + a``."

msgid "Scalar multiplication"
msgstr "Множення на скаляр"

#, fuzzy
msgid ""
"Vectors represent both direction and magnitude. A value representing only "
"magnitude is called a **scalar**. Scalars use the :ref:`class_float` type in "
"Godot."
msgstr ""
"Вектор — це напрямок з модулем. А значення, яке позначає лише модуль — це "
"**скаляр**."

msgid "A vector can be multiplied by a **scalar**:"
msgstr "Вектор можна помножити на **скаляр**:"

#, fuzzy
msgid ""
"Multiplying a vector by a positive scalar does not change its direction, "
"only its magnitude. Multiplying with a negative scalar results in a vector "
"in the opposite direction. This is how you **scale** a vector."
msgstr ""
"Множення на скаляр не змінює напрямку вектора — лише модуль. Таким чином ви "
"можете **відмасштабувати** вектор."

msgid "Practical applications"
msgstr "Практичне застосування"

msgid "Let's look at two common uses for vector addition and subtraction."
msgstr ""
"Погляньмо на два найпоширеніші способи використання суми та різниці векторів."

msgid "Movement"
msgstr "Пересування"

#, fuzzy
msgid ""
"A vector can represent **any** quantity with a magnitude and direction. "
"Typical examples are: position, velocity, acceleration, and force. In this "
"image, the spaceship at step 1 has a position vector of ``(1, 3)`` and a "
"velocity vector of ``(2, 1)``. The velocity vector represents how far the "
"ship moves each step. We can find the position for step 2 by adding the "
"velocity to the current position."
msgstr ""
"Вектор може позначати **будь-що** що має довжину та напрямок. Наприклад: "
"положення, швидкість, прискорення й сила. На цьому зображенні, космічний "
"корабель, на першому кроці, знаходиться в точці ``(1,3)`` та має вектор "
"швидкості ``(2,1)``. Вектор швидкості показує, як сильно повинен зміститись "
"корабель на кожному кроці. Ми можемо знайти його положення на другому кроці "
"додавши вектор швидкості до його попереднього положення."

#, fuzzy
msgid ""
"Velocity measures the **change** in position per unit of time. The new "
"position is found by adding the velocity multiplied by the elapsed time "
"(here assumed to be one unit, e.g. 1 s) to the previous position."
msgstr ""
"Швидкість визначає **зміну** положення за одиницю часу. Нове положення можна "
"знайти додавши швидкість до старого положення."

msgid ""
"In a typical 2D game scenario, you would have a velocity in pixels per "
"second, and multiply it by the ``delta`` parameter (time elapsed since the "
"previous frame) from the :ref:`_process() "
"<class_Node_private_method__process>` or :ref:`_physics_process() "
"<class_Node_private_method__physics_process>` callbacks."
msgstr ""

msgid "Pointing toward a target"
msgstr "Указування на ціль"

msgid ""
"In this scenario, you have a tank that wishes to point its turret at a "
"robot. Subtracting the tank's position from the robot's position gives the "
"vector pointing from the tank to the robot."
msgstr ""
"В цій ситуації, ви маєте танка, який хоче направити свою гармату на робота. "
"Різниця положень танка й робота дасть нам вектор що вказує від танка, до "
"робота."

#, fuzzy
msgid "To find a vector pointing from ``A`` to ``B``, use ``B - A``."
msgstr ""
"Щоб знайти вектор, який вказує від ``A`` до ``B`` використовуйте ``B - A``."

msgid "Unit vectors"
msgstr "Одиничні вектори"

msgid ""
"A vector with **magnitude** of ``1`` is called a **unit vector**. They are "
"also sometimes referred to as **direction vectors** or **normals**. Unit "
"vectors are helpful when you need to keep track of a direction."
msgstr ""
"Вектор з **довжиною** ``1`` називається **одиничним вектором**. Їх ще іноді "
"називають **напрямними векторами** чи **нормалями**. Одиничні вектори "
"корисні, коли необхідно знати про напрямок без довжини."

msgid "Normalization"
msgstr "Нормалізація"

#, fuzzy
msgid ""
"**Normalizing** a vector means reducing its length to ``1`` while preserving "
"its direction. This is done by dividing each of its components by its "
"magnitude. Because this is such a common operation, Godot provides a "
"dedicated :ref:`normalized() <class_Vector2_method_normalized>` method for "
"this:"
msgstr ""
"Щоб нормалізувати вектор потрібно зменшити його величину до ``1`` але при "
"цьому зберегти його напрямок. Зробити це можна поділивши кожен з його "
"компонентів на його довжину. Так як це дуже поширена операція, і "
"``Vector2``, і ``Vector3`` мають метод для нормалізації:"

#, fuzzy
msgid ""
"Because normalization involves dividing by the vector's length, you cannot "
"normalize a vector of length ``0``. Attempting to do so would normally "
"result in an error. In GDScript though, trying to call the ``normalized()`` "
"method on a vector of length 0 leaves the value untouched and avoids the "
"error for you."
msgstr ""
"Через те, що нормалізація включає в себе ділення на довжину вектора, "
"неможливо нормалізувати вектор з довжиною ``0``. Спроба зробити це викличе "
"помилку."

msgid "Reflection"
msgstr "Відбиття"

msgid ""
"A common use of unit vectors is to indicate **normals**. Normal vectors are "
"unit vectors aligned perpendicularly to a surface, defining its direction. "
"They are commonly used for lighting, collisions, and other operations "
"involving surfaces."
msgstr ""
"Вектори часто використовуються для того, щоб позначати **нормалі**. Вектор "
"нормалі — це одиничний вектор, спрямований перпендикулярно до якоїсь "
"поверхні. Він вказує на сторону, в яку повернута ця поверхня. Нормалі "
"використовуються при обчисленні освітлення, зіткнень та інших операцій, "
"зв'язаних із поверхнями."

msgid ""
"For example, imagine we have a moving ball that we want to bounce off a wall "
"or other object:"
msgstr ""
"Наприклад, уявімо, що ми маємо кулю, що рухається і ми хочемо, щоб вона "
"відбилася від стіни чи іншого об'єкта:"

#, fuzzy
msgid ""
"The surface normal has a value of ``(0, -1)`` because this is a horizontal "
"surface. When the ball collides, we take its remaining motion (the amount "
"left over when it hits the surface) and reflect it using the normal. In "
"Godot, there is a :ref:`bounce() <class_Vector2_method_bounce>` method to "
"handle this. Here is a code example of the above diagram using a :ref:"
"`CharacterBody2D <class_CharacterBody2D>`:"
msgstr ""
"Нормаль поверхні має значення ``(0, -1)`` бо вона повернута горизонтально. "
"Коли куля вдаряється в неї, ми беремо залишок від переміщення (частину "
"вектора швидкості, на яку повинна була переміститись куля якби не зіткнулась "
"з поверхнею) та віддзеркалюємо його використовуючи нормаль. В Godot клас :"
"ref:`Vector2 <class_Vector2>` має метод ``bounce()`` який займається цим. "
"Ось, приклад зі схеми вище, написаний на мові GDScript з використанням :ref:"
"`KinematicBody2D <class_KinematicBody2D>`:"

msgid "Dot product"
msgstr "Скалярний добуток"

msgid ""
"The **dot product** is one of the most important concepts in vector math, "
"but is often misunderstood. Dot product is an operation on two vectors that "
"returns a **scalar**. Unlike a vector, which contains both magnitude and "
"direction, a scalar value has only magnitude."
msgstr ""
"**Скалярний добуток** — це одне з найважливіших понять у векторній "
"математиці. Проте, його часто не розуміють. Скалярний добуток — це операція, "
"яка бере два вектори, та повертає **скаляр**. На відміну від векторів, які "
"мають модуль та напрямок, скаляр — це просто число, яке має лише модуль."

msgid "The formula for dot product takes two common forms:"
msgstr "Є дві формули для обчислення скалярного добутку:"

msgid "and"
msgstr "і"

msgid ""
"The mathematical notation *||A||* represents the magnitude of vector ``A``, "
"and *A*\\ :sub:`x` means the ``x`` component of vector ``A``."
msgstr ""

#, fuzzy
msgid ""
"However, in most cases it is easiest to use the built-in :ref:`dot() "
"<class_Vector2_method_dot>` method. Note that the order of the two vectors "
"does not matter:"
msgstr ""
"Хоча, найкращим рішенням буде використати вбудований метод. Запримітьте, що "
"порядок векторів не має значення:"

#, fuzzy
msgid ""
"The dot product is most useful when used with unit vectors, making the first "
"formula reduce to just ``cos(θ)``. This means we can use the dot product to "
"tell us something about the angle between two vectors:"
msgstr ""
"Скалярний добуток найбільш корисний, коли використовується з одиничними "
"векторами, спрощуючи першу формулу до ``cosθ``. А значить, результат "
"скалярного добутку, може нам розповісти щось про кут між векторами:"

msgid ""
"When using unit vectors, the result will always be between ``-1`` (180°) and "
"``1`` (0°)."
msgstr ""
"Якщо множаться одиничні вектори, то результат буде в межах від ``-1`` (180°) "
"до ``1`` (0°)."

msgid "Facing"
msgstr "Напрямок"

msgid ""
"We can use this fact to detect whether an object is facing toward another "
"object. In the diagram below, the player ``P`` is trying to avoid the "
"zombies ``A`` and ``B``. Assuming a zombie's field of view is **180°**, can "
"they see the player?"
msgstr ""
"Ми можемо використати це для того, щоб дізнатись, чи дивиться один об'єкт на "
"іншого. На схемі нижче, гравець ``p`` намагається уникати зомбі ``A`` і "
"``B``. Припустімо, поле зору зомбі має кут **180°**, чи можуть вони побачити "
"гравця?"

#, fuzzy
msgid ""
"The green arrows ``fA`` and ``fB`` are **unit vectors** representing the "
"zombie's facing direction and the blue semicircle represents its field of "
"view. For zombie ``A``, we find the direction vector ``AP`` pointing to the "
"player using ``P - A`` and normalize it, however, Godot has a helper method "
"to do this called :ref:`direction_to() <class_Vector2_method_direction_to>`. "
"If the angle between this vector and the facing vector is less than 90°, "
"then the zombie can see the player."
msgstr ""
"Зелені стрілочки ``fA`` й ``fB`` — це **одиничні вектори**, що позначають "
"напрямки, куди повернуті зомбі, а блакитні півкруги — їх поле зору. Для "
"зомбі ``A``, ми можемо знайти вектор напрямку ``AP``, який вказує на гравця, "
"використавши ``P-A`` та нормалізувавши його. До речі, Godot має допоміжний "
"метод для цього, він називається ``direction_to``. Якщо кут між цим "
"вектором, і тим що вказує на напрямок зомбі менший ніж 90° — то зомбі бачить "
"гравця."

msgid "In code it would look like this:"
msgstr "У коді це виглядатиме ось так:"

msgid "Cross product"
msgstr "Векторний добуток"

msgid ""
"Like the dot product, the **cross product** is an operation on two vectors. "
"However, the result of the cross product is a vector with a direction that "
"is perpendicular to both. Its magnitude depends on their relative angle. If "
"two vectors are parallel, the result of their cross product will be a null "
"vector."
msgstr ""
"Як і скалярний добуток, **векторний добуток** — це операція над двома "
"векторами. Але результат векторного добутку — це ще один вектор, який "
"направлений перпендикулярно до двох інших. Його довжина залежить від кута "
"між ними. Якщо вектори паралельні — то результатом векторного добутку буде "
"нульовий вектор."

msgid "The cross product is calculated like this:"
msgstr "Ось так обчислюється векторний добуток:"

#, fuzzy
msgid ""
"With Godot, you can use the built-in :ref:`Vector3.cross() "
"<class_Vector3_method_cross>` method:"
msgstr "В Godot можна використати вбудований метод:"

msgid ""
"The cross product is not mathematically defined in 2D. The :ref:`Vector2."
"cross() <class_Vector2_method_cross>` method is a commonly used analog of "
"the 3D cross product for 2D vectors."
msgstr ""

msgid ""
"In the cross product, order matters. ``a.cross(b)`` does not give the same "
"result as ``b.cross(a)``. The resulting vectors point in **opposite** "
"directions."
msgstr ""
"Для векторного добутку важливий порядок: ``a.cross(b)`` дасть інший "
"результат аніж ``b.cross(a)``. Отримані вектори будуть дивитись у протилежні "
"сторони."

msgid "Calculating normals"
msgstr "Обчислення нормалей"

#, fuzzy
msgid ""
"One common use of cross products is to find the surface normal of a plane or "
"surface in 3D space. If we have the triangle ``ABC`` we can use vector "
"subtraction to find two edges ``AB`` and ``AC``. Using the cross product, "
"``AB × AC`` produces a vector perpendicular to both: the surface normal."
msgstr ""
"Часто, векторний добуток використовують, щоб знайти нормаль площини чи "
"поверхні у тривимірному просторі. Якщо у нас є трикутник ``ABC``, то ми "
"можемо використати різницю векторів щоб знайти два його ребра: ``AB`` і "
"``AC``. А використавши векторний добуток ми знайдемо перпендикуляр до них — "
"він і буде нормаллю поверхні."

msgid "Here is a function to calculate a triangle's normal:"
msgstr "Ось функція для обчислення нормалі трикутника:"

msgid "Pointing to a target"
msgstr "Указування на ціль"

msgid ""
"In the dot product section above, we saw how it could be used to find the "
"angle between two vectors. However, in 3D, this is not enough information. "
"We also need to know what axis to rotate around. We can find that by "
"calculating the cross product of the current facing direction and the target "
"direction. The resulting perpendicular vector is the axis of rotation."
msgstr ""
"У розділі про скалярний добуток ми побачили, як він може бути використаний "
"для знаходження кута між векторами. Цього не достатньо для повороту в 3D. "
"Нам також потрібно знати навколо якої осі обертатись. Ми можемо знайти її "
"знайшовши векторний добуток між вектором який дивиться уперед і тим, що "
"направлений на ціль. Отриманий перпендикуляр і буде віссю обертання."

msgid "More information"
msgstr "Додаткова інформація"

msgid ""
"For more information on using vector math in Godot, see the following "
"articles:"
msgstr ""
"Дізнатись більше про використання векторів у Godot можна в наступних статтях:"

msgid ":ref:`doc_vectors_advanced`"
msgstr ":ref:`doc_vectors_advanced`"

msgid ":ref:`doc_matrices_and_transforms`"
msgstr ":ref:`doc_matrices_and_transforms`"

msgid "Translation status"
msgstr "Стан перекладу"
