# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Matrices and transforms"
msgstr "Матриці та перетворення"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"Before reading this tutorial, we recommend that you thoroughly read and "
"understand the :ref:`doc_vector_math` tutorial, as this tutorial requires a "
"knowledge of vectors."
msgstr ""
"Перед тим як читати цю статтю, радимо вам пройти урок :ref:"
"`doc_vector_math`так як вам потрібно знати базові концепції векторів щоб "
"зрозуміти цю статтю."

msgid ""
"This tutorial is about *transformations* and how we represent them in Godot "
"using matrices. It is not a full in-depth guide to matrices. Transformations "
"are most of the time applied as translation, rotation, and scale, so we will "
"focus on how to represent those with matrices."
msgstr ""
"Ця стаття розповідає про *перетворення* та про те, як ми представляємо їх у "
"Godot за допомогою матриць. Це не є поглиблений посібник з матриць. "
"Перетворення в основному застосовуються для переміщення, обертання та "
"масштабування, тому ми зосередимося на тому, як це робити за допомогою "
"матриць."

msgid ""
"Most of this guide focuses on 2D, using :ref:`class_Transform2D` and :ref:"
"`class_Vector2`, but the way things work in 3D is very similar."
msgstr ""
"Більша частина цього посібника зосереджена на 2D і використовує :ref:"
"`class_Transform2D` та :ref:`class_Vector2`, але перетворення в 3D працюють "
"схожим чином."

msgid ""
"As mentioned in the previous tutorial, it is important to remember that in "
"Godot, the Y axis points *down* in 2D. This is the opposite of how most "
"schools teach linear algebra, with the Y axis pointing up."
msgstr ""
"Як згадувалося в попередній статті, важливо пам'ятати, що в Godot, у 2D, "
"вісь Y вказує *вниз*. На відміну від шкільного курсу лінійної алгебри, де "
"вісь Y вказує вгору."

msgid ""
"The convention is that the X axis is red, the Y axis is green, and the Z "
"axis is blue. This tutorial is color-coded to match these conventions, but "
"we will also represent the origin vector with a blue color."
msgstr ""
"Умовність полягає в тому, що вісь X - червона, вісь Y - зелена, а вісь Z - "
"синя. Ця стаття буде використовувати колір відповідно до цієї умовності, але "
"синім кольором ми також будемо малювати вектор походження."

msgid "Matrix components and the Identity matrix"
msgstr "Компоненти матриці та Матриця Ідентичності"

msgid ""
"The identity matrix represents a transform with no translation, no rotation, "
"and no scale. Let's start by looking at the identity matrix and how its "
"components relate to how it visually appears."
msgstr ""
"Матриця ідентичності - це перетворення без переміщення, обертання і "
"масштабування. Почнемо з погляду на матрицю ідентичності і на те, як її "
"компоненти пов'язані з тим, як вона візуально проявляється."

msgid ""
"Matrices have rows and columns, and a transformation matrix has specific "
"conventions on what each does."
msgstr ""
"Матриці мають рядки та стовпці, а матриця перетворення має конкретні "
"умовності щодо того, що робить кожен з них."

msgid ""
"In the image above, we can see that the red X vector is represented by the "
"first column of the matrix, and the green Y vector is likewise represented "
"by the second column. A change to the columns will change these vectors. We "
"will see how they can be manipulated in the next few examples."
msgstr ""
"На зображенні вище ми бачимо, що червоний вектор X представлений першим "
"стовпцем матриці, а зелений вектор Y - представлений другим стовпцем. Зміна "
"стовпців змінить ці вектори. Ми побачимо, як ними можна маніпулювати в "
"наступних прикладах."

msgid ""
"You should not worry about manipulating rows directly, as we usually work "
"with columns. However, you can think of the rows of the matrix as showing "
"which vectors contribute to moving in a given direction."
msgstr ""
"Вам не варто чіплятися за безпосереднє маніпулювання рядками, бо зазвичай ми "
"працюємо зі стовпцями. Однак ви можете думати про рядки матриці, як про "
"вектори, які сприяють руху в заданому напрямку."

#, fuzzy
msgid ""
"When we refer to a value such as ``t.x.y``, that's the Y component of the X "
"column vector. In other words, the bottom-left of the matrix. Similarly, ``t."
"x.x`` is top-left, ``t.y.x`` is top-right, and ``t.y.y`` is bottom-right, "
"where ``t`` is the Transform2D."
msgstr ""
"Коли ми маємо на увазі таке значення, як *t.x.y*, то це векторний компонент "
"Y зі стовпця X. Іншими словами, внизу зліва в матриці. Аналогічно, *t.x.x* - "
"зверху зліва, *t.y.x* - зверху справа, а *t.y.y* - внизу справа, *t* - це "
"перетворення Transform2D."

msgid "Scaling the transformation matrix"
msgstr "Масштабування за допомогою матриці перетворення"

msgid ""
"Applying a scale is one of the easiest operations to understand. Let's start "
"by placing the Godot logo underneath our vectors so that we can visually see "
"the effects on an object:"
msgstr ""
"Масштабування є однією з найпростіших для розуміння операцій. Почнемо з "
"розміщення логотипу Godot під нашими векторами, щоб ми могли візуально "
"бачити вплив на об'єкт:"

msgid ""
"Now, to scale the matrix, all we need to do is multiply each component by "
"the scale we want. Let's scale it up by 2. 1 times 2 becomes 2, and 0 times "
"2 becomes 0, so we end up with this:"
msgstr ""
"Тепер, щоб масштабувати матрицю, все, що нам потрібно зробити, це помножити "
"кожен компонент на потрібний масштаб. Давайте збільшимо його на 2. 1 "
"помножити на 2 стає 2, а 0 помножити на 2 стає 0, тому ми в кінцевому "
"підсумку отримуємо це:"

#, fuzzy
msgid "To do this in code, we multiply each of the vectors:"
msgstr "Для цього в коді можна просто помножити кожен вектор:"

msgid ""
"If we wanted to return it to its original scale, we can multiply each "
"component by 0.5. That's pretty much all there is to scaling a "
"transformation matrix."
msgstr ""
"Якби ми хотіли повернути його до початкового масштабу, ми могли б помножити "
"кожен компонент на 0,5. Це майже все, що треба знати для масштабування "
"матриці перетворення."

#, fuzzy
msgid ""
"To calculate the object's scale from an existing transformation matrix, you "
"can use ``length()`` on each of the column vectors."
msgstr ""
"Щоб обчислити масштаб об'єкта з існуючої матриці перетворення, ви можете "
"використовувати ``length()`` на кожному векторному стовпці."

#, fuzzy
msgid ""
"In actual projects, you can use the ``scaled()`` method to perform scaling."
msgstr ""
"У реальних проектах можна використовувати метод ``scaled()`` для виконання "
"масштабування."

msgid "Rotating the transformation matrix"
msgstr "Обертання за допомогою матриці перетворення"

msgid ""
"We'll start the same way as earlier, with the Godot logo underneath the "
"identity matrix:"
msgstr "Почнемо з того самого логотипу Godot під матрицею ідентичності:"

msgid ""
"As an example, let's say we want to rotate our Godot logo clockwise by 90 "
"degrees. Right now the X axis points right and the Y axis points down. If we "
"rotate these in our head, we would logically see that the new X axis should "
"point down and the new Y axis should point left."
msgstr ""
"Припустимо, що ми хочемо повернути наш логотип за годинниковою стрілкою на "
"90 градусів. Зараз вісь X вказує праворуч, а вісь Y - вниз. Якщо ми уявімо "
"їх поворот, то зрозуміємо, що нова вісь X повинна вказувати вниз, а нова "
"вісь Y повинна вказувати ліворуч."

msgid ""
"You can imagine that you grab both the Godot logo and its vectors, and then "
"spin it around the center. Wherever you finish spinning, the orientation of "
"the vectors determines what the matrix is."
msgstr ""
"Ви можете уявити собі, що ви хапаєте, і логотип Godot, і його вектори, а "
"потім крутите його відносно центру. Де б ви не спинили обертатися, "
"орієнтація векторів визначає матрицю."

#, fuzzy
msgid ""
"We need to represent \"down\" and \"left\" in normal coordinates, so means "
"we'll set X to (0, 1) and Y to (-1, 0). These are also the values of "
"``Vector2.DOWN`` and ``Vector2.LEFT``. When we do this, we get the desired "
"result of rotating the object:"
msgstr ""
"Нам потрібно представляти \"низ\" і \"ліво\" у звичайних координатах, тому "
"це означає, що ми встановимо X у (0, 1) та Y у (-1, 0). Це також значення "
"``Vector2.DOWN`` і ``Vector2.LEFT``. Коли ми це зробимо, то отримаємо "
"задуманий поворот об'єкта:"

msgid ""
"If you have trouble understanding the above, try this exercise: Cut a square "
"of paper, draw X and Y vectors on top of it, place it on graph paper, then "
"rotate it and note the endpoints."
msgstr ""
"Якщо у вас виникли проблеми з розумінням вищесказаного, спробуйте таку "
"вправу: Витніть з паперу квадрат, намалюйте на ньому вектори X і Y, "
"помістіть його на розграфлений папір, потім поверніть його і занотуйте куди "
"вказують вектори. *(Примітка перекладача: Напрям вверх має координати (0, "
"-1), вправо - (1, 0), вниз - (0, 1), вліво - (-1, 0), при обертанні картинки "
"її вектори змінюють напрямок у який вказують)*."

msgid ""
"To perform rotation in code, we need to be able to calculate the values "
"programmatically. This image shows the formulas needed to calculate the "
"transformation matrix from a rotation angle. Don't worry if this part seems "
"complicated, I promise it's the hardest thing you need to know."
msgstr ""
"Для виконання обертання в коді нам потрібно вміти обчислювати значення "
"програмно. Це зображення показує формули, необхідні для обчислення матриці "
"кута повороту. Не хвилюйтеся, якщо ця частина здається складною, я обіцяю, "
"що це найважче, що вам потрібно знати."

msgid ""
"Godot represents all rotations with radians, not degrees. A full turn is "
"`TAU` or `PI*2` radians, and a quarter turn of 90 degrees is `TAU/4` or "
"`PI/2` radians. Working with `TAU` usually results in more readable code."
msgstr ""
"Godot представляє всі обертання в радіанах, а не градусах. Повний поворот "
"рівний ``TAU``, або ``PI*2``, радіан, а чверть повороту, на 90 градусів, - "
"``TAU/4``, або ``PI/2`` радіан. Використання ``TAU`` зазвичай дає більш "
"читабельний код."

msgid ""
"Fun fact: In addition to Y being *down* in Godot, rotation is represented "
"clockwise. This means that all the math and trig functions behave the same "
"as a Y-is-up CCW system, since these differences \"cancel out\". You can "
"think of rotations in both systems being \"from X to Y\"."
msgstr ""
"Цікавий факт: На додаток до того, що Y в Godot вказує *вниз*, обертання "
"представлене за годинниковою стрілкою. Це означає, що всі математичні та "
"тригерні функції поводяться так само, як і система CCW Y-зверху, оскільки ці "
"відмінності \"скасовуються\". Ви можете думати, що обертання в обох системах "
"є \"від X до Y\"."

#, fuzzy
msgid ""
"In order to perform a rotation of 0.5 radians (about 28.65 degrees), we plug "
"in a value of 0.5 to the formula above and evaluate to find what the actual "
"values should be:"
msgstr ""
"Для того щоб виконати обертання на 0,5 радіанів (близько 28,65 градусів), ми "
"просто підключаємо значення 0,5 до формули вище і вираховуємо, які фактичні "
"значення повинні бути:"

msgid "Here's how that would be done in code (place the script on a Node2D):"
msgstr "Ось як це буде зроблено в коді (помістіть скрипт на вузол Node2D):"

#, fuzzy
msgid ""
"To calculate the object's rotation from an existing transformation matrix, "
"you can use ``atan2(t.x.y, t.x.x)``, where t is the Transform2D."
msgstr ""
"Для обчислення обертання об'єкта з існуючої матриці перетворення можна "
"використовувати ``atan2(t.x.y, t.x.x)``, де t є Transform2D."

#, fuzzy
msgid ""
"In actual projects, you can use the ``rotated()`` method to perform "
"rotations."
msgstr ""
"У реальних проектах ви можете використовувати метод ``rotated()`` для "
"виконання обертань."

msgid "Basis of the transformation matrix"
msgstr "Основа матриці перетворення"

#, fuzzy
msgid ""
"So far we have only been working with the ``x`` and ``y``, vectors, which "
"are in charge of representing rotation, scale, and/or shearing (advanced, "
"covered at the end). The X and Y vectors are together called the *basis* of "
"the transformation matrix. The terms \"basis\" and \"basis vectors\" are "
"important to know."
msgstr ""
"До сих пір ми працювали тільки з векторами ``x`` і ``y``, які відповідають "
"за представлення обертання, масштабування та/або перекосів (висвітлені "
"далі). Вектори X і Y разом називаються *основою* матриці перетворення. "
"Терміни \"основа\" і \"основні вектори\" важливо знати."

#, fuzzy
msgid ""
"You might have noticed that :ref:`class_Transform2D` actually has three :ref:"
"`class_Vector2` values: ``x``, ``y``, and ``origin``. The ``origin`` value "
"is not part of the basis, but it is part of the transform, and we need it to "
"represent position. From now on we'll keep track of the origin vector in all "
"examples. You can think of origin as another column, but it's often better "
"to think of it as completely separate."
msgstr ""
"Можливо, ви помітили, що :ref:`class_Transform2D` насправді має три "
"значення :ref:`class_Vector2`: ``x``, ``y`` і ``origin`` . Значення "
"``origin`` не є частиною основи, але воно є частиною перетворення, і "
"потрібне нам, щоб представляти позицію. Відтепер ми будемо відстежувати у "
"всіх прикладах вектор ``origin``. Ви можете думати про нього, як про іншу "
"колонку, але краще вважати, що він йде окремо."

#, fuzzy
msgid ""
"Note that in 3D, Godot has a separate :ref:`class_Basis` structure for "
"holding the three :ref:`class_Vector3` values of the basis, since the code "
"can get complex and it makes sense to separate it from :ref:"
"`class_Transform3D` (which is composed of one :ref:`class_Basis` and one "
"extra :ref:`class_Vector3` for the origin)."
msgstr ""
"Запримітьте, що в 3D Godot має окрему структуру :ref:`class_Basis` для "
"утримання трьох значень основи :ref:`class_Vector3`, оскільки код може "
"ускладнитися і має сенс відокремити його від :ref:`class_Transform` (який "
"складається з однієї :ref:`class_Basis` і одного додаткового :ref:"
"`class_Vector3` для походження)."

msgid "Translating the transformation matrix"
msgstr "Переміщення за допомогою матриці перетворення"

#, fuzzy
msgid ""
"Changing the ``origin`` vector is called *translating* the transformation "
"matrix. Translating is basically a technical term for \"moving\" the object, "
"but it explicitly does not involve any rotation."
msgstr ""
"Зміна вектора ``origin`` призводить до переміщення. При цьому переміщення не "
"передбачає ніякого обертання."

msgid ""
"Let's work through an example to help understand this. We will start with "
"the identity transform like last time, except we will keep track of the "
"origin vector this time."
msgstr ""
"Давайте розглянемо приклад, щоб зрозуміти це. Ми почнемо з матриці "
"ідентичності, як минулого разу, за винятком того, що цього разу ми будемо "
"відстежувати вектор походження."

#, fuzzy
msgid ""
"If we want to move the object to a position of (1, 2), we need to set its "
"``origin`` vector to (1, 2):"
msgstr ""
"Якщо ми хочемо, щоб об'єкт рухався в положення (1, 2), нам просто потрібно "
"встановити його вектор походження ``origin`` на (1, 2):"

#, fuzzy
msgid ""
"There is also a ``translated()`` method, which performs a different "
"operation to adding or changing ``origin`` directly. The ``translated()`` "
"method will translate the object *relative to its own rotation*. For "
"example, an object rotated 90 degrees clockwise will move to the right when "
"``translated()`` with ``Vector2.UP``."
msgstr ""
"Існує також метод ``translated()``, який виконує іншу операцію з додавання, "
"або зміни, ``origin`` безпосередньо. Метод ``translated()`` перемістить "
"об'єкт *відносно його власного повороту*. Наприклад, об'єкт, повернутий на "
"90 градусів за годинниковою стрілкою, ``translated()`` з ``Vector2.UP`` "
"перемістить вправо."

msgid ""
"Godot's 2D uses coordinates based on pixels, so in actual projects you will "
"want to translate by hundreds of units."
msgstr ""
"Godot в 2D використовує координати, засновані на пікселях, тому в реальних "
"проектах ви будете переміщувати на сотні одиниць."

msgid "Putting it all together"
msgstr "Збираємо все це докупи"

#, fuzzy
msgid ""
"We're going to apply everything we mentioned so far onto one transform. To "
"follow along, create a project with a Sprite2D node and use the Godot logo "
"for the texture resource."
msgstr ""
"Ми збираємося застосувати все, про що ми досі говорили, для одного "
"перетворення. Щоб продовжити далі, створіть простий проект з вузлом Sprite і "
"використайте логотип Godot для в якості його текстури."

msgid ""
"Let's set the translation to (350, 150), rotate by -0.5 rad, and scale by 3. "
"I've posted a screenshot, and the code to reproduce it, but I encourage you "
"to try and reproduce the screenshot without looking at the code!"
msgstr ""
"Давайте встановимо переміщення на (350, 150), поворот на -0,5 радіан і "
"масштаб на 3. Я опублікував скріншот, і код, для його відтворення, але "
"закликаю вас спробувати відтворити скріншот, не заглядаючи в код!"

msgid "Shearing the transformation matrix (advanced)"
msgstr "Перекоси за допомогою матриці перетворення (додатково)"

msgid ""
"If you are only looking for how to *use* transformation matrices, feel free "
"to skip this section of the tutorial. This section explores an uncommonly "
"used aspect of transformation matrices for the purpose of building an "
"understanding of them."
msgstr ""
"Якщо ви шукаєте інформацію тільки про *використання* матриць перетворення, "
"не соромтеся пропустити цей розділ статті. Цей розділ досліджує мало коли "
"використовуваний аспект матриць перетворення з метою формування розуміння їх."

msgid "Node2D provides a shearing property out of the box."
msgstr ""

msgid ""
"You may have noticed that a transform has more degrees of freedom than the "
"combination of the above actions. The basis of a 2D transformation matrix "
"has four total numbers in two :ref:`class_Vector2` values, while a rotation "
"value and a Vector2 for scale only has 3 numbers. The high-level concept for "
"the missing degree of freedom is called *shearing*."
msgstr ""
"Можливо, ви помітили, що перетворення має більше ступенів свободи, ніж "
"поєднання вищезазначених дій. Основа матриці 2D-перетворення має чотири "
"загальних числа у двох значеннях :ref:`class_Vector2`, тоді як значення "
"обертання та Вектор2 для масштабу мають лише 3 числа. Концепція високого "
"рівня з обмеження ступенів свободи дозволяє *перекоси*."

msgid ""
"Normally, you will always have the basis vectors perpendicular to each "
"other. However, shearing can be useful in some situations, and understanding "
"shearing helps you understand how transforms work."
msgstr ""
"Як правило, базові вектори у вас завжди будуть перпендикулярні один одному. "
"Однак перекоси можуть бути корисними в деяких ситуаціях, а їх розуміння "
"допомагає зрозуміти, як працюють перетворення."

msgid ""
"To show you visually how it will look, let's overlay a grid onto the Godot "
"logo:"
msgstr ""
"Щоб візуально показати вам, як це буде виглядати, давайте накладемо сітку на "
"логотип Godot:"

msgid ""
"Each point on this grid is obtained by adding the basis vectors together. "
"The bottom-right corner is X + Y, while the top-right corner is X - Y. If we "
"change the basis vectors, the entire grid moves with it, as the grid is "
"composed of the basis vectors. All lines on the grid that are currently "
"parallel will remain parallel no matter what changes we make to the basis "
"vectors."
msgstr ""
"Кожна точка на цій сітці є отримана за допомогою додавання основних "
"векторів. Нижній правий кут рівний X + Y, а верхній правий кут рівний X - Y. "
"Якщо ми змінимо вектори основи, то з ними зрушиться вся сітка, так як сітка "
"складається з основних векторів. Всі лінії на сітці, які в даний час "
"паралельні, залишаться паралельними, незалежно від того, які зміни ми "
"вносимо в основні вектори."

msgid "As an example, let's set Y to (1, 1):"
msgstr "Як приклад, давайте встановимо Y на (1, 1):"

msgid ""
"You can't set the raw values of a Transform2D in the editor, so you *must* "
"use code if you want to shear the object."
msgstr ""
"Ви не можете встановити необроблені значення Transform2D у редакторі, тому "
"ви *повинні* використовувати код, якщо хочете перекосити об'єкт."

msgid ""
"Due to the vectors no longer being perpendicular, the object has been "
"sheared. The bottom-center of the grid, which is (0, 1) relative to itself, "
"is now located at a world position of (1, 1)."
msgstr ""
"Через те, що вектори більше не перпендикулярні, об'єкт перекосився. Нижній "
"центр сітки, який (0, 1) відносно себе, у світовому положенні тепер "
"розташований (1, 1)."

msgid ""
"The intra-object coordinates are called UV coordinates in textures, so let's "
"borrow that terminology for here. To find the world position from a relative "
"position, the formula is U * X + V * Y, where U and V are numbers and X and "
"Y are the basis vectors."
msgstr ""
"Внутрішні координати об'єкта називаються текстурними координатами, тому "
"давайте запозичимо цю термінологію сюди. Щоб знайти світову позицію з "
"відносної позиції використовується формула - U * X + V * Y, де U і V - "
"числа, а X і Y - базові вектори."

msgid ""
"The bottom-right corner of the grid, which is always at the UV position of "
"(1, 1), is at the world position of (2, 1), which is calculated from X*1 + "
"Y*1, which is (1, 0) + (1, 1), or (1 + 1, 0 + 1), or (2, 1). This matches up "
"with our observation of where the bottom-right corner of the image is."
msgstr ""
"Нижній правий кут сітки, який в текстурних координатах завжди знаходиться на "
"(1, 1), світових знаходиться на (2, 1), які розраховуються від X*1 + Y*1, що "
"дорівнює (1, 0) + (1, 1), або (1 + 1, 0 + 1), або (2, 1). Це узгоджується з "
"нашим спостереженням за тим, де знаходиться правий нижній кут зображення."

msgid ""
"Similarly, the top-right corner of the grid, which is always at the UV "
"position of (1, -1), is at the world position of (0, -1), which is "
"calculated from X*1 + Y*-1, which is (1, 0) - (1, 1), or (1 - 1, 0 - 1), or "
"(0, -1). This matches up with our observation of where the top-right corner "
"of the image is."
msgstr ""
"Аналогічно, верхній правий кут сітки, який в текстурних координатах завжди "
"знаходиться на (1, -1), у світових знаходиться на (0, -1), які вираховуються "
"з X*1 + Y*-1, що дорівнює (1, 0) - (1, 1), або (1 - 1, 0 - 1), або (0, -1). "
"Це узгоджується з нашим спостереженням за тим, де знаходиться верхній правий "
"кут зображення."

msgid ""
"Hopefully you now fully understand the how a transformation matrix affects "
"the object, and the relationship between the basis vectors and how the "
"object's \"UV\" or \"intra-coordinates\" have their world position changed."
msgstr ""
"Сподіваюся, тепер ви повністю розумієте, як матриця перетворення впливає на "
"об'єкт, і взаємозв'язок між основними векторами і тим, як \"внутрішні "
"координати\" об'єкта змінюють своє світове положення."

msgid ""
"In Godot, all transform math is done relative to the parent node. When we "
"refer to \"world position\", that would be relative to the node's parent "
"instead, if the node had a parent."
msgstr ""
"У Godot вся математика перетворення виконується відносно батьківського "
"вузла. Коли ми маємо на увазі \"світову позицію\", то говоримо про позицію "
"відносно батьківського вузла, якщо у вузла є батько."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about linear transformations: https://www.youtube.com/watch?"
"v=kYB8IZa5AuE"
msgstr ""
"Якщо ви хочете отримати додаткові пояснення, вам слід переглянути чудове "
"відео 3Blue1Brown про лінійні перетворення: https://www.youtube.com/watch?"
"v=kYB8IZa5AuE"

msgid "Practical applications of transforms"
msgstr "Практичне застосування перетворень"

#, fuzzy
msgid ""
"In actual projects, you will usually be working with transforms inside "
"transforms by having multiple :ref:`class_Node2D` or :ref:`class_Node3D` "
"nodes parented to each other."
msgstr ""
"У реальних проектах ви зазвичай працюватимете з перетвореннями всередині "
"перетворень, маючи кілька вузлів :ref:`class_Node2D` або :ref:"
"`class_Spatial`, пов’язаних між собою."

#, fuzzy
msgid ""
"However, it's useful to understand how to manually calculate the values we "
"need. We will go over how you could use :ref:`class_Transform2D` or :ref:"
"`class_Transform3D` to manually calculate transforms of nodes."
msgstr ""
"Однак іноді дуже корисно вручну обчислити потрібні значення. Ми розглянемо, "
"як ви можете використовувати :ref:`class_Transform2D` або :ref:"
"`class_Transform` для ручного обчислення перетворень вузлів."

msgid "Converting positions between transforms"
msgstr "Конвертування позицій між перетвореннями"

msgid ""
"There are many cases where you'd want to convert a position in and out of a "
"transform. For example, if you have a position relative to the player and "
"would like to find the world (parent-relative) position, or if you have a "
"world position and want to know where it is relative to the player."
msgstr ""
"Є багато випадків, коли вам треба конвертувати позицію в і зовні "
"перетворення. Наприклад, якщо у вас є позиція відносно гравця і ви хотіли б "
"знайти світову (відносну батька) позицію, або якщо у вас є світова позиція і "
"ви хочете знати, де вона знаходиться відносно гравця."

#, fuzzy
msgid ""
"We can find what a vector relative to the player would be defined in world "
"space as using the ``*`` operator:"
msgstr ""
"Ми можемо знайти, який вектор, відносно гравця, буде визначатися у світовому "
"просторі як такий, що використовує метод ``xform``:"

#, fuzzy
msgid ""
"And we can use the ``*`` operator in the opposite order to find a what world "
"space position would be if it was defined relative to the player:"
msgstr ""
"І ми можемо використовувати метод ``xform_inv``, щоб знайти, якою була б "
"позиція світового простору, якби вона була визначена відносно гравця:"

msgid ""
"If you know in advance that the transform is positioned at (0, 0), you can "
"use the \"basis_xform\" or \"basis_xform_inv\" methods instead, which skip "
"dealing with translation."
msgstr ""
"Якщо ви заздалегідь знаєте, що вузол перетворення розташований на (0, 0), то "
"можете використовувати методи ``basis_xform``, або ``basis_xform_inv``, які "
"пропускають конвертацію."

msgid "Moving an object relative to itself"
msgstr "Переміщення об'єкта відносно себе"

msgid ""
"A common operation, especially in 3D games, is to move an object relative to "
"itself. For example, in first-person shooter games, you would want the "
"character to move forward (-Z axis) when you press :kbd:`W`."
msgstr ""
"Поширеною операцією, особливо в 3D-іграх, є переміщення об'єкта відносно "
"себе. Наприклад, у шутерах від першої особи потрібно, щоб персонаж рухався "
"вперед (вісь -Z) під час натискання клавіші :kbd:`W`."

#, fuzzy
msgid ""
"Since the basis vectors are the orientation relative to the parent, and the "
"origin vector is the position relative to the parent, we can add multiples "
"of the basis vectors to move an object relative to itself."
msgstr ""
"Оскільки базові вектори - це орієнтація відносно предка, а вектор походження "
"- це позиція відносно предка, ми можемо просто додати кратні базових "
"векторів, щоб перемістити об'єкт відносно себе."

msgid "This code moves an object 100 units to its own right:"
msgstr "Цей код переміщує об'єкт на 100 одиниць праворуч:"

msgid "For moving in 3D, you would need to replace \"x\" with \"basis.x\"."
msgstr "Для переміщення в 3D вам потрібно буде замінити ``x`` на ``basis.x``."

#, fuzzy
msgid ""
"In actual projects, you can use ``translate_object_local`` in 3D or "
"``move_local_x`` and ``move_local_y`` in 2D to do this."
msgstr ""
"У реальних проектах для цього можна використовувати "
"``translate_object_local`` в 3D, чи ``move_local_x`` і ``move_local_y`` в 2D."

msgid "Applying transforms onto transforms"
msgstr "Застосування перетворень на перетвореннях"

msgid ""
"One of the most important things to know about transforms is how you can use "
"several of them together. A parent node's transform affects all of its "
"children. Let's dissect an example."
msgstr ""
"Одна з найважливіших речей, які потрібно знати про перетворення, - це те, що "
"ви можете використовувати кілька їх разом. Перетворення батьківського вузла "
"впливає на всіх його дітей. Давайте розглянемо приклад."

msgid ""
"In this image, the child node has a \"2\" after the component names to "
"distinguish them from the parent node. It might look a bit overwhelming with "
"so many numbers, but remember that each number is displayed twice (next to "
"the arrows and also in the matrices), and that almost half of the numbers "
"are zero."
msgstr ""
"На цьому зображенні дочірній вузол має приставку \"2\" до назв компонентів, "
"щоб відрізнити їх від компонентів батьківського вузла. Це може виглядати "
"трохи приголомшливо з такою кількістю чисел, але пам'ятайте, що кожне число "
"відображається двічі (поруч зі стрілками, а також у матрицях), і що майже "
"половина чисел дорівнює нулю."

msgid ""
"The only transformations going on here are that the parent node has been "
"given a scale of (2, 1), the child has been given a scale of (0.5, 0.5), and "
"both nodes have been given positions."
msgstr ""
"Єдині перетворення, що відбуваються тут, - це те, що батьківському вузлу "
"була наданий масштаб (2, 1), дитині - масштаб (0,5, 0,5), і обом вузлам були "
"надані позиції."

#, fuzzy
msgid ""
"All child transformations are affected by the parent transformations. The "
"child has a scale of (0.5, 0.5), so you would expect it to be a 1:1 ratio "
"square, and it is, but only relative to the parent. The child's X vector "
"ends up being (1, 0) in world space, because it is scaled by the parent's "
"basis vectors. Similarly, the child node's ``origin`` vector is set to (1, "
"1), but this actually moves it (2, 1) in world space, due to the parent "
"node's basis vectors."
msgstr ""
"Батьківські перетворення впливають на всі дитячі перетворення. Дитина має "
"масштаб (0,5, 0,5), тому ви очікуєте, що це буде квадрат зі співвідношенням "
"1:1, і це так, але тільки відносно батька. Вектор X дитини в кінцевому "
"підсумку знаходиться (1, 0) у світовому просторі, тому що він масштабується "
"за основними векторами батька. Аналогічно, вектор походження дочірнього "
"вузла встановлений на (1, 1), але це, фактично, рухає його на (2, 1) у "
"світовому просторі через вектори батьківського вузла."

msgid ""
"To calculate a child transform's world space transform manually, this is the "
"code we would use:"
msgstr ""
"Щоб розрахувати перетворення дитини відносно світового простору вручну, ми "
"можемо використовувати такий код:"

#, fuzzy
msgid ""
"In actual projects, we can find the world transform of the child by applying "
"one transform onto another using the ``*`` operator:"
msgstr ""
"У реальних проектах ми можемо знайти світове перетворення дитини, "
"застосувавши одне перетворення до іншого за допомогою оператора ``*``:"

msgid "When multiplying matrices, order matters! Don't mix them up."
msgstr "При множенні матриць, порядок має значення! Не змішуйте їх."

msgid "Lastly, applying the identity transform will always do nothing."
msgstr ""
"Нарешті, застосування перетворення ідентичності завжди нічого не зробить."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about matrix composition: https://www.youtube.com/watch?"
"v=XkY2DOUCWMU"
msgstr ""
"Якщо ви хочете отримати додаткове пояснення, вам слід переглянути чудове "
"відео 3Blue1Brown про матричну композицію: https://www.youtube.com/watch?"
"v=XkY2DOUCWMU"

msgid "Inverting a transformation matrix"
msgstr "Інвертування матриці перетворення"

#, fuzzy
msgid ""
"The \"affine_inverse\" function returns a transform that \"undoes\" the "
"previous transform. This can be useful in some situations. Let's take a look "
"at a few examples."
msgstr ""
"Функція ``affine_inverse`` повертає перетворення, яке \"скасовує\" попереднє "
"перетворення. Це може бути корисно в деяких ситуаціях, але легше просто "
"навести кілька прикладів."

msgid ""
"Multiplying an inverse transform by the normal transform undoes all "
"transformations:"
msgstr ""
"Множення інвертованого перетворення на нормальне перетворення скасовує всі "
"перетворення:"

#, fuzzy
msgid ""
"Transforming a position by a transform and its inverse results in the same "
"position:"
msgstr ""
"Перетворення позиції на перетворення та її інверсію призводить до тої ж "
"позиції (те ж саме для ``xform_inv``):"

msgid "How does it all work in 3D?"
msgstr "Як усе це працює в 3D?"

#, fuzzy
msgid ""
"One of the great things about transformation matrices is that they work very "
"similarly between 2D and 3D transformations. All the code and formulas used "
"above for 2D work the same in 3D, with 3 exceptions: the addition of a third "
"axis, that each axis is of type :ref:`class_Vector3`, and also that Godot "
"stores the :ref:`class_Basis` separately from the :ref:`class_Transform3D`, "
"since the math can get complex and it makes sense to separate it."
msgstr ""
"Один з плюсів матриць перетворення полягає в тому, що вони працюють дуже "
"аналогічно між 2D і 3D перетвореннями. Всі коди та формули, що "
"використовувалися вище для 2D, працюють однаково і в 3D, за 3-ма винятками: "
"додавання третьої осі, кожна вісь належить до типу :ref:`class_Vector3`, "
"Godot зберігає :ref:`class_Basis` окремо від :ref:`class_Transform`, "
"оскільки математика може ускладнитися, і має сенс відокремити її."

msgid ""
"All of the concepts for how translation, rotation, scale, and shearing work "
"in 3D are all the same compared to 2D. To scale, we take each component and "
"multiply it; to rotate, we change where each basis vector is pointing; to "
"translate, we manipulate the origin; and to shear, we change the basis "
"vectors to be non-perpendicular."
msgstr ""
"Всі концепції того, як працюють переміщення, обертання, масштабування і "
"скошення в 3D, такі самі, як і в 2D. Для масштабування беремо кожен "
"компонент і множимо його; щоб повернути, ми змінюємо, напрям кожного "
"основного вектора; для переміщення ми маніпулюємо походженням;а для "
"перекосів, ми змінюємо основні вектори, щоб вони були неперпендикулярними."

msgid ""
"If you would like, it's a good idea to play around with transforms to get an "
"understanding of how they work. Godot allows you to edit 3D transform "
"matrices directly from the inspector. You can download this project which "
"has colored lines and cubes to help visualize the :ref:`class_Basis` vectors "
"and the origin in both 2D and 3D: https://github.com/godotengine/godot-demo-"
"projects/tree/master/misc/matrix_transform"
msgstr ""
"Якщо хочете, можете по-експериментувати з перетвореннями, щоб зрозуміти їх "
"роботу. Godot дозволяє редагувати матриці 3D-перетворення безпосередньо в "
"Інспекторі. Ви можете завантажити цей проект, який має кольорові лінії та "
"кубики, щоб допомогти візуалізувати вектори :ref:`class_Basis` та походження "
"як у 2D, так і в 3D: https://github.com/godotengine/godot-demo-projects/tree/"
"master/misc/matrix_transform"

#, fuzzy
msgid ""
"You cannot edit Node2D's transform matrix directly in Godot 4.0's inspector. "
"This may be changed in a future release of Godot."
msgstr ""
"Ви не можете редагувати матрицю перетворення Node2D безпосередньо в "
"інспекторі Godot 3.2. Це може змінитися в майбутньому випуску Godot."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about 3D linear transformations: https://www.youtube.com/"
"watch?v=rHLEWRxRGiM"
msgstr ""
"Якщо хочете отримати додаткове пояснення, вам слід ознайомитися з чудовим "
"відео 3Blue1Brown про 3D-лінійні перетворення: https://www.youtube.com/watch?"
"v=rHLEWRxRGiM"

msgid "Representing rotation in 3D (advanced)"
msgstr "Представлення обертання в 3D (додатково)"

msgid ""
"The biggest difference between 2D and 3D transformation matrices is how you "
"represent rotation by itself without the basis vectors."
msgstr ""
"Найбільша відмінність між матрицями перетворення 2D і 3D полягає в тому, як "
"ви представляєте обертання саме по собі без базових векторів."

#, fuzzy
msgid ""
"With 2D, we have an easy way (atan2) to switch between a transformation "
"matrix and an angle. In 3D, rotation is too complex to represent as one "
"number. There is something called Euler angles, which can represent "
"rotations as a set of 3 numbers, however, they are limited and not very "
"useful, except for trivial cases."
msgstr ""
"З 2D ми маємо простий спосіб (atan2) перемикатися між матрицею перетворення "
"та кутом. У 3D ми не можемо просто представити обертання як одне число. "
"Існує те, що називається кутами Ейлера, які можуть представляти обертання у "
"вигляді набору з 3 чисел, однак вони обмежені і не дуже корисні, за винятком "
"тривіальних випадків."

#, fuzzy
msgid ""
"In 3D we do not typically use angles, we either use a transformation basis "
"(used pretty much everywhere in Godot), or we use quaternions. Godot can "
"represent quaternions using the :ref:`class_Quaternion` struct. My "
"suggestion to you is to completely ignore how they work under-the-hood, "
"because they are very complicated and unintuitive."
msgstr ""
"У 3D ми зазвичай не використовуємо кути, ми або використовуємо основу "
"перетворення (використовується майже скрізь в Godot), або ми використовуємо "
"кватерніони. Godot може представляти кватерніони за допомогою структури :ref:"
"`class_Quat`. Я пропоную вам не ламати собі голову над тим, як вони "
"працюють, тому що це дуже складно."

msgid ""
"However, if you really must know how it works, here are some great "
"resources, which you can follow in order:"
msgstr ""
"Однак, якщо вам дійсно треба знати, як це працює, ось деякі великі ресурси, "
"з якими ви можете ознайомитися:"

msgid "https://www.youtube.com/watch?v=mvmuCPvRoWQ"
msgstr "https://www.youtube.com/watch?v=mvmuCPvRoWQ"

msgid "https://www.youtube.com/watch?v=d4EgbgTm0Bg"
msgstr "https://www.youtube.com/watch?v=d4EgbgTm0Bg"

msgid "https://eater.net/quaternions"
msgstr "https://eater.net/quaternions"

msgid "Translation status"
msgstr "Стан перекладу"
