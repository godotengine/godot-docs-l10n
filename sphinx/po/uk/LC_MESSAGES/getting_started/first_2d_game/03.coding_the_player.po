# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Coding the player"
msgstr "Кодування гравця"

msgid ""
"In this lesson, we'll add player movement, animation, and set it up to "
"detect collisions."
msgstr ""
"У цьому уроці ми додамо гравцю рух, анімацію та налаштуємо йому виявлення "
"зіткнень."

msgid ""
"To do so, we need to add some functionality that we can't get from a built-"
"in node, so we'll add a script. Click the ``Player`` node and click the "
"\"Attach Script\" button:"
msgstr ""
"Для цього нам потрібно додати деяку функціональність, яку ми не можемо "
"отримати від вбудованого вузла, тому ми додамо скрипт. Клацніть на вузлі "
"``Player`` і натисніть кнопку \"Долучити скрипт\":"

msgid ""
"In the script settings window, you can leave the default settings alone. "
"Just click \"Create\":"
msgstr ""
"У вікні налаштувань скрипту ви можете залишити налаштування за "
"замовчуванням. Просто натисніть \"Створити\":"

msgid ""
"If you're creating a C# script or other languages, select the language from "
"the `language` drop down menu before hitting create."
msgstr ""
"Якщо ви створюєте скрипт на C# , або іншій мові, виберіть мову зі спадного "
"меню `Мова`, перед тим, як створити скрипт."

msgid ""
"If this is your first time encountering GDScript, please read :ref:"
"`doc_scripting` before continuing."
msgstr ""
"Якщо ви вперше стикаєтеся з GDScript, будь ласка, прочитайте :ref:"
"`doc_scripting`, перш ніж продовжити."

msgid "Start by declaring the member variables this object will need:"
msgstr ""
"Почніть з оголошення змінних-членів, які будуть потрібні цьому об'єкту:"

msgid ""
"Using the ``export`` keyword on the first variable ``speed`` allows us to "
"set its value in the Inspector. This can be handy for values that you want "
"to be able to adjust just like a node's built-in properties. Click on the "
"``Player`` node and you'll see the property now appears in the \"Script "
"Variables\" section of the Inspector. Remember, if you change the value "
"here, it will override the value written in the script."
msgstr ""
"Використання ключового слова ``export`` на першій змінній ``speed`` "
"(швидкість) дозволяє нам встановлювати її значення в Інспекторі. Це може "
"бути зручно для значень, які ви хочете мати можливість регулювати так само, "
"як і вбудовані властивості вузла. Натисніть на вузол ``Player``, і ви "
"побачите властивість, яка появилася в розділі інспектора \"Script "
"Variables\" (\"Змінні скриптів\"). Пам'ятайте, що якщо ви зміните тут "
"значення, воно перепише значення, записане в скрипті."

msgid ""
"If you're using C#, you need to (re)build the project assemblies whenever "
"you want to see new export variables or signals. This build can be manually "
"triggered by clicking the word \"Mono\" at the bottom of the editor window "
"to reveal the Mono Panel, then clicking the \"Build Project\" button."
msgstr ""
"Якщо ви використовуєте C#, вам потрібно (пере)будувати збірки проєктів, коли "
"ви хочете бачити нові змінні експорту, чи сигнали. Цю збірку можна вручну "
"запустити, натиснувши слово \"Mono\" внизу вікна редактора, щоб відкрити "
"панель Mono, а потім натиснути кнопку \"Build Project\"."

msgid ""
"The ``_ready()`` function is called when a node enters the scene tree, which "
"is a good time to find the size of the game window:"
msgstr ""
"Функція ``_ready()`` викликається , коли вузол входить в дерево сцени, "
"чудовий момент , щоб задати розмір вікна гри:"

msgid ""
"Now we can use the ``_process()`` function to define what the player will "
"do. ``_process()`` is called every frame, so we'll use it to update elements "
"of our game, which we expect will change often. For the player, we need to "
"do the following:"
msgstr ""
"Тепер ми можемо використовувати функцію ``_process()``, щоб визначити, що "
"робитиме гравець. ``_process()`` викликається кожен кадр, тому ми будемо "
"використовувати її для оновлення тих елементів нашої гри, які будуть часто "
"змінюватися. Для гравця нам потрібно зробити наступне:"

msgid "Check for input."
msgstr "Перевірити ввід."

msgid "Move in the given direction."
msgstr "Рухати в заданому напрямі."

msgid "Play the appropriate animation."
msgstr "Відтворити відповідну анімацію."

msgid ""
"First, we need to check for input - is the player pressing a key? For this "
"game, we have 4 direction inputs to check. Input actions are defined in the "
"Project Settings under \"Input Map\". Here, you can define custom events and "
"assign different keys, mouse events, or other inputs to them. For this game, "
"we will map the arrow keys to the four directions."
msgstr ""
"Спочатку нам потрібно перевірити ввід - чи гравець натискає клавішу? Для "
"цієї гри у нас є 4 напрямки для перевірки. Дії введення визначені в "
"Параметрах проекту в розділі \"Карта введення\". Тут ви можете визначити "
"власні події та призначити їм різні клавіші, події миші чи інші входи. Для "
"цієї гри ми зіставимо клавіші зі стрілками до чотирьох напрямків."

msgid ""
"Click on *Project -> Project Settings* to open the project settings window "
"and click on the *Input Map* tab at the top. Type \"move_right\" in the top "
"bar and click the \"Add\" button to add the ``move_right`` action."
msgstr ""
"Натисніть *Проект -> Параметри проекту*, щоб відкрити вікно налаштувань "
"проекту, і натисніть на вкладку \"Карта введення\" вгорі. Введіть "
"\"move_right\" у верхній графі та натисніть кнопку \"Додати\", щоб додати "
"дію ``move_right``."

msgid ""
"We need to assign a key to this action. Click the \"+\" icon on the right, "
"then click the \"Key\" option in the drop-down menu. A dialog asks you to "
"type in the desired key. Press the right arrow on your keyboard and click "
"\"Ok\"."
msgstr ""
"Нам потрібно призначити ключ до цієї дії. Натисніть значок \"+\" праворуч, а "
"потім натисніть опцію \"Клавіша\" в випадаючому меню. У діалоговому вікні "
"буде запропоновано натиснути потрібну клавішу. Натисніть стрілку вправо на "
"клавіатурі і натисніть \"Ok\"."

msgid "Repeat these steps to add three more mappings:"
msgstr "Повторіть ці дії, щоб додати ще три зіставлення:"

msgid "``move_left`` mapped to the left arrow key."
msgstr "``move_left`` з клавішею зі стрілкою вліво."

msgid "``move_up`` mapped to the up arrow key."
msgstr "``move_up`` з клавішею зі стрілкою вгору."

msgid "And ``move_down`` mapped to the down arrow key."
msgstr "Та ``move_down`` з клавішею зі стрілкою вниз."

msgid "Your input map tab should look like this:"
msgstr "Вкладка карти введення має мати такий вигляд:"

msgid "Click the \"Close\" button to close the project settings."
msgstr "Натисніть кнопку \"Закрити\", щоб закрити параметри проекту."

msgid ""
"We only mapped one key to each input action, but you can map multiple keys, "
"joystick buttons, or mouse buttons to the same input action."
msgstr ""
"Ми зіставили лише одну клавішу з кожною вхідною дією, але ви можете "
"зіставити кілька клавіш, кнопок джойстика або кнопок миші з однією і тією ж "
"дією введення."

msgid ""
"You can detect whether a key is pressed using ``Input.is_action_pressed()``, "
"which returns ``true`` if it's pressed or ``false`` if it isn't."
msgstr ""
"Ви можете визначити, чи натиснута кнопка за допомогою функції ``Input."
"is_action_pressed()``, яка повертає ``true``, якщо клавіша натиснута або "
"``false``, якщо ні."

msgid ""
"We start by setting the ``velocity`` to ``(0, 0)`` - by default, the player "
"should not be moving. Then we check each input and add/subtract from the "
"``velocity`` to obtain a total direction. For example, if you hold ``right`` "
"and ``down`` at the same time, the resulting ``velocity`` vector will be "
"``(1, 1)``. In this case, since we're adding a horizontal and a vertical "
"movement, the player would move *faster* diagonally than if it just moved "
"horizontally."
msgstr ""
"Почнемо з того, що встановимо значення ``velocity`` на ``(0, 0)`` - за "
"замовчуванням гравець рухатися не повинен. Потім, ми перевіряємо кожне "
"введення і додаємо/віднімаємо значення з ``velocity``, щоб отримати "
"загальний напрямок. Наприклад, якщо ви одночасно утримуєте ``right`` і "
"``down``, отриманий вектор ``velocity`` буде ``(1, 1)``. В цьому випадку, "
"оскільки ми додаємо одночасно горизонтальний і вертикальний рух, гравець "
"буде рухатися *швидше*, ніж якби він переміщувався просто по горизонталі."

msgid ""
"We can prevent that if we *normalize* the velocity, which means we set its "
"*length* to ``1``, then multiply by the desired speed. This means no more "
"fast diagonal movement."
msgstr ""
"Ми зможемо уникнути цього, якщо *нормалізуємо* швидкість, що означає, що ми "
"встановлюємо її *довжину* на ``1`` і будемо множити на бажану швидкість. Це "
"означає відсутність швидшого руху по діагоналі."

msgid ""
"If you've never used vector math before, or need a refresher, you can see an "
"explanation of vector usage in Godot at :ref:`doc_vector_math`. It's good to "
"know but won't be necessary for the rest of this tutorial."
msgstr ""
"Якщо ви ніколи раніше не використовували векторну математику, або вам "
"потрібно освіжити знання, ви можете побачити пояснення по використанню "
"векторів у Godot у :ref:`doc_vector_math`. Це добре знати, але це не буде "
"потрібно для решти цього уроку."

msgid ""
"We also check whether the player is moving so we can call ``play()`` or "
"``stop()`` on the AnimatedSprite."
msgstr ""
"Ми також перевіряємо, чи гравець рухається, щоб ми могли викликати "
"``play()`` або ``stop ()`` на AnimatedSprite."

msgid ""
"``$`` is shorthand for ``get_node()``. So in the code above, "
"``$AnimatedSprite.play()`` is the same as ``get_node(\"AnimatedSprite\")."
"play()``."
msgstr ""
"``$`` це скорочення для ``get_node()``. Так що в наведеному вище коді "
"``$AnimatedSprite.play()`` це те саме, що і ``get_node(\"AnimatedSprite\")."
"play()``."

msgid ""
"In GDScript, ``$`` returns the node at the relative path from the current "
"node, or returns ``null`` if the node is not found. Since AnimatedSprite is "
"a child of the current node, we can use ``$AnimatedSprite``."
msgstr ""
"У GDScript ``$`` повертає вузол на відносному шляху від поточного вузла, або "
"повертає ``null`` якщо вузол не знайдено. Оскільки AnimatedSprite є нащадком "
"поточного вузла, ми можемо використовувати ``$AnimatedSprite``."

msgid ""
"Now that we have a movement direction, we can update the player's position. "
"We can also use ``clamp()`` to prevent it from leaving the screen. "
"*Clamping* a value means restricting it to a given range. Add the following "
"to the bottom of the ``_process`` function (make sure it's not indented "
"under the `else`):"
msgstr ""
"Тепер, коли у нас є напрямок руху, ми можемо оновити позицію гравця. Ми "
"також можемо використовувати ``clamp()``, щоб він не покинув екран. "
"*Clamping* означає обмеження руху діапазоном. Додайте наступне в кінець "
"функції ``_process`` (переконайтеся, що під `else` нема відступу):"

msgid ""
"The `delta` parameter in the `_process()` function refers to the *frame "
"length* - the amount of time that the previous frame took to complete. Using "
"this value ensures that your movement will remain consistent even if the "
"frame rate changes."
msgstr ""
"Параметр ``delta`` у функції ``_process ()`` означає *тривалість кадру* - "
"тобто часу, необхідного для завершення попереднього кадру. Використання "
"цього значення гарантує, що ваш рух залишатиметься послідовним, навіть якщо "
"частота кадрів змінюється."

msgid ""
"Click \"Play Scene\" (:kbd:`F6`, :kbd:`Cmd + R` on macOS) and confirm you "
"can move the player around the screen in all directions."
msgstr ""
"Натисніть \"Відтворити сцену\" (:kbd:`F6`, :kbd:`Cmd + R` на macOS) і "
"переконайтеся, що можете рухати гравця по екрані у всіх напрямках."

msgid "If you get an error in the \"Debugger\" panel that says"
msgstr "Якщо ви отримуєте помилку на панелі \"Зневаджувач\", яка говорить"

msgid ""
"``Attempt to call function 'play' in base 'null instance' on a null "
"instance``"
msgstr ""
"``Спроба виклику функції 'play' в основі 'null instance' на нульовому "
"зразкові``"

msgid ""
"this likely means you spelled the name of the AnimatedSprite node wrong. "
"Node names are case-sensitive and ``$NodeName`` must match the name you see "
"in the scene tree."
msgstr ""
"це, ймовірно, означає, що ви неправильно написали ім'я вузла AnimatedSprite. "
"Імена вузлів чутливі до регістру і ``$НазваВузла`` повинно відповідати "
"назві, яку ви бачите в дереві сцен."

msgid "Choosing animations"
msgstr "Вибір анімації"

msgid ""
"Now that the player can move, we need to change which animation the "
"AnimatedSprite is playing based on its direction. We have the \"walk\" "
"animation, which shows the player walking to the right. This animation "
"should be flipped horizontally using the ``flip_h`` property for left "
"movement. We also have the \"up\" animation, which should be flipped "
"vertically with ``flip_v`` for downward movement. Let's place this code at "
"the end of the ``_process()`` function:"
msgstr ""
"Тепер, коли гравець може рухатися, нам потрібно змінювати анімацію "
"відтворення AnimatedSprite, в залежності від напрямку руху. У нас є анімація "
"\"walk\", де гравець йде вправо. Цю анімацію слід перевернути горизонтально, "
"використовуючи властивість ``flip_h``, для руху ліворуч. У нас також є "
"анімація \"up\", яку слід перевернути вертикально за допомогою ``flip_v`` "
"для руху вниз. Розмістимо цей код в кінці функції ``_process()``:"

msgid ""
"The boolean assignments in the code above are a common shorthand for "
"programmers. Since we're doing a comparison test (boolean) and also "
"*assigning* a boolean value, we can do both at the same time. Consider this "
"code versus the one-line boolean assignment above:"
msgstr ""
"Булеві призначення в наведеному вище коді - це звичайна стенограма для "
"програмістів. Оскільки ми робимо тест порівняння (булевий), а також "
"*присвоюємо* булеве значення, ми можемо робити і те й інше. Розглянемо цей "
"код порівняно з однорядним булевим призначенням вище:"

msgid ""
"Play the scene again and check that the animations are correct in each of "
"the directions."
msgstr ""
"Відтворіть сцену ще раз і перевірте правильність анімації в кожному з "
"напрямків."

msgid ""
"A common mistake here is to type the names of the animations wrong. The "
"animation names in the SpriteFrames panel must match what you type in the "
"code. If you named the animation ``\"Walk\"``, you must also use a capital "
"\"W\" in the code."
msgstr ""
"Загальною помилкою є неправильне іменування анімацій. Імена анімацій в "
"панелі SpriteFrames повинні збігатися з іменами анімацій в вашому коді. Якщо "
"ви назвали анімацію ``\"Walk\"``, ви повинні також використовувати велику "
"літеру \"W\" в коді."

msgid ""
"When you're sure the movement is working correctly, add this line to "
"``_ready()``, so the player will be hidden when the game starts:"
msgstr ""
"Коли ви впевнені, що рух працює правильно, додайте цей рядок до ``_ready "
"()``, щоб гравець був прихований, коли гра починається:"

msgid "Preparing for collisions"
msgstr "Підготовка до зіткнень"

msgid ""
"We want ``Player`` to detect when it's hit by an enemy, but we haven't made "
"any enemies yet! That's OK, because we're going to use Godot's *signal* "
"functionality to make it work."
msgstr ""
"Ми хочемо виявляти зіткнення гравця з ворогами, але ворогів ми ще не "
"створили! Це добре, тому що ми будемо використовувати *сигнали* Godot."

msgid "Add the following at the top of the script, after ``extends Area2D``:"
msgstr "Додайте наступний код в початок скрипта, після ``extends Area2d``:"

msgid ""
"This defines a custom signal called \"hit\" that we will have our player "
"emit (send out) when it collides with an enemy. We will use ``Area2D`` to "
"detect the collision. Select the ``Player`` node and click the \"Node\" tab "
"next to the Inspector tab to see the list of signals the player can emit:"
msgstr ""
"Цей рядок визначає власний сигнал під назвою \"hit\" (\"удар\"), який буде "
"випромінюватися з нашого гравця, коли він буде стикатися з ворогом. Ми "
"будемо використовувати ``Area2D`` для виявлення зіткнення. Виберіть вузол "
"``Player`` і натисніть на вкладку \"Вузол\" поруч із вкладкою Інспектор, щоб "
"побачити список сигналів, які гравець може випромінювати:"

msgid ""
"Notice our custom \"hit\" signal is there as well! Since our enemies are "
"going to be ``RigidBody2D`` nodes, we want the ``body_entered(body: Node)`` "
"signal. This signal will be emitted when a body contacts the player. Click "
"\"Connect..\" and the \"Connect a Signal\" window appears. We don't need to "
"change any of these settings so click \"Connect\" again. Godot will "
"automatically create a function in your player's script."
msgstr ""
"Зверніть увагу, що наш користувацький сигнал \"hit\" там також присутнiй! "
"Оскільки наші противники будуть вузлами ``RigidBody2D``, нам потрібен сигнал "
"``body_entered(body: Node)``. Цей сигнал буде викликатися, коли тіло (body) "
"контактує з гравцем. Натисніть \"Підключити..\" i з'явиться вікно "
"\"Підключити сигнал\". Нам не потрібно змінювати будь-які з цих налаштувань, "
"тож знову натиснiть \"Підключити\". Godot автоматично створить функцію у "
"скрипті вашого гравця."

msgid ""
"Note the green icon indicating that a signal is connected to this function. "
"Add this code to the function:"
msgstr ""
"Зверніть увагу на зелений значок, який вказує на те, що сигнал підключений "
"до цієї функції. Додайте цей код до функції:"

msgid ""
"Each time an enemy hits the player, the signal is going to be emitted. We "
"need to disable the player's collision so that we don't trigger the ``hit`` "
"signal more than once."
msgstr ""
"Кожен раз, коли ворог б’є гравця, буде випромінюватися сигнал. Нам потрібно "
"відключити зіткнення гравця, щоб ми не запускали сигнал ``hit`` більше "
"одного разу."

msgid ""
"Disabling the area's collision shape can cause an error if it happens in the "
"middle of the engine's collision processing. Using ``set_deferred()`` tells "
"Godot to wait to disable the shape until it's safe to do so."
msgstr ""
"Відключення області зіткнення може призвести до помилки, якщо це станеться "
"під час опрацювання редактором зіткнень. Використання ``set_deferred()`` "
"говорить Godot почекати, і вимкнути область, коли це буде безпечно."

msgid ""
"The last piece is to add a function we can call to reset the player when "
"starting a new game."
msgstr ""
"Остання деталь, яку треба додати це функція, яку ми можемо викликати для "
"появи гравця при запуску нової гри."

msgid "With the player working, we'll work on the enemy in the next lesson."
msgstr ""
"З гравцем покінчено, в наступному уроці ми будемо працювати над ворогом."

msgid "Translation status"
msgstr "Стан перекладу"
