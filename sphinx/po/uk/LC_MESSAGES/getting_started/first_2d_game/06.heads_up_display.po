# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Heads up display"
msgstr "Поверхневий екран"

msgid ""
"The final piece our game needs is a User Interface (UI) to display things "
"like score, a \"game over\" message, and a restart button."
msgstr ""
"Остання частина, яка потрібна нашій грі, - це інтерфейс користувача (UI) для "
"відображення таких речей, як рахунок, повідомлення \"гра завершена\" та "
"кнопка перезавантаження."

msgid ""
"Create a new scene, and add a :ref:`CanvasLayer <class_CanvasLayer>` node "
"named ``HUD``. \"HUD\" stands for \"heads-up display\", an informational "
"display that appears as an overlay on top of the game view."
msgstr ""
"Створіть нову сцену та додайте вузол :ref:`CanvasLayer <class_CanvasLayer>` "
"з іменем ``HUD``. \"HUD\" означає \"head-up display\" , інформаційний екран, "
"який відображається поверх ігрового вікна."

msgid ""
"The :ref:`CanvasLayer <class_CanvasLayer>` node lets us draw our UI elements "
"on a layer above the rest of the game, so that the information it displays "
"isn't covered up by any game elements like the player or mobs."
msgstr ""
"Вузол :ref:`CanvasLayer <class_CanvasLayer>` дозволяє нам малювати наші "
"елементи призначені для інтерфейсу користувача поверх решти частини гри, так "
"що відображена в ньому інформація не прикривається ніякими ігровими "
"елементами, такими як гравець, чи моби."

msgid "The HUD needs to display the following information:"
msgstr "HUD повинен відобразити наступну інформацію:"

msgid "Score, changed by ``ScoreTimer``."
msgstr "Рахунок, змінюваний ``ScoreTimer``."

msgid "A message, such as \"Game Over\" or \"Get Ready!\""
msgstr ""
"Повідомлення, наприклад \"Game Over\" (\"Гра закінчена\"), або \"Get Ready!"
"\" (\"Готуйся!\")"

msgid "A \"Start\" button to begin the game."
msgstr "Кнопка \"Start\"(\"Старт\"), щоб розпочати гру."

msgid ""
"The basic node for UI elements is :ref:`Control <class_Control>`. To create "
"our UI, we'll use two types of :ref:`Control <class_Control>` nodes: :ref:"
"`Label <class_Label>` and :ref:`Button <class_Button>`."
msgstr ""
"Основний вузол для елементів інтерфейсу - :ref:`Control <class_Control>`. "
"Для створення нашого інтерфейсу ми будемо використовувати два типи цього "
"вузла : :ref:`Label <class_Label>` та :ref:`Button <class_Button>`."

msgid "Create the following as children of the ``HUD`` node:"
msgstr "Додайте вузлу ``HUD`` таких нащадків:"

msgid ":ref:`Label <class_Label>` named ``ScoreLabel``."
msgstr ":ref:`Label <class_Label>` названа ``ScoreLabel`` (Мітка рахунку)."

msgid ":ref:`Label <class_Label>` named ``Message``."
msgstr ":ref:`Label <class_Label>` названа ``Message``( повідомлення)."

msgid ":ref:`Button <class_Button>` named ``StartButton``."
msgstr ":ref:`Button <class_Button>` названа ``StartButton`` (кнопка старту)."

msgid ":ref:`Timer <class_Timer>` named ``MessageTimer``."
msgstr ""
":ref:`Timer <class_Timer>` названий ``MessageTimer`` (таймер повідомлення)."

msgid ""
"Click on the ``ScoreLabel`` and type a number into the ``Text`` field in the "
"Inspector. The default font for ``Control`` nodes is small and doesn't scale "
"well. There is a font file included in the game assets called \"Xolonium-"
"Regular.ttf\". To use this font, do the following:"
msgstr ""
"Клацніть на ``ScoreLabel`` і введіть число в поле ``Text`` в Інспекторі. "
"Шрифт за замовчуванням для вузлів ``Control`` невеликий і не дуже "
"масштабується. У ігрових активах є файл шрифту, який називається \"Xolonium-"
"Regular.ttf\" (даний шрифт підтримує кирилицю). Щоб використовувати цей "
"шрифт, виконайте наступне:"

msgid ""
"Under **Theme overrides > Fonts** click on the empty box and select \"New "
"DynamicFont\""
msgstr ""
"У розділі **Theme overrides > Fonts** *(Визначення теми > Шрифти)* в "
"порожній графі виберіть \"New DynamicFont\" (\"Новий динамічний шрифт\")"

msgid ""
"Click on the \"DynamicFont\" you added, and under **Font > FontData**, "
"choose \"Load\" and select the \"Xolonium-Regular.ttf\" file."
msgstr ""
"Клацніть на доданому \"DynamicFont\", а під **Font > FontData** *(Шрифт > "
"Дані шрифту)* виберіть \"Завантажити\" та виберіть файл \"Xolonium-Regular."
"ttf\"."

msgid "Set the \"Size\" property under ``Settings``, ``64`` works well."
msgstr ""
"Встановіть властивість ``Size`` в \"Settings\" на ``64`` для кращого вигляду."

msgid ""
"Once you've done this on the ``ScoreLabel``, you can click the down arrow "
"next to the Font property and choose \"Copy\", then \"Paste\" it in the same "
"place on the other two Control nodes."
msgstr ""
"Зробивши це зі ``ScoreLabel`` ви можете натиснути стрілку вниз поряд з "
"властивістю DynamicFont і вибрати \"Копіювати\", а потім \"Вставити\" його в "
"тому ж місці на других вузлах Control."

msgid ""
"**Anchors and Margins:** ``Control`` nodes have a position and size, but "
"they also have anchors and margins. Anchors define the origin - the "
"reference point for the edges of the node. Margins update automatically when "
"you move or resize a control node. They represent the distance from the "
"control node's edges to its anchor."
msgstr ""
"**Прив'язки та поля:** вузли ``Control`` мають положення та розмір, але вони "
"також мають прив'язки (якорі) та поля. Прив'язки визначають початок "
"координат - опорну точку для країв вузла. Поля оновлюються автоматично під "
"час переміщення, чи зміни розміру, контрольного вузла. Вони представляють "
"відстань від країв контрольного вузла до його прив'язки. Детальнішу "
"інформацію дивіться :ref:`doc_design_interfaces_with_the_control_nodes`."

msgid ""
"Arrange the nodes as shown below. Click the \"Layout\" button to set a "
"Control node's layout:"
msgstr ""
"Впорядкуйте вузли, як показано нижче. Натисніть кнопку \"Макет\", щоб "
"встановити макет вузла керування:"

msgid ""
"You can drag the nodes to place them manually, or for more precise "
"placement, use the following settings:"
msgstr ""
"Ви можете перетягнути вузли, щоб розмістити їх вручну, або, для точнішого "
"розміщення, скористайтеся такими налаштуваннями:"

msgid "ScoreLabel"
msgstr "ScoreLabel (Мітка рахунку)"

msgid "*Layout* : \"Top Wide\""
msgstr "*Макет* : \"Згори за шириною\""

msgid "*Text* : ``0``"
msgstr "*Text* : ``0``"

msgid "*Align* : \"Center\""
msgstr "*Align* (вирівнювання): \"Center\""

msgid "Message"
msgstr "Повідомлення"

msgid "*Layout* : \"HCenter Wide\""
msgstr "*Макет* : \"Гор. за центром за шириною\""

msgid "*Text* : ``Dodge the Creeps!``"
msgstr "*Text* : ``Dodge the Creeps!`` (``Ухились від крипів!``)"

msgid "*Autowrap* : \"On\""
msgstr "*Autowrap* (Авто-згортання) : \"Увімкнено\""

msgid "StartButton"
msgstr "StartButton (Кнопка Старту)"

msgid "*Text* : ``Start``"
msgstr "*Text* : ``Старт``"

msgid "*Layout* : \"Center Bottom\""
msgstr "*Макет* : \"За центром внизу \""

msgid "*Margin* :"
msgstr "*Margin* (Поле) :"

msgid "Top: ``-200``"
msgstr "Top *(зверху)*: ``-200``"

msgid "Bottom: ``-100``"
msgstr "Bottom *(Знизу)*: ``-100``"

msgid ""
"On the ``MessageTimer``, set the ``Wait Time`` to ``2`` and set the ``One "
"Shot`` property to \"On\"."
msgstr ""
"На ``MessageTimer``, встановіть ``Wait Time`` *(Час затримки)* на ``2`` і "
"встановіть властивість ``One Shot`` на \"Увімкнено\"."

msgid "Now add this script to ``HUD``:"
msgstr "Тепер додайте скрипт до ``HUD``:"

msgid ""
"The ``start_game`` signal tells the ``Main`` node that the button has been "
"pressed."
msgstr "Сигнал ``start_game`` вказує вузлу ``Main``, що кнопка була натиснута."

msgid ""
"This function is called when we want to display a message temporarily, such "
"as \"Get Ready\"."
msgstr ""
"Ця функція буде викликатися тоді, коли ми хочемо показати повідомлення "
"тимчасово, наприклад, \"Приготуйся\"."

msgid ""
"This function is called when the player loses. It will show \"Game Over\" "
"for 2 seconds, then return to the title screen and, after a brief pause, "
"show the \"Start\" button."
msgstr ""
"Ця функція викликається, коли гравець програє. Вона показує напис \"Game "
"Over\" протягом 2 секунд, потім повертає екран заголовка і, після короткої "
"паузи, покаже кнопку \"Старт\"."

msgid ""
"When you need to pause for a brief time, an alternative to using a Timer "
"node is to use the SceneTree's ``create_timer()`` function. This can be very "
"useful to add delays such as in the above code, where we want to wait some "
"time before showing the \"Start\" button."
msgstr ""
"Коли вам потрібно зробити паузу на короткий час, альтернативою використанню "
"вузла Timer є використання функції SceneTree (Дерева Сцени) "
"``create_timer()``. Це може бути дуже корисно для такої затримки, як, "
"наприклад, у наведеному вище коді, де ми хочемо зачекати трохи часу, перш "
"ніж показувати кнопку \"Старт\"."

msgid "This function is called by ``Main`` whenever the score changes."
msgstr "Ця функція викликається ``Main`` щоразу, коли рахунок змінюється."

msgid ""
"Connect the ``timeout()`` signal of ``MessageTimer`` and the ``pressed()`` "
"signal of ``StartButton`` and add the following code to the new functions:"
msgstr ""
"Підключіть сигнал ``timeout()`` від ``MessageTimer`` і сигнал ``pressed()`` "
"від ``StartButton`` та додайте наступний код до нових функцій:"

msgid "Connecting HUD to Main"
msgstr "Підключення HUD до Main"

msgid ""
"Now that we're done creating the ``HUD`` scene, go back to ``Main``. "
"Instance the ``HUD`` scene in ``Main`` like you did the ``Player`` scene. "
"The scene tree should look like this, so make sure you didn't miss anything:"
msgstr ""
"Тепер, коли ми закінчили створення сцени ``HUD``, збережіть її та "
"поверніться до ``Main``. Вставте ``HUD`` сцену в ``Main``, як ви вставили "
"сцену ``Player``. Повне дерево має виглядати так, тож переконайтеся, що ви "
"нічого не пропустили:"

msgid ""
"Now we need to connect the ``HUD`` functionality to our ``Main`` script. "
"This requires a few additions to the ``Main`` scene:"
msgstr ""
"Тепер нам потрібно підключити функції ``HUD`` до нашого скрипту ``Main``. "
"Для цього потрібно кілька доповнень до сцени ``Main``:"

msgid ""
"In the Node tab, connect the HUD's ``start_game`` signal to the "
"``new_game()`` function of the Main node by typing \"new_game\" in the "
"\"Receiver Method\" in the \"Connect a Signal\" window. Verify that the "
"green connection icon now appears next to ``func new_game()`` in the script."
msgstr ""
"На вкладці Вузол приєднайте сигнал HUD ``start_game`` до функції "
"``new_game()`` вузла Main ввівши \"new_game\" в \"Receiver Method\" у вікні "
"\"Під'єднання сигналу\". Переконайтеся, що в скрипті поряд з ``func "
"new_game()`` появилася зелена іконка підключення."

msgid ""
"In ``new_game()``, update the score display and show the \"Get Ready\" "
"message:"
msgstr ""
"У ``new_game()`` поновіть відображення рахунку і покажіть повідомлення \"Get "
"Ready\" (\"Приготуйся\"):"

msgid "In ``game_over()`` we need to call the corresponding ``HUD`` function:"
msgstr "У ``game_over()`` нам потрібно викликати відповідну функцію ``HUD``:"

msgid ""
"Finally, add this to ``_on_ScoreTimer_timeout()`` to keep the display in "
"sync with the changing score:"
msgstr ""
"Нарешті, додайте це до ``_on_ScoreTimer_timeout()`` для синхронізації "
"відображення рахунку зі зміною рахунку:"

msgid ""
"Now you're ready to play! Click the \"Play the Project\" button. You will be "
"asked to select a main scene, so choose ``Main.tscn``."
msgstr ""
"Тепер ви готові грати! Натисніть кнопку \"Відтворити проєкт\". Вам буде "
"запропоновано вибрати головну сцену, тому виберіть ``Main.tscn``."

msgid "Removing old creeps"
msgstr "Видалення старих крипів"

msgid ""
"If you play until \"Game Over\" and then start a new game right away, the "
"creeps from the previous game may still be on the screen. It would be better "
"if they all disappeared at the start of a new game. We just need a way to "
"tell *all* the mobs to remove themselves. We can do this with the \"group\" "
"feature."
msgstr ""
"Якщо ви дограєте до кінця гри, а потім починаєте нову гру, крипи з "
"попередньої гри все ще залишаються на екрані. Було б краще, якби вони всі "
"зникли на початку нової гри. Нам просто потрібно сказати *всім* мобам, що "
"вони мають знищитися. Ми можемо зробити це за допомогою функції "
"\"group\" (*група*)."

msgid ""
"In the ``Mob`` scene, select the root node and click the \"Node\" tab next "
"to the Inspector (the same place where you find the node's signals). Next to "
"\"Signals\", click \"Groups\" and you can type a new group name and click "
"\"Add\"."
msgstr ""
"В сцені ``Mob`` виберіть кореневий вузол і клацніть вкладку \"Вузол\" поряд "
"з Інспектором (там де ви знаходите сигнали вузла). Біля \"Сигнали\" "
"натисніть \"Групи\", і ви можете ввести нову назву групи та натиснути "
"\"Додати\"."

msgid ""
"Now all mobs will be in the \"mobs\" group. We can then add the following "
"line to the ``new_game()`` function in ``Main``:"
msgstr ""
"Тепер всі моби будуть в групі \"mobs\". Ми можемо додати наступні рядки до "
"функції ``game_over()`` в ``Main``:"

msgid ""
"The ``call_group()`` function calls the named function on every node in a "
"group - in this case we are telling every mob to delete itself."
msgstr ""
"Функція ``call_group()`` викликає кожну іменовану функцію на кожному вузлу в "
"групі - в цьому випадку ми кажемо кожному мобу видаляти себе."

msgid ""
"The game's mostly done at this point. In the next and last part, we'll "
"polish it a bit by adding a background, looping music, and some keyboard "
"shortcuts."
msgstr ""
"На цьому етапі гра майже завершена. У наступній і останній частині ми трохи "
"відшліфуємо її, додавши фон, музику, що зациклюється, і кілька комбінацій "
"клавіш."

msgid "Translation status"
msgstr "Стан перекладу"
