# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Designing the mob scene"
msgstr "Проектування сцени монстра"

msgid ""
"In this part, you're going to code the monsters, which we'll call mobs. In "
"the next lesson, we'll spawn them randomly around the playable area."
msgstr ""
"У цій частині ви збираєтеся кодувати монстрів, яких будемо називати мобами. "
"На наступному уроці ми будемо розміщувати їх випадковим чином навколо "
"ігрової області."

msgid ""
"Let's design the monsters themselves in a new scene. The node structure is "
"going to be similar to the *Player* scene."
msgstr ""
"Давайте спроектуємо самих монстрів в новій сцені. Структура вузлів буде "
"схожа на сцену гравця *Player*."

msgid ""
"Create a scene with, once again, a *KinematicBody* node as its root. Name it "
"*Mob*. Add a *Spatial* node as a child of it, name it *Pivot*. And drag and "
"drop the file ``mob.glb`` from the *FileSystem* dock onto the *Pivot* to add "
"the monster's 3D model to the scene. You can rename the newly created *mob* "
"node into *Character*."
msgstr ""
"Знову створіть сцену з одним вузлом *KinematicBody* в якості кореня. Назвіть "
"його *Mob*. Додайте вузол *Spatial* в якості нащадка і назвіть його *Pivot*. "
"Виділіть і перетягніть файл ``mob.glb`` з панелі *Файлова система* на "
"*Pivot*, щоб додати 3D модель монстра до сцени. Ви можете перейменувати "
"щойно створений вузол *mob* на *Character*."

msgid "|image0|"
msgstr "|image0|"

msgid "image0"
msgstr "image0"

msgid ""
"We need a collision shape for our body to work. Right-click on the *Mob* "
"node, the scene's root, and click *Add Child Node*."
msgstr ""
"Нам потрібна форма зіткнення, для роботи тіла. Клацніть правою кнопкою миші "
"на вузлі *Mob*, корені сцени, і натисніть *Додати дочірній вузол*."

msgid "|image1|"
msgstr "|image1|"

msgid "image1"
msgstr "image1"

msgid "Add a *CollisionShape*."
msgstr "Додайте *CollisionShape*."

msgid "|image2|"
msgstr "|image2|"

msgid "image2"
msgstr "image2"

msgid "In the *Inspector*, assign a *BoxShape* to the *Shape* property."
msgstr "У *Інспекторі* призначте властивості *Shape* стан *BoxShape*."

msgid "|image3|"
msgstr "|image3|"

msgid "image3"
msgstr "image3"

msgid ""
"We should change its size to fit the 3D model better. You can do so "
"interactively by clicking and dragging on the orange dots."
msgstr ""
"Ми повинні змінити його розмір, щоб краще відповідати розміру 3D-моделі. Ви "
"можете зробити це інтерактивно, натиснувши та перетягнувши помаранчеві точки."

msgid ""
"The box should touch the floor and be a little thinner than the model. "
"Physics engines work in such a way that if the player's sphere touches even "
"the box's corner, a collision will occur. If the box is a little too big "
"compared to the 3D model, you may die at a distance from the monster, and "
"the game will feel unfair to the players."
msgstr ""
"Коробка повинна торкатися підлоги і бути трохи тонше моделі. Фізичні рушії "
"працюють таким чином, що якщо сфера гравця торкнеться навіть кута коробки, "
"відбудеться зіткнення. Якщо коробка трохи завелика в порівнянні з 3D-"
"моделлю, ви можете померти на відстані від монстра, і гра буде "
"несправедливою по відношенню до гравців."

msgid "|image4|"
msgstr "|image4|"

msgid "image4"
msgstr "image4"

msgid ""
"Notice that my box is taller than the monster. It is okay in this game "
"because we're looking at the scene from above and using a fixed perspective. "
"Collision shapes don't have to match the model exactly. It's the way the "
"game feels when you test it that should dictate their form and size."
msgstr ""
"Зверніть увагу, що моя коробка вище, ніж монстр. Це нормально в цій грі, "
"тому що ми дивимося на сцену зверху і використовуємо фіксовану перспективу. "
"Форми зіткнення не повинні точно відповідати моделі. Це та форма та розмір, "
"які гра відчуває, коли ви тестуєте її."

msgid "Removing monsters off-screen"
msgstr "Видалення монстрів поза екраном"

msgid ""
"We're going to spawn monsters at regular time intervals in the game level. "
"If we're not careful, their count could increase to infinity, and we don't "
"want that. Each mob instance has both a memory and a processing cost, and we "
"don't want to pay for it when the mob's outside the screen."
msgstr ""
"Ми збираємося створювати монстрів через регулярні проміжки часу на ігровому "
"рівні. Якщо ми не будемо обережні, їх кількість може збільшитися до "
"нескінченності, а ми цього не хочемо. Кожен екземпляр моба займає як "
"пам'ять, так і процес обробки, але нам не потрібно це, для монстрів які "
"знаходиться за межами екрана."

msgid ""
"Once a monster leaves the screen, we don't need it anymore, so we can delete "
"it. Godot has a node that detects when objects leave the screen, "
"*VisibilityNotifier*, and we're going to use it to destroy our mobs."
msgstr ""
"Як тільки монстр покидає екран, він нам більше не потрібен, тому ми можемо "
"видалити його. Godot має вузол, який виявляє, коли об'єкти залишають екран, "
"*VisibilityNotifier*, і ми збираємося використовувати його, щоб знищити "
"наших монстрів."

msgid ""
"When you keep instancing an object in games, there's a technique you can use "
"to avoid the cost of creating and destroying instances all the time called "
"pooling. It consists of pre-creating an array of objects and reusing them "
"over and over."
msgstr ""
"Якщо ви продовжите вставляти екземпляри об'єкта в ігри, то є техніка, яку ви "
"можете використовувати, щоб уникнути витрат на створення та знищення "
"вставлених екземплярів весь час, яка називається об'єднанням. Вона полягає в "
"попередньому створенні масиву об'єктів і повторного використання їх знову і "
"знову."

msgid ""
"When working with GDScript, you don't need to worry about this. The main "
"reason to use pools is to avoid freezes with garbage-collected languages "
"like C# or Lua. GDScript uses a different technique to manage memory, "
"reference counting, which doesn't have that caveat. You can learn more about "
"that here :ref:`doc_gdscript_basics_memory_management`."
msgstr ""
"При роботі з GDScript вам не потрібно турбуватися про це. Основна причина "
"використання об'єднань полягає в тому, щоб уникнути замерзання в мовах, що "
"збирають сміття, такими як C#, або Lua. GDScript використовує інший метод "
"для управління пам'яттю, підрахунком посилань, тому не має такого "
"застереження. Ви можете дізнатися більше про це тут :ref:"
"`doc_gdscript_basics_memory_management`."

msgid ""
"Select the *Mob* node and add a *VisibilityNotifier* as a child of it. "
"Another box, pink this time, appears. When this box completely leaves the "
"screen, the node will emit a signal."
msgstr ""
"Виберіть вузол *Mob* і додайте *VisibilityNotifier* в якості нащадка. "
"З'явиться ще одна коробка, на цей раз, рожева. Коли ця коробка повністю "
"покине екран, вузол буде випромінювати сигнал."

msgid "|image5|"
msgstr "|image5|"

msgid "image5"
msgstr "image5"

msgid "Resize it using the orange dots until it covers the entire 3D model."
msgstr ""
"Змініть коробку за допомогою помаранчевих точок, щоб вона охопила всю 3D-"
"модель."

msgid "|image6|"
msgstr "Зображення"

msgid "image6"
msgstr "image6"

msgid "Coding the mob's movement"
msgstr "Кодування руху монстра"

msgid ""
"Let's implement the monster's motion. We're going to do this in two steps. "
"First, we'll write a script on the *Mob* that defines a function to "
"initialize the monster. We'll then code the randomized spawn mechanism in "
"the *Main* scene and call the function from there."
msgstr ""
"Давайте реалізуємо рух монстра. Ми зробимо це в два етапи. По-перше, ми "
"напишемо скрипт для *Mob*, який визначає функцію ініціалізації монстра. "
"Потім ми закодуємо механізм випадкової появи на головній сцені *Main* і "
"викличемо функцію звідти."

msgid "Attach a script to the *Mob*."
msgstr "Доєднайте скрипт до вузла *Mob*."

msgid "|image7|"
msgstr "|image7|"

msgid "image7"
msgstr "image7"

msgid ""
"Here's the movement code to start with. We define two properties, "
"``min_speed`` and ``max_speed``, to define a random speed range. We then "
"define and initialize the ``velocity``."
msgstr ""
"Ось початковий код руху. Визначаємо дві властивості, ``min_speed`` і "
"``max_speed``, щоб визначити діапазон випадкової швидкості. Потім ми "
"визначаємо та ініціалізуємо ``velocity``."

msgid ""
"Similarly to the player, we move the mob every frame by calling "
"``KinematicBody``\\ 's ``move_and_slide()`` method. This time, we don't "
"update the ``velocity`` every frame: we want the monster to move at a "
"constant speed and leave the screen, even if it were to hit an obstacle."
msgstr ""
"Подібно до гравця, ми переміщуємо моб кожен кадр, викликаючи метод "
"``move_and_slide()`` з ``KinematicBody``. На цей раз ми не оновлюємо "
"``velocity`` кожен кадр: ми хочемо, щоб монстр рухався з постійною швидкістю "
"і залишав екран, навіть якщо зіткнувся з перешкодою."

msgid ""
"You may see a warning in GDScript that the return value from "
"``move_and_slide()`` is unused. This is expected. You can simply ignore the "
"warning or, if you want to hide it entirely, add the comment ``# warning-"
"ignore:return_value_discarded`` just above the ``move_and_slide(velocity)`` "
"line. To read more about the GDScript warning system, see :ref:"
"`doc_gdscript_warning_system`."
msgstr ""
"Ви можете побачити попередження в GDScript про те, що повернуте значення з "
"``move_and_slide()`` не використовується. Це очікувано. Ви можете просто "
"проігнорувати попередження або, якщо хочете повністю приховати його, додати "
"коментар ``# warning-ignore:return_value_discarded`` трохи вище рядка "
"``move_and_slide(velocity)``. Щоб дізнатися більше про систему попереджень "
"GDScript, див. :ref:`doc_gdscript_warning_system`."

msgid ""
"We need to define another function to calculate the start velocity. This "
"function will turn the monster towards the player and randomize both its "
"angle of motion and its velocity."
msgstr ""
"Нам потрібно визначити іншу функцію для розрахунку початкової швидкості. Ця "
"функція поверне монстра в напрямку гравця і задасть йому випадкові кут руху "
"та швидкість."

msgid ""
"The function will take a ``start_position``, the mob's spawn position, and "
"the ``player_position`` as its arguments."
msgstr ""
"Функція прийме позицію появи монстра ``start_position`` і позицію гравця "
"``player_position`` в якості аргументів."

msgid ""
"We position the mob at ``start_position`` and turn it towards the player "
"using the ``look_at_from_position()`` method, and randomize the angle by "
"rotating a random amount around the Y axis. Below, ``rand_range()`` outputs "
"a random value between ``-PI / 4`` radians and ``PI / 4`` radians."
msgstr ""
"Спочатку ми розміщуємо монстра на ``start_position`` і повертаємо його до "
"гравця за допомогою методу ``look_at_from_position()`` і задаємо випадковий "
"кут, обертаючи по осі Y. Нижче ``rand_range()`` виводить випадкове значення "
"між радіанами ``-PI / 4`` і радіанами ``PI / 4``."

msgid ""
"We then calculate a random speed using ``rand_range()`` once again and we "
"use it to calculate the velocity."
msgstr ""
"Потім вираховуємо випадкову швидкість, використовуючи ``rand_range()`` ще "
"раз."

msgid ""
"We start by creating a 3D vector pointing forward, multiply it by our "
"``random_speed``, and finally rotate it using the ``Vector3`` class's "
"``rotated()`` method."
msgstr ""
"Ми починаємо зі створення 3D-вектора, що вказує вперед, множимо його на наш "
"випадкову швидкість ``random_speed``, і, нарешті, обертаємо його за "
"допомогою методу ``rotated()`` класу ``Vector3``."

msgid "Leaving the screen"
msgstr "Залишання екрану"

msgid ""
"We still have to destroy the mobs when they leave the screen. To do so, "
"we'll connect our *VisibilityNotifier* node's ``screen_exited`` signal to "
"the *Mob*."
msgstr ""
"Ми все ще повинні знищувати монстрів, коли вони залишають екран. Для цього "
"ми підключимо сигнал ``screen_exited`` нашого вузла *VisibilityNotifier* до "
"*Mob*."

msgid ""
"Head back to the 3D viewport by clicking on the *3D* label at the top of the "
"editor. You can also press :kbd:`Ctrl + F2` (:kbd:`Alt + 2` on macOS)."
msgstr ""
"Поверніться до 3D вікна перегляду, натиснувши на мітку *3D* у верхній "
"частині редактора. Ви також можете натиснути :kbd:`Ctrl + F2` (:kbd:`Alt + "
"2`на macOS)."

msgid "|image8|"
msgstr "|image8|"

msgid "image8"
msgstr "image8"

msgid ""
"Select the *VisibilityNotifier* node and on the right side of the interface, "
"navigate to the *Node* dock. Double-click the *screen_exited()* signal."
msgstr ""
"Виберіть вузол *VisibilityNotifier* і в правій частині інтерфейсу перейдіть "
"до панелі *Вузол*. Двічі клацніть сигнал *screen_exited()*."

msgid "|image9|"
msgstr "|image9|"

msgid "image9"
msgstr "image9"

msgid "Connect the signal to the *Mob*."
msgstr "Підключіть сигнал до *Mob*."

msgid "|image10|"
msgstr "|image10|"

msgid "image10"
msgstr "image10"

msgid ""
"This will take you back to the script editor and add a new function for you, "
"``_on_VisibilityNotifier_screen_exited()``. From it, call the "
"``queue_free()`` method. This will destroy the mob instance when the "
"*VisibilityNotifier* \\'s box leaves the screen."
msgstr ""
"Це поверне вас до редактора скриптів і створить для вас нову функцію, "
"``_on_VisibilityNotifier_screen_exited()``. З неї викличте метод "
"``queue_free()``. Це знищить екземпляр монстра, коли коробка "
"*VisibilityNotifier* покине екран."

msgid ""
"Our monster is ready to enter the game! In the next part, you will spawn "
"monsters in the game level."
msgstr ""
"Наш монстр готовий появитися в грі! У наступній частині ви будете "
"породжувати монстрів на ігровому рівні."

msgid "Here is the complete ``Mob.gd`` script for reference."
msgstr "Ось повний скрипт ``Mob.gd`` для довідки."

msgid "Translation status"
msgstr "Стан перекладу"
