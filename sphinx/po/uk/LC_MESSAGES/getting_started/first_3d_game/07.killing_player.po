# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Killing the player"
msgstr "Убивство гравця"

msgid ""
"We can kill enemies by jumping on them, but the player still can't die. "
"Let's fix this."
msgstr ""
"Ми можемо убивати ворогів просто стрибнувши на них, проте гравець "
"залишається безсмертним. Давайте пофіксимо це."

#, fuzzy
msgid ""
"We want to detect being hit by an enemy differently from squashing them. We "
"want the player to die when they're moving on the floor, but not if they're "
"in the air. We could use vector math to distinguish the two kinds of "
"collisions. Instead, though, we will use an :ref:`Area3D <class_Area3D>` "
"node, which works well for hitboxes."
msgstr ""
"Успішний удар має надходити від ворога, який не підлягає розчавленню. Ми "
"хочемо, щоб гравець помирав при зіткненні з монстрами на підлозі, але не "
"коли знаходиться в повітрі. Ми могли б використовувати векторну математику, "
"щоб розрізняти два типи зіткнень. Замість цього, однак, ми будемо "
"використовувати вузол Area, який добре підходить для хітбоксів *(hit - удар, "
"boxes - коробки)*."

msgid "Hitbox with the Area node"
msgstr "Хітбокс з вузла Area"

#, fuzzy
msgid ""
"Head back to the ``player.tscn`` scene and add a new child node :ref:`Area3D "
"<class_Area3D>`. Name it ``MobDetector`` Add a :ref:`CollisionShape3D "
"<class_CollisionShape3D>` node as a child of it."
msgstr ""
"Поверніться до сцени гравця *Player* та додайте новий вузол *Area*. Назвіть "
"його *MobDetector*. Додайте вузол *CollisionShape* в якості нащадка."

msgid "|image0|"
msgstr "|image0|"

msgid "image0"
msgstr "image0"

msgid "In the *Inspector*, assign a cylinder shape to it."
msgstr "В *Інспекторі* призначте йому форму циліндра."

msgid "|image1|"
msgstr "|image1|"

msgid "image1"
msgstr "image1"

msgid ""
"Here is a trick you can use to make the collisions only happen when the "
"player is on the ground or close to it. You can reduce the cylinder's height "
"and move it up to the top of the character. This way, when the player jumps, "
"the shape will be too high up for the enemies to collide with it."
msgstr ""
"Ось трюк, який ви можете використовувати, щоб відбирати тільки ті зіткнення, "
"що коли гравець знаходиться на землі, або близько до неї. Ви можете зменшити "
"висоту циліндра і перемістити його до верхньої частини персонажа. Таким "
"чином, коли гравець стрибає, форма буде занадто високо, щоб вороги "
"зіткнулися з нею."

msgid "|image2|"
msgstr "|image2|"

msgid "image2"
msgstr "image2"

msgid ""
"You also want the cylinder to be wider than the sphere. This way, the player "
"gets hit before colliding and being pushed on top of the monster's collision "
"box."
msgstr ""
"Окрім цього циліндр має бути ширше сфери. Таким чином, гравець буде "
"отримувати удар до того як сам нанесе його монстру."

msgid "The wider the cylinder, the more easily the player will get killed."
msgstr "Чим ширше циліндр, тим легше буде убивати гравця."

#, fuzzy
msgid ""
"Next, select the ``MobDetector`` node again, and in the *Inspector*, turn "
"**off** its *Monitorable* property. This makes it so other physics nodes "
"cannot detect the area. The complementary *Monitoring* property allows it to "
"detect collisions. Then, remove the *Collision -> Layer* and set the mask to "
"the \"enemies\" layer."
msgstr ""
"Далі знову виберіть вузол *MobDetector* і в *Інспекторі* вимкніть його "
"властивість *Monitorable*. Таким чином інші фізичні вузли не зможуть виявити "
"область. Додаткова властивість *Monitoring* дозволяє йому виявляти "
"зіткнення. Потім видаліть *Collision -> Layer* і встановіть маску на шар "
"\"enemies\"."

msgid "|image3|"
msgstr "|image3|"

msgid "image3"
msgstr "image3"

msgid ""
"When areas detect a collision, they emit signals. We're going to connect one "
"to the ``Player`` node. Select ``MobDetector`` and go to *Inspector*'s "
"*Node* tab, double-click the ``body_entered`` signal and connect it to the "
"``Player``"
msgstr ""
"Коли області виявляють зіткнення, вони випромінюють сигнали. Ми підключимо "
"один з них до вузла ``Гравець``. Виберіть ``MobDetector`` і перейдіть на "
"вкладку ``Вузол`` у *Inspector*, двічі клацніть по сигналу ``body_entered`` "
"і підключіть його до ``Player``"

msgid "|image4|"
msgstr "|image4|"

msgid "image4"
msgstr "image4"

#, fuzzy
msgid ""
"The *MobDetector* will emit ``body_entered`` when a :ref:`CharacterBody3D "
"<class_CharacterBody3D>` or a :ref:`RigidBody3D <class_RigidBody3D>` node "
"enters it. As it only masks the \"enemies\" physics layers, it will only "
"detect the ``Mob`` nodes."
msgstr ""
"*MobDetector* буде випромінювати ``body_entered``, коли в нього входить "
"вузол *KinematicBody*, або *RigidBody*. Оскільки він реагує лише на фізичні "
"шари \"enemies\", він буде виявляти лише вузли *Mob*."

msgid ""
"Code-wise, we're going to do two things: emit a signal we'll later use to "
"end the game and destroy the player. We can wrap these operations in a "
"``die()`` function that helps us put a descriptive label on the code."
msgstr ""
"З точки зору коду, ми збираємося зробити дві речі: випромінюваний сигнал ми "
"пізніше будемо використовувати для завершення гри і знищення гравця. Ми "
"можемо обернути ці операції в функцію ``die()``, яка допоможе нам поставити "
"описову мітку на коді."

msgid ""
"Try the game again by pressing :kbd:`F5`. If everything is set up correctly, "
"the character should die when an enemy runs into the collider. Note that "
"without a ``Player``, the following line"
msgstr ""
"Спробуйте запустити гру ще раз, натиснувши :kbd:`F5`. Якщо все налаштовано "
"правильно, персонаж має загинути, коли ворог вбіжить у колайдер. Зверніть "
"увагу, що без ``Player`` наступний рядок"

msgid "gives error because there is no $Player!"
msgstr ""

#, fuzzy
msgid ""
"Also note that the enemy colliding with the player and dying depends on the "
"size and position of the ``Player`` and the ``Mob``\\ 's collision shapes. "
"You may need to move them and resize them to achieve a tight game feel."
msgstr ""
"Однак запримітьте, що це повністю залежить від розміру та положення гравця "
"та форм зіткнення *Mob*. Можливо, вам доведеться перемістити їх і змінити "
"розмір, щоб досягти жорсткого ігрового відчуття."

msgid "Ending the game"
msgstr "Завершення гри"

#, fuzzy
msgid ""
"We can use the ``Player``\\ 's ``hit`` signal to end the game. All we need "
"to do is connect it to the ``Main`` node and stop the ``MobTimer`` in "
"reaction."
msgstr ""
"Ми можемо використовувати сигнал гравця *Player* ``hit``, для завершення "
"гри. Все, що нам потрібно зробити, це підключити його до головного вузла "
"*Main* і запрограмувати зупинку *MobTimer* при його надходженні."

#, fuzzy
msgid ""
"Open ``main.tscn``, select the ``Player`` node, and in the *Node* dock, "
"connect its ``hit`` signal to the ``Main`` node."
msgstr ""
"Відкрийте ``Main.tscn``, виберіть вузол *Player*, а на панелі *Вузол* "
"підключіть його сигнал ``hit`` до головного вузла *Main*."

msgid "|image5|"
msgstr "|image5|"

msgid "image5"
msgstr "image5"

#, fuzzy
msgid "Get the timer, and stop it, in the ``_on_player_hit()`` function."
msgstr "Функція ``_on_Player_hit()`` отримує сигнал і зупиняє таймер."

msgid ""
"If you try the game now, the monsters will stop spawning when you die, and "
"the remaining ones will leave the screen."
msgstr ""
"Якщо ви спробуєте гру зараз, монстри перестануть появлятися, коли ви "
"помрете, а інші залишать екран."

msgid ""
"You can pat yourself in the back: you prototyped a complete 3D game, even if "
"it's still a bit rough."
msgstr ""
"Можете погладити себе по голові: ви створили прототип повної 3D-гри, хай, "
"навіть, вона все ще трохи груба."

msgid ""
"From there, we'll add a score, the option to retry the game, and you'll see "
"how you can make the game feel much more alive with minimalistic animations."
msgstr ""
"Звідси ми додамо рахунок, можливість повторити гру, і ви побачите, як можна "
"трохи оживити гру за допомогою мінімалістичних анімацій."

msgid "Code checkpoint"
msgstr "Перевірка коду"

#, fuzzy
msgid ""
"Here are the complete scripts for the ``Main``, ``Mob``, and ``Player`` "
"nodes, for reference. You can use them to compare and check your code."
msgstr ""
"Ось повні скрипти для вузлів *Main*, *Mob* та *Player*, для довідки. Ви "
"можете використовувати їх для порівняння та перевірки вашого коду."

#, fuzzy
msgid "Starting with ``main.gd``."
msgstr "Починаючи з ``Main.gd``."

msgid "Next is ``Mob.gd``."
msgstr "Продовжуючи ``Mob.gd``."

msgid "Finally, the longest script, ``Player.gd``:"
msgstr "І завершуючи найдовшим скриптом , ``Player.gd``:"

msgid "See you in the next lesson to add the score and the retry option."
msgstr ""
"До зустрічі на наступному уроці, щоб додати рахунок та можливість повторити "
"спробу."

msgid "Translation status"
msgstr "Стан перекладу"
