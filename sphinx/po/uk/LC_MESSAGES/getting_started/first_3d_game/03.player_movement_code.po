# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Moving the player with code"
msgstr "Кодування переміщення гравця"

msgid ""
"It's time to code! We're going to use the input actions we created in the "
"last part to move the character."
msgstr ""
"Настав час коду! Ми будемо використовувати дії введення, які створили в "
"останній частині, для переміщення персонажа."

#, fuzzy
msgid ""
"Right-click the ``Player`` node and select *Attach Script* to add a new "
"script to it. In the popup, set the *Template* to *Empty* before pressing "
"the *Create* button."
msgstr ""
"Правою клавішею мишки клацніть на вузлі *Player* в виберіть *Долучити "
"скрипт*, щоб додати новий скрипт до нього. У спливаючому вікні встановіть "
"*Шаблон* *Empty (порожній)* і натисніть *Створити*."

msgid "|image0|"
msgstr "|image0|"

msgid "image0"
msgstr "image0"

msgid ""
"Let's start with the class's properties. We're going to define a movement "
"speed, a fall acceleration representing gravity, and a velocity we'll use to "
"move the character."
msgstr ""
"Почнемо з властивостей класу. Ми збираємося визначити швидкість руху, "
"прискорення падіння, що являє собою гравітацію, і швидкість, яку ми будемо "
"використовувати для переміщення персонажа."

#, fuzzy
msgid ""
"These are common properties for a moving body. The ``target_velocity`` is a :"
"ref:`3D vector <class_Vector3>` combining a speed with a direction. Here, we "
"define it as a property because we want to update and reuse its value across "
"frames."
msgstr ""
"Це загальні властивості для рухомого тіла. ``velocity`` це 3D-вектор, що "
"поєднує швидкість з напрямком. Тут ми визначаємо його як властивість, "
"оскільки хочемо оновити та повторно використовувати його значення в різних "
"кадрах."

msgid ""
"The values are quite different from 2D code because distances are in meters. "
"While in 2D, a thousand units (pixels) may only correspond to half of your "
"screen's width, in 3D, it's a kilometer."
msgstr ""
"Значення сильно відрізняються від 2D-коду, тому що відстані вимірюються в "
"метрах. У той час як в 2D, тисяча одиниць (пікселів) може відповідати тільки "
"половині ширини вашого екрану, в 3D, це кілометр."

#, fuzzy
msgid ""
"Let's code the movement. We start by calculating the input direction vector "
"using the global ``Input`` object, in ``_physics_process()``."
msgstr ""
"Тепер давайте кодувати рух. Почнемо з розрахунку введеного вектора напрямку "
"за допомогою глобального об'єкта ``Input``, в ``_physics_process()``."

msgid ""
"Here, we're going to make all calculations using the ``_physics_process()`` "
"virtual function. Like ``_process()``, it allows you to update the node "
"every frame, but it's designed specifically for physics-related code like "
"moving a kinematic or rigid body."
msgstr ""
"Тут ми збираємося зробити всі розрахунки за допомогою віртуальної функції "
"``_physics_process()``. Функція ``_process()`` дозволяє оновлювати вузол "
"кожен кадр, ``_physics_process()`` розроблена спеціально для коду, "
"пов'язаного з фізикою, на кшталт переміщення кінематичного або жорсткого "
"тіла."

msgid ""
"To learn more about the difference between ``_process()`` and "
"``_physics_process()``, see :ref:`doc_idle_and_physics_processing`."
msgstr ""
"Щоб дізнатися більше про різницю між ``_process()`` та "
"``_physics_process()`` дивіться :ref:`doc_idle_and_physics_processing`."

msgid ""
"We start by initializing a ``direction`` variable to ``Vector3.ZERO``. Then, "
"we check if the player is pressing one or more of the ``move_*`` inputs and "
"update the vector's ``x`` and ``z`` components accordingly. These correspond "
"to the ground plane's axes."
msgstr ""
"Починаємо з ініціалізації змінної ``direction`` з ``Vector3.ZERO``. Потім ми "
"перевіряємо, чи натискає гравець один, чи кілька, вводів ``move_*``, і "
"відповідно оновлюємо компоненти вектора ``x`` та ``z``. Вони відповідають "
"осям площини землі."

msgid ""
"These four conditions give us eight possibilities and eight possible "
"directions."
msgstr ""
"Ці чотири умови дають нам вісім можливостей і вісім можливих напрямків."

#, fuzzy
msgid ""
"In case the player presses, say, both W and D simultaneously, the vector "
"will have a length of about ``1.4``. But if they press a single key, it will "
"have a length of ``1``. We want the vector's length to be consistent, and "
"not move faster diagonally. To do so, we can call its ``normalized()`` "
"method."
msgstr ""
"У випадку, якщо гравець натискає, скажімо, W і D одночасно, вектор буде мати "
"довжину близько ``1.4``. Але при натисканні однієї клавіші, довжина буде "
"``1``. Нам треба, щоб довжина вектора була однаковою. Для цього можна "
"скористатися його методом ``normalize()``."

msgid ""
"Here, we only normalize the vector if the direction has a length greater "
"than zero, which means the player is pressing a direction key."
msgstr ""
"Тут ми нормалізуємо вектор тільки в тому випадку, якщо напрямок має довжину "
"більше нуля, а це означає, що гравець натискає дві клавіші напрямку."

msgid ""
"We compute the direction the ``$Pivot`` is looking by creating a :ref:`Basis "
"<class_Basis>` that looks in the ``direction`` direction."
msgstr ""

#, fuzzy
msgid ""
"Then, we update the velocity. We have to calculate the ground velocity and "
"the fall speed separately. Be sure to go back one tab so the lines are "
"inside the ``_physics_process()`` function but outside the condition we just "
"wrote above."
msgstr ""
"Потім оновлюємо швидкість. Ми повинні розрахувати швидкість руху по землі і "
"швидкість падіння окремо. Обов'язково поверніться на один відступ, щоб рядки "
"були всередині функції, але за межами умови, яку ми щойно написали."

#, fuzzy
msgid ""
"The ``CharacterBody3D.is_on_floor()`` function returns ``true`` if the body "
"collided with the floor in this frame. That's why we apply gravity to the "
"``Player`` only while it is in the air."
msgstr ""
"Метод ``is_on_floor()`` є інструментом з класу ``KinematicBody``. Він "
"повертає ``true``, якщо тіло зіткнулося з підлогою в цьому кадрі. Ось чому "
"ми застосовуємо гравітацію до гравця: ми стикаємося з підлогою, а не пливемо "
"над нею, як монстри."

#, fuzzy
msgid ""
"For the vertical velocity, we subtract the fall acceleration multiplied by "
"the delta time every frame. This line of code will cause our character to "
"fall in every frame, as long as it is not on or colliding with the floor."
msgstr ""
"Для вертикальної швидкості віднімаємо прискорення падіння "
"``fall_acceleration`` помножене на дельту часу ``delta`` кожного кадру. "
"Зверніть увагу на використання оператора ``-=``, який є скороченням для "
"``variable = variable - ...``."

msgid ""
"The physics engine can only detect interactions with walls, the floor, or "
"other bodies during a given frame if movement and collisions happen. We will "
"use this property later to code the jump."
msgstr ""
"Фізичний рушій може виявляти взаємодії зі стінами, підлогою або іншими "
"тілами під час заданого кадру тільки в тому випадку, якщо відбуваються рухи "
"і зіткнення. Ми скористаємося цією властивістю пізніше, щоб закодувати "
"стрибок."

msgid ""
"On the last line, we call ``CharacterBody3D.move_and_slide()`` which is a "
"powerful method of the ``CharacterBody3D`` class that allows you to move a "
"character smoothly. If it hits a wall midway through a motion, the engine "
"will try to smooth it out for you. It uses the *velocity* value native to "
"the :ref:`CharacterBody3D <class_CharacterBody3D>`"
msgstr ""
"В останньому рядку ми викликаємо ``CharacterBody3D.move_and_slide()``, який "
"є потужним методом класу ``CharacterBody3D``, що дозволяє плавно "
"переміщувати персонажа. Якщо він вдаряється об стіну посеред руху, рушій "
"спробує згладити це для вас. Для цього використовується значення *velocity*, "
"що належить класу :ref:`CharacterBody3D <клас_CharacterBody3D>`"

msgid "And that's all the code you need to move the character on the floor."
msgstr "І це весь код, який вам потрібен для переміщення персонажа по підлозі."

msgid "Here is the complete ``Player.gd`` code for reference."
msgstr "Ось повний код ``Player.gd`` для перевірки."

msgid "Testing our player's movement"
msgstr "Тестування руху нашого гравця"

#, fuzzy
msgid ""
"We're going to put our player in the ``Main`` scene to test it. To do so, we "
"need to instantiate the player and then add a camera. Unlike in 2D, in 3D, "
"you won't see anything if your viewport doesn't have a camera pointing at "
"something."
msgstr ""
"Ми збираємося поставити нашого гравця на головну сцену *Main*, щоб "
"перевірити його. Для цього нам потрібно налаштувати гравця, а потім додати "
"камеру. На відміну від 2D, в 3D ви нічого не побачите, якщо у вашому світі "
"немає камери."

#, fuzzy
msgid ""
"Save your ``Player`` scene and open the ``Main`` scene. You can click on the "
"*Main* tab at the top of the editor to do so."
msgstr ""
"Збережіть сцену *Player* та відкрийте головну сцену *Main*. Щоб зробити це, "
"ви можете натиснути на вкладку *Main* у верхній частині редактора."

msgid "|image1|"
msgstr "|image1|"

msgid "image1"
msgstr "image1"

#, fuzzy
msgid ""
"If you closed the scene before, head to the *FileSystem* dock and double-"
"click ``main.tscn`` to re-open it."
msgstr ""
"Якщо ви закрили сцену раніше, перейдіть до панелі *Файлова система* та двічі "
"клацніть ``Main.tscn``, щоб знову відкрити її."

#, fuzzy
msgid ""
"To instantiate the ``Player``, right-click on the ``Main`` node and select "
"*Instantiate Child Scene*."
msgstr ""
"Щоб створити екземпляр гравця *Player*, клацніть правою кнопкою мишки на "
"вузлі *Main* та виберіть пункт *Створити екземпляр дочірньої сцени*."

msgid "|image2|"
msgstr "|image2|"

msgid "image2"
msgstr "image2"

#, fuzzy
msgid ""
"In the popup, double-click ``player.tscn``. The character should appear in "
"the center of the viewport."
msgstr ""
"У спливаючому вікні двічі клацніть *Player.tscn*. Персонаж повинен появитися "
"в центрі вікна перегляду."

msgid "Adding a camera"
msgstr "Додавання камери"

#, fuzzy
msgid ""
"Let's add the camera next. Like we did with our *Player*\\ 's *Pivot*, we're "
"going to create a basic rig. Right-click on the ``Main`` node again and "
"select *Add Child Node*. Create a new :ref:`Marker3D <class_Marker3D>`, and "
"name it ``CameraPivot``. Select ``CameraPivot`` and add a child node :ref:"
"`Camera3D <class_Camera3D>` to it. Your scene tree should look like this."
msgstr ""
"Тепер давайте додамо камеру. Як і в випадку з *Pivot* нашого гравця "
"*Player*, ми збираємося створити базову конструкцію. Клацніть правою кнопкою "
"мишки на головному вузлі *Main* ще раз і виберіть, на цей раз, *Додати "
"дочірній вузол*. Створіть новий *Position3D*, назвіть його *CameraPivot* і "
"додайте йому вузол *Camera* в якості нащадка. Ваше дерево сцени має "
"виглядати так."

msgid "|image3|"
msgstr "|image3|"

msgid "image3"
msgstr "image3"

msgid ""
"Notice the *Preview* checkbox that appears in the top-left when you have the "
"*Camera* selected. You can click it to preview the in-game camera projection."
msgstr ""
"Зверніть увагу на галочку *Попередній перегляд*, яка відображається у "
"верхньому лівому куті, коли вибрано камеру. Ви можете натиснути її, щоб "
"глянути на гру через камеру."

msgid "|image4|"
msgstr "|image4|"

msgid "image4"
msgstr "image4"

msgid ""
"We're going to use the *Pivot* to rotate the camera as if it was on a crane. "
"Let's first split the 3D view to be able to freely navigate the scene and "
"see what the camera sees."
msgstr ""
"Ми збираємося використовувати *Pivot* для повороту камери, ніби вона крані. "
"Давайте спочатку розділимо 3D-вигляд, щоб мати можливість вільно "
"переміщатися по сцені і бачити, що бачить камера."

msgid ""
"In the toolbar right above the viewport, click on *View*, then *2 "
"Viewports*. You can also press :kbd:`Ctrl + 2` (:kbd:`Cmd + 2` on macOS)."
msgstr ""
"На панелі інструментів прямо над вікном перегляду, натисніть на *Перегляд*, "
"а потім *2 Панелі перегляду*. Ви також можете натиснути :kbd:`Ctrl + 2` (:"
"kbd:`Cmd + 2` на macOS)."

msgid "|image11|"
msgstr "|image11|"

msgid "image11"
msgstr "image11"

msgid "|image5|"
msgstr "|image5|"

msgid "image5"
msgstr "image5"

#, fuzzy
msgid ""
"On the bottom view, select your :ref:`Camera3D <class_Camera3D>` and turn on "
"camera Preview by clicking the checkbox."
msgstr ""
"У нижньому вікні виберіть камеру та увімкніть попередній перегляд камери, "
"поставивши галочку."

msgid "|image6|"
msgstr "Зображення"

msgid "image6"
msgstr "image6"

msgid ""
"In the top view, move the camera about ``19`` units on the Z axis (the blue "
"one)."
msgstr ""
"У верхньому вікні перемістіть камеру на ``19`` одиниць по осі Z (синій)."

msgid "|image7|"
msgstr "|image7|"

msgid "image7"
msgstr "image7"

#, fuzzy
msgid ""
"Here's where the magic happens. Select the *CameraPivot* and rotate it "
"``-45`` degrees around the X axis (using the red circle). You'll see the "
"camera move as if it was attached to a crane."
msgstr ""
"Тут і відбувається магія. Виділіть *CameraPivot* і поверніть його на ``45`` "
"градусів навколо осі X (за допомогою червоного кола). Ви побачите, як камера "
"рухається так, ніби вона була прикріплена до крана."

msgid "|image8|"
msgstr "|image8|"

msgid "image8"
msgstr "image8"

msgid ""
"You can run the scene by pressing :kbd:`F6` and press the arrow keys to move "
"the character."
msgstr ""
"Ви можете запустити сцену, натиснувши :kbd:`F6` та скористатися клавішами зі "
"стрілками для переміщення персонажа."

msgid "|image9|"
msgstr "|image9|"

msgid "image9"
msgstr "image9"

msgid ""
"We can see some empty space around the character due to the perspective "
"projection. In this game, we're going to use an orthographic projection "
"instead to better frame the gameplay area and make it easier for the player "
"to read distances."
msgstr ""
"Ми можемо бачити деякий порожній простір навколо персонажа завдяки "
"перспективній проекції. У цій грі ми збираємося використовувати ортографічну "
"проекцію, щоб краще обрамити ігрову зону та полегшити гравцеві читання "
"відстаней."

msgid ""
"Select the *Camera* again and in the *Inspector*, set the *Projection* to "
"*Orthogonal* and the *Size* to ``19``. The character should now look flatter "
"and the ground should fill the background."
msgstr ""
"Знову виберіть камеру і в *Інспекторі* встановіть для *Projection* значення "
"*Orthogonal* і *Size* на ``19``. Персонаж тепер повинен виглядати плоскішим, "
"а земля повинна заповнити фон."

msgid ""
"When using an orthogonal camera in Godot 4, directional shadow quality is "
"dependent on the camera's *Far* value. The higher the *Far* value, the "
"further away the camera will be able to see. However, higher *Far* values "
"also decrease shadow quality as the shadow rendering has to cover a greater "
"distance."
msgstr ""

msgid ""
"If directional shadows look too blurry after switching to an orthogonal "
"camera, decrease the camera's *Far* property to a lower value such as "
"``100``. Don't decrease this *Far* property too much, or objects in the "
"distance will start disappearing."
msgstr ""

msgid "|image10|"
msgstr "|image10|"

msgid "image10"
msgstr "image10"

msgid ""
"Test your scene and you should be able to move in all 8 directions and not "
"glitch through the floor!"
msgstr ""

#, fuzzy
msgid ""
"Ultimately, we have both player movement and the view in place. Next, we "
"will work on the monsters."
msgstr ""
"При цьому у нас є як рух гравця, так і вид на місце. Далі ми будемо "
"працювати над монстрами."

msgid "Translation status"
msgstr "Стан перекладу"
