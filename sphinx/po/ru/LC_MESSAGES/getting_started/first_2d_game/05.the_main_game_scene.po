# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "The main game scene"
msgstr "Главная сцена игры"

msgid ""
"Now it's time to bring everything we did together into a playable game scene."
msgstr ""
"Итак, настало время перенести всё, что мы сделали вместе, на играбельную "
"игровую сцену."

msgid ""
"Create a new scene and add a :ref:`Node <class_Node>` named ``Main``. (The "
"reason we are using Node instead of Node2D is because this node will be a "
"container for handling game logic. It does not require 2D functionality "
"itself.)"
msgstr ""
"Создайте новую сцену и добавьте :ref:`Node <class_Node>` с именем ``Main``. "
"(Причиной, по которой мы используем Node, а не Node2D, является то, что узел "
"будет контейнером для обработки игровой логики. Это не требует именно "
"двумерного функционала.)"

msgid ""
"Click the **Instance** button (represented by a chain link icon) and select "
"your saved ``Player.tscn``."
msgstr ""
"Нажмите на кнопку **Instance** (**Экземпляр**, представленную в иконке "
"ссылки) и выберите Ваш сохраненный ``Player.tscn``."

msgid ""
"Now, add the following nodes as children of ``Main``, and name them as shown "
"(values are in seconds):"
msgstr ""
"Теперь добавьте следующие узлы в виде дочерних элементов ``Main`` и назовите "
"их как показано ниже (значения указаны в секундах):"

msgid ""
":ref:`Timer <class_Timer>` (named ``MobTimer``) - to control how often mobs "
"spawn"
msgstr ""
":ref:`Timer <class_Timer>` (назвать ``MobTimer``) - чтобы контролировать "
"частоту появления мобов"

msgid ""
":ref:`Timer <class_Timer>` (named ``ScoreTimer``) - to increment the score "
"every second"
msgstr ""
":ref:`Timer <class_Timer>` (назвать ``ScoreTimer``) - чтобы каждую секунду "
"увеличивать счет"

msgid ""
":ref:`Timer <class_Timer>` (named ``StartTimer``) - to give a delay before "
"starting"
msgstr ""
":ref:`Timer <class_Timer>` (назвать ``StartTimer``) - чтобы дать задержку "
"перед стартом игры"

msgid ""
":ref:`Position2D <class_Position2D>` (named ``StartPosition``) - to indicate "
"the player's start position"
msgstr ""
":ref:`Position2D <class_Position2D>` (назвать ``StartPosition``) - чтобы "
"указать начальную позицию игрока"

msgid ""
"Set the ``Wait Time`` property of each of the ``Timer`` nodes as follows:"
msgstr ""
"Задайте значение ``Wait Time`` для каждого из узлов ``Timer`` следующим "
"образом:"

msgid "``MobTimer``: ``0.5``"
msgstr "``MobTimer``: ``0.5``"

msgid "``ScoreTimer``: ``1``"
msgstr "``ScoreTimer``: ``1``"

msgid "``StartTimer``: ``2``"
msgstr "``StartTimer``: ``2``"

msgid ""
"In addition, set the ``One Shot`` property of ``StartTimer`` to \"On\" and "
"set ``Position`` of the ``StartPosition`` node to ``(240, 450)``."
msgstr ""
"Кроме того, установите для свойства ``One Shot`` узла ``StartTimer`` "
"значение \"Вкл\" и для свойства ``Position`` узла ``StartPosition`` "
"установите значение ``(240, 450)``."

msgid "Spawning mobs"
msgstr "Добавление мобов"

msgid ""
"The Main node will be spawning new mobs, and we want them to appear at a "
"random location on the edge of the screen. Add a :ref:`Path2D "
"<class_Path2D>` node named ``MobPath`` as a child of ``Main``. When you "
"select ``Path2D``, you will see some new buttons at the top of the editor:"
msgstr ""
"Узел Main будет порождать новых мобов, и мы хотим, чтобы они появлялись в "
"случайном месте на краю экрана. Добавьте узел :ref:`Path2D <class_Path2D>` с "
"именем ``MobPath`` как дочерний элемент узла ``Main``. Когда вы выберете "
"``Path2D``, вы увидите несколько новых кнопок в верхней части редактора:"

msgid ""
"Select the middle one (\"Add Point\") and draw the path by clicking to add "
"the points at the corners shown. To have the points snap to the grid, make "
"sure \"Use Grid Snap\" and \"Use Snap\" are both selected. These options can "
"be found to the left of the \"Lock\" button, appearing as a magnet next to "
"some dots and intersecting lines, respectively."
msgstr ""
"Выберите среднюю (\"Add Point\") и нарисуйте путь щелчками мыши, чтобы "
"добавить точки в показанных углах. Чтобы точки привязывались к сетке, "
"убедитесь, что выбраны \"Use Grid Snap\" и \"Use Snap\". Эти опции можно "
"найти слева от кнопки \"Lock\", они отображаются в виде магнита рядом с "
"точками и пересекающимися линиями соответственно."

msgid ""
"Draw the path in *clockwise* order, or your mobs will spawn pointing "
"*outwards* instead of *inwards*!"
msgstr ""
"Нарисуйте путь в порядке *по часовой стрелке*, иначе ваши мобы будут "
"появляться с направлением *наружу*, а не *внутрь*!"

msgid ""
"After placing point ``4`` in the image, click the \"Close Curve\" button and "
"your curve will be complete."
msgstr ""
"Поместив точку \"4\" на изображение, нажмите кнопку \"Сомкнуть кривую\", и "
"она будет завершена."

msgid ""
"Now that the path is defined, add a :ref:`PathFollow2D <class_PathFollow2D>` "
"node as a child of ``MobPath`` and name it ``MobSpawnLocation``. This node "
"will automatically rotate and follow the path as it moves, so we can use it "
"to select a random position and direction along the path."
msgstr ""
"Теперь, когда путь определен, добавьте узел :ref:`PathFollow2D "
"<class_PathFollow2D>` как дочерний элемент ``MobPath`` и назовите его "
"``MobSpawnLocation``. Этот узел будет автоматически вращаться и следовать по "
"пути при его перемещении, поэтому мы можем использовать его для выбора "
"случайной позиции и направления вдоль пути."

msgid "Your scene should look like this:"
msgstr "Ваша сцена должна выглядеть так:"

msgid "Main script"
msgstr "Главный скрипт"

msgid ""
"Add a script to ``Main``. At the top of the script, we use ``export "
"(PackedScene)`` to allow us to choose the Mob scene we want to instance."
msgstr ""
"Добавьте скрипт к узлу ``Main``. В верхней части скрипта мы пишем ``export "
"(PackedScene)``, что позволяет нам выбрать сцену Mob, экземпляр которой мы "
"хотим сделать."

msgid ""
"We also add a call to ``randomize()`` here so that the random number "
"generator generates different random numbers each time the game is run:"
msgstr ""
"Мы также добавляем здесь вызов ``randomize()``, чтобы случайный генератор "
"чисел генерировал различные случайные числа каждый раз, когда запускается "
"игра :"

msgid ""
"Click the ``Main`` node and you will see the ``Mob Scene`` property in the "
"Inspector under \"Script Variables\"."
msgstr ""
"Выберите узел ``Main`` и вы увидите свойство ``MobScene`` в окне Инспектора "
"под \"Script Variables\"."

msgid "You can assign this property's value in two ways:"
msgstr "Значение этого свойства можно присвоить двумя способами:"

msgid ""
"Drag ``Mob.tscn`` from the \"FileSystem\" dock and drop it in the **Mob "
"Scene** property."
msgstr ""
"Перетащите ``Mob.tscn`` из панели \"Файловая система\" в свойство **Mob "
"Scene**."

msgid ""
"Click the down arrow next to \"[empty]\" and choose \"Load\". Select ``Mob."
"tscn``."
msgstr ""
"Нажмите стрелочку вниз рядом с \"[пусто]\" (\"[empty]\") и выберите "
"\"Загрузить\" (\"Load\"). Затем выберите ``Mob.tscn``."

msgid ""
"Next, select the ``Player`` node in the Scene dock, and access the Node dock "
"on the sidebar. Make sure to have the Signals tab selected in the Node dock."
msgstr ""
"Затем выберите узел ``Player`` (\"Игрок\") в панели \"Сцена\" (\"Scene\") и "
"откройте вкладку \"Узел\" (\"Node\") в инспекторе. Убедитесь, что во вкладке "
"\"Узел\" выбрана вкладка \"Сигналы\" (\"Signals\")."

msgid ""
"You should see a list of the signals for the ``Player`` node. Find and "
"double-click the ``hit`` signal in the list (or right-click it and select "
"\"Connect...\"). This will open the signal connection dialog. We want to "
"make a new function named ``game_over``, which will handle what needs to "
"happen when a game ends. Type \"game_over\" in the \"Receiver Method\" box "
"at the bottom of the signal connection dialog and click \"Connect\". Add the "
"following code to the new function, as well as a ``new_game`` function that "
"will set everything up for a new game:"
msgstr ""
"Вы должны увидеть список сигналов для узла ``Player``. В списке найдите и "
"дважды щелкните по сигналу ``hit`` (или щелкните по нему правой кнопкой мыши "
"и выберите \"Присоединить...\"). Это откроет диалоговое окно подключения "
"сигнала. Мы хотим создать новую функцию с именем ``game_over``, которая "
"будет обрабатывать то, что должно произойти, когда игра заканчивается. "
"Введите \"game_over\" в поле \"Метод-приёмник\" в нижней части диалогового "
"окна подключения сигнала и нажмите \"Присоединить\". Добавьте следующий код "
"в новую функцию, а также функцию ``new_game``, которая настроит всё для "
"новой игры:"

msgid ""
"Now connect the ``timeout()`` signal of each of the Timer nodes "
"(``StartTimer``, ``ScoreTimer`` , and ``MobTimer``) to the main script. "
"``StartTimer`` will start the other two timers. ``ScoreTimer`` will "
"increment the score by 1."
msgstr ""
"Теперь присоедините сигнал ``timeout()`` каждого из узлов Timer "
"(``StartTimer``, ``ScoreTimer`` и ``MobTimer``) к главному скрипту. "
"``StartTimer`` запустит два других таймера. ``ScoreTimer`` будет увеличивать "
"счет на 1."

msgid ""
"In ``_on_MobTimer_timeout()``, we will create a mob instance, pick a random "
"starting location along the ``Path2D``, and set the mob in motion. The "
"``PathFollow2D`` node will automatically rotate as it follows the path, so "
"we will use that to select the mob's direction as well as its position. When "
"we spawn a mob, we'll pick a random value between ``150.0`` and ``250.0`` "
"for how fast each mob will move (it would be boring if they were all moving "
"at the same speed)."
msgstr ""
"В функции ``_on_MobTimer_timeout()`` мы создадим экземпляр моба, выберем "
"случайное начальное местоположение вдоль ``Path2D`` и приведем его в "
"движение. Узел ``PathFollow2D`` будет автоматически поворачивать его по "
"направлению пути, поэтому мы воспользуемся этим, чтобы выбрать направление "
"моба и его позицию. Когда мы создаем моба, получаем случайное значение от "
"``150.0`` до ``250.0`` - это определяет скорость движения моба (было бы "
"скучно, если бы они все двигались с одинаковой скоростью)."

msgid ""
"Note that a new instance must be added to the scene using ``add_child()``."
msgstr ""
"Обратите внимание, что новый экземпляр должен быть добавлен в сцену с "
"помощью функции ``add_child()``."

msgid ""
"Why ``PI``? In functions requiring angles, Godot uses *radians*, not "
"degrees. Pi represents a half turn in radians, about ``3.1415`` (there is "
"also ``TAU`` which is equal to ``2 * PI``). If you're more comfortable "
"working with degrees, you'll need to use the ``deg2rad()`` and ``rad2deg()`` "
"functions to convert between the two."
msgstr ""
"Почему ``PI``? В функциях, требующих углы, Godot использует *радианы*, а не "
"градусы. Число Пи представляет собой пол-оборота в радианах, примерно "
"``3.1415`` (также есть переменная ``TAU``, которая равна ``2 * PI``) Если "
"вам удобнее работать с градусами, вам нужно использовать функции "
"``deg2rad()`` и ``rad2deg()`` для преобразования между ними."

msgid "Testing the scene"
msgstr "Тестирование сцены"

msgid ""
"Let's test the scene to make sure everything is working. Add this "
"``new_game`` call to ``_ready()``:"
msgstr ""
"Давайте протестируем сцену, чтобы убедиться, что все работает. Добавьте в "
"``_ready()`` вызов ``new_game``:"

msgid ""
"Let's also assign ``Main`` as our \"Main Scene\" - the one that runs "
"automatically when the game launches. Press the \"Play\" button and select "
"``Main.tscn`` when prompted."
msgstr ""
"Также давайте назначим сцену ``Main`` в качестве нашей \"Главной сцены\", "
"которая запускается автоматически при запуске игры. Нажмите кнопку \"Play\" "
"и выберите ``Main.tscn`` при появлении запроса."

msgid ""
"If you had already set another scene as the \"Main Scene\", you can right "
"click ``Main.tscn`` in the FileSystem dock and select \"Set As Main Scene\"."
msgstr ""
"Если Вы уже настроили другую сцену как \"Главную Сцену\" (\"Main Scene\"), "
"Вы можете нажать правой кнопкой мыши на ``Main.tscn``в панели Файловой "
"системы и выбрать \"Установить в качестве Главной Сцены\" (\"Set As Main "
"Scene\")."

msgid ""
"You should be able to move the player around, see mobs spawning, and see the "
"player disappear when hit by a mob."
msgstr ""
"У вас должна быть возможность перемещать игрока, видеть, как появляются "
"мобы, и видеть, как игрок исчезает, когда его бьет моб."

msgid ""
"When you're sure everything is working, remove the call to ``new_game()`` "
"from ``_ready()``."
msgstr ""
"Когда вы убедитесь, что всё работает, удалите вызов ``new_game()`` из "
"``_ready()``."

msgid ""
"What's our game lacking? Some user interface. In the next lesson, we'll add "
"a title screen and display the player's score."
msgstr ""
"Чего не хватает нашей игре? Какого-нибудь пользовательского интерфейса. В "
"следующем уроке мы добавим заглавный экран и отобразим очки игрока."

msgid "Translation status"
msgstr "Translation status (статус перевода)"
