# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Kinematic character (2D)"
msgstr "Кинематический персонаж (2D)"

msgid "Introduction"
msgstr "Введение"

msgid ""
"Yes, the name sounds strange. \"Kinematic Character\". What is that? The "
"reason for the name is that, when physics engines came out, they were called "
"\"Dynamics\" engines (because they dealt mainly with collision responses). "
"Many attempts were made to create a character controller using the dynamics "
"engines, but it wasn't as easy as it seemed. Godot has one of the best "
"implementations of dynamic character controller you can find (as it can be "
"seen in the 2d/platformer demo), but using it requires a considerable level "
"of skill and understanding of physics engines (or a lot of patience with "
"trial and error)."
msgstr ""
"Да, название звучит странно. «Кинематический персонаж». Что это? Причина "
"такого названия в том, что когда появились физические движки, они назывались "
"движками динамики (потому что они работали в основном с реакцией на "
"столкновения). Было предпринято много попыток создать контроллер персонажа, "
"используя движки динамики, но это оказалось не так просто, как казалось. "
"Godot имеет одну из лучших реализаций динамического контроллера персонажа, "
"которую вы можете найти (это можно увидеть в демонстрации 2d/платформера), "
"но ее использование требует значительного уровня мастерства и понимания "
"физических движков (или большого терпения на пробы и ошибки)."

msgid ""
"Some physics engines, such as Havok seem to swear by dynamic character "
"controllers as the best option, while others (PhysX) would rather promote "
"the kinematic one."
msgstr ""
"Некоторые физические движки, такие, как Havok, преподносят динамические "
"контроллеры персонажей как лучший вариант, в то же время как другие (PhysX), "
"напротив, продвигают только кинематику."

msgid "So, what is the difference?:"
msgstr "Так, а в чём разница?:"

msgid ""
"A **dynamic character controller** uses a rigid body with an infinite "
"inertia tensor. It's a rigid body that can't rotate. Physics engines always "
"let objects move and collide, then solve their collisions all together. This "
"makes dynamic character controllers able to interact with other physics "
"objects seamlessly, as seen in the platformer demo. However, these "
"interactions are not always predictable. Collisions can take more than one "
"frame to be solved, so a few collisions may seem to displace a tiny bit. "
"Those problems can be fixed, but require a certain amount of skill."
msgstr ""
"**Динамический контроллер персонажа** использует твёрдое тело с бесконечным "
"тензором инерции. Это твёрдое тело, которое не может вращаться. Физические "
"движки всегда позволяют объектам двигаться и сталкиваться, а затем решают их "
"столкновения разом. Это делает динамические контроллеры персонажей "
"способными бесшовно взаимодействовать с другими объектами физики, как "
"показано в демо-версии платформера. Однако, эти взаимодействия не всегда "
"предсказуемы. Столкновения могут длиться более одного кадра для завершения "
"расчётов, и несколько столкновений могут оказаться смещёнными на несколько "
"бит. Эти проблемы могут быть устранены, но требуют определенной квалификации."

msgid ""
"A **kinematic character controller** is assumed to always begin in a non-"
"colliding state, and will always move to a non-colliding state. If it starts "
"in a colliding state, it will try to free itself like rigid bodies do, but "
"this is the exception, not the rule. This makes their control and motion a "
"lot more predictable and easier to program. However, as a downside, they "
"can't directly interact with other physics objects, unless done by hand in "
"code."
msgstr ""
"Предполагается, что **контроллер кинематических персонажей** всегда начинает "
"в состоянии отсутствия столкновений и всегда переходит в состояние "
"отсутствия столкновений. Если он начнёт в состоянии столкновения, то он "
"попытается освободиться, как это делают твёрдые тела, но это исключение, а "
"не правило. Это делает управление им и движение гораздо более предсказуемыми "
"и более простыми в программировании. Однако, как недостаток, он не может "
"напрямую взаимодействовать с другими физическими объектами, если это не "
"делается вручную в коде."

msgid ""
"This short tutorial will focus on the kinematic character controller. "
"Basically, the old-school way of handling collisions (which is not "
"necessarily simpler under the hood, but well hidden and presented as a nice "
"and simple API)."
msgstr ""
"В этом кратком учебном пособии основное внимание будет уделено "
"кинематическому контроллеру персонажа. В основном, тут используется способ "
"работы со столкновениями старой школы (который не обязательно проще под "
"капотом, но хорошо скрыт и представлен как хороший и простой API)."

msgid "Physics process"
msgstr "Обработка физики"

msgid ""
"To manage the logic of a kinematic body or character, it is always advised "
"to use physics process, because it's called before physics step and its "
"execution is in sync with physics server, also it is called the same amount "
"of times per second, always. This makes physics and motion calculation work "
"in a more predictable way than using regular process, which might have "
"spikes or lose precision if the frame rate is too high or too low."
msgstr ""
"Чтобы управлять логикой кинематического тела или персонажа, всегда "
"рекомендуется использовать процесс обработки физики, потому что он "
"вызывается перед шагом физики и его выполнение находится в синхронизации с "
"сервером физики, а также вызов производится одинаковое количество раз в "
"секунду, всегда. Это делает работу по расчёту физики и движения более "
"предсказуемой, чем при использовании обычного процесса, который может иметь "
"всплески или потерять точность, если частота кадров слишком высока или "
"слишком низка."

msgid "Scene setup"
msgstr "Настройка сцены"

msgid ""
"To have something to test, here's the scene (from the tilemap tutorial): :"
"download:`kbscene.zip <files/kbscene.zip>`. We'll be creating a new scene "
"for the character. Use the robot sprite and create a scene like this:"
msgstr ""
"Чтобы проверить что-то, вот сцена (из учебного пособия tilemap): :download:"
"`kbscene.zip <files/kbscene.zip>`. Мы создадим новую сцену для персонажа. "
"Используйте спрайт робота и создайте сцену следующим образом:"

msgid ""
"You'll notice that there's a warning icon next to our CollisionShape2D node; "
"that's because we haven't defined a shape for it. Create a new CircleShape2D "
"in the shape property of CollisionShape2D. Click on <CircleShape2D> to go to "
"the options for it, and set the radius to 30:"
msgstr ""
"Вы заметите, что рядом с нашим узлом CollisionShape2D есть значок "
"предупреждения; это потому, что мы не определили форму для него. Создайте "
"новый CircleShape2D в свойстве формы CollisionShape2D. Нажмите кнопку < "
"CircleShape2D >, чтобы перейти к его параметрам, и установите радиус, равный "
"30:"

msgid ""
"**Note: As mentioned before in the physics tutorial, the physics engine "
"can't handle scale on most types of shapes (only collision polygons, planes "
"and segments work), so always change the parameters (such as radius) of the "
"shape instead of scaling it. The same is also true for the kinematic/rigid/"
"static bodies themselves, as their scale affects the shape scale.**"
msgstr ""
"**Внимание: Как упоминалось выше в учебном пособии по физике, модуль физики "
"не может обрабатывать масштаб на большинстве типов форм (работают только "
"многоугольники столкновений, плоскости и сегменты), поэтому всегда изменяйте "
"параметры (например, радиус) формы вместо её масштабирования. То же самое "
"справедливо и для самих кинематических/жёстких/статических тел, поскольку их "
"масштаб влияет на масштаб формы.**"

msgid ""
"Now, create a script for the character, the one used as an example above "
"should work as a base."
msgstr ""
"Теперь создайте скрипт для персонажа, который использовался в качестве "
"примера выше и должен работать, как изначально."

msgid ""
"Finally, instance that character scene in the tilemap, and make the map "
"scene the main one, so it runs when pressing play."
msgstr ""
"Наконец, инстанцируйте эту сцену персонажа в tilemap и сделайте сцену карты "
"главной, чтобы она запускалась при нажатии на воспроизведение."

msgid "Moving the kinematic character"
msgstr "Перемещение кинематического персонажа"

msgid ""
"Go back to the character scene, and open the script, the magic begins now! "
"Kinematic body will do nothing by default, but it has a useful function "
"called :ref:`KinematicBody2D.move_and_collide() "
"<class_KinematicBody2D_method_move_and_collide>`. This function takes a :ref:"
"`Vector2 <class_Vector2>` as an argument, and tries to apply that motion to "
"the kinematic body. If a collision happens, it stops right at the moment of "
"the collision."
msgstr ""
"Вернитесь к сцене персонажа и откройте скрипт, магия начинается сейчас! "
"Кинематическое тело по умолчанию ничего не делает, но имеет полезную "
"функцию :ref:`KinematicBody2D.move_and_collide() "
"<class_KinematicBody2D_method_move_and_collide>`. Эта функция принимает :ref:"
"`Vector2 <class_Vector2>` в качестве аргумента и пытается применить это "
"движение к кинематическому телу. Если происходит столкновение, она "
"останавливается прямо в момент столкновения."

msgid "So, let's move our sprite downwards until it hits the floor:"
msgstr "Итак, давайте сдвинем наш спрайт вниз, пока он не ударится об пол:"

msgid ""
"The result is that the character will move, but stop right when hitting the "
"floor. Pretty cool, huh?"
msgstr ""
"В результате персонаж двигается, но останавливается прямо при ударе о пол. "
"Довольно круто, да?"

msgid ""
"The next step will be adding gravity to the mix, this way it behaves a "
"little more like a regular game character:"
msgstr ""
"Следующим шагом будет добавление гравитации к миксу, путь он ведет себя "
"немного ближе к обычному игровому персонажу:"

msgid ""
"Now the character falls smoothly. Let's make it walk to the sides, left and "
"right when touching the directional keys. Remember that the values being "
"used (for speed at least) are pixels/second."
msgstr ""
"Теперь персонаж плавно падает. Давайте заставим его идти в стороны, влево и "
"вправо при нажатии на клавиши управления. Следует помнить, что используемые "
"значения (по крайней мере для скорости) составляют пикселы в секунду."

msgid "This adds simple walking support by pressing left and right:"
msgstr "Это добавляет простую поддержку ходьбы при нажатии влево и вправо:"

msgid "And give it a try."
msgstr "И попробуем."

msgid ""
"This is a good starting point for a platformer. A more complete demo can be "
"found in the demo zip distributed with the engine, or in the https://github."
"com/godotengine/godot-demo-projects/tree/master/2d/kinematic_character."
msgstr ""
"Это хорошая отправная точка для платформера. Более полную демонстрацию можно "
"найти в demo zip, распространяемом вместе с движком, или в https://github."
"com/godotengine/godot-demo-projects/tree/master/2d/kinematic_character."

msgid "Translation status"
msgstr "Translation status (статус перевода)"
