# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Kinematic character (2D)"
msgstr "Кинематический персонаж (2D)"

msgid "Introduction"
msgstr "Введение"

msgid ""
"Yes, the name sounds strange. \"Kinematic Character\". What is that? The "
"reason for the name is that, when physics engines came out, they were called "
"\"Dynamics\" engines (because they dealt mainly with collision responses). "
"Many attempts were made to create a character controller using the dynamics "
"engines, but it wasn't as easy as it seemed. Godot has one of the best "
"implementations of dynamic character controller you can find (as it can be "
"seen in the 2d/platformer demo), but using it requires a considerable level "
"of skill and understanding of physics engines (or a lot of patience with "
"trial and error)."
msgstr ""
"Да, название звучит странно. «Кинематический персонаж». Что это? Причина "
"такого названия в том, что когда появились физические движки, они назывались "
"движками динамики (потому что они работали в основном с реакцией на "
"столкновения). Было предпринято много попыток создать контроллер персонажа, "
"используя движки динамики, но это оказалось не так просто, как казалось. "
"Godot имеет одну из лучших реализаций динамического контроллера персонажа, "
"которую вы можете найти (это можно увидеть в демонстрации 2d/платформера), "
"но ее использование требует значительного уровня мастерства и понимания "
"физических движков (или большого терпения на пробы и ошибки)."

msgid ""
"Some physics engines, such as Havok seem to swear by dynamic character "
"controllers as the best option, while others (PhysX) would rather promote "
"the kinematic one."
msgstr ""
"Некоторые физические движки, такие, как Havok, преподносят динамические "
"контроллеры персонажей как лучший вариант, в то же время как другие (PhysX), "
"напротив, продвигают только кинематику."

msgid "So, what is the difference?:"
msgstr "Так, а в чём разница?:"

msgid ""
"A **dynamic character controller** uses a rigid body with an infinite "
"inertia tensor. It's a rigid body that can't rotate. Physics engines always "
"let objects move and collide, then solve their collisions all together. This "
"makes dynamic character controllers able to interact with other physics "
"objects seamlessly, as seen in the platformer demo. However, these "
"interactions are not always predictable. Collisions can take more than one "
"frame to be solved, so a few collisions may seem to displace a tiny bit. "
"Those problems can be fixed, but require a certain amount of skill."
msgstr ""
"**Динамический контроллер персонажа** использует твёрдое тело с бесконечным "
"тензором инерции. Это твёрдое тело, которое не может вращаться. Физические "
"движки всегда позволяют объектам двигаться и сталкиваться, а затем решают их "
"столкновения разом. Это делает динамические контроллеры персонажей "
"способными бесшовно взаимодействовать с другими объектами физики, как "
"показано в демо-версии платформера. Однако, эти взаимодействия не всегда "
"предсказуемы. Столкновения могут длиться более одного кадра для завершения "
"расчётов, и несколько столкновений могут оказаться смещёнными на несколько "
"бит. Эти проблемы могут быть устранены, но требуют определенной квалификации."

msgid ""
"A **kinematic character controller** is assumed to always begin in a non-"
"colliding state, and will always move to a non-colliding state. If it starts "
"in a colliding state, it will try to free itself like rigid bodies do, but "
"this is the exception, not the rule. This makes their control and motion a "
"lot more predictable and easier to program. However, as a downside, they "
"can't directly interact with other physics objects, unless done by hand in "
"code."
msgstr ""
"Предполагается, что **контроллер кинематических персонажей** всегда начинает "
"в состоянии отсутствия столкновений и всегда переходит в состояние "
"отсутствия столкновений. Если он начнёт в состоянии столкновения, то он "
"попытается освободиться, как это делают твёрдые тела, но это исключение, а "
"не правило. Это делает управление им и движение гораздо более предсказуемыми "
"и более простыми в программировании. Однако, как недостаток, он не может "
"напрямую взаимодействовать с другими физическими объектами, если это не "
"делается вручную в коде."

#, fuzzy
msgid ""
"This short tutorial focuses on the kinematic character controller. It uses "
"the old-school way of handling collisions, which is not necessarily simpler "
"under the hood, but well hidden and presented as an API."
msgstr ""
"В этом кратком учебном пособии основное внимание будет уделено "
"кинематическому контроллеру персонажа. В основном, тут используется способ "
"работы со столкновениями старой школы (который не обязательно проще под "
"капотом, но хорошо скрыт и представлен как хороший и простой API)."

msgid "Physics process"
msgstr "Обработка физики"

msgid ""
"To manage the logic of a kinematic body or character, it is always advised "
"to use physics process, because it's called before physics step and its "
"execution is in sync with physics server, also it is called the same amount "
"of times per second, always. This makes physics and motion calculation work "
"in a more predictable way than using regular process, which might have "
"spikes or lose precision if the frame rate is too high or too low."
msgstr ""
"Чтобы управлять логикой кинематического тела или персонажа, всегда "
"рекомендуется использовать процесс обработки физики, потому что он "
"вызывается перед шагом физики и его выполнение находится в синхронизации с "
"сервером физики, а также вызов производится одинаковое количество раз в "
"секунду, всегда. Это делает работу по расчёту физики и движения более "
"предсказуемой, чем при использовании обычного процесса, который может иметь "
"всплески или потерять точность, если частота кадров слишком высока или "
"слишком низка."

msgid "Scene setup"
msgstr "Настройка сцены"

#, fuzzy
msgid ""
"To have something to test, here's the scene (from the tilemap tutorial): "
"`kinematic_character_2d_starter.zip <https://github.com/godotengine/godot-"
"docs-project-starters/releases/download/latest-4.x/"
"kinematic_character_2d_starter.zip>`_. We'll be creating a new scene for the "
"character. Use the robot sprite and create a scene like this:"
msgstr ""
"Чтобы проверить что-то, вот сцена (из учебного пособия tilemap): :download:"
"`kbscene.zip <files/kbscene.zip>`. Мы создадим новую сцену для персонажа. "
"Используйте спрайт робота и создайте сцену следующим образом:"

msgid ""
"You'll notice that there's a warning icon next to our CollisionShape2D node; "
"that's because we haven't defined a shape for it. Create a new CircleShape2D "
"in the shape property of CollisionShape2D. Click on <CircleShape2D> to go to "
"the options for it, and set the radius to 30:"
msgstr ""
"Вы заметите, что рядом с нашим узлом CollisionShape2D есть значок "
"предупреждения; это потому, что мы не определили форму для него. Создайте "
"новый CircleShape2D в свойстве формы CollisionShape2D. Нажмите кнопку < "
"CircleShape2D >, чтобы перейти к его параметрам, и установите радиус, равный "
"30:"

msgid ""
"**Note: As mentioned before in the physics tutorial, the physics engine "
"can't handle scale on most types of shapes (only collision polygons, planes "
"and segments work), so always change the parameters (such as radius) of the "
"shape instead of scaling it. The same is also true for the kinematic/rigid/"
"static bodies themselves, as their scale affects the shape scale.**"
msgstr ""
"**Внимание: Как упоминалось выше в учебном пособии по физике, модуль физики "
"не может обрабатывать масштаб на большинстве типов форм (работают только "
"многоугольники столкновений, плоскости и сегменты), поэтому всегда изменяйте "
"параметры (например, радиус) формы вместо её масштабирования. То же самое "
"справедливо и для самих кинематических/жёстких/статических тел, поскольку их "
"масштаб влияет на масштаб формы.**"

msgid ""
"Now, create a script for the character, the one used as an example above "
"should work as a base."
msgstr ""
"Теперь создайте скрипт для персонажа, который использовался в качестве "
"примера выше и должен работать, как изначально."

msgid ""
"Finally, instance that character scene in the tilemap, and make the map "
"scene the main one, so it runs when pressing play."
msgstr ""
"Наконец, инстанцируйте эту сцену персонажа в tilemap и сделайте сцену карты "
"главной, чтобы она запускалась при нажатии на воспроизведение."

msgid "Moving the kinematic character"
msgstr "Перемещение кинематического персонажа"

#, fuzzy
msgid ""
"Go back to the character scene, and open the script, the magic begins now! "
"Kinematic body will do nothing by default, but it has a useful function "
"called ``CharacterBody2D.move_and_collide()``. This function takes a :ref:"
"`Vector2 <class_Vector2>` as an argument, and tries to apply that motion to "
"the kinematic body. If a collision happens, it stops right at the moment of "
"the collision."
msgstr ""
"Вернитесь к сцене персонажа и откройте скрипт, магия начинается сейчас! "
"Кинематическое тело по умолчанию ничего не делает, но имеет полезную "
"функцию :ref:`KinematicBody2D.move_and_collide() "
"<class_KinematicBody2D_method_move_and_collide>`. Эта функция принимает :ref:"
"`Vector2 <class_Vector2>` в качестве аргумента и пытается применить это "
"движение к кинематическому телу. Если происходит столкновение, она "
"останавливается прямо в момент столкновения."

msgid "So, let's move our sprite downwards until it hits the floor:"
msgstr "Итак, давайте сдвинем наш спрайт вниз, пока он не ударится об пол:"

msgid ""
"The result is that the character will move, but stop right when hitting the "
"floor. Pretty cool, huh?"
msgstr ""
"В результате персонаж двигается, но останавливается прямо при ударе о пол. "
"Довольно круто, да?"

msgid ""
"The next step will be adding gravity to the mix, this way it behaves a "
"little more like a regular game character:"
msgstr ""
"Следующим шагом будет добавление гравитации к миксу, путь он ведет себя "
"немного ближе к обычному игровому персонажу:"

msgid ""
"Now the character falls smoothly. Let's make it walk to the sides, left and "
"right when touching the directional keys. Remember that the values being "
"used (for speed at least) are pixels/second."
msgstr ""
"Теперь персонаж плавно падает. Давайте заставим его идти в стороны, влево и "
"вправо при нажатии на клавиши управления. Следует помнить, что используемые "
"значения (по крайней мере для скорости) составляют пикселы в секунду."

#, fuzzy
msgid "This adds basic support for walking when pressing left and right:"
msgstr "Это добавляет простую поддержку ходьбы при нажатии влево и вправо:"

msgid "And give it a try."
msgstr "И попробуем."

msgid ""
"This is a good starting point for a platformer. A more complete demo can be "
"found in the demo zip distributed with the engine, or in the https://github."
"com/godotengine/godot-demo-projects/tree/master/2d/kinematic_character."
msgstr ""
"Это хорошая отправная точка для платформера. Более полную демонстрацию можно "
"найти в demo zip, распространяемом вместе с движком, или в https://github."
"com/godotengine/godot-demo-projects/tree/master/2d/kinematic_character."

msgid "Translation status"
msgstr "Статус перевода"
