# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Ray-casting"
msgstr "Трассировка лучей"

msgid "Introduction"
msgstr "Введение"

msgid ""
"One of the most common tasks in game development is casting a ray (or custom "
"shaped object) and checking what it hits. This enables complex behaviors, "
"AI, etc. to take place. This tutorial will explain how to do this in 2D and "
"3D."
msgstr ""
"Одна из самых частых задач в разработке игр — это испускание луча (или "
"собственного объекта с формой) и проверка того, что он пересекает. Это "
"позволяет создавать сложные поведения, ИИ и т.д. В этом учебном пособии "
"объясняется, как это сделать в 2D и 3D пространстве."

msgid ""
"Godot stores all the low level game information in servers, while the scene "
"is just a frontend. As such, ray casting is generally a lower-level task. "
"For simple raycasts, node such as :ref:`RayCast <class_RayCast>` and :ref:"
"`RayCast2D <class_RayCast2D>` will work, as they will return every frame "
"what the result of a raycast is."
msgstr ""
"Godot сохраняет всю низкоуровневую игровую информацию в серверах, тогда как "
"сцена это просто внешний интерфейс. Таким образом, трассировка лучей это "
"низкоуровневый процесс. Для простых трассировок можно использовать такие "
"узлы, как :ref:`RayCast <class_RayCast>` и :ref:`RayCast2D "
"<class_RayCast2D>`, так как они будут возвращать результат в каждом кадре."

msgid ""
"Many times, though, ray-casting needs to be a more interactive process so a "
"way to do this by code must exist."
msgstr ""
"Во многих случаях, однако, трассировка лучей требует более сложной обработки "
"так что должен существовать способ делать это через код."

msgid "Space"
msgstr "Пространство"

msgid ""
"In the physics world, Godot stores all the low level collision and physics "
"information in a *space*. The current 2d space (for 2D Physics) can be "
"obtained by accessing :ref:`CanvasItem.get_world_2d().space "
"<class_CanvasItem_method_get_world_2d>`. For 3D, it's :ref:`Spatial."
"get_world().space <class_Spatial_method_get_world>`."
msgstr ""
"В пространстве физики, Godot хранит все низкоуровневые столкновения и "
"физическую информацию в *пространстве*. Текущее 2d пространство (для 2D "
"физики) может быть получено с помощью :ref:`CanvasItem.get_world_2d().space "
"<class_CanvasItem_method_get_world_2d>`. Для 3D это :ref:`Spatial."
"get_world().space <class_Spatial_method_get_world>`."

msgid ""
"The resulting space :ref:`RID <class_RID>` can be used in :ref:"
"`PhysicsServer <class_PhysicsServer>` and :ref:`Physics2DServer "
"<class_Physics2DServer>` respectively for 3D and 2D."
msgstr ""
"В итоге пространство :ref:`RID <class_RID>` может быть использовано в :ref:"
"`PhysicsServer <class_PhysicsServer>` и :ref:`Physics2DServer "
"<class_Physics2DServer>` соответственно для 3D и 2D ."

msgid "Accessing space"
msgstr "Доступ к пространству"

msgid ""
"Godot physics runs by default in the same thread as game logic, but may be "
"set to run on a separate thread to work more efficiently. Due to this, the "
"only time accessing space is safe is during the :ref:`Node."
"_physics_process() <class_Node_method__physics_process>` callback. Accessing "
"it from outside this function may result in an error due to space being "
"*locked*."
msgstr ""
"По умолчанию физика Godot запускается в том же потоке, что и игровая логика, "
"но также может быть запущена и в отдельном потоке для более эффективной "
"работы. В связи с этим, доступ к пространству безопасен только в функции "
"обратного вызова :ref:`Node._physics_process() "
"<class_Node_method__physics_process>`. Доступ к нему извне этой функции "
"может привести к ошибке из-за *заблокированного* пространства."

msgid ""
"To perform queries into physics space, the :ref:`Physics2DDirectSpaceState "
"<class_Physics2DDirectSpaceState>` and :ref:`PhysicsDirectSpaceState "
"<class_PhysicsDirectSpaceState>` must be used."
msgstr ""
"Для выполнения запросов в физическом пространстве нужно использовать :ref:"
"`Physics2DDirectSpaceState <class_Physics2DDirectSpaceState>` и :ref:"
"`PhysicsDirectSpaceState <class_PhysicsDirectSpaceState>`."

msgid "Use the following code in 2D:"
msgstr "Используйте следующий код в 2D:"

msgid "Or more directly:"
msgstr "Или более прямо:"

msgid "And in 3D:"
msgstr "И для 3D:"

msgid "Raycast query"
msgstr "Запрос трассировки лучей"

msgid ""
"For performing a 2D raycast query, the method :ref:"
"`Physics2DDirectSpaceState.intersect_ray() "
"<class_Physics2DDirectSpaceState_method_intersect_ray>` may be used. For "
"example:"
msgstr ""
"Для выполнения такого запроса для 2D можно использовать метод :ref:"
"`Physics2DDirectSpaceState.intersect_ray() "
"<class_Physics2DDirectSpaceState_method_intersect_ray>`. Например:"

msgid ""
"The result is a dictionary. If the ray didn't hit anything, the dictionary "
"will be empty. If it did hit something, it will contain collision "
"information:"
msgstr ""
"Результатом будет словарь. Если луч ни с чем не столкнулся, словарь будет "
"пуст. Если же столкнулся, то будет содержать информацию о столкновении:"

msgid ""
"The ``result`` dictionary when a collision occurs contains the following "
"data:"
msgstr ""
"Словарь ``result`` после столкновения будет содержать следующие данные:"

msgid "The data is similar in 3D space, using Vector3 coordinates."
msgstr ""
"Те же данные подобны и для 3D пространства, но используют координаты в "
"Vector3."

msgid "Collision exceptions"
msgstr "Исключения столкновений"

msgid ""
"A common use case for ray casting is to enable a character to gather data "
"about the world around it. One problem with this is that the same character "
"has a collider, so the ray will only detect its parent's collider, as shown "
"in the following image:"
msgstr ""
"Распространенный способ использования трассировки лучей это сбор данных об "
"окружающем мире для персонажа. Одна из проблем с этим возникает когда у "
"персонажа есть коллайдер, и луч будет сталкиваться с ним, как показано на "
"следующем рисунке:"

msgid ""
"To avoid self-intersection, the ``intersect_ray()`` function can take an "
"optional third parameter which is an array of exceptions. This is an example "
"of how to use it from a KinematicBody2D or any other collision object node:"
msgstr ""
"Для избежания самопересечения функция ``intersect_ray()`` может принимать "
"третий необязательный параметр, который представляет массив исключений. "
"Пример, как это использовать для KinematicBody2D, или любого другого узла "
"столкновений:"

msgid "The exceptions array can contain objects or RIDs."
msgstr "Массивы исключений могут содержать объекты или RIDs."

msgid "Collision Mask"
msgstr "Маска столкновения"

msgid ""
"While the exceptions method works fine for excluding the parent body, it "
"becomes very inconvenient if you need a large and/or dynamic list of "
"exceptions. In this case, it is much more efficient to use the collision "
"layer/mask system."
msgstr ""
"Метод исключений хорошо работает, когда нужно исключить родительское тело, "
"но очень неудобен, если это нужно сделать для больших и/или динамических "
"списков исключений. Для этого случая гораздо эффективнее использовать "
"систему слоев/масок столкновений."

msgid ""
"The optional fourth argument for ``intersect_ray()`` is a collision mask. "
"For example, to use the same mask as the parent body, use the "
"``collision_mask`` member variable:"
msgstr ""
"Необязательный четвертый параметр для ``intersect_ray()`` это маска "
"столкновений. Например, для использования той же маски, что и в родительском "
"теле, используйте переменную ``collision_mask``:"

msgid ""
"See :ref:`doc_physics_introduction_collision_layer_code_example` for details "
"on how to set the collision mask."
msgstr ""
"См. :ref:`doc_physics_introduction_collision_layer_code_example` для "
"получения дополнительной информации о том, как установить маску столкновений."

msgid "3D ray casting from screen"
msgstr "Трассировка лучей из экрана в 3D"

msgid ""
"Casting a ray from screen to 3D physics space is useful for object picking. "
"There is not much need to do this because :ref:`CollisionObject "
"<class_CollisionObject>` has an \"input_event\" signal that will let you "
"know when it was clicked, but in case there is any desire to do it manually, "
"here's how."
msgstr ""
"Трассировка луча из экранного в 3D физическое пространство полезно для "
"выбора объекта. Не требуется много усилий для выполнения этого поскольку :"
"ref:`CollisionObject <class_CollisionObject>` имеет сигнал \"input_event\" "
"который способен уведомить вас при клике, но в случае если вам понадобится "
"сделать это вручную, здесь показано как."

msgid ""
"To cast a ray from the screen, you need a :ref:`Camera <class_Camera>` node. "
"A ``Camera`` can be in two projection modes: perspective and orthogonal. "
"Because of this, both the ray origin and direction must be obtained. This is "
"because ``origin`` changes in orthogonal mode, while ``normal`` changes in "
"perspective mode:"
msgstr ""
"Для трассировки луча с экрана, вам нужен узел ref:`Camera <class_Camera>`. "
"``Camera`` может быть в двух режимах проекции: перспективном и "
"ортогональном. Из-за этого, необходимо предоставить и начальную точку "
"(``origin``) луча и направление (нормаль). Начальная точка (``origin``) "
"изменяется в ортогональном режиме, а *нормаль* изменяется в перспективном:"

msgid "To obtain it using a camera, the following code can be used:"
msgstr "Для его получения с помощью камеры можно использовать следующий код:"

msgid ""
"Remember that during ``_input()``, the space may be locked, so in practice "
"this query should be run in ``_physics_process()``."
msgstr ""
"Помните, что во время выполнения ``_input()`` пространство может быть "
"заблокировано, поэтому на практике этот запрос должен выполняться в "
"``_physics_process()``."

msgid "Translation status"
msgstr "Translation status (статус перевода)"
