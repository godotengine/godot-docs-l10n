# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Physics introduction"
msgstr "Введение в физику"

msgid ""
"In game development, you often need to know when two objects in the game "
"intersect or come into contact. This is known as **collision detection**. "
"When a collision is detected, you typically want something to happen. This "
"is known as **collision response**."
msgstr ""
"При разработке игры часто нужно знать, когда два объекта в игре пересекаются "
"или сталкиваются. Это называется **обнаружением столкновений**. При "
"обнаружении столкновения, как правило, требуется, чтобы что-либо произошло. "
"Это называется **реакцией на столкновение**."

msgid ""
"Godot offers a number of collision objects in 2D and 3D to provide both "
"collision detection and response. Trying to decide which one to use for your "
"project can be confusing. You can avoid problems and simplify development if "
"you understand how each works and what their pros and cons are."
msgstr ""
"Godot предлагает ряд объектов столкновений в 2D и 3D как для обнаружения "
"столкновений, так и для реагирования на них. Определение, какие из них "
"использовать в Вашем проекте, может оказаться сложным. Избежать проблем и "
"упростить разработку можно, если понимать, как работает каждый из них и "
"каковы его достоинства и недостатки."

msgid "In this guide, you will learn:"
msgstr "В этом руководстве вы узнаете:"

msgid "Godot's four collision object types"
msgstr "Четыре типа объектов столкновений в Godot"

msgid "How each collision object works"
msgstr "Как работает каждый объект столкновений"

msgid "When and why to choose one type over another"
msgstr "Когда и почему выбирать один тип среди других"

msgid ""
"This document's examples will use 2D objects. Every 2D physics object and "
"collision shape has a direct equivalent in 3D and in most cases they work in "
"much the same way."
msgstr ""
"В примерах этого документа будут использоваться 2D объекты. Каждый 2D "
"физический объект и форма столкновений имеют прямой эквивалент в 3D и в "
"большинстве случаев работают одинаковыми способами."

msgid "Collision objects"
msgstr "Объекты столкновений"

msgid ""
"Godot offers four kinds of physics bodies, extending :ref:`CollisionObject2D "
"<class_CollisionObject2D>`:"
msgstr ""
"Godot предлагает четыре вида физических тел, расширяющих :ref:"
"`CollisionObject2D <class_CollisionObject2D>`:"

msgid ":ref:`Area2D <class_Area2D>`"
msgstr ""

msgid ""
"``Area2D`` nodes provide **detection** and **influence**. They can detect "
"when objects overlap and can emit signals when bodies enter or exit. An "
"``Area2D`` can also be used to override physics properties, such as gravity "
"or damping, in a defined area."
msgstr ""
"Узлы ``Area2D`` обеспечивают **обнаружение** и **влияние**. Они могут "
"определять, когда объекты перекрываются, и испускать сигналы при входе или "
"выходе тел. Кроме того, ``Area2D`` можно использовать для переопределения "
"физических свойств, таких, как сила тяжести или упругость, в определенной "
"области."

msgid ""
"The other three bodies extend :ref:`PhysicsBody2D <class_PhysicsBody2D>`:"
msgstr ""
"Остальные три тела расширяют :ref:`PhysicsBody2D <class_PhysicsBody2D>`:"

msgid ":ref:`StaticBody2D <class_StaticBody2D>`"
msgstr ""

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. They are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"Статическое тело — это тело, которое не перемещается физическим движком. Оно "
"участвует в обнаружении столкновений, но не движется в ответ на "
"столкновение. Чаще всего используется для объектов, являющихся частью среды, "
"или не требующих какого-либо динамического поведения."

msgid ":ref:`RigidBody2D <class_RigidBody2D>`"
msgstr ""

msgid ""
"This is the node that implements simulated 2D physics. You do not control a "
"``RigidBody2D`` directly, but instead you apply forces to it (gravity, "
"impulses, etc.) and the physics engine calculates the resulting movement. :"
"ref:`Read more about using rigid bodies. <doc_rigid_body>`"
msgstr ""
"Это узел реализует симуляцию 2D физики. Вы не управляете RigidBody2D "
"напрямую, а прикладываете к нему силы (гравитация, импульсы и т. д.), и "
"физический движок вычисляет результирующее движение. :ref:`Подробнее об "
"использовании твёрдых тел. <doc_rigid_body>`"

msgid ":ref:`KinematicBody2D <class_KinematicBody2D>`"
msgstr ""

msgid ""
"A body that provides collision detection, but no physics. All movement and "
"collision response must be implemented in code."
msgstr ""
"Тело, которое обеспечивает обнаружение столкновений, но не физику. Все "
"движения и реакции на столкновения должны быть реализованы в коде."

msgid "Physics material"
msgstr "Физический материал"

msgid ""
"Static bodies and rigid bodies can be configured to use a :ref:`physics "
"material <class_PhysicsMaterial>`. This allows adjusting the friction and "
"bounce of an object, and set if it's absorbent and/or rough."
msgstr ""

msgid "Collision shapes"
msgstr "Виды и формы коллизий (столкновений)"

msgid ""
"A physics body can hold any number of :ref:`Shape2D <class_Shape2D>` objects "
"as children. These shapes are used to define the object's collision bounds "
"and to detect contact with other objects."
msgstr ""
"Физическое тело может содержать любое количество :ref:`Shape2D "
"<class_Shape2D>` объектов в качестве потомков. Эти формы используются для "
"определения границ столкновения объекта и обнаружения контакта с другими "
"объектами."

msgid ""
"In order to detect collisions, at least one ``Shape2D`` must be assigned to "
"the object."
msgstr ""
"Чтобы обнаруживать столкновения, объекту должен быть назначен хотя бы один "
"``Shape2D``."

msgid ""
"The most common way to assign a shape is by adding a :ref:`CollisionShape2D "
"<class_CollisionShape2D>` or :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>` as a child of the object. These nodes allow you "
"to draw the shape directly in the editor workspace."
msgstr ""
"Наиболее распространенным способом назначения формы является добавление :ref:"
"`CollisionShape2D <class_CollisionShape2D>` или :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>` как дочернего элемента объекта. Такие узлы "
"позволят Вам рисовать форму непосредственно в рабочем пространстве редактора."

msgid ""
"Be careful to never scale your collision shapes in the editor. The \"Scale\" "
"property in the Inspector should remain ``(1, 1)``. When changing the size "
"of the collision shape, you should always use the size handles, **not** the "
"``Node2D`` scale handles. Scaling a shape can result in unexpected collision "
"behavior."
msgstr ""
"Будьте осторожны и никогда не масштабируйте формы столкновений в редакторе. "
"Свойство «Масштаб» в инспекторе должно оставаться ``(1, 1)``. При изменении "
"размера формы столкновения всегда следует использовать параметры размера, а "
"не параметры масштаба ``Node2D``. Масштабирование формы может привести к "
"неожиданному поведению при столкновении."

msgid "Physics process callback"
msgstr "Обратный вызов для физических процессов"

msgid ""
"The physics engine may spawn multiple threads to improve performance, so it "
"can use up to a full frame to process physics. Because of this, the value of "
"a body's state variables such as ``position`` or ``linear velocity`` may not "
"be accurate for the current frame."
msgstr ""

msgid ""
"In order to avoid this inaccuracy, any code that needs to access a body's "
"properties should be run in the :ref:`Node._physics_process() "
"<class_Node_method__physics_process>` callback, which is called before each "
"physics step at a constant frame rate (60 times per second by default). This "
"method will be passed a ``delta`` parameter, which is a floating-point "
"number equal to the time passed in *seconds* since the last step. When using "
"the default 60 Hz physics update rate, it will typically be equal to "
"``0.01666...`` (but not always, see below)."
msgstr ""
"Чтобы избежать этой проблемы, любой код, которому требуется доступ к "
"свойствам тела, должен выполняться в обратном вызове :ref:`Node."
"_physics_process() <class_Node_method__physics_process>`, который вызывается "
"перед каждым шагом расчёта физики с постоянной частотой кадров (по умолчанию "
"60 раз в секунду). Этому методу будет передан параметр ``delta``, являющимся "
"числом с плавающей запятой, равным времени, прошедшему в секундах с момента "
"последнего шага. При использовании частоты обновления физики по умолчанию 60 "
"Гц она обычно будет равна ``0,01666...`` (но не всегда, см. ниже)."

msgid ""
"It's recommended to always use the ``delta`` parameter when relevant in your "
"physics calculations, so that the game behaves correctly if you change the "
"physics update rate or if the player's device can't keep up."
msgstr ""
"Рекомендуется всегда использовать параметр ``delta`` в Ваших физических "
"вычислениях, чтобы игра вела себя правильно, если Вы измените скорость "
"обновления физики, или если устройство игрока будет тормозить."

msgid "Collision layers and masks"
msgstr "Слои и маски столкновений"

msgid ""
"One of the most powerful, but frequently misunderstood, collision features "
"is the collision layer system. This system allows you to build up complex "
"interactions between a variety of objects. The key concepts are **layers** "
"and **masks**. Each ``CollisionObject2D`` has 20 different physics layers it "
"can interact with."
msgstr ""
"Одной из самых мощных, но часто неправильно понимаемых возможностей в "
"системе столкновений является система слоёв столкновений. Она позволяет "
"создавать сложные взаимодействия между различными объектами. Ключевыми "
"понятиями являются **слои** и **маски**. Каждый ``CollisionObject2D`` имеет "
"20 различных физических слоев, с которыми он может взаимодействовать."

msgid "Let's look at each of the properties in turn:"
msgstr "Рассмотрим каждое из свойств по очереди:"

msgid "collision_layer"
msgstr "collision_layеr"

msgid ""
"This describes the layers that the object appears **in**. By default, all "
"bodies are on layer ``1``."
msgstr ""
"Здесь описываются слои, на которых **отображается** объект. По умолчанию все "
"тела находятся на слое ``1``."

msgid "collision_mask"
msgstr "collision_mаsk"

msgid ""
"This describes what layers the body will **scan** for collisions. If an "
"object isn't in one of the mask layers, the body will ignore it. By default, "
"all bodies scan layer ``1``."
msgstr ""
"Здесь описываются слои, которые будут использоваться для **сканирования** "
"телом столкновений. Если объект не находится в одном из слоев маски, тело "
"игнорирует его. По умолчанию все тела сканируют слой ``1``."

msgid ""
"These properties can be configured via code, or by editing them in the "
"Inspector."
msgstr ""
"Эти свойства можно настроить с помощью кода или путем их редактирования в "
"инспекторе."

msgid ""
"Keeping track of what you're using each layer for can be difficult, so you "
"may find it useful to assign names to the layers you're using. Names can be "
"assigned in Project Settings -> Layer Names."
msgstr ""
"Отслеживать, для чего используется каждый слой, может быть затруднительно, "
"поэтому может оказаться полезным назначить имена используемым слоям. Имена "
"можно присвоить в меню Настройки проекта - > Имена слоев."

msgid "GUI example"
msgstr "Пример GUI"

msgid ""
"You have four node types in your game: Walls, Player, Enemy, and Coin. Both "
"Player and Enemy should collide with Walls. The Player node should detect "
"collisions with both Enemy and Coin, but Enemy and Coin should ignore each "
"other."
msgstr ""
"В игре есть четыре типа узлов: «Стены», «Игрок», «Враг» и «Монета». И Игрок, "
"и Враг должны сталкиваться со стенами. Узел Игрок должен обнаруживать "
"столкновения как с Враг, так и с Монета, но Враг и Монета должны "
"игнорировать друг друга."

msgid ""
"Start by naming layers 1-4 \"walls\", \"player\", \"enemies\", and \"coins\" "
"and place each node type in its respective layer using the \"Layer\" "
"property. Then set each node's \"Mask\" property by selecting the layers it "
"should interact with. For example, the Player's settings would look like "
"this:"
msgstr ""
"Начните с именования слоев 1-4: «walls», «player», «enemies» и «coins» и "
"поместите каждый тип узла в соответствующий слой с помощью свойства «Слой». "
"Затем задайте свойство «Маска» каждого узла, выбрав слои, с которыми он "
"должен взаимодействовать. Например, настройки игрока будут выглядеть "
"следующим образом:"

msgid "Code example"
msgstr "Пример кода"

msgid ""
"In function calls, layers are specified as a bitmask. Where a function "
"enables all layers by default, the layer mask will be given as "
"``0x7fffffff``. Your code can use binary, hexadecimal, or decimal notation "
"for layer masks, depending on your preference."
msgstr ""
"В вызовах функций слои задаются как битовая маска. Если функция включает все "
"слои по умолчанию, маска слоя будет задана как ``0x7fffffff``. Код может "
"использовать двоичное, шестнадцатеричное или десятичное представление для "
"масок слоев в зависимости от предпочтений пользователя."

msgid ""
"The code equivalent of the above example where layers 1, 3 and 4 were "
"enabled would be as follows::"
msgstr ""
"Код, эквивалентный приведенному выше примеру, в котором были включены уровни "
"1, 3 и 4, будет следующим:"

msgid "Area2D"
msgstr "Area2D"

msgid ""
"Area nodes provide **detection** and **influence**. They can detect when "
"objects overlap and emit signals when bodies enter or exit. Areas can also "
"be used to override physics properties, such as gravity or damping, in a "
"defined area."
msgstr ""
"Узлы областей обеспечивают **обнаружение ** и **влияние**. Они могут "
"обнаруживать перекрытия объектов и испускать сигналы при входе или выходе "
"тел. Области также могут использоваться для переопределения физических "
"свойств, таких как сила тяжести или упругости в определенной области."

msgid "There are three main uses for :ref:`Area2D <class_Area2D>`:"
msgstr "Есть три основных варианта использования :ref:`Area2D <class_Area2D>`:"

msgid "Overriding physics parameters (such as gravity) in a given region."
msgstr ""
"Переопределение физических параметров (таких как гравитация) в данной "
"области."

msgid ""
"Detecting when other bodies enter or exit a region or what bodies are "
"currently in a region."
msgstr ""
"Обнаружение, когда другие тела входят или выходят из области или какие тела "
"находятся в настоящее время в области."

msgid "Checking other areas for overlap."
msgstr "Проверка других областей на перекрытие."

msgid "By default, areas also receive mouse and touchscreen input."
msgstr ""
"По умолчанию области также получают ввод с помощью мыши и сенсорного экрана."

msgid "StaticBody2D"
msgstr "StaticBоdy2D"

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. However, it can impart motion or rotation to a colliding body "
"**as if** it were moving, using its ``constant_linear_velocity`` and "
"``constant_angular_velocity`` properties."
msgstr ""
"Статическое тело — это тело, которое не перемещается физическим движком. Оно "
"участвует в обнаружении столкновений, но не движется в ответ на "
"столкновение. Однако, оно может передавать движение или вращение "
"столкнувшемуся телу, **как если бы** оно двигалось, используя его "
"свойства``constant_linear_velocity`` и ``constant_angular_velocity``."

msgid ""
"``StaticBody2D`` nodes are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"Узлы ``StaticBody2D`` чаще всего используются для объектов, которые являются "
"частью среды, или которым не требуется какое-либо динамическое поведение."

msgid "Example uses for ``StaticBody2D``:"
msgstr "Примеры использования ``StaticBody2D``:"

msgid "Platforms (including moving platforms)"
msgstr "Платформы (включая движущиеся платформы)"

msgid "Conveyor belts"
msgstr "Конвейерные ленты"

msgid "Walls and other obstacles"
msgstr "Стены и другие препятствия"

msgid "RigidBody2D"
msgstr "RigidBоdy2D"

msgid ""
"This is the node that implements simulated 2D physics. You do not control a :"
"ref:`RigidBody2D <class_RigidBody2D>` directly. Instead, you apply forces to "
"it and the physics engine calculates the resulting movement, including "
"collisions with other bodies, and collision responses, such as bouncing, "
"rotating, etc."
msgstr ""
"Реализует симуляцию 2D-физики. Вы не управляете :ref:`RigidBody2D "
"<class_RigidBody2D>` напрямую. Вместо этого к нему применяются силы, и "
"физический движок вычисляет результирующее движение, включая столкновения с "
"другими телами и реакции на столкновения, такие как отскок, поворот и т.д."

msgid ""
"You can modify a rigid body's behavior via properties such as \"Mass\", "
"\"Friction\", or \"Bounce\", which can be set in the Inspector."
msgstr ""
"Поведение твёрдого тела можно изменить с помощью таких свойств, как «Масса», "
"«Трение» или «Отскок», которые можно задать в инспекторе."

msgid ""
"The body's behavior is also affected by the world's properties, as set in "
"`Project Settings -> Physics`, or by entering an :ref:`Area2D "
"<class_Area2D>` that is overriding the global physics properties."
msgstr ""
"На поведение тела также влияют свойства мира, заданные в `Свойства проекта - "
"> Физика`, или вход в :ref:`Area2D <class_Area2D>`, переопределяющего "
"глобальные свойства физики."

msgid ""
"When a rigid body is at rest and hasn't moved for a while, it goes to sleep. "
"A sleeping body acts like a static body, and its forces are not calculated "
"by the physics engine. The body will wake up when forces are applied, either "
"by a collision or via code."
msgstr ""
"Когда твёрдое тело находится в состоянии покоя и какое-то время не "
"двигалось, оно «засыпает». Спящее тело ведёт себя как статическое тело, и "
"его силы не рассчитываются физическим движком. Тело будет просыпаться либо "
"при приложении сил, либо при столкновении, либо при помощи кода."

msgid "Rigid body modes"
msgstr "Режимы твёрдого тела"

msgid "A rigid body can be set to one of four modes:"
msgstr "Твёрдое тело может быть установлено в один из четырех режимов:"

msgid ""
"**Rigid** - The body behaves as a physical object. It collides with other "
"bodies and responds to forces applied to it. This is the default mode."
msgstr ""
"**Твёрдое** — тело ведет себя как физический объект. Оно сталкивается с "
"другими телами и реагирует на приложенные к нему силы. Это режим по "
"умолчанию."

msgid ""
"**Static** - The body behaves like a :ref:`StaticBody2D "
"<class_StaticBody2D>` and does not move."
msgstr ""
"**Статичное** — тело ведет себя как :ref:`StaticBody2D <class_StaticBody2D>` "
"и не двигается."

msgid "**Character** - Similar to \"Rigid\" mode, but the body cannot rotate."
msgstr ""
"**Персонаж** — аналогично режиму «Твёрдое», но тело не может вращаться."

msgid ""
"**Kinematic** - The body behaves like a :ref:`KinematicBody2D "
"<class_KinematicBody2D>` and must be moved by code."
msgstr ""
"**Кинематическое** — Тело ведет себя как :ref:`KinematicBody2D "
"<class_KinematicBody2D>` и должно перемещаться кодом."

msgid "Using RigidBody2D"
msgstr "Использование RigidBody2D"

msgid ""
"One of the benefits of using a rigid body is that a lot of behavior can be "
"had \"for free\" without writing any code. For example, if you were making "
"an \"Angry Birds\"-style game with falling blocks, you would only need to "
"create RigidBody2Ds and adjust their properties. Stacking, falling, and "
"bouncing would automatically be calculated by the physics engine."
msgstr ""
"Одним из преимуществ использования жесткого тела является то, что различные "
"поведения можно получить «бесплатно», без написания какого-либо кода. "
"Например, если бы Вы делали игру в стиле «Angry Birds» с падающими блоками, "
"Вам нужно было бы просто создать различные RigidBody2D и скорректировать их "
"свойства. Штабелирование, падение и отскок будут автоматически "
"рассчитываться с помощью физического движка."

msgid ""
"However, if you do wish to have some control over the body, you should take "
"care - altering the ``position``, ``linear_velocity``, or other physics "
"properties of a rigid body can result in unexpected behavior. If you need to "
"alter any of the physics-related properties, you should use the :ref:"
"`_integrate_forces() <class_RigidBody2D_method__integrate_forces>` callback "
"instead of ``_physics_process()``. In this callback, you have access to the "
"body's :ref:`Physics2DDirectBodyState <class_Physics2DDirectBodyState>`, "
"which allows for safely changing properties and synchronizing them with the "
"physics engine."
msgstr ""
"Однако, если вы хотите иметь некоторый контроль над телом, Вам следует быть "
"осторожным — изменение ``position``, ``linear_velocity`` или других "
"физических свойств твёрдого тела может привести к неожиданному поведению. "
"Если необходимо изменить какое-либо из связанных с физикой свойств, следует "
"использовать обратный вызов :ref:`_integrate_forces() "
"<class_RigidBody2D_method__integrate_forces>`вместо ``_physics_process ()``. "
"В этом обратном вызове вы имеете доступ к :ref:`Physics2DDirectBodyState "
"<class_Physics2DDirectBodyState>` тела, что позволяет безопасно изменять "
"свойства и синхронизировать их с физическим движком."

msgid "For example, here is the code for an \"Asteroids\" style spaceship:"
msgstr "Например, вот код космического корабля в стиле «Asterioids»:"

msgid ""
"Note that we are not setting the ``linear_velocity`` or ``angular_velocity`` "
"properties directly, but rather applying forces (``thrust`` and ``torque``) "
"to the body and letting the physics engine calculate the resulting movement."
msgstr ""
"Обратите внимание, что мы не устанавливаем свойства ``linear_velocity`` или "
"``angular_velocity`` напрямую, а, скорее, прикладываем силы (``thrust`` и "
"``torque``) к телу и позволяем физическому движку рассчитать результирующее "
"движение."

msgid ""
"When a rigid body goes to sleep, the ``_integrate_forces()`` function will "
"not be called. To override this behavior, you will need to keep the body "
"awake by creating a collision, applying a force to it, or by disabling the :"
"ref:`can_sleep <class_RigidBody2D_property_can_sleep>` property. Be aware "
"that this can have a negative effect on performance."
msgstr ""
"Когда жесткое тело переходит в спящий режим, функция ``_integrate_forces()`` "
"не вызывается. Чтобы переопределить это поведение, необходимо сохранить тело "
"в рабочем состоянии, создав столкновение, применив к нему силу или отключив "
"свойство :ref:`can_sleep <class_RigidBody2D_property_can_sleep>`. Помните, "
"что это может негативно сказаться на производительности."

msgid "Contact reporting"
msgstr "Отслеживание контактов"

msgid ""
"By default, rigid bodies do not keep track of contacts, because this can "
"require a huge amount of memory if many bodies are in the scene. To enable "
"contact reporting, set the :ref:`contacts_reported "
"<class_RigidBody2D_property_contacts_reported>` property to a non-zero "
"value. The contacts can then be obtained via :ref:`Physics2DDirectBodyState."
"get_contact_count() "
"<class_Physics2DDirectBodyState_method_get_contact_count>` and related "
"functions."
msgstr ""
"По умолчанию твёрдые тела не отслеживают контакты, поскольку это может "
"потребовать огромного объема памяти, если в сцене находится много тел. Чтобы "
"включить отслеживание контактов, задайте для свойства :ref:"
"`contacts_reported <class_RigidBody2D_property_contacts_reported>` ненулевое "
"значение. Контакты могут быть получены через :ref:`Physics2DDirectBodyState."
"get_contact_count() "
"<class_Physics2DDirectBodyState_method_get_contact_count>` и связанные с ним "
"функции."

msgid ""
"Contact monitoring via signals can be enabled via the :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>` property. See :ref:"
"`RigidBody2D <class_RigidBody2D>` for the list of available signals."
msgstr ""
"Мониторинг контактов через сигналы можно включить с помощью свойства :ref:"
"`contact_monitor <class_RigidBody2D_property_contact_monitor>`. Список "
"доступных сигналов см. в разделе :ref:`RigidBody2D <class_RigidBody2D>`."

msgid "KinematicBody2D"
msgstr "KinematicBоdy2D"

msgid ""
":ref:`KinematicBody2D <class_KinematicBody2D>` bodies detect collisions with "
"other bodies, but are not affected by physics properties like gravity or "
"friction. Instead, they must be controlled by the user via code. The physics "
"engine will not move a kinematic body."
msgstr ""
":ref:`KinematicBody2D <class_KinematicBody2D>` обнаруживают столкновения с "
"другими телами, но на них не влияют физические свойства, такие как "
"гравитация или трение. Вместо этого они должны управляться пользователем "
"через код. Физический движок не будет перемещать кинематическое тело."

msgid ""
"When moving a kinematic body, you should not set its ``position`` directly. "
"Instead, you use the ``move_and_collide()`` or ``move_and_slide()`` methods. "
"These methods move the body along a given vector, and it will instantly stop "
"if a collision is detected with another body. After the body has collided, "
"any collision response must be coded manually."
msgstr ""
"При перемещении кинематического тела не следует устанавливать его "
"``position`` непосредственно. Вместо этого используются методы "
"``move_and_collide()`` или ``move_and_slide()``. Эти методы перемещают тело "
"по заданному вектору, и оно мгновенно останавливается, если обнаруживается "
"столкновение с другим телом. После того как тело столкнулось, любая реакция "
"на столкновение должна быть закодирована вручную."

msgid "Kinematic collision response"
msgstr "Реакция кинематического тела на столкновение"

msgid ""
"After a collision, you may want the body to bounce, to slide along a wall, "
"or to alter the properties of the object it hit. The way you handle "
"collision response depends on which method you used to move the "
"KinematicBody2D."
msgstr ""
"После столкновения тело может отскочить, начать скользить по стене или "
"изменить свойства объекта, в который оно попало. Способ обработки реакции на "
"столкновение зависит от способа перемещения KinematicBody2D."

msgid ":ref:`move_and_collide <class_KinematicBody2D_method_move_and_collide>`"
msgstr ""

msgid ""
"When using ``move_and_collide()``, the function returns a :ref:"
"`KinematicCollision2D <class_KinematicCollision2D>` object, which contains "
"information about the collision and the colliding body. You can use this "
"information to determine the response."
msgstr ""
"При использовании ``move_and_collide()`` функция возвращает объект :ref:"
"`KinematicCollision2D <class_KinematicCollision2D>`, который содержит "
"информацию о столкновении и столкнувшемся теле. Эту информацию можно "
"использовать для определения реакции."

msgid ""
"For example, if you want to find the point in space where the collision "
"occurred:"
msgstr ""
"Например, если нужно найти точку в пространстве, где произошло столкновение:"

msgid "Or to bounce off of the colliding object:"
msgstr "Или отскочить от объекта, с которым столкнулись:"

msgid ":ref:`move_and_slide <class_KinematicBody2D_method_move_and_slide>`"
msgstr ""

msgid ""
"Sliding is a common collision response; imagine a player moving along walls "
"in a top-down game or running up and down slopes in a platformer. While it's "
"possible to code this response yourself after using ``move_and_collide()``, "
"``move_and_slide()`` provides a convenient way to implement sliding movement "
"without writing much code."
msgstr ""
"Скольжение является общей реакцией на столкновение; представьте себе игрока, "
"движущегося вдоль стен в игре с видом сверху, или бегающего вверх и вниз по "
"склонам в платформере. Хотя этот ответ и можно закодировать самостоятельно "
"после использования ``move_and_collide()``, ``move_and_slide()`` "
"обеспечивает более удобный способ реализации скользящего движения без "
"написания большого количества кода."

msgid ""
"``move_and_slide()`` automatically includes the timestep in its calculation, "
"so you should **not** multiply the velocity vector by ``delta``."
msgstr ""
"``move_and_slide()`` автоматически включает временной интервал в свои "
"расчеты, поэтому **не умножайте** вектор скорости на ``delta``."

msgid ""
"For example, use the following code to make a character that can walk along "
"the ground (including slopes) and jump when standing on the ground:"
msgstr ""
"Например, используйте следующий код для создания персонажа, который может "
"ходить по земле (включая уклоны) и прыгать, когда стоит на земле:"

msgid ""
"See :ref:`doc_kinematic_character_2d` for more details on using "
"``move_and_slide()``, including a demo project with detailed code."
msgstr ""
"Дополнительные сведения по использованию ``move_and_slide()`` см. в разделе :"
"ref:`doc_kinematic_character_2d`, включая демонстрационный проект с "
"подробным кодом."

msgid "Translation status"
msgstr "Translation status (статус перевода)"
