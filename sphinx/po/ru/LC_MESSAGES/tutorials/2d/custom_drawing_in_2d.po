# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 18:00+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom drawing in 2D"
msgstr "Пользовательская отрисовка в 2D"

msgid "Introduction"
msgstr "Введение"

#, fuzzy
msgid ""
"Godot has nodes to draw sprites, polygons, particles, and all sorts of "
"stuff. For most cases, this is enough. If there's no node to draw something "
"specific you need, you can make any 2D node (for example, :ref:`Control "
"<class_Control>` or :ref:`Node2D <class_Node2D>` based) draw custom commands."
msgstr ""
"В Godot есть узлы для рисования спрайтов, многоугольников, частиц и прочего. "
"В большинстве случаев этого достаточно; но не всегда. Прежде чем плакать от "
"страха, тоски и ярости из-за того, что узла для рисования этого конкретного "
"*чего-то* не существует... было бы хорошо знать, что можно легко заставить "
"любой 2D-узел (на основе :ref:`Control < class_Control> `или :ref:` Node2D "
"<class_Node2D> `) рисовать пользовательские команды. Также это "
"*действительно* легко сделать."

msgid ""
"Custom drawing in a 2D node is *really* useful. Here are some use cases:"
msgstr ""
"Пользовательский рисунок в 2D узле *действительно* полезен.Вот несколько "
"примеров, почему:"

msgid ""
"Drawing shapes or logic that existing nodes can't do, such as an image with "
"trails or a special animated polygon."
msgstr ""
"Рисование фигур или логики, которые не обрабатываются узлами (пример: "
"создание узла, который рисует круг, изображение со следами, особый вид "
"анимированного многоугольника и т. д.)."

msgid ""
"Visualizations that are not that compatible with nodes, such as a tetris "
"board. (The tetris example uses a custom draw function to draw the blocks.)"
msgstr ""
"Визуализации, несовместимые с узлами, как доска тетриса. (В примере с "
"тетрисом для рисования блоков используется пользовательская функция "
"рисования блоков.)"

msgid ""
"Drawing a large number of simple objects. Custom drawing avoids the overhead "
"of using a large number of nodes, possibly lowering memory usage and "
"improving performance."
msgstr ""
"Рисование большого количества простых объектов. Пользовательское рисование "
"позволяет избежать накладных расходов при использовании большого количества "
"узлов, что может снизить использование памяти и улучшить производительность."

msgid ""
"Making a custom UI control. There are plenty of controls available, but when "
"you have unusual needs, you will likely need a custom control."
msgstr ""
"Создание пользовательского элемента управления пользовательского интерфейса "
"(UI). Существует множество доступных элементов управления, но когда у вас "
"есть нестандартные требования, вероятно, вам потребуется создать собственный "
"элемент управления."

msgid "Drawing"
msgstr "Отрисовка"

msgid ""
"Add a script to any :ref:`CanvasItem <class_CanvasItem>` derived node, like :"
"ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`. Then override "
"the ``_draw()`` function."
msgstr ""
"Добавьте сценарий к любому производному узлу :ref:`CanvasItem "
"<class_CanvasItem>`, например :ref:`Control <class_Control>` или :ref:"
"`Node2D <class_Node2D>`. Затем переопределите функцию ``_draw ()``."

msgid ""
"Draw commands are described in the :ref:`CanvasItem <class_CanvasItem>` "
"class reference. There are plenty of them."
msgstr ""
"Команды рисования описаны в справочнике по классу :ref:`CanvasItem "
"<class_CanvasItem>`. Их много."

msgid "Updating"
msgstr "Обновление"

msgid ""
"The ``_draw()`` function is only called once, and then the draw commands are "
"cached and remembered, so further calls are unnecessary."
msgstr ""
"Функция ``_draw ()`` вызывается только один раз, а затем команды рисования "
"кэшируются и запоминаются, поэтому дальнейшие вызовы не нужны."

#, fuzzy
msgid ""
"If re-drawing is required because a state or something else changed, call :"
"ref:`CanvasItem.queue_redraw() <class_CanvasItem_method_queue_redraw>` in "
"that same node and a new ``_draw()`` call will happen."
msgstr ""
"Если требуется повторная отрисовка из-за того, что состояние или что-то ещё "
"изменилось, просто вызовите :ref:`CanvasItem.update () "
"<class_CanvasItem_method_update>` в том же узле, и произойдёт новый вызов "
"``_draw ()``."

msgid ""
"Here is a little more complex example, a texture variable that will be "
"redrawn if modified:"
msgstr ""
"Вот немного более сложный пример, переменная текстуры, которая будет "
"перерисована при изменении:"

#, fuzzy
msgid ""
"In some cases, it may be desired to draw every frame. For this, call "
"``queue_redraw()`` from the ``_process()`` callback, like this:"
msgstr ""
"В некоторых случаях может потребоваться отрисовка каждого кадра. Для этого "
"просто вызовите ``update ()`` из обратного вызова ``_process ()``, например:"

msgid "Coordinates"
msgstr "Координаты"

msgid ""
"The drawing API uses the CanvasItem's coordinate system, not necessarily "
"pixel coordinates. Which means it uses the coordinate space created after "
"applying the CanvasItem's transform. Additionally, you can apply a custom "
"transform on top of it by using :ref:"
"`draw_set_transform<class_CanvasItem_method_draw_set_transform>` or :ref:"
"`draw_set_transform_matrix<class_CanvasItem_method_draw_set_transform_matrix>`."
msgstr ""

msgid ""
"When using ``draw_line``, you should consider the width of the line. When "
"using a width that is an odd size, the position should be shifted by ``0.5`` "
"to keep the line centered as shown below."
msgstr ""

msgid "The same applies to the ``draw_rect`` method with ``filled = false``."
msgstr ""

msgid "An example: drawing circular arcs"
msgstr "Пример: рисование дуг окружности"

msgid ""
"We will now use the custom drawing functionality of the Godot Engine to draw "
"something that Godot doesn't provide functions for. As an example, Godot "
"provides a ``draw_circle()`` function that draws a whole circle. However, "
"what about drawing a portion of a circle? You will have to code a function "
"to perform this and draw it yourself."
msgstr ""
"Теперь мы будем использовать пользовательские функции рисования Godot "
"Engine, чтобы рисовать то, для чего Godot не предоставляет функций. В "
"качестве примера Godot предоставляет функцию ``draw_circle ()``, которая "
"рисует весь круг. Однако как насчет рисования части круга? Вам нужно будет "
"написать функцию для этого и нарисовать ее самостоятельно."

msgid "Arc function"
msgstr "Функция дуги"

msgid ""
"An arc is defined by its support circle parameters, that is, the center "
"position and the radius. The arc itself is then defined by the angle it "
"starts from and the angle at which it stops. These are the 4 arguments that "
"we have to provide to our drawing function. We'll also provide the color "
"value, so we can draw the arc in different colors if we wish."
msgstr ""
"Дуга определяется параметрами опорной окружности, то есть положением центра "
"и радиусом. Сама дуга затем определяется углом, с которого она начинается, и "
"углом, под которым она заканчивается. Это 4 аргумента, которые мы должны "
"предоставить нашей функции рисования. Мы также предоставим значение цвета, "
"чтобы при желании можно было нарисовать дугу разными цветами."

msgid ""
"Basically, drawing a shape on the screen requires it to be decomposed into a "
"certain number of points linked from one to the next. As you can imagine, "
"the more points your shape is made of, the smoother it will appear, but the "
"heavier it will also be in terms of processing cost. In general, if your "
"shape is huge (or in 3D, close to the camera), it will require more points "
"to be drawn without it being angular-looking. On the contrary, if your shape "
"is small (or in 3D, far from the camera), you may decrease its number of "
"points to save processing costs; this is known as *Level of Detail (LOD)*. "
"In our example, we will simply use a fixed number of points, no matter the "
"radius."
msgstr ""
"По сути, рисование фигуры на экране требует, чтобы она была разложена на "
"определенное количество точек, связанных между собой. Как вы понимаете, чем "
"из большего количества точек состоит ваша фигура, тем более гладкой она "
"будет выглядеть, но тем тяжелее она будет также с точки зрения затрат на "
"обработку. В общем, если ваша фигура огромна (или в 3D, близко к камере), "
"для ее рисования потребуется больше точек, но она не будет угловатой. "
"Напротив, если ваша фигура маленькая (или в 3D, вдали от камеры), вы можете "
"уменьшить количество точек, чтобы сократить затраты на обработку; это "
"известно как *Уровень Детализации (LOD)*. В нашем примере мы просто будем "
"использовать фиксированное количество точек независимо от радиуса."

#, fuzzy
msgid ""
"Remember the number of points our shape has to be decomposed into? We fixed "
"this number in the ``nb_points`` variable to a value of ``32``. Then, we "
"initialize an empty ``PackedVector2Array``, which is simply an array of "
"``Vector2``\\ s."
msgstr ""
"Помните, на сколько точек нужно разложить нашу фигуру? Мы зафиксировали это "
"число в переменной ``nb_points`` на значение ``32``. Затем мы инициализируем "
"пустой ``PoolVector2Array``, который представляет собой просто массив "
"``Vector2 ``\\s."

msgid ""
"The next step consists of computing the actual positions of these 32 points "
"that compose an arc. This is done in the first for-loop: we iterate over the "
"number of points for which we want to compute the positions, plus one to "
"include the last point. We first determine the angle of each point, between "
"the starting and ending angles."
msgstr ""
"Следующий шаг состоит в вычислении фактического положения этих 32 точек, "
"составляющих дугу. Это делается в первом цикле for: мы перебираем количество "
"точек, для которых мы хотим вычислить позиции, плюс одна, чтобы включить "
"последнюю точку. Сначала мы определяем угол каждой точки между начальным и "
"конечным углами."

#, fuzzy
msgid ""
"The reason why each angle is decreased by 90° is that we will compute 2D "
"positions out of each angle using trigonometry (you know, cosine and sine "
"stuff...). However, ``cos()`` and ``sin()`` use radians, not degrees. The "
"angle of 0° (0 radian) starts at 3 o'clock, although we want to start "
"counting at 12 o'clock. So we decrease each angle by 90° in order to start "
"counting from 12 o'clock."
msgstr ""
"Причина, по которой каждый угол уменьшается на 90°, заключается в том, что "
"мы будем вычислять 2D-положения для каждого угла, используя тригонометрию "
"(вы знаете, косинус и синус...). Однако для простоты ``cos ()`` и ``sin ()`` "
"используют радианы, а не градусы. Угол 0° (0 радиан) начинается с 3 часов, "
"хотя мы хотим начать отсчет с 12 часов. Таким образом, мы уменьшаем каждый "
"угол на 90 °, чтобы начать отсчет с 12 часов."

#, fuzzy
msgid ""
"The actual position of a point located on a circle at angle ``angle`` (in "
"radians) is given by ``Vector2(cos(angle), sin(angle))``. Since ``cos()`` "
"and ``sin()`` return values between -1 and 1, the position is located on a "
"circle of radius 1. To have this position on our support circle, which has a "
"radius of ``radius``, we simply need to multiply the position by ``radius``. "
"Finally, we need to position our support circle at the ``center`` position, "
"which is performed by adding it to our ``Vector2`` value. Finally, we insert "
"the point in the ``PackedVector2Array`` which was previously defined."
msgstr ""
"Фактическое положение точки, расположенной на окружности под углом ``angle`` "
"(в радианах), определяется как ``Vector2(cos (angle), sin (angle))``. Так "
"как ``cos ()`` и ``sin ()`` возвращают значения от -1 до 1, позиция "
"находится на окружности с радиусом 1. Чтобы это положение было на нашей "
"опорной окружности, которая имеет радиус ``radius``, нам просто нужно "
"умножить позицию на ``radius``. Наконец, нам нужно расположить наш опорный "
"круг в ``центральном`` положении, что выполняется путем добавления его к "
"нашему значению ``Vector2``. Наконец, мы вставляем точку в массив "
"``PoolVector2Array``, который был определен ранее."

msgid ""
"Now, we need to actually draw our points. As you can imagine, we will not "
"simply draw our 32 points: we need to draw everything that is between each "
"of them. We could have computed every point ourselves using the previous "
"method, and drew it one by one. But this is too complicated and inefficient "
"(except if explicitly needed), so we simply draw lines between each pair of "
"points. Unless the radius of our support circle is big, the length of each "
"line between a pair of points will never be long enough to see them. If that "
"were to happen, we would simply need to increase the number of points."
msgstr ""
"Теперь нам нужно на самом нарисовать наши точки. Как вы можете себе "
"представить, мы не просто нарисуем наши 32 точки: нам нужно нарисовать все, "
"что находится между каждой из них. Мы могли бы сами вычислить каждую точку, "
"используя предыдущий метод, и нарисовать ее одну за другой. Но это слишком "
"сложно и неэффективно (за исключением случаев, когда это явно необходимо), "
"поэтому мы просто проводим линии между каждой парой точек. Если радиус "
"нашего круга поддержки не велик, длина каждой линии между парой точек "
"никогда не будет достаточной, чтобы их увидеть. Если бы это произошло, нам "
"просто нужно было бы увеличить количество точек."

msgid "Draw the arc on the screen"
msgstr "Отрисовка дуги на экране"

msgid ""
"We now have a function that draws stuff on the screen; it is time to call it "
"inside the ``_draw()`` function:"
msgstr ""
"Теперь у нас есть функция, которая рисует что-то на экране; пришло время "
"вызвать ее внутри функции ``_draw ()``:"

msgid "Result:"
msgstr "Результат:"

msgid "Arc polygon function"
msgstr "Функция сегмента"

msgid ""
"We can take this a step further and not only write a function that draws the "
"plain portion of the disc defined by the arc, but also its shape. The method "
"is exactly the same as before, except that we draw a polygon instead of "
"lines:"
msgstr ""
"Мы можем сделать шаг вперед и не только написать функцию, которая рисует "
"простую часть диска, определенную дугой, но и ее форму. Метод точно такой "
"же, как и раньше, за исключением того, что мы рисуем многоугольник вместо "
"линий:"

msgid "Dynamic custom drawing"
msgstr "Динамическое пользовательское рисование"

msgid ""
"All right, we are now able to draw custom stuff on the screen. However, it "
"is static; let's make this shape turn around the center. The solution to do "
"this is simply to change the angle_from and angle_to values over time. For "
"our example, we will simply increment them by 50. This increment value has "
"to remain constant or else the rotation speed will change accordingly."
msgstr ""
"Хорошо, теперь мы можем рисовать на экране пользовательские объекты. Однако "
"они статичны; давайте заставим эту фигуру вращаться вокруг центра. Решение "
"состоит в том, чтобы просто изменять значения angle_from и angle_to с "
"течением времени. Для нашего примера мы просто увеличим их на 50. Это "
"значение приращения должно оставаться постоянным, иначе скорость вращения "
"соответственно изменится."

msgid ""
"First, we have to make both angle_from and angle_to variables global at the "
"top of our script. Also note that you can store them in other nodes and "
"access them using ``get_node()``."
msgstr ""
"Во-первых, мы должны сделать переменные angle_from и angle_to глобальными в "
"верхней части нашего скрипта. Также обратите внимание, что вы можете хранить "
"их в других узлах и получать к ним доступ с помощью ``get_node()``."

msgid "We make these values change in the _process(delta) function."
msgstr "Мы изменяем эти значения в функции _process(delta)."

msgid ""
"We also increment our angle_from and angle_to values here. However, we must "
"not forget to ``wrap()`` the resulting values between 0 and 360°! That is, "
"if the angle is 361°, then it is actually 1°. If you don't wrap these "
"values, the script will work correctly, but the angle values will grow "
"bigger and bigger over time until they reach the maximum integer value Godot "
"can manage (``2^31 - 1``). When this happens, Godot may crash or produce "
"unexpected behavior."
msgstr ""
"Здесь мы также увеличиваем наши значения angle_from и angle_to. Однако мы не "
"должны забывать применять ``wrap()`` в диапазоне от 0 до 360° для "
"результирующих значений! То есть, если угол равен 361°, то на самом деле он "
"равен 1°. Если вы не обернете эти значения, скрипт будет работать правильно, "
"но значения угла будут со временем увеличиваться и увеличиваться, пока не "
"достигнут максимального целочисленного значения, которым может управлять "
"Godot (``2^31 - 1``). Когда это произойдет, Godot может выйти из строя или "
"привести к неожиданному поведению."

#, fuzzy
msgid ""
"Finally, we must not forget to call the ``queue_redraw()`` function, which "
"automatically calls ``_draw()``. This way, you can control when you want to "
"refresh the frame."
msgstr ""
"Наконец, мы не должны забывать вызывать функцию ``update()``, которая "
"автоматически вызывает ``_draw()``. Таким образом, вы можете контролировать, "
"когда вы хотите обновить кадр."

msgid ""
"Also, don't forget to modify the ``_draw()`` function to make use of these "
"variables:"
msgstr ""
"Кроме того, не забудьте изменить функцию ``_draw()``, чтобы использовать эти "
"переменные:"

msgid ""
"Let's run! It works, but the arc is rotating insanely fast! What's wrong?"
msgstr ""
"Давайте запустим! Это работает, но дуга вращается безумно быстро! Что не так?"

msgid ""
"The reason is that your GPU is actually displaying the frames as fast as it "
"can. We need to \"normalize\" the drawing by this speed; to achieve that, we "
"have to make use of the ``delta`` parameter of the ``_process()`` function. "
"``delta`` contains the time elapsed between the two last rendered frames. It "
"is generally small (about 0.0003 seconds, but this depends on your "
"hardware), so using ``delta`` to control your drawing ensures that your "
"program runs at the same speed on everybody's hardware."
msgstr ""
"Причина в том, что ваш графический процессор на самом деле отображает кадры "
"так быстро, как только может. Нам нужно \"нормализовать\" рисунок под эту "
"скорость; для этого мы должны использовать параметр ``delta`` функции "
"``_process ()``. ``delta`` содержит время, прошедшее между двумя последними "
"отрисованными кадрами. Как правило, он невелик (около 0,0003 секунды, но это "
"зависит от вашего оборудования), поэтому использование ``delta`` для "
"управления вашим рисунком гарантирует, что ваша программа будет работать с "
"одинаковой скоростью на любом оборудовании."

msgid ""
"In our case, we simply need to multiply our ``rotation_angle`` variable by "
"``delta`` in the ``_process()`` function. This way, our 2 angles will be "
"increased by a much smaller value, which directly depends on the rendering "
"speed."
msgstr ""
"В нашем случае нам просто нужно умножить нашу переменную ``rotation_angle`` "
"на ``delta`` в функции ``_process()``. Таким образом, наши 2 угла будут "
"увеличены на гораздо меньшее значение, которое напрямую зависит от скорости "
"рендеринга."

msgid "Let's run again! This time, the rotation displays fine!"
msgstr "Давайте снова запустим! На этот раз вращение отображается правильно!"

msgid "Antialiased drawing"
msgstr "**Сглаживание**"

#, fuzzy
msgid ""
"Godot offers method parameters in :ref:"
"`draw_line<class_CanvasItem_method_draw_line>` to enable antialiasing, but "
"not all custom drawing methods offer this ``antialiased`` parameter."
msgstr ""
"Godot предлагает параметры метода в :ref:"
"`draw_line<class_CanvasItem_method_draw_line>` для включения сглаживания, но "
"это не работает надёжно во всех ситуациях (например, на мобильных/веб-"
"платформах, или когда включен HDR). В :ref:"
"`draw_polygon<class_CanvasItem_method_draw_polygon>` также отсутствует "
"параметр ``antialiased``."

msgid ""
"For custom drawing methods that don't provide an ``antialiased`` parameter, "
"you can enable 2D MSAA instead, which affects rendering in the entire "
"viewport. This provides high-quality antialiasing, but a higher performance "
"cost and only on specific elements. See :ref:`doc_2d_antialiasing` for more "
"information."
msgstr ""

msgid "Tools"
msgstr "Инструменты"

msgid ""
"Drawing your own nodes might also be desired while running them in the "
"editor. This can be used as a preview or visualization of some feature or "
"behavior. See :ref:`doc_running_code_in_the_editor` for more information."
msgstr ""
"Рисование собственных узлов может также быть желательным при их выполнении в "
"редакторе. Это может использоваться в качестве предварительного просмотра "
"или визуализации некоторой функциональности, или поведения. Дополнительную "
"информацию смотрите в разделе :ref:`doc_running_code_in_the_editor`."

msgid "Translation status"
msgstr "Translation status (статус перевода)"
