# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Sync the gameplay with audio and music"
msgstr "Синхронизация игры со звуками и музыкой"

msgid "Introduction"
msgstr "Введение"

msgid ""
"In any application or game, sound and music playback will have a slight "
"delay. For games, this delay is often so small that it is negligible. Sound "
"effects will come out a few milliseconds after any play() function is "
"called. For music this does not matter as in most games it does not interact "
"with the gameplay."
msgstr ""
"В приложении или игре воспроизведения звуков и музыки имеют небольшую "
"задержку. Для игр эта задержка часто настолько мала, что ей пренебрегают. "
"Звуковые эффекты появятся через несколько миллисекунд после вызова функции "
"play (). Для музыки это не имеет значения, поскольку в большинстве игр она "
"не влияет на игровой процесс."

msgid ""
"Still, for some games (mainly, rhythm games), it may be required to "
"synchronize player actions with something happening in a song (usually in "
"sync with the BPM). For this, having more precise timing information for an "
"exact playback position is useful."
msgstr ""
"Тем не менее, для некоторых игр (в основном, ритм-игр) может потребоваться "
"синхронизировать действия игрока с тем, что происходит в песне (обычно "
"синхронно с BPM). Для этого полезно иметь более точную информацию о времени "
"воспроизведения."

msgid ""
"Achieving very low playback timing precision is difficult. This is because "
"many factors are at play during audio playback:"
msgstr ""
"Достичь низкой задержки воспроизведения трудно. Это происходит потому, что "
"во время воспроизведения аудио работают много других процессов :"

msgid ""
"Audio is mixed in chunks (not continuously), depending on the size of audio "
"buffers used (check latency in project settings)."
msgstr ""
"Аудио микшируется кусочками (не непрерывно), в зависимости от размера "
"используемых аудио буферов, (проверьте задержку в настройках проекта)."

msgid "Mixed chunks of audio are not played immediately."
msgstr "Микшированные фрагменты звука воспроизводятся не сразу."

msgid "Graphics APIs display two or three frames late."
msgstr "API графики имеют задержку на два или три кадра."

msgid "When playing on TVs, some delay may be added due to image processing."
msgstr ""
"При воспроизведении на телевизоре может добавляться некоторая задержка из-за "
"передачи изображения."

msgid ""
"The most common way to reduce latency is to shrink the audio buffers (again, "
"by editing the latency setting in the project settings). The problem is that "
"when latency is too small, sound mixing will require considerably more CPU. "
"This increases the risk of skipping (a crack in sound because a mix callback "
"was lost)."
msgstr ""
"Самый распространенный способ уменьшить задержку - уменьшить аудиобуфер "
"(опять же, отредактировав настройку задержки в настройках проекта). Проблема "
"в том, что когда задержка слишком мала, для микширования звука требуется "
"значительно больше процессорного времени. Это увеличивает риск пропуска "
"звука из-за того, что процессор не успел подготовить микс."

msgid ""
"This is a common tradeoff, so Godot ships with sensible defaults that should "
"not need to be altered."
msgstr ""
"Это распространенный компромисс, поэтому Godot поставляется с настройками по "
"умолчанию, которые не требуется изменять."

msgid ""
"The problem, in the end, is not this slight delay but synchronizing graphics "
"and audio for games that require it. Beginning with Godot 3.2, some helpers "
"were added to obtain more precise playback timing."
msgstr ""
"Проблема, в конце концов, не в этой небольшой задержке, а в синхронизации "
"графики и звука для игр, в которых это требуется. Начиная с Godot 3.2, были "
"добавлены некоторые помощники для получения более точного времени "
"воспроизведения."

msgid "Using the system clock to sync"
msgstr "Использование системных часов для синхронизации"

msgid ""
"As mentioned before, If you call :ref:`AudioStreamPlayer."
"play()<class_AudioStreamPlayer_method_play>`, sound will not begin "
"immediately, but when the audio thread processes the next chunk."
msgstr ""
"Как упоминалось ранее, если вы вызовете: ref: `AudioStreamPlayer.play () "
"<class_AudioStreamPlayer_method_play>`, звук начнется не сразу, а когда "
"процессор обработает фрагмент."

msgid ""
"This delay can't be avoided but it can be estimated by calling :ref:"
"`AudioServer."
"get_time_to_next_mix()<class_AudioServer_method_get_time_to_next_mix>`."
msgstr ""
"Этой задержки нельзя избежать, но ее можно оценить, вызвав: ref: "
"`AudioServer.get_time_to_next_mix () "
"<class_AudioServer_method_get_time_to_next_mix>`."

msgid ""
"The output latency (what happens after the mix) can also be estimated by "
"calling :ref:`AudioServer."
"get_output_latency()<class_AudioServer_method_get_output_latency>`."
msgstr ""
"Выходную задержку (ту, что происходит после микширования) также можно "
"оценить, вызвав: ref: `AudioServer.get_output_latency () "
"<class_AudioServer_method_get_output_latency>`."

msgid ""
"Add these two and it's possible to guess almost exactly when sound or music "
"will begin playing in the speakers during *_process()*:"
msgstr ""
"Добавьте эти два метода, и можно почти точно предсказать, когда звук или "
"музыка будут услышаны в динамиках во время * _process () *:"

msgid ""
"In the long run, though, as the sound hardware clock is never exactly in "
"sync with the system clock, the timing information will slowly drift away."
msgstr ""
"В долгосрочной перспективе, звуковые аппаратные часы никогда не "
"синхронизируются точно с системными часами, информация о времени будет "
"постепенно расстраиваться."

msgid ""
"For a rhythm game where a song begins and ends after a few minutes, this "
"approach is fine (and it's the recommended approach). For a game where "
"playback can last a much longer time, the game will eventually go out of "
"sync and a different approach is needed."
msgstr ""
"Для ритм-игры, в которой песня начинается и заканчивается через несколько "
"минут, этот подход подходит (и это рекомендуемый подход). Для игры, в "
"которой воспроизведение может длиться намного дольше, игра в конечном итоге "
"выйдет из синхронизации, и потребуется другой подход."

msgid "Using the sound hardware clock to sync"
msgstr "Использование звуковых аппаратных часов для синхронизации"

msgid ""
"Using :ref:`AudioStreamPlayer."
"get_playback_position()<class_AudioStreamPlayer_method_get_playback_position>` "
"to obtain the current position for the song sounds ideal, but it's not that "
"useful as-is. This value will increment in chunks (every time the audio "
"callback mixed a block of sound), so many calls can return the same value. "
"Added to this, the value will be out of sync with the speakers too because "
"of the previously mentioned reasons."
msgstr ""
"Использование: ref: `AudioStreamPlayer.get_playback_position () "
"<class_AudioStreamPlayer_method_get_playback_position>` для получения "
"текущей позиции воспроизведения кажется идеально, но это не так. Это "
"значение будет увеличиваться по частям (каждый раз, когда обрабатывается "
"очередной блок звука), поэтому многие вызовы могут возвращать одно и то же "
"значение. Кроме того, значение будет не синхронизировано с динамиками по "
"ранее упомянутым причинам."

msgid ""
"To compensate for the \"chunked\" output, there is a function that can "
"help: :ref:`AudioServer."
"get_time_since_last_mix()<class_AudioServer_method_get_time_since_last_mix>`."
msgstr ""
"Чтобы компенсировать \"фрагментированный\" вывод, есть функция, которая "
"может помочь:: ref: `AudioServer.get_time_since_last_mix () "
"<class_AudioServer_method_get_time_since_last_mix>`."

msgid ""
"Adding the return value from this function to *get_playback_position()* "
"increases precision:"
msgstr ""
"Добавление возвращаемого значения из этой функции в * get_playback_position "
"() * увеличивает точность:"

msgid ""
"To increase precision, subtract the latency information (how much it takes "
"for the audio to be heard after it was mixed):"
msgstr ""
"Чтобы повысить точность, вычтите информацию о задержке (чтобы звук был "
"слышен сразу после его микширования):"

msgid ""
"The result may be a bit jittery due how multiple threads work. Just check "
"that the value is not less than in the previous frame (discard it if so). "
"This is also a less precise approach than the one before, but it will work "
"for songs of any length, or synchronizing anything (sound effects, as an "
"example) to music."
msgstr ""
"Результат может быть немного нестабильным из-за того, что работают несколько "
"потоков. Просто убедитесь, что значение не меньше, чем в предыдущем кадре "
"(не используйте этот метод, если это не так). Это также менее точный подход, "
"чем предыдущий, но он будет работать для песен любой длины или для "
"синхронизации чего-либо (например, звуковых эффектов) с музыкой."

msgid "Here is the same code as before using this approach:"
msgstr "Вот тот же код, что и до использования этого подхода:"

msgid "Translation status"
msgstr "Статус перевода"
