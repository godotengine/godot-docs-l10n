# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: cs\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced vector math"
msgstr "Pokročilá vektorová matematika"

msgid "Planes"
msgstr "Roviny"

msgid ""
"The dot product has another interesting property with unit vectors. Imagine "
"that perpendicular to that vector (and through the origin) passes a plane. "
"Planes divide the entire space into positive (over the plane) and negative "
"(under the plane), and (contrary to popular belief) you can also use their "
"math in 2D:"
msgstr ""
"Skalární součin má jinou zajímavou vlastnost s jednotkovými vektory. "
"Představte si, že kolmice na tento vektor (a skrz počátek) projde rovinou. "
"Roviny rozdělují celý prostor na kladný (nad rovinou) a záporný (pod "
"rovinou) a (na rozdíl od všeobecné domněnky), můžete použít jejich "
"matematické operace i ve 2D:"

msgid ""
"Unit vectors that are perpendicular to a surface (so, they describe the "
"orientation of the surface) are called **unit normal vectors**. Though, "
"usually they are just abbreviated as *normals*. Normals appear in planes, 3D "
"geometry (to determine where each face or vertex is siding), etc. A "
"**normal** *is* a **unit vector**, but it's called *normal* because of its "
"usage. (Just like we call (0,0) the Origin!)."
msgstr ""

msgid ""
"It's as simple as it looks. The plane passes by the origin and the surface "
"of it is perpendicular to the unit vector (or *normal*). The side towards "
"the vector points to is the positive half-space, while the other side is the "
"negative half-space. In 3D this is exactly the same, except that the plane "
"is an infinite surface (imagine an infinite, flat sheet of paper that you "
"can orient and is pinned to the origin) instead of a line."
msgstr ""
"Je to tak jednoduché, jak to vypadá. Rovina prochází počátkem a její plocha "
"je kolmá na jednotkový vektor (nebo *normálu*). Strana směřující k vektoru "
"je kladný poloprostor, zatímco druhá strana je záporný poloprostor. Ve 3D je "
"to úplně stejné, kromě toho, že rovina je nekonečná plocha (představte si "
"nekonečný plochý list papíru, který můžete orientovat a je přišpendlený k "
"počátku) místo přímky."

msgid "Distance to plane"
msgstr "Vzdálenost k rovině"

msgid ""
"Now that it's clear what a plane is, let's go back to the dot product. The "
"dot product between a **unit vector** and any **point in space** (yes, this "
"time we do dot product between vector and position), returns the **distance "
"from the point to the plane**:"
msgstr ""
"Nyní, když je zřejmé co je rovina, se podíváme zpět na skalární součin. "
"Skalární součin mezi **jednotkovým vektorem** a nějakým **bodem v prostoru** "
"(ano, tentokrát děláme skalární součin mezi vektorem a pozicí), vrátí "
"**vzdálenost od bodu k rovině**:"

msgid ""
"But not just the absolute distance, if the point is in the negative half "
"space the distance will be negative, too:"
msgstr ""
"Ale ne jen absolutní vzdálenost, pokud se bod nachází v záporném "
"poloprostoru, vzdálenost bude také záporná:"

msgid "This allows us to tell which side of the plane a point is."
msgstr "To nám umožňuje říct, na které straně roviny se bod nachází."

msgid "Away from the origin"
msgstr "Pryč od počátku"

msgid ""
"I know what you are thinking! So far this is nice, but *real* planes are "
"everywhere in space, not only passing through the origin. You want real "
"*plane* action and you want it *now*."
msgstr ""
"Vím, na co myslíte! Zatím je to pěkné, ale *skutečné* roviny jsou všude v "
"prostoru, nejen že procházejí počátkem. Chcete reálnou *rovinu* v akci a "
"chcete ji *hned*."

msgid ""
"Remember that planes not only split space in two, but they also have "
"*polarity*. This means that it is possible to have perfectly overlapping "
"planes, but their negative and positive half-spaces are swapped."
msgstr ""
"Pamatujte, že roviny nejen rozdělují prostor na dvě části, ale mají také "
"*polaritu*. To znamená, že je možné mít dokonale se překrývající roviny, ale "
"jejich záporné a kladné poloprostory jsou přehozeny."

msgid ""
"With this in mind, let's describe a full plane as a **normal** *N* and a "
"**distance from the origin** scalar *D*. Thus, our plane is represented by N "
"and D. For example:"
msgstr ""
"S ohledem na to, popíšeme celou roviny jako **normálu** *N* a skalár "
"**vzdálenost od počátku** *D*. Naše rovina je tedy zastoupena N a D. "
"Například:"

msgid ""
"For 3D math, Godot provides a :ref:`Plane <class_Plane>` built-in type that "
"handles this."
msgstr ""
"Pro 3D matematiku poskytuje Godot vestavěný typ :ref:`Plane <class_Plane>`, "
"který se o to postará."

msgid ""
"Basically, N and D can represent any plane in space, be it for 2D or 3D "
"(depending on the amount of dimensions of N) and the math is the same for "
"both. It's the same as before, but D is the distance from the origin to the "
"plane, travelling in N direction. As an example, imagine you want to reach a "
"point in the plane, you will just do:"
msgstr ""

msgid ""
"This will stretch (resize) the normal vector and make it touch the plane. "
"This math might seem confusing, but it's actually much simpler than it "
"seems. If we want to tell, again, the distance from the point to the plane, "
"we do the same but adjusting for distance:"
msgstr ""

msgid "The same thing, using a built-in function:"
msgstr ""

msgid "This will, again, return either a positive or negative distance."
msgstr ""

msgid ""
"Flipping the polarity of the plane can be done by negating both N and D. "
"This will result in a plane in the same position, but with inverted negative "
"and positive half spaces:"
msgstr ""

msgid ""
"Of course, Godot also implements this operator in :ref:`Plane "
"<class_Plane>`, so doing:"
msgstr ""

msgid "Will work as expected."
msgstr ""

msgid ""
"So, remember, a plane is just that and its main practical use is calculating "
"the distance to it. So, why is it useful to calculate the distance from a "
"point to a plane? It's extremely useful! Let's see some simple examples.."
msgstr ""

msgid "Constructing a plane in 2D"
msgstr ""

msgid ""
"Planes clearly don't come out of nowhere, so they must be built. "
"Constructing them in 2D is easy, this can be done from either a normal (unit "
"vector) and a point, or from two points in space."
msgstr ""

msgid ""
"In the case of a normal and a point, most of the work is done, as the normal "
"is already computed, so just calculate D from the dot product of the normal "
"and the point."
msgstr ""

msgid ""
"For two points in space, there are actually two planes that pass through "
"them, sharing the same space but with normal pointing to the opposite "
"directions. To compute the normal from the two points, the direction vector "
"must be obtained first, and then it needs to be rotated 90° degrees to "
"either side:"
msgstr ""

msgid ""
"The rest is the same as the previous example, either point_a or point_b will "
"work since they are in the same plane:"
msgstr ""

msgid ""
"Doing the same in 3D is a little more complex and will be explained further "
"down."
msgstr ""

msgid "Some examples of planes"
msgstr ""

msgid ""
"Here is a simple example of what planes are useful for. Imagine you have a "
"`convex <https://www.mathsisfun.com/definitions/convex.html>`__ polygon. For "
"example, a rectangle, a trapezoid, a triangle, or just any polygon where no "
"faces bend inwards."
msgstr ""

msgid ""
"For every segment of the polygon, we compute the plane that passes by that "
"segment. Once we have the list of planes, we can do neat things, for example "
"checking if a point is inside the polygon."
msgstr ""

msgid ""
"We go through all planes, if we can find a plane where the distance to the "
"point is positive, then the point is outside the polygon. If we can't, then "
"the point is inside."
msgstr ""

msgid "Code should be something like this:"
msgstr ""

msgid ""
"Pretty cool, huh? But this gets much better! With a little more effort, "
"similar logic will let us know when two convex polygons are overlapping too. "
"This is called the Separating Axis Theorem (or SAT) and most physics engines "
"use this to detect collision."
msgstr ""

msgid ""
"With a point, just checking if a plane returns a positive distance is enough "
"to tell if the point is outside. With another polygon, we must find a plane "
"where *all* *the* *other* *polygon* *points* return a positive distance to "
"it. This check is performed with the planes of A against the points of B, "
"and then with the planes of B against the points of A:"
msgstr ""

msgid ""
"As you can see, planes are quite useful, and this is the tip of the iceberg. "
"You might be wondering what happens with non convex polygons. This is "
"usually just handled by splitting the concave polygon into smaller convex "
"polygons, or using a technique such as BSP (which is not used much nowadays)."
msgstr ""

msgid "Collision detection in 3D"
msgstr ""

msgid ""
"This is another bonus bit, a reward for being patient and keeping up with "
"this long tutorial. Here is another piece of wisdom. This might not be "
"something with a direct use case (Godot already does collision detection "
"pretty well) but it's used by almost all physics engines and collision "
"detection libraries :)"
msgstr ""

msgid ""
"Remember that converting a convex shape in 2D to an array of 2D planes was "
"useful for collision detection? You could detect if a point was inside any "
"convex shape, or if two 2D convex shapes were overlapping."
msgstr ""

msgid ""
"Well, this works in 3D too, if two 3D polyhedral shapes are colliding, you "
"won't be able to find a separating plane. If a separating plane is found, "
"then the shapes are definitely not colliding."
msgstr ""

msgid ""
"To refresh a bit a separating plane means that all vertices of polygon A are "
"in one side of the plane, and all vertices of polygon B are in the other "
"side. This plane is always one of the face-planes of either polygon A or "
"polygon B."
msgstr ""

msgid ""
"In 3D though, there is a problem to this approach, because it is possible "
"that, in some cases a separating plane can't be found. This is an example of "
"such situation:"
msgstr ""

msgid ""
"To avoid it, some extra planes need to be tested as separators, these planes "
"are the cross product between the edges of polygon A and the edges of "
"polygon B"
msgstr ""

msgid "So the final algorithm is something like:"
msgstr ""

msgid "More information"
msgstr "Více informací"

msgid ""
"For more information on using vector math in Godot, see the following "
"article:"
msgstr ""

msgid ":ref:`doc_matrices_and_transforms`"
msgstr ""

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video series \"Essence of Linear Algebra\": https://www.youtube."
"com/watch?v=fNk_zzaMoSs&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab"
msgstr ""

msgid "Translation status"
msgstr "Stav překladu"
