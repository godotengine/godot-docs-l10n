# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Heads up display"
msgstr ""

msgid ""
"The final piece our game needs is a User Interface (UI) to display things "
"like score, a \"game over\" message, and a restart button."
msgstr ""

#, fuzzy
msgid ""
"Create a new scene, and add a :ref:`CanvasLayer <class_CanvasLayer>` node "
"named ``HUD``. \"HUD\" stands for \"heads-up display\", an informational "
"display that appears as an overlay on top of the game view."
msgstr ""
"게임에 마지막으로 필요한 것은 UI입니다: 인터페이스로 점수, \"game over\" 메시"
"지, 재시작 버튼을 화면에 보여줍니다. 새 씬을 만들고, :ref:`CanvasLayer "
"<class_CanvasLayer>` 노드를 추가하고 ``HUD``\\ 라고 이름지으세요. \"HUD\"는 "
"\"heads-up display\"의 약자로, 정보를 게임 화면 앞에 덮어씌우는 방식입니다."

msgid ""
"The :ref:`CanvasLayer <class_CanvasLayer>` node lets us draw our UI elements "
"on a layer above the rest of the game, so that the information it displays "
"isn't covered up by any game elements like the player or mobs."
msgstr ""
":ref:`CanvasLayer <class_CanvasLayer>` 노드는 게임 위 레이어에 우리의 UI 요소"
"들을 그릴수 있게 해주고, 이로써 보여지는 정보가 플레이어나 몹과 같은 게임 요"
"소들에 의해 가려지지 않게 만듭니다."

msgid "The HUD needs to display the following information:"
msgstr "HUD는 다음 정보를 표시해야 합니다:"

msgid "Score, changed by ``ScoreTimer``."
msgstr "``ScoreTimer``\\ 에 의해 변경되는 점수(Score)."

msgid "A message, such as \"Game Over\" or \"Get Ready!\""
msgstr "\"Game Over\"나 \"Get Ready!\"와 같은 메시지"

msgid "A \"Start\" button to begin the game."
msgstr "게임을 시작하기 위한 \"Start\" 버튼."

msgid ""
"The basic node for UI elements is :ref:`Control <class_Control>`. To create "
"our UI, we'll use two types of :ref:`Control <class_Control>` nodes: :ref:"
"`Label <class_Label>` and :ref:`Button <class_Button>`."
msgstr ""
"UI 요소의 기초가 되는 노드는 :ref:`Control <class_Control>`\\ 입니다. UI를 만"
"들기 위해, 우리는 두 가지 타입의 :ref:`Control <class_Control>` 노드: :ref:"
"`Label <class_Label>`\\ 과 :ref:`Button <class_Button>`\\ 을 사용할 것입니다."

msgid "Create the following as children of the ``HUD`` node:"
msgstr "다음 노드들을 ``HUD`` 노드의 자식으로 추가하세요:"

msgid ":ref:`Label <class_Label>` named ``ScoreLabel``."
msgstr "``ScoreLabel``\\ 로 이름지은 :ref:`Label <class_Label>`."

msgid ":ref:`Label <class_Label>` named ``Message``."
msgstr "``Message``\\ 로 이름지은 :ref:`Label <class_Label>`."

msgid ":ref:`Button <class_Button>` named ``StartButton``."
msgstr "``StartButton``\\ 으로 이름지은 :ref:`Button <class_Button>`."

msgid ":ref:`Timer <class_Timer>` named ``MessageTimer``."
msgstr "``MessageTimer``\\ 로 이름지은 :ref:`Timer <class_Timer>`."

msgid ""
"Click on the ``ScoreLabel`` and type a number into the ``Text`` field in the "
"Inspector. The default font for ``Control`` nodes is small and doesn't scale "
"well. There is a font file included in the game assets called \"Xolonium-"
"Regular.ttf\". To use this font, do the following:"
msgstr ""
"``ScoreLabel``\\ 을 클릭하고 인스펙터(Inspecter)의 *Text* 필드에 숫자를 입력"
"하세요. ``Control`` 노드의 기본 폰트는 작아서 크기 조정이 잘 되지 않습니다. "
"게임 에셋에는 \"Xolonium-Regular.ttf\"라는 폰트 파일이 있습니다. 이 폰트를 사"
"용하려면, 각 ``Control`` 노드마다 다음과 같이 하세요:"

#, fuzzy
msgid ""
"Under **Theme overrides > Fonts** click on the empty box and select \"New "
"DynamicFont\""
msgstr "\"Custom Fonts\" 에서, \"새 DynamicFont\"를 선택하세요"

#, fuzzy
msgid ""
"Click on the \"DynamicFont\" you added, and under **Font > FontData**, "
"choose \"Load\" and select the \"Xolonium-Regular.ttf\" file."
msgstr ""
"추가한 \"DynamicFont\"를 클릭하고, \"Font/Font Data\" 아래에서, \"불러오기"
"(Load)\"를 눌러서 \"Xolonium-Regular.ttf\" 파일을 선택하세요. 또한 폰트의 "
"``Size``\\ 도 설정해야 합니다. ``64`` 정도가 좋습니다."

msgid "Set the \"Size\" property under ``Settings``, ``64`` works well."
msgstr ""

#, fuzzy
msgid ""
"Once you've done this on the ``ScoreLabel``, you can click the down arrow "
"next to the Font property and choose \"Copy\", then \"Paste\" it in the same "
"place on the other two Control nodes."
msgstr ""
"``ScoreLabel``\\ 에서 이 작업을 수행하고 나면 DynamicFont 속성 옆에 있는 아래"
"쪽 화살표를 클릭하고 \"복사(Copy)\"를 선택한 다음 다른 두 Control 노드의 같"
"은 위치에 \"붙여넣기(Paste)\"를 할 수 있습니다."

#, fuzzy
msgid ""
"**Anchors and Margins:** ``Control`` nodes have a position and size, but "
"they also have anchors and margins. Anchors define the origin - the "
"reference point for the edges of the node. Margins update automatically when "
"you move or resize a control node. They represent the distance from the "
"control node's edges to its anchor."
msgstr ""
"**앵커(Anchors)와 마진(Margins):** ``Control`` 노드는 위치와 크기를 가지고 있"
"고, 앵커와 마진 또한 가지고 있습니다. 앵커는 노드의 가장자리에 대한 참조점인 "
"원점을 정의합니다. 마진은 컨트롤 노드를 움직이거나 크기를 조정할 때 자동으로 "
"업데이트됩니다. 마진은 컨트롤 노드들의 모서리가 앵커로부터 얼마나 떨어져 있"
"는 지를 나타냅니다. 더 자세한 설명은 :ref:"
"`doc_design_interfaces_with_the_control_nodes`\\ 를 참고하세요."

msgid ""
"Arrange the nodes as shown below. Click the \"Layout\" button to set a "
"Control node's layout:"
msgstr ""
"아래에 보이는 대로 노드를 배열하세요. \"레이아웃(Layout)\" 버튼을 클릭해서 "
"Control 노드의 레이아웃을 설정하세요:"

msgid ""
"You can drag the nodes to place them manually, or for more precise "
"placement, use the following settings:"
msgstr ""
"여러분은 노드를 드래그해서 수동으로 놓을 수도 있지만 더 정확하게 하고 싶다면 "
"다음 설정을 사용하세요:"

msgid "ScoreLabel"
msgstr "ScoreLabel"

msgid "*Layout* : \"Top Wide\""
msgstr "*레이아웃(Layout)* : \"위쪽 넓게(Top Wide)\""

msgid "*Text* : ``0``"
msgstr "*Text* : ``0``"

msgid "*Align* : \"Center\""
msgstr "*Align* : \"Center\""

msgid "Message"
msgstr "메시지"

msgid "*Layout* : \"HCenter Wide\""
msgstr "*레이아웃(Layout)* : \"수평선 중앙 넓게(HCenter Wide)\""

msgid "*Text* : ``Dodge the Creeps!``"
msgstr "*Text* : ``Dodge the Creeps!``"

msgid "*Autowrap* : \"On\""
msgstr "*Autowrap* : \"On\""

msgid "StartButton"
msgstr "StartButton"

msgid "*Text* : ``Start``"
msgstr "*Text* : ``Start``"

msgid "*Layout* : \"Center Bottom\""
msgstr "*레이아웃(Layout)* : \"아래쪽 중앙(Center Bottom)\""

msgid "*Margin* :"
msgstr "*Margin* :"

msgid "Top: ``-200``"
msgstr "Top: ``-200``"

msgid "Bottom: ``-100``"
msgstr "Bottom: ``-100``"

msgid ""
"On the ``MessageTimer``, set the ``Wait Time`` to ``2`` and set the ``One "
"Shot`` property to \"On\"."
msgstr ""
"``MessageTimer``\\ 에서 ``Wait Time``\\ 을 ``2``\\ 로 설정하고 ``One Shot`` "
"속성을 \"사용(On)\"으로 설정합니다."

msgid "Now add this script to ``HUD``:"
msgstr "이제 ``HUD``\\ 에 이 스크립트를 추가하세요:"

msgid ""
"The ``start_game`` signal tells the ``Main`` node that the button has been "
"pressed."
msgstr "``start_game`` 시그널은 ``Main`` 노드에게 버튼이 눌려졌음을 알립니다."

msgid ""
"This function is called when we want to display a message temporarily, such "
"as \"Get Ready\"."
msgstr ""
"이 함수는 \"Get Ready\"와 같은 메시지를 일시적으로 표시하고 싶을 때 호출됩니"
"다."

msgid ""
"This function is called when the player loses. It will show \"Game Over\" "
"for 2 seconds, then return to the title screen and, after a brief pause, "
"show the \"Start\" button."
msgstr ""
"이 함수는 플레이어가 패배했을 때 호출됩니다. 이 함수는 2초동안 \"Game "
"Over\"를 보여주고, 타이틀 화면으로 돌아와서, 잠깐 일시정지한 후 \"Start\" 버"
"튼을 보여줍니다."

msgid ""
"When you need to pause for a brief time, an alternative to using a Timer "
"node is to use the SceneTree's ``create_timer()`` function. This can be very "
"useful to add delays such as in the above code, where we want to wait some "
"time before showing the \"Start\" button."
msgstr ""
"잠시 일시 정지를 해야 한다면 타이머 노드를 사용하는 대신 SceneTree의 "
"``create_timer()`` 함수를 사용하는 것이 좋습니다. 이 함수는 \"Start\" 버튼을 "
"표시하기 전에 잠시 기다려야 하는 위의 코드와 같이 지연을 추가하는 데 매우 유"
"용할 수 있습니다."

msgid "This function is called by ``Main`` whenever the score changes."
msgstr "이 함수는 점수가 변경될 때마다 ``Main``\\ 에 의해서 호출됩니다."

msgid ""
"Connect the ``timeout()`` signal of ``MessageTimer`` and the ``pressed()`` "
"signal of ``StartButton`` and add the following code to the new functions:"
msgstr ""
"``MessageTimer``\\ 의 ``timeout()`` 시그널과 ``StartButton``\\ 의 "
"``pressed()`` 시그널을 연결하고 다음 코드를 새 함수에 추가하세요:"

msgid "Connecting HUD to Main"
msgstr "메인에 HUD를 연결하기"

msgid ""
"Now that we're done creating the ``HUD`` scene, go back to ``Main``. "
"Instance the ``HUD`` scene in ``Main`` like you did the ``Player`` scene. "
"The scene tree should look like this, so make sure you didn't miss anything:"
msgstr ""
"이제 ``HUD`` 씬 만들기가 끝났으니 저장하고 다시 ``Main``\\ 으로 돌아가세요. "
"``Player`` 씬에서 했듯이 ``HUD`` 씬을 ``Main``\\ 에 인스턴스화하고, 트리의 "
"맨 아래에 배치하세요. 모든 트리는 다음처럼 보여야 하므로, 놓친 것이 없는지 확"
"인해보세요:"

msgid ""
"Now we need to connect the ``HUD`` functionality to our ``Main`` script. "
"This requires a few additions to the ``Main`` scene:"
msgstr ""
"이제 ``HUD`` 기능을 ``Main`` 스크립트에 연결할 것입니다. 여기에는 ``Main`` 씬"
"에 추가적인 것들이 요구됩니다:"

msgid ""
"In the Node tab, connect the HUD's ``start_game`` signal to the "
"``new_game()`` function of the Main node by typing \"new_game\" in the "
"\"Receiver Method\" in the \"Connect a Signal\" window. Verify that the "
"green connection icon now appears next to ``func new_game()`` in the script."
msgstr ""
"Node 탭에서 \"시그널을 메서드에 연결(Connect a Signal to a Method)\" 창의 "
"\"받는 메서드(Receiver Method)\"에 \"new_game\"을 입력해 HUD의 "
"``start_game`` 신호를 Main 노드의 ``new_game()`` 함수에 연결하세요. 이제 스크"
"립트의 ``func new_game()`` 옆에 녹색 연결 아이콘이 나타나는지 확인하세요."

msgid ""
"In ``new_game()``, update the score display and show the \"Get Ready\" "
"message:"
msgstr ""
"``new_game()``\\ 에서, 점수 화면을 업데이트하고 \"Get Ready\" 메시지를 보이"
"게 합니다:"

msgid "In ``game_over()`` we need to call the corresponding ``HUD`` function:"
msgstr "``game_over()``\\ 에서는, 해당 ``HUD`` 함수를 호출해야 합니다:"

msgid ""
"Finally, add this to ``_on_ScoreTimer_timeout()`` to keep the display in "
"sync with the changing score:"
msgstr ""
"마지막으로, ``_on_ScoreTimer_timeout()``\\ 을 추가해서 점수가 바뀌면 화면과 "
"일치하도록 합니다:"

msgid ""
"Now you're ready to play! Click the \"Play the Project\" button. You will be "
"asked to select a main scene, so choose ``Main.tscn``."
msgstr ""
"이제 실행할 준비가 끝났습니다! \"프로젝트 실행\" 버튼을 누르세요. 메인 씬을 "
"선택하라고 물어보면 ``Main.tscn``\\ 을 골라줍시다."

msgid "Removing old creeps"
msgstr "오래된 적들 제거하기"

msgid ""
"If you play until \"Game Over\" and then start a new game right away, the "
"creeps from the previous game may still be on the screen. It would be better "
"if they all disappeared at the start of a new game. We just need a way to "
"tell *all* the mobs to remove themselves. We can do this with the \"group\" "
"feature."
msgstr ""
"\"Game Over\"까지 플레이한 다음 바로 새 게임을 시작하면 이전 게임의 크립이 화"
"면에 계속 표시될 수 있습니다. 새 게임이 시작될 때 모두 사라지면 더 좋을 것입"
"니다. 우리는 *모든* 몹에게 스스로 제거하도록 지시할 방법이 필요합니다. \"그룹"
"(group)\" 기능으로 이 작업을 수행할 수 있습니다."

msgid ""
"In the ``Mob`` scene, select the root node and click the \"Node\" tab next "
"to the Inspector (the same place where you find the node's signals). Next to "
"\"Signals\", click \"Groups\" and you can type a new group name and click "
"\"Add\"."
msgstr ""
"``Mob`` 씬에서 루트 노드를 선택하고 인스펙터 옆에 있는 \"노드(Node)\" 탭을 클"
"릭하세요(노드의 시그널을 찾을 수 있는 동일한 위치). \"시그널(Signals)\" 옆에 "
"있는 \"그룹(Groups)\"을 클릭하고 새 그룹 이름을 입력하고 \"추가(Add)\"를 클릭"
"하세요."

#, fuzzy
msgid ""
"Now all mobs will be in the \"mobs\" group. We can then add the following "
"line to the ``new_game()`` function in ``Main``:"
msgstr ""
"이제 모든 몹이 \"몹\" 그룹에 포함됩니다. 그런 다음 ``Main``\\ 의 "
"``game_over()`` 함수에 다음 줄을 추가하세요:"

msgid ""
"The ``call_group()`` function calls the named function on every node in a "
"group - in this case we are telling every mob to delete itself."
msgstr ""
"``call_group()`` 함수는 그룹의 모든 노드에서 지정된 함수를 호출합니다. 이 경"
"우 모든 몹에게 자신을 삭제하도록 지시합니다."

msgid ""
"The game's mostly done at this point. In the next and last part, we'll "
"polish it a bit by adding a background, looping music, and some keyboard "
"shortcuts."
msgstr ""

msgid "Translation status"
msgstr "번역 상태"
