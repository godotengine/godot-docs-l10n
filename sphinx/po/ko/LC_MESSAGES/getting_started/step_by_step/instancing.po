# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Creating instances"
msgstr "인스턴스 만들기"

msgid ""
"In the previous part, we saw that a scene is a collection of nodes organized "
"in a tree structure, with a single node as its root. You can split your "
"project into any number of scenes. This feature helps you break down and "
"organize your game's different components."
msgstr ""
"이전 파트에서는 씬이 하나의 루트 노드를 가진 트리 구조로 구성된 노드 모음임"
"을 알아보았습니다. 프로젝트를 여러 씬으로 분할할 수 있습니다. 이 기능은 게임"
"의 다양한 구성 요소를 분리하고 조직하는 데 도움이 됩니다."

msgid ""
"You can create as many scenes as you'd like and save them as files with the "
"``.tscn`` extension, which stands for \"text scene\". The ``Label.tscn`` "
"file from the previous lesson was an example. We call those files \"Packed "
"Scenes\" as they pack information about your scene's content."
msgstr ""
"원하는 만큼 씬을 생성하고 ``.tscn`` 확장자를 가진 파일로 저장할 수 있습니다. "
"이는 \"텍스트 씬\"을 나타내는 약자입니다. 이전 레슨에서 사용한 ``Label."
"tscn`` 파일이 그 예입니다. 우리는 이러한 파일을 \"패킹된 씬(Packed "
"Scenes)\"이라고 부르며, 씬의 내용에 대한 정보를 포함합니다."

msgid ""
"Here's an example of a ball. It's composed of a :ref:`RigidBody2D "
"<class_RigidBody2D>` node as its root named Ball, which allows the ball to "
"fall and bounce on walls, a :ref:`Sprite <class_Sprite>` node, and a :ref:"
"`CollisionShape2D <class_CollisionShape2D>`."
msgstr ""
"다음은 볼(Ball)의 예입니다. 이는 볼이 벽에 떨어지고 튀는 것을 가능하게 하는 "
"루트로 \"Ball\"이라는 이름의 :ref:`RigidBody2D <class_RigidBody2D>` 노드로 구"
"성되어 있습니다. 또한 :ref:`Sprite <class_Sprite>` 노드와 :ref:"
"`CollisionShape2D <class_CollisionShape2D>`도 포함하고 있습니다."

msgid ""
"Once you saved a scene, it works as a blueprint: you can reproduce it in "
"other scenes as many times as you'd like. Replicating an object from a "
"template like this is called **instancing**."
msgstr ""
"한 번 씬을 저장하면, 이는 청사진(blueprint)으로 작동합니다. 원하는 만큼 다른 "
"씬에서 재생산할 수 있습니다. 이와 같이 템플릿에서 객체를 복제하는 것을 **인스"
"턴싱(Instancing)**이라고 합니다."

msgid ""
"As we mentioned in the previous part, instanced scenes behave like a node: "
"the editor hides their content by default. When you instance the Ball, you "
"only see the Ball node. Notice also how each duplicate has a unique name."
msgstr ""
"이전 파트에서 언급한 바와 같이, 인스턴스화된 씬은 노드처럼 동작합니다: 기본적"
"으로 에디터는 그 내용을 숨깁니다. Ball을 인스턴스화하면 Ball 노드만 표시됩니"
"다. 또한 각 복제본은 고유한 이름을 가지고 있음을 주목하세요."

msgid ""
"Every instance of the Ball scene starts with the same structure and "
"properties as ``Ball.tscn``. However, you can modify each independently, "
"such as changing how they bounce, how heavy they are, or any property "
"exposed by the source scene."
msgstr ""
"Ball 씬의 모든 인스턴스는 ``Ball.tscn`` 과 동일한 구조와 속성으로 시작합니"
"다. 그러나 각각을 독립적으로 수정할 수 있으며, 튀는 방식, 무게 등 소스 씬에"
"서 노출된 모든 속성을 변경할 수 있습니다."

msgid "In practice"
msgstr "연습해보기"

msgid ""
"Let's use instancing in practice to see how it works in Godot. We invite you "
"to download the ball's sample project we prepared for you: :download:"
"`instancing.zip <files/instancing.zip>`."
msgstr ""
"인스턴스가 Godot에서 실제로 어떻게 사용되는지 봅시다. 당신을 위해 준비한 "
"'the ball's sample project' 를 다운로드해봅시다: :download:`instancing.zip "
"<files/instancing.zip>`."

msgid ""
"Extract the archive on your computer. Then, open Godot, and in the project "
"manager, click the Import button to import the project."
msgstr ""
"당신의 컴퓨터에 압축을 푸세요. 그러면 Godot을 열고, 프로젝트 매니저에서 프로"
"젝트를 가져오기 위해 가져오기 버튼을 누릅니다."

msgid ""
"In the pop-up that appears, click the browse button and navigate to the "
"folder you extracted."
msgstr ""
"팝업창이 나타나면 찾아보기 버튼을 클릭하고, 압축을 푼 폴더로 이동하세요."

msgid "Double-click the ``project.godot`` file to open it."
msgstr "``project.godot`` 파일을 더블 클릭하여 열어주세요."

msgid "Finally, click the Import & Edit button."
msgstr "마지막으로 \"가져오기 & 편집\" 버튼을 클릭하세요."

msgid ""
"The project contains two packed scenes: ``Main.tscn``, containing walls "
"against which the ball collides, and ``Ball.tscn``. The Main scene should "
"open automatically."
msgstr ""
"프로젝트에는 공이 충돌하는 벽을 포함한 ``Main.tscn`` 과 ``Ball.tscn`` 이라는 "
"두 개의 패킹된 씬이 포함되어 있습니다. Main 씬은 자동으로 열릴 것입니다."

msgid ""
"Let's add a ball as a child of the Main node. In the Scene dock, select the "
"Main node. Then, click the link icon at the top of the scene dock. This "
"button allows you to add an instance of a scene as a child of the currently "
"selected node."
msgstr ""
"Main 노드의 하위 항목으로 볼을 추가해 보겠습니다. Scene 독에서 Main 노드를 선"
"택한 다음, Scene 독 상단에 있는 링크 아이콘을 클릭하세요. 이 버튼을 사용하면 "
"현재 선택된 노드의 하위로 씬의 인스턴스를 추가할 수 있습니다."

msgid "Double-click the ball scene to instance it."
msgstr "볼 씬을 두 번 클릭하여 인스턴스화하세요."

msgid "The ball appears in the top-left corner of the viewport."
msgstr "ball이 좌상단 구석의 뷰 포트에 나옵니다."

msgid "Click on it and drag it towards the center of the view."
msgstr "클릭한 후에 화면의 중앙으로 드래그하세요."

msgid "Play the game by pressing F5. You should see it fall."
msgstr ""
"F5를 눌러 게임을 실행하세요. 그러면 볼이 떨어지는 것을 볼 수 있을 것입니다."

msgid ""
"Now, we want to create more instances of the Ball node. With the ball still "
"selected, press :kbd:`Ctrl-D` (:kbd:`Cmd-D` on macOS) to call the duplicate "
"command. Click and drag to move the new ball to a different location."
msgstr ""
"이제 Ball 노드의 더 많은 인스턴스를 생성하려고 합니다. 볼을 선택한 상태에서 :"
"kbd:`Ctrl-D` (:kbd:`Cmd-D` macOS)를 눌러 복제 명령을 실행하세요. 새로운 볼을 "
"다른 위치로 이동하기 위해 클릭하고 드래그하세요."

msgid "You can repeat this process until you have several in the scene."
msgstr "씬에 몇 개를 가지더라도 반복할 수 있습니다."

msgid ""
"Play the game again. You should now see every ball fall independently from "
"one another. This is what instances do. Each is an independent reproduction "
"of a template scene."
msgstr ""
"게임을 다시 실행하세요. 이제 각각의 볼이 서로 독립적으로 떨어지는 것을 볼 수 "
"있을 것입니다. 이것이 인스턴스의 동작 방식입니다. 각 인스턴스는 템플릿 씬의 "
"독립적인 복제품입니다."

msgid "Editing scenes and instances"
msgstr "씬과 인스턴스 편집하기"

msgid "There is more to instances. With this feature, you can:"
msgstr ""
"인스턴스에는 더 많은 기능이 있습니다. 이 기능을 사용하면 다음과 같은 작업을 "
"수행할 수 있습니다:"

msgid ""
"Change the properties of one ball without affecting the others using the "
"Inspector."
msgstr ""
"다른 것들에 영향을 주지 않고서도 인스펙터를 이용해 ball 하나의 속성을 바꿀 "
"수 있습니다."

msgid ""
"Change the default properties of every Ball by opening the ``Ball.tscn`` "
"scene and making a change to the Ball node there. Upon saving, all instances "
"of the Ball in the project will see their values update."
msgstr ""
"모든 볼(ball)의 기본 속성을 변경하려면 ``Ball.tscn`` 씬을 열고 볼 노드에서 변"
"경 사항을 수행하세요. 저장하면 프로젝트 안에 있는 모든 볼의 인스턴스 값이 업"
"데이트됩니다."

msgid ""
"Changing a property on an instance always overrides values from the "
"corresponding packed scene."
msgstr "인스턴스의 속성을 변경하면 해당 패킹된 씬의 값이 항상 덮어씁니다."

msgid ""
"Let's try this. Open ``Ball.tscn`` and select the Ball node. In the "
"Inspector on the right, click on the PhysicsMaterial property to expand it."
msgstr ""
"이를 실습해 보겠습니다. ``Ball.tscn`` 을 열고 볼(ball) 노드를 선택하세요. 오"
"른쪽에 있는 인스펙터(inspector)에서 PhysicsMaterial 속성을 클릭하여 확장하세"
"요."

msgid ""
"Set its Bounce property to ``2`` by clicking on the number field, typing "
"``2``, and pressing :kbd:`Enter`."
msgstr ""
"바운스(Bounce) 속성을 ``2`` 로 설정하기 위해 숫자 필드를 클릭하고, ``2`` 를 "
"입력한 다음 :kbd:`Enter`를 눌러주세요."

msgid ""
"Play the game by pressing :kbd:`F5` and notice how all balls now bounce a "
"lot more. As the Ball scene is a template for all instances, modifying it "
"and saving causes all instances to update accordingly."
msgstr ""
":kbd:`F5`를 눌러 게임을 실행하고 모든 볼이 이제 훨씬 더 많이 튀는 것을 확인하"
"세요. 볼 씬은 모든 인스턴스의 템플릿이므로 수정하고 저장하면 모든 인스턴스가 "
"해당 내용을 업데이트합니다."

msgid ""
"Let's now adjust an individual instance. Head back to the Main scene by "
"clicking on the corresponding tab above the viewport."
msgstr ""
"개별 인스턴스를 조절해봅시다. 뷰 포트 위쪽에서 해당하는 탭을 클릭하면 메인 씬"
"으로 돌아올 수 있습니다."

msgid ""
"Select one of the instanced Ball nodes and, in the Inspector, set its "
"Gravity Scale value to ``10``."
msgstr ""
"인스턴스화된 Ball 노드를 하나 선택하고, 인스펙터에서 중력 배수 값을 ``10``으"
"로 설정합니다."

msgid "A grey \"revert\" button appears next to the adjusted property."
msgstr "속성을 조절하고 나서, 회색 복구 버튼이 나타납니다."

msgid ""
"This icon indicates you are overriding a value from the source packed scene. "
"Even if you modify the property in the original scene, the value override "
"will be preserved in the instance. Clicking the revert icon will restore the "
"property to the value in the saved scene."
msgstr ""
"이 아이콘은 씬에서 팩된 소스의 값을 덮어썼다는 것을 알려줍니다. 원본 씬의 속"
"성을 수정하더라도 인스턴스에 덮어씌워진 값이 보존됩니다. 복구 아이콘을 누르"
"면 저장된 씬에서 속성 값을 불러옵니다."

msgid ""
"Rerun the game and notice how this ball now falls much faster than the "
"others."
msgstr ""
"게임을 다시 실행하여 이 Ball이 다른 것보다 훨씬 빠르게 떨어지는지 봅시다."

msgid ""
"If you change a value on the ``PhysicsMaterial`` of one instance, it will "
"affect all the others. This is because ``PhysicsMaterial`` is a resource, "
"and resources are shared between instances. To make a resource unique for "
"one instance, right-click on it in the Inspector and click Make Unique in "
"the contextual menu."
msgstr ""
"한 인스턴스의 ``물리 머티리얼`` 값을 변경하면 다른 모든 인스턴스에도 영향을 "
"미칩니다. 이는 ``물리 머티리얼``이 리소스이고 인스턴스 간에 리소스가 공유되"
"기 때문입니다. 한 인스턴스에 대해 리소스를 고유하게 만들려면 Inspector에서 해"
"당 리소스를 마우스 오른쪽 버튼으로 클릭하고 상황에 맞는 메뉴에서 유일하게 만"
"들기를 클릭하세요."

msgid ""
"Resources are another essential building block of Godot games we will cover "
"in a later lesson."
msgstr ""
"리소스는 우리가 이후 강의에서 다룰 Godot 게임의 또 다른 필수 구성 요소입니다."

msgid "Scene instances as a design language"
msgstr "디자인 언어로서의 씬 인스턴스"

msgid ""
"Instances and scenes in Godot offer an excellent design language, setting "
"the engine apart from others out there. We designed Godot around this "
"concept from the ground up."
msgstr ""
"Godot의 인스턴스와 씬은 뛰어난 디자인 언어를 제공하여 다른 엔진과 차별화됩니"
"다. 우리는 처음부터 이 개념을 중심으로 Godot를 디자인했습니다."

msgid ""
"We recommend dismissing architectural code patterns when making games with "
"Godot, such as Model-View-Controller (MVC) or Entity-Relationship diagrams. "
"Instead, you can start by imagining the elements players will see in your "
"game and structure your code around them."
msgstr ""
"Godot로 게임을 만들 때는 모델-뷰-컨트롤러(MVC)이나 엔터티-관계 다이어그램과 "
"같은 아키텍처 코드 패턴은 잊어버리세요. 대신, 플레이어가 게임에서 보게 될 요"
"소를 상상하고 이를 중심으로 코드를 구성하면 됩니다."

msgid "For example, you could break down a shooter game like so:"
msgstr "예를 들어 슈팅 게임을 다음과 같이 분류할 수 있습니다:"

msgid ""
"You can come up with a diagram like this for almost any type of game. Each "
"rectangle represents an entity that's visible in the game from the player's "
"perspective. The arrows tell you which scene owns which."
msgstr ""
"거의 모든 유형의 게임에 대해 이와 같은 다이어그램을 만들 수 있습니다. 각 사각"
"형은 플레이어의 관점에서 게임에서 볼 수 있는 엔티티를 나타냅니다. 화살표는 어"
"떤 씬이 어떤 씬을 소유하고 있는지 알려줍니다."

#, fuzzy
msgid ""
"Once you have a diagram, we recommended creating a scene for each element "
"listed in it to develop your game. You'll use instancing, either by code or "
"directly in the editor, to build your tree of scenes."
msgstr ""
"이렇게 다이어그램을 만들고 나서, 추천하는 게임 제작 과정은 다이어그램의 각 요"
"소로 이루어진 씬을 만드는 것입니다. (코드 또는 에디터에서 직접) 인스턴스화를 "
"사용해서 소유권 관계를 만들게 됩니다."

#, fuzzy
msgid ""
"Programmers tend to spend a lot of time designing abstract architectures and "
"trying to fit components into it. Designing based on scenes makes "
"development faster and more straightforward, allowing you to focus on the "
"game logic itself. Because most game components map directly to a scene, "
"using a design based on scene instantiation means you need little other "
"architectural code."
msgstr ""
"게임을 (혹은 일반적으로 소프트웨어를) 프로그래밍할 때 가장 오래 걸리는 부분"
"은 구조를 설계하고 게임의 구성 요소를 그 구조에 알맞게 끼워 넣는 것입니다. "
"이 방법을 대체하기 위해 씬을 기반으로 설계하면 게임의 논리 자체에 집중하게 되"
"어서, 개발을 좀 더 빠르고 직관적으로 만듭니다. 대부분의 게임 구성 요소가 그대"
"로 씬이 되기 때문에, 씬 인스턴스화를 기반으로 한 설계를 사용하는 것은 다른 구"
"조적 코드가 필요하지 않게 되기 때문입니다."

#, fuzzy
msgid ""
"Here's the example of a scene diagram for an open-world game with tons of "
"assets and nested elements:"
msgstr ""
"많은 애셋과 중첩된 요소들로 이루어진 오픈월드 게임의 복잡한 예를 하나 더 살펴"
"보겠습니다:"

msgid ""
"Imagine we started by creating the room. We could make a couple of different "
"room scenes, with unique arrangements of furniture in them. Later, we could "
"make a house scene that uses multiple room instances for the interior. We "
"would create a citadel out of many instanced houses and a large terrain on "
"which we would place the citadel. Each of these would be a scene instancing "
"one or more sub-scenes."
msgstr ""
"방을 만드는 것부터 시작했다고 상상해 보세요. 가구 배치 방법에 따라 여러 개의 "
"방 씬을 만들 수 있습니다. 이후 방 인스턴스를 여러 개 사용해 집 씬을 만들 수 "
"있습니다. 인스턴스화된 여러 집과 성채를 배치할 넓은 지형을 사용하면 성채도 만"
"들 수 있습니다. 이들 각각은 하나 이상의 하위 씬을 인스턴스화하는 씬입니다."

#, fuzzy
msgid ""
"Later, we could create scenes representing guards and add them to the "
"citadel. They would be indirectly added to the overall game world."
msgstr ""
"나중에는 경호원 (그리고 다른 NPC)의 씬을 만들고 마찬가지로 성에 추가할 수 있"
"습니다. 그 결과, 씬들은 게임 세상 전체에 간접적으로 추가됩니다."

#, fuzzy
msgid ""
"With Godot, it's easy to iterate on your game like this, as all you need to "
"do is create and instantiate more scenes. We designed the editor to be "
"accessible to programmers, designers, and artists alike. A typical team "
"development process can involve 2D or 3D artists, level designers, game "
"designers, and animators, all working with the Godot editor."
msgstr ""
"Godot에서는 한 번 만든 씬을 더 많은 씬으로 인스턴스하는 방식으로 작업을 쉽게 "
"반복할 수 있습니다. 게다가 에디터 UI는 프로그래머에게도 비 프로그래머에게도 "
"친근하게 설계되었습니다. 일반적인 팀 개발 과정에는 2D나 3D 아티스트, 레벨 디"
"자이너, 게임 디자이너, 애니메이터가 있지만, 모두 에디터 인터페이스에서 작업합"
"니다."

msgid "Summary"
msgstr "요약"

msgid ""
"Instancing, the process of producing an object from a blueprint has many "
"handy uses. With scenes, it gives you:"
msgstr ""
"청사진에서 객체를 생성하는 과정인 인스턴스화는 다양한 편의성을 제공합니다. 씬"
"에서 제공되는 것 :"

#, fuzzy
msgid "The ability to divide your game into reusable components."
msgstr "Bar와 Counter를 다시 사용할 수 있는 UI 구성 요소로 바꾸기"

msgid "A tool to structure and encapsulate complex systems."
msgstr "복잡한 시스템을 구조화하고 캡슐화하는 도구."

msgid ""
"A language to think about your game project's structure in a natural way."
msgstr "게임 프로젝트의 구조를 자연스러운 방법으로 생각하기 위한 언어."

msgid "Translation status"
msgstr "번역 상태"
