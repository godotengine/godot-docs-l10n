# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Background loading"
msgstr "백그라운드 로딩"

msgid ""
"When switching the main scene of your game (e.g. going to a new level), you "
"might want to show a loading screen with some indication that progress is "
"being made. The main load method (``ResourceLoader::load`` or just ``load`` "
"from GDScript) blocks your thread, making your game appear frozen and "
"unresponsive while the resource is being loaded. This document discusses the "
"alternative of using the ``ResourceInteractiveLoader`` class for smoother "
"load screens."
msgstr ""
"(새로운 레벨로 가는 것과 같이) 메인 씬을 교체하려 할 때, 로딩 진행상황을 알려"
"주는 화면을 보여주고 싶을 때가 있을 겁니다. 메인 로드 메소드"
"(``ResourceLoader::load`` 또는 그냥 GDScript에서 ``load`` 함수)는 스레드를 블"
"로킹하기 때문에 리소스가 불러와지기 전까지는 게임이 멈추고 반응하지 않는 것처"
"럼 보일 것입니다. 이 문서에서는 대신 ``ResourceInteractiveLoader`` 클래스를 "
"사용하여 보다 부드러운 로딩 화면을 만드는 법에 대해 이야기할 것입니다."

msgid "ResourceInteractiveLoader"
msgstr "ResourceInteractiveLoader"

msgid ""
"The ``ResourceInteractiveLoader`` class allows you to load a resource in "
"stages. Every time the method ``poll`` is called, a new stage is loaded, and "
"control is returned to the caller. Each stage is generally a sub-resource "
"that is loaded by the main resource. For example, if you're loading a scene "
"that loads 10 images, each image will be one stage."
msgstr ""
"``ResourceInteractiveLoader`` 클래스는 리소스를 여러 단계에 걸쳐 로드할 수 있"
"도록 합니다. ``poll`` 함수가 호출될 때마다 새로운 스테이지가 로드되며 호출한 "
"함수에게로 제어가 반환됩니다. 각 스테이지는 일반적으로 메인 리소스에 의해 로"
"드되는 서브 리소스입니다. 예를 들어 여러분이 10개의 이미지를 로드하는 씬 하나"
"를 불러온다면, 각 이미지가 하나의 스테이지가 될 것입니다."

msgid "Usage"
msgstr "사용례"

msgid "Usage is generally as follows"
msgstr "대개 아래와 같이 사용합니다"

msgid "Obtaining a ResourceInteractiveLoader"
msgstr "ResourceInteractiveLoader 가져오기"

msgid ""
"This method will give you a ResourceInteractiveLoader that you will use to "
"manage the load operation."
msgstr ""
"이 함수에서 반환된 ResourceInteractiveLoader를 사용하여 로딩 작업을 관리할 "
"수 있습니다."

msgid "Polling"
msgstr "폴링(Polling)"

msgid ""
"Use this method to advance the progress of the load. Each call to ``poll`` "
"will load the next stage of your resource. Keep in mind that each stage is "
"one entire \"atomic\" resource, such as an image, or a mesh, so it will take "
"several frames to load."
msgstr ""
"이 함수로 로딩을 한단계 더 진행시킵니다. ``poll`` 의 각 호출마다 여러분의 리"
"소스의 다음 스테이지를 로드합니다. 각 스테이지는 이미지 하나 또는 메쉬 하나"
"와 같은 하나의 \"원자적\"인 리소스임을 명심하시기 바랍니다. 그렇기 때문에 로"
"딩에 몇 프레임을 사용할 수 있습니다."

msgid ""
"Returns ``OK`` on no errors, ``ERR_FILE_EOF`` when loading is finished. Any "
"other return value means there was an error and loading has stopped."
msgstr ""
"에러가 없으면 ``OK`` 가 반환되며, 로딩이 끝나면 ``ERR_FILE_EOF`` 가 반환됩니"
"다. 그 외의 다른 리턴값은 에러가 발생했으며 로딩이 멈췄음을 의미합니다."

msgid "Load progress (optional)"
msgstr "로딩 진행도(선택사항)"

msgid "To query the progress of the load, use the following methods:"
msgstr "현재 로딩 상황을 알아보려면 다음 함수들을 사용해 보세요:"

msgid ""
"``get_stage_count`` returns the total number of stages to load. "
"``get_stage`` returns the current stage being loaded."
msgstr ""
"``get_stage_count`` 는 로딩에 필요한 전체 스테이지 수를 반환합니다. "
"``get_stage`` 는 현재 불러오는 중이 스테이지를 반환합니다."

msgid "Forcing completion (optional)"
msgstr "강제로 완료시키기 (선택사항)"

msgid ""
"Use this method if you need to load the entire resource in the current "
"frame, without any more steps."
msgstr ""
"전체 리소스를 추가 스텝 없이 현재 프레임에 전부 불러오려면 이 함수를 사용합니"
"다."

msgid "Obtaining the resource"
msgstr "리소스 가져오기"

msgid ""
"If everything goes well, use this method to retrieve your loaded resource."
msgstr ""
"모든 일들이 잘 진행됐다면 아래 함수로 불러온 리소스를 가져올 수 있습니다."

msgid "Example"
msgstr "예제"

msgid ""
"This example demonstrates how to load a new scene. Consider it in the "
"context of the :ref:`doc_singletons_autoload` example."
msgstr ""
"이 예제서는 새로운 씬을 로드하는 방법을 보여줍니다. :ref:"
"`doc_singletons_autoload` 예제의 문맥에서 봐 주시기 바랍니다."

msgid ""
"First, we set up some variables and initialize the ``current_scene`` with "
"the main scene of the game:"
msgstr ""
"우선 몇몇 변수들을 설정하고 ``current_scene`` 을 게임의 메인 씬으로 초기화합"
"니다:"

msgid ""
"The function ``goto_scene`` is called from the game when the scene needs to "
"be switched. It requests an interactive loader, and calls "
"``set_process(true)`` to start polling the loader in the ``_process`` "
"callback. It also starts a \"loading\" animation, which could show a "
"progress bar or loading screen."
msgstr ""
"``goto_scene`` 함수는 씬이 바뀌어야 할 때 게임에서 호출됩니다. 이 함수는 인터"
"랙티브 로더를 요청하고, ``set_process(true)`` 를 호출하여 ``_progress`` 콜백"
"에서 로더를 폴링하기 시작합니다. 또한 \"loading\" 애니메이션을 시작하여 프로"
"그래스 바나 로딩 화면을 보여줄 수 있습니다."

msgid ""
"``_process`` is where the loader is polled. ``poll`` is called, and then we "
"deal with the return value from that call. ``OK`` means keep polling, "
"``ERR_FILE_EOF`` means loading is done, anything else means there was an "
"error. Also note we skip one frame (via ``wait_frames``, set on the "
"``goto_scene`` function) to allow the loading screen to show up."
msgstr ""
"``_process`` 에서 로더를 폴링합니다. ``poll`` 을 호출하고 나서, 리턴값을 이용"
"해야 합니다. ``OK`` 가 리턴되면 폴링을 계속해야 하고, ``ERR_FILE_EOF`` 는 로"
"딩이 끝났으며, 다른 리턴값은 에러가 있음을 의미합니다. 또한 로딩 화면을 띄워"
"주기 위해 (``goto_scene`` 함수에서 설정한 ``wait_frames`` 변수를 통해) 한 프"
"레임을 건너뛰는 점을 참고하시기 바랍니다."

msgid ""
"Note how we use ``OS.get_ticks_msec`` to control how long we block the "
"thread. Some stages might load fast, which means we might be able to cram "
"more than one call to ``poll`` in one frame; some might take way more than "
"your value for ``time_max``, so keep in mind we won't have precise control "
"over the timings."
msgstr ""
"여기서 어떻게 ``OS.get_ticks_msec`` 를 사용하여 얼마나 이 스레드를 블로킹할"
"지 참고하시기 바랍니다. 어떤 스테이지는 빨리 로드될 수 있기 때문에 한 프레임"
"에 ``poll``을 한번 이상 호출할 수 있을지 모릅니다. 또 어떤 경우는 "
"``time_max``보다 오랜 시간이 걸릴 수도 있습니다. 따라서 타이밍에 대해서는 정"
"밀한 제어를 할 수 없다는 점을 염두하시기 바랍니다."

msgid ""
"Some extra helper functions. ``update_progress`` updates a progress bar, or "
"can also update a paused animation (the animation represents the entire load "
"process from beginning to end). ``set_new_scene`` puts the newly loaded "
"scene on the tree. Because it's a scene being loaded, ``instance()`` needs "
"to be called on the resource obtained from the loader."
msgstr ""
"몇몇 추가 도우미 함수가 있습니다. ``update_progress`` 함수는 프로그레스 바를 "
"갱신하거나 일시정지된 애니메이션을 업데이트할 수 있습니다(애니메이션은 처음부"
"터 끝까지의 로딩 진행도를 대표합니다). ``set_new_scene`` 함수가 새 씬을 트리"
"에 배치합니다. 씬을 로드한 것이기 때문에 로더에서 가져온 리소스에 "
"``instance()`` 를 호출할 필요가 있습니다."

msgid "Using multiple threads"
msgstr "멀티스레드 사용하기"

msgid ""
"ResourceInteractiveLoader can be used from multiple threads. A couple of "
"things to keep in mind if you attempt it:"
msgstr ""
"ResourceInteractiveLoader은 여러 스레드에서 사용할 수 있습니다. 사용해보기에 "
"앞서 생각해봐야 할 것들이 있습니다:"

msgid "Use a semaphore"
msgstr "세마포어 사용"

msgid ""
"While your thread waits for the main thread to request a new resource, use a "
"``Semaphore`` to sleep (instead of a busy loop or anything similar)."
msgstr ""
"지금 스레드가 메인 스레드에서 새 리소스를 요청하는 동안 (busy loop나 비슷한 "
"걸 하는 대신) sleep하기 위하여 ``Semaphore`` 를 사용하세요."

msgid "Not blocking main thread during the polling"
msgstr "폴링하는 동안에는 메인 스레드 블로킹하지 않기"

msgid ""
"If you have a mutex to allow calls from the main thread to your loader "
"class, don't lock the main thread while you call ``poll`` on your loader "
"class. When a resource is done loading, it might require some resources from "
"the low-level APIs (VisualServer, etc), which might need to lock the main "
"thread to acquire them. This might cause a deadlock if the main thread is "
"waiting for your mutex while your thread is waiting to load a resource."
msgstr ""
"메인 스레드에서 로더 클래스를 호출할 때 사용하는 뮤텍스가 있다면 로더 클래스"
"에서 ``poll`` 하는 동안에는 메인 스레드를 잠그지 않아야 합니다. 리소스 로딩"
"이 끝나면 (VisualServer과 같은) 로우레벨 API에서 일부 리소스를 필요로 할 수"
"도 있습니다. 이 API들은 리소스를 가져오기 위해 메인 스레드를 잠글 필요가 있"
"을 수도 있습니다. 이는 여러분의 스레드가 리소스 로드를 기다리는 동안 메인 스"
"레드가 여러분의 뮤텍스를 기다리고 있으므로 데드락을 일으킬 수 있습니다."

msgid "Example class"
msgstr "예제 클래스"

msgid ""
"You can find an example class for loading resources in threads here: :"
"download:`resource_queue.gd <files/resource_queue.gd>`. Usage is as follows:"
msgstr ""
"스레드 내에서 리소스 로딩을 하는 예제 클래스 예제가 있습니다: :download:"
"`resource_queue.gd <files/resource_queue.gd>`. 아래와 같이 사용하면 됩니다:"

msgid "Call after you instance the class to start the thread."
msgstr "스레드를 시작하기 위해 클래스를 인스턴싱한 다음 함수를 호출하세요."

msgid ""
"Queue a resource. Use optional argument \"p_in_front\" to put it in front of "
"the queue."
msgstr ""
"리소스를 큐에 넣습니다. 선택 인자인 \"p_in_front\"를 사용하여 큐의 앞부분에 "
"넣을 수 있습니다."

msgid "Remove a resource from the queue, discarding any loading done."
msgstr "큐에서 리소스를 제거합니다. 로딩이 끝난 리소스를 폐기합니다."

msgid ""
"Returns ``true`` if a resource is fully loaded and ready to be retrieved."
msgstr ""
"리소스 전체가 로드되었으며 가져올 준비가 된 경우 ``true`` 를 반환합니다."

msgid ""
"Get the progress of a resource. Returns -1 if there was an error (for "
"example if the resource is not in the queue), or a number between 0.0 and "
"1.0 with the progress of the load. Use mostly for cosmetic purposes "
"(updating progress bars, etc), use ``is_ready`` to find out if a resource is "
"actually ready."
msgstr ""
"리소스 로딩 진행도를 가져옵니다. (리소스가 큐에 없는 경우와 같이)에러가 있는 "
"경우 -1을 반환하고 아닌 경우 0.0에서 1.0 사이의 진행도 숫자를 반환합니다. 대"
"개 (프로그레스 바를 갱신하는 것과 같은) 보여주기 위한 용도로 사용됩니다. 리소"
"스를 실제로 사용할 수 있는지 확인하려면 ``is_ready`` 를 사용하세요."

msgid ""
"Returns the fully loaded resource, or ``null`` on error. If the resource is "
"not fully loaded (``is_ready`` returns ``false``), it will block your thread "
"and finish the load. If the resource is not on the queue, it will call "
"``ResourceLoader::load`` to load it normally and return it."
msgstr ""
"로드가 완료된 리소스를 가져오거나, 에러가 있으면 ``null``을 반환합니다. 만약 "
"리소스가 전부 로드되지 않았다면(``is_ready`` 가 ``false``인 경우), 스레드를 "
"블로킹하며 로드가 끝날 때까지 기다립니다. 만약 리소스가 큐에 없다면 평소처럼 "
"``ResourceLoader::load`` 를 호출하고 그 결과를 반환합니다."

msgid "Example:"
msgstr "예시:"

msgid ""
"**Note**: this code, in its current form, is not tested in real world "
"scenarios. If you run into any issues, ask for help in one of `Godot's "
"community channels <https://godotengine.org/community>`__."
msgstr ""
"**참고**: 이 형태의 코드는 실제 환경에서 테스트되지 않았습니다. 여기에 문제"
"가 발생했다면, `고도 커뮤니티 채널 <https://godotengine.org/community>`__ 중 "
"하나에 도움을 요청해 보세요."

msgid "Translation status"
msgstr "번역 상태"
