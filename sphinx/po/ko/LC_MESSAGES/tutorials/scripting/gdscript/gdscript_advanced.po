# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GDScript: An introduction to dynamic languages"
msgstr "GDScript: 동적 언어 소개"

msgid "About"
msgstr "정보"

msgid ""
"This tutorial aims to be a quick reference for how to use GDScript more "
"efficiently. It focuses on common cases specific to the language, but also "
"covers a lot of information on dynamically typed languages."
msgstr ""
"이 튜토리얼은 GDScript를 더 효과적으로 사용하는 방법에 대한 빠른 참고 문헌입"
"니다. 언어와 관련된 일반적인 사례 뿐만 아니라, 동적 타입 언어의 많은 정보도 "
"다루고 있습니다."

msgid ""
"It's meant to be especially useful for programmers with little or no "
"previous experience with dynamically typed languages."
msgstr ""
"이 문서는 특히 이전까지 동적 타입 언어에 대한 경험이 없던 프로그래머에게 더 "
"유용합니다."

msgid "Dynamic nature"
msgstr "동적 성질"

msgid "Pros & cons of dynamic typing"
msgstr "동적 타이핑의 장단점"

msgid ""
"GDScript is a Dynamically Typed language. As such, its main advantages are "
"that:"
msgstr "GDScript는 동적 타입 언어입니다. 따라서, 주요 장점은 다음과 같습니다:"

#, fuzzy
msgid "The language is easy to get started with."
msgstr "언어가 간결하고 배우기 쉽습니다."

msgid "Most code can be written and changed quickly and without hassle."
msgstr "대부분의 코드를 쉽고 빠르게 작성하고 변경할 수 있습니다."

msgid "Less code written means less errors & mistakes to fix."
msgstr "적은 코드 작성으로 오류와 실수를 줄일 수 있습니다."

msgid "The code is easy to read (little clutter)."
msgstr ""

msgid "No compilation is required to test."
msgstr "테스트하기 위한 컴파일 작업이 필요 없습니다."

msgid "Runtime is tiny."
msgstr "런타임이 작습니다."

#, fuzzy
msgid "It has duck-typing and polymorphism by nature."
msgstr "덕 타이핑(Duck-typing)과 폴리모피즘(polymorphism)."

msgid "While the main disadvantages are:"
msgstr "반면 주요 단점은 다음과 같습니다:"

msgid "Less performance than statically typed languages."
msgstr "정적 타입 언어보다 낮은 퍼포먼스."

#, fuzzy
msgid "More difficult to refactor (symbols can't be traced)."
msgstr "리팩토링하기 더 어려움(기호(symbol)를 추적할 수 없음)"

msgid ""
"Some errors that would typically be detected at compile time in statically "
"typed languages only appear while running the code (because expression "
"parsing is more strict)."
msgstr ""
"정적 타입 언어에서 컴파일 시간에 감지되는 오류가 오직 코드를 실행할 때만 나타"
"납니다 (정적 타입 언어에서의 표현 구문 분석이 더 엄격하기 때문입니다)."

msgid ""
"Less flexibility for code-completion (some variable types are only known at "
"run-time)."
msgstr "코드 완성에 덜 유연함 (일부 변수 타입은 런타임에만 알려집니다)."

#, fuzzy
msgid ""
"This, translated to reality, means that Godot used with GDScript is a "
"combination designed to create games quickly and efficiently. For games that "
"are very computationally intensive and can't benefit from the engine built-"
"in tools (such as the Vector types, Physics Engine, Math library, etc), the "
"possibility of using C++ is present too. This allows you to still create "
"most of the game in GDScript and add small bits of C++ in the areas that "
"need a performance boost."
msgstr ""
"이것은 현실로 번역하면 Godot+GDScript가 게임을 빠르고 효율적으로 생성하도록 "
"설계된 조합임을 의미합니다. 매우 계산 집약적이고 엔진 내장 툴(예: 벡터 타입, "
"물리 엔진, 수학 라이브러리 등)의 이점을 얻을 수 없는 게임의 경우 C++를 사용"
"할 수 있는 가능성도 있습니다. 이를 통해 여전히 GDScript에서 대부분의 게임을 "
"생성하고 성능 향상이 필요한 영역에만 약간의 C++를 추가할 수 있습니다."

msgid "Variables & assignment"
msgstr "변수 & 할당"

msgid ""
"All variables in a dynamically typed language are \"variant\"-like. This "
"means that their type is not fixed, and is only modified through assignment. "
"Example:"
msgstr ""
"동적 타입 언어의 모든 변수는 \"변이형(variant)\"과 유사합니다. 즉, 변수 타입"
"은 고정되어 있지 않고 할당을 통해서만 수정됩니다. 예제:"

msgid "Static:"
msgstr "정적 언어:"

msgid "Dynamic:"
msgstr "동적 언어:"

msgid "As function arguments:"
msgstr "함수 인수로:"

msgid ""
"Functions are of dynamic nature too, which means they can be called with "
"different arguments, for example:"
msgstr ""
"함수도 동적인 특성을 지니므로 함수를 다른 인수로 호출할 수 있습니다. 예를 들"
"면:"

msgid "Pointers & referencing:"
msgstr "포인터(Pointer) & 참조:"

msgid ""
"In static languages, such as C or C++ (and to some extent Java and C#), "
"there is a distinction between a variable and a pointer/reference to a "
"variable. The latter allows the object to be modified by other functions by "
"passing a reference to the original one."
msgstr ""
"C 나 C++ (그리고 어느 정도는 Java와 C#) 같은 정적 언어에서, 변수와 변수에 대"
"한 포인터/참조는 구별됩니다. 후자는 원래의 참조를 전달하여 다른 함수에 의해 "
"오브젝트가 수정되도록 할 수 있습니다."

msgid ""
"In C# or Java, everything not a built-in type (int, float, sometimes String) "
"is always a pointer or a reference. References are also garbage-collected "
"automatically, which means they are erased when no longer used. Dynamically "
"typed languages tend to use this memory model, too. Some Examples:"
msgstr ""
"C#, Java에서 내장 타입(int, float, 때로는 String)이 아닌 모든 것은 항상 포인"
"터 또는 참조입니다. 참조도 자동으로 가비지 컬렉터가 수집하므로 더 이상 사용하"
"지 않으면 지워집니다. 동적으로 타입이 지정된 언어도 이 메모리 모델을 사용하"
"는 경향이 있습니다. 몇 가지 예:"

msgid "C++:"
msgstr "C++:"

msgid "Java:"
msgstr "Java:"

msgid "GDScript:"
msgstr "GDScript:"

#, fuzzy
msgid ""
"In GDScript, only base types (int, float, string and the vector types) are "
"passed by value to functions (value is copied). Everything else (instances, "
"arrays, dictionaries, etc) is passed as reference. Classes that inherit :ref:"
"`class_RefCounted` (the default if nothing is specified) will be freed when "
"not used, but manual memory management is allowed too if inheriting manually "
"from :ref:`class_Object`."
msgstr ""
"GDScript에서는 기본 타입(int, float, String, Vector 타입)만 값으로 함수에 전"
"달됩니다(값이 복사됨). 다른 모든 것(인스턴스, 배열, 딕셔너리 등)은 참조로 전"
"달됩니다. :ref:`class_Reference`\\ (아무것도 지정되지 않은 경우 기본값)를 상"
"속하는 클래스는 사용되지 않을 때 해제되지만 :ref:`class_Object`\\ 에서 수동으"
"로 상속하는 경우 수동 메모리 관리가 가능합니다."

msgid "Arrays"
msgstr "배열"

msgid ""
"Arrays in dynamically typed languages can contain many different mixed "
"datatypes inside and are always dynamic (can be resized at any time). "
"Compare for example arrays in statically typed languages:"
msgstr ""
"동적 타입 언어에서의 배열은 다양한 혼합 데이터 타입을 포함할 수 있으며 항상 "
"동적입니다 (어느 때나 크기가 조절될 수 있습니다). 정적 타입 언어의 배열과 비"
"교하는 예제:"

msgid "And in GDScript:"
msgstr "그리고 GDScript에서는:"

msgid ""
"In dynamically typed languages, arrays can also double as other datatypes, "
"such as lists:"
msgstr ""
"동적 타입 언어에서, 배열은 리스트(list)와 같은 다른 데이터 타입으로도 사용할 "
"수도 있습니다:"

msgid "Or unordered sets:"
msgstr "또는 순서가 없는 집합(unordered set)이 될 수도 있습니다:"

msgid "Dictionaries"
msgstr "딕셔너리"

msgid ""
"Dictionaries are a powerful tool in dynamically typed languages. Most "
"programmers that come from statically typed languages (such as C++ or C#) "
"ignore their existence and make their life unnecessarily more difficult. "
"This datatype is generally not present in such languages (or only in limited "
"form)."
msgstr ""
"딕셔너리는 동적 타입 언어에서 강력한 툴입니다. 정적 타입 언어(C++나 C#)를 사"
"용하는 대부분의 프로그래머는 딕셔너리의 존재를 무시해서 불필요하게 삶을 더 어"
"렵게 만듭니다. 이 데이터 타입은 일반적으로 그러한 언어에서 존재하지 않습니다"
"(또는 제한된 형태로만 존재합니다)."

msgid ""
"Dictionaries can map any value to any other value with complete disregard "
"for the datatype used as either key or value. Contrary to popular belief, "
"they are efficient because they can be implemented with hash tables. They "
"are, in fact, so efficient that some languages will go as far as "
"implementing arrays as dictionaries."
msgstr ""
"딕셔너리는 키나 값으로 사용되는 데이터 타입을 완전히 무시하고 모든 값을 다른 "
"값에 매핑할 수 있습니다. 일반적인 편견과 달리 딕셔너리는 해시 테이블로 구현"
"될 수 있기 때문에 효율적입니다. 실제로 일부 언어는 배열을 딕셔너리로 구현하기"
"까지 할 정도로 효율적입니다."

msgid "Example of Dictionary:"
msgstr "딕셔너리의 예제:"

msgid ""
"Dictionaries are also dynamic, keys can be added or removed at any point at "
"little cost:"
msgstr ""
"딕셔너리 또한 동적이기에, 적은 비용으로 어디에나 키를 추가하고 삭제할 수 있습"
"니다:"

#, fuzzy
msgid ""
"In most cases, two-dimensional arrays can often be implemented more easily "
"with dictionaries. Here's a battleship game example:"
msgstr ""
"대부분의 경우, 2차원 배열은 종종 딕셔너리로 더 쉽게 구현될 수 있습니다. 여기 "
"간단한 배틀쉽(Battleship) 게임 예제가 있습니다:"

msgid ""
"Dictionaries can also be used as data markup or quick structures. While "
"GDScript's dictionaries resemble python dictionaries, it also supports Lua "
"style syntax and indexing, which makes it useful for writing initial states "
"and quick structs:"
msgstr ""
"딕셔너리는 데이터 마크업이나 빠른 구조에도 사용될 수 있습니다. GDScript 딕셔"
"너가 python 딕셔너리와 닮은 한편, GDScript는 초기 상태와 빠른 구조체를 작성하"
"는 데 유용한 Lua 스타일 문법과 인덱싱도 지원합니다:"

msgid "For & while"
msgstr "for & while"

#, fuzzy
msgid ""
"Iterating using the C-style for loop in C-derived languages can be quite "
"complex:"
msgstr "일부 정적 타입 언어에서 반복문은 꽤 복잡해질 수 있습니다:"

msgid ""
"Because of this, GDScript makes the opinionated decision to have a for-in "
"loop over iterables instead:"
msgstr ""

msgid ""
"Container datatypes (arrays and dictionaries) are iterable. Dictionaries "
"allow iterating the keys:"
msgstr ""
"컨테이너 데이터 타입(배열과 딕셔너리)도 반복 가능합니다. 딕셔너리는 키를 반복"
"할 수 있습니다:"

msgid "Iterating with indices is also possible:"
msgstr "인덱스로 반복하기도 가능합니다:"

msgid "The range() function can take 3 arguments:"
msgstr "range() 함수는 3개의 인수를 가질 수 있습니다:"

msgid "Some examples involving C-style for loops:"
msgstr ""

msgid "Translate to:"
msgstr "번역:"

#, fuzzy
msgid "And backwards looping done through a negative counter:"
msgstr "그리고 음수 카운터를 통해 역방향 루프가 됩니다:"

msgid "Becomes:"
msgstr "위는 이렇게 구현됩니다:"

msgid "While"
msgstr "동안"

msgid "while() loops are the same everywhere:"
msgstr "while() 루프는 모든 곳에서 동일합니다:"

msgid "Custom iterators"
msgstr "커스텀 반복자(Iterator)"

msgid ""
"You can create custom iterators in case the default ones don't quite meet "
"your needs by overriding the Variant class's ``_iter_init``, ``_iter_next``, "
"and ``_iter_get`` functions in your script. An example implementation of a "
"forward iterator follows:"
msgstr ""
"스크립트에서 Variant 클래스의 ``_iter_init``, ``_iter_next``, ``_iter_get`` "
"함수를 재정의해서 기본 반복자가 필요에 맞지 않는 경우 커스텀 반복자를 만들 "
"수 있습니다. 순방향 반복기의 구현 예는 다음과 같습니다."

msgid "And it can be used like any other iterator:"
msgstr "그리고 모든 다른 반복자처럼 사용될 수 있습니다:"

msgid ""
"Make sure to reset the state of the iterator in ``_iter_init``, otherwise "
"nested for-loops that use custom iterators will not work as expected."
msgstr ""
"``_iter_init``\\ 에서 반복자의 상태를 리셋해야 합니다. 그렇지 않으면 커스텀 "
"반복자를 사용하는 중첩된 for 루프가 예상대로 작동하지 않습니다."

msgid "Duck typing"
msgstr "덕 타이핑(Duck typing)"

msgid ""
"One of the most difficult concepts to grasp when moving from a statically "
"typed language to a dynamic one is duck typing. Duck typing makes overall "
"code design much simpler and straightforward to write, but it's not obvious "
"how it works."
msgstr ""
"정적 타입 언어에서 동적 타입 언어로 이동할 때 가장 이해하기 어려운 개념 중 하"
"나는 덕 타이핑입니다. 덕 타이핑을 사용하면 전체 코드 디자인을 훨씬 간단하고 "
"쉽게 작성할 수 있지만 작동 방식이 명확하지 않습니다."

msgid ""
"As an example, imagine a situation where a big rock is falling down a "
"tunnel, smashing everything on its way. The code for the rock, in a "
"statically typed language would be something like:"
msgstr ""
"예를 들어 큰 바위가 터널 아래로 떨어져 진행 경로의 모든 것을 부수는 상황을 상"
"상해 보세요. 정적 타입 언어의 바위 코드는 다음과 같을 것입니다:"

msgid ""
"This way, everything that can be smashed by a rock would have to inherit "
"Smashable. If a character, enemy, piece of furniture, small rock were all "
"smashable, they would need to inherit from the class Smashable, possibly "
"requiring multiple inheritance. If multiple inheritance was undesired, then "
"they would have to inherit a common class like Entity. Yet, it would not be "
"very elegant to add a virtual method ``smash()`` to Entity only if a few of "
"them can be smashed."
msgstr ""
"이렇게 하면 바위에 의해 박살날 수 있는 모든 것이 Smashable을 상속받아야 합니"
"다. 캐릭터, 적, 가구, 작은 바위가 모두 부숴질 수 있는 경우 Smashable 클래스에"
"서 상속받아야 하며 다중 상속이 필요할 수 있습니다. 다중 상속이 바람직하지 않"
"은 경우 Entity와 같은 공통 클래스를 상속받아야 합니다. 그러나 Entity들 중 일"
"부만이 박살날 수 있다고 해서 가상 메서드 ``smash()`` 를 추가하는 것은 그리 우"
"아하지 않을 것입니다."

msgid ""
"With dynamically typed languages, this is not a problem. Duck typing makes "
"sure you only have to define a ``smash()`` function where required and "
"that's it. No need to consider inheritance, base classes, etc."
msgstr ""
"동적 타입 언어에서는 문제가 되지 않습니다. 덕 타이핑을 사용하면 필요한 경우 "
"``smash()`` 함수만 정의하면 됩니다. 상속, 기본 클래스 등을 고려할 필요가 없습"
"니다."

msgid ""
"And that's it. If the object that hit the big rock has a smash() method, it "
"will be called. No need for inheritance or polymorphism. Dynamically typed "
"languages only care about the instance having the desired method or member, "
"not what it inherits or the class type. The definition of Duck Typing should "
"make this clearer:"
msgstr ""
"이게 다에요. 큰 바위에 부딪힌 객체에 smash() 메서드가 있으면 호출됩니다. 상속"
"이나 다형성이 필요하지 않습니다. 동적 타입 언어는 원하는 메소드 또는 멤버가 "
"있는 인스턴스에만 관심이 있으며 상속 대상이나 클래스 유형이 아닙니다. 덕 타이"
"핑의 정의는 이를 더 명확하게 만듭니다:"

msgid ""
"*\"When I see a bird that walks like a duck and swims like a duck and quacks "
"like a duck, I call that bird a duck\"*"
msgstr ""
"*\"내가 오리처럼 걷고 오리처럼 수영하고 오리처럼 우는 새를 볼 때, 나는 그 새"
"를 오리라고 부른다\"*"

msgid "In this case, it translates to:"
msgstr "우리의 경우에는, 다음과 같이 번역됩니다:"

msgid ""
"*\"If the object can be smashed, don't care what it is, just smash it.\"*"
msgstr "*\"물체를 박살낼 수 있다면, 무엇이든 상관없이, 그냥 박살낸다.\"*"

msgid "Yes, we should call it Hulk typing instead."
msgstr "예, 우리는 이를 대신 헐크 타이핑이라 불러야겠네요."

msgid ""
"It's possible that the object being hit doesn't have a smash() function. "
"Some dynamically typed languages simply ignore a method call when it doesn't "
"exist, but GDScript is stricter, so checking if the function exists is "
"desirable:"
msgstr ""
"충돌한 물체에 smash() 함수가 없을 수도 있습니다. 일부 동적 타입 언어는 존재하"
"지 않는 메서드 호출은 간단히 무시하지만 GDScript는 더 엄격하므로 함수가 존재"
"하는지 확인하는 것이 바람직합니다:"

msgid ""
"Then, simply define that method and anything the rock touches can be smashed."
msgstr ""
"그런 다음 메서드를 정의하기만 하면 바위가 닿는 모든 것이 박살날 수 있습니다."

msgid "Translation status"
msgstr "번역 상태"
