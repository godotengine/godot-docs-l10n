# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using SceneTree"
msgstr "씬 트리(SceneTree) 사용하기"

msgid "Introduction"
msgstr "소개"

msgid ""
"In previous tutorials, everything revolved around the concept of nodes. "
"Scenes are collections of nodes. They become active once they enter the "
"*scene tree*."
msgstr ""
"이전 튜토리얼에서는 모든 것이 노드 개념을 중심으로 진행됐습니다. 씬은 노드의 "
"모음입니다. 노드는 *씬 트리(scene tree)*\\ 에 들어가면 활성화됩니다."

msgid "MainLoop"
msgstr "메인루프(MainLoop)"

msgid ""
"The way Godot works internally is as follows. There is the :ref:`OS "
"<class_OS>` class, which is the only instance that runs at the beginning. "
"Afterwards, all drivers, servers, scripting languages, scene system, etc are "
"loaded."
msgstr ""
"Godot가 내부적으로 작동하는 방식은 다음과 같습니다. 처음에 실행되는 유일한 인"
"스턴스인 :ref:`OS <class_OS>` 클래스가 있습니다. 그 이후에 모든 드라이버, 서"
"버, 스크립팅 언어, 씬 시스템 등을 불러옵니다."

msgid ""
"When initialization is complete, :ref:`OS <class_OS>` needs to be supplied "
"a :ref:`MainLoop <class_MainLoop>` to run. Up to this point, all this is "
"internals working (you can check main/main.cpp file in the source code if "
"you are ever interested to see how this works internally)."
msgstr ""
"초기화가 완료될 때 :ref:`OS <class_OS>`\\ 를 실행하려면 :ref:`MainLoop "
"<class_MainLoop>`\\ 가 제공되어야 합니다. 여기까지는 이 모든 것이 내부적으로 "
"작동하는 방식입니다(내부적으로 어떻게 작동하는지 알고 싶다면 소스 코드에서 "
"main/main.cpp 파일을 확인하세요)."

msgid ""
"The user program, or game, starts in the MainLoop. This class has a few "
"methods, for initialization, idle (frame-synchronized callback), fixed "
"(physics-synchronized callback), and input. Again, this is low level and "
"when making games in Godot, writing your own MainLoop seldom makes sense."
msgstr ""
"사용자 프로그램, 게임은 MainLoop에서 시작됩니다. 이 클래스에는 초기화, 유휴: "
"프레임에 동기화된 콜백(idle: frame-synchronized callback), 고정: 물리에 동기"
"화된 콜백(fixed: physics-synchronized callback) 및 입력에 대한 몇 가지 메서드"
"가 있습니다. 다시 말하지만, 이는 로우 레벨이며 Godot에서 게임을 만들 때 "
"MainLoop를 작성하는 것은 거의 의미가 없습니다."

msgid "SceneTree"
msgstr "씬트리"

msgid ""
"One of the ways to explain how Godot works is that it's a high level game "
"engine over a low level middleware."
msgstr ""
"Godot가 어떻게 작동하는지 설명하는 방법 중 하나는 Godot가 저수준 미들웨어보"
"다 높은 수준의 게임 엔진이라는 것입니다."

msgid ""
"The scene system is the game engine, while the :ref:`OS <class_OS>` and "
"servers are the low level API."
msgstr ""
"씬 시스템은 게임 엔진이고 :ref:`OS <class_OS>`\\ 와 서버는 로우 레벨 API입니"
"다."

msgid ""
"The scene system provides its own main loop to OS, :ref:`SceneTree "
"<class_SceneTree>`. This is automatically instanced and set when running a "
"scene, no need to do any extra work."
msgstr ""
"씬 시스템은 OS, 즉 :ref:`SceneTree <class_SceneTree>`\\ 에 자체 메인 루프를 "
"제공합니다. 메인 루프는 씬이 실행되는 동안 자동으로 인스턴스화되고 설정되므"
"로 추가 작업을 수행할 필요가 없습니다."

msgid ""
"It's important to know that this class exists because it has a few important "
"uses:"
msgstr ""
"이 클래스는 몇 가지 중요한 용도로 쓰이기 때문에 이 클래스가 존재한다는 것을 "
"아는 것이 중요합니다:"

#, fuzzy
msgid ""
"It contains the root :ref:`Viewport <class_Viewport>`, to which a scene is "
"added as a child when it's first opened to become part of the *Scene Tree* "
"(more on that next)."
msgstr ""
"루트 노드로 :ref:`Viewport <class_Viewport>`\\ 가 포함되어 있으며, *씬 트리"
"*\\ 에 자식으로 추가되어서 씬 트리의 일부가 됩니다(자세한 내용은 다음에 설"
"명)."

msgid ""
"It contains information about the groups and has the means to call all nodes "
"in a group or get a list of them."
msgstr ""
"그룹에 관한 정보가 포함되어 있어서 그룹의 모든 노드를 호출하거나 그룹의 목록"
"을 가져옵니다."

msgid ""
"It contains some global state functionality, such as setting pause mode or "
"quitting the process."
msgstr ""
"일시 정지 모드 설정이나 프로세스 종료와 같은, 일부 전역 상태 기능이 포함되어 "
"있습니다."

msgid ""
"When a node is part of the Scene Tree, the :ref:`SceneTree "
"<class_SceneTree>` singleton can be obtained by calling :ref:`Node."
"get_tree() <class_Node_method_get_tree>`."
msgstr ""
"노드가 씬 트리의 일부인 경우 :ref:`Node.get_tree() "
"<class_Node_method_get_tree>`\\ 를 호출해서 :ref:`SceneTree "
"<class_SceneTree>` 싱글톤(Singleton)을 가져올 수 있습니다."

msgid "Root viewport"
msgstr "루트 뷰포트(Root viewport)"

msgid ""
"The root :ref:`Viewport <class_Viewport>` is always at the top of the scene. "
"From a node, it can be obtained in two different ways:"
msgstr ""
"루트 :ref:`Viewport <class_Viewport>`\\ 는 항상 씬의 맨 위에 있습니다. 노드에"
"서 두 가지 다른 방법으로 가져올 수 있습니다:"

msgid ""
"This node contains the main viewport. Anything that is a child of a :ref:"
"`Viewport <class_Viewport>` is drawn inside of it by default, so it makes "
"sense that the top of all nodes is always a node of this type otherwise "
"nothing would be seen."
msgstr ""
"이 노드는 메인 뷰포트를 포함합니다. :ref:`Viewport <class_Viewport>`\\ 의 모"
"든 자식은 기본적으로 그 안에 그려지므로 모든 노드의 맨 위는 항상 이 타입의 노"
"드이며 그렇지 않으면 아무 것도 보이지 않을 것입니다."

msgid ""
"While other viewports can be created in the scene (for split-screen effects "
"and such), this one is the only one that is never created by the user. It's "
"created automatically inside SceneTree."
msgstr ""
"씬에 다른 뷰포트를 만들 수도 있지만(분할 화면 효과 등을 위해서) 루트 뷰포트"
"는 유저가 만들 수 없는 유일한 노드입니다. 씬 트리에서 자동으로 생성됩니다."

msgid "Scene tree"
msgstr "씬 트리"

msgid ""
"When a node is connected, directly or indirectly, to the root viewport, it "
"becomes part of the *scene tree*."
msgstr ""
"노드가 루트 뷰포트에 직·간접적으로 연결되면 *씬 트리*\\ 의 일부가 됩니다."

msgid ""
"This means that as explained in previous tutorials, it will get the "
"``_enter_tree()`` and ``_ready()`` callbacks (as well as ``_exit_tree()``)."
msgstr ""
"즉, 이전 튜토리얼에서 설명했듯이 ``_enter_tree()``, ``_ready()`` 콜백 (및 "
"``_exit_tree()``)을 가져옵니다."

msgid ""
"When nodes enter the *Scene Tree*, they become active. They get access to "
"everything they need to process, get input, display 2D and 3D visuals, "
"receive and send notifications, play sounds, etc. When they are removed from "
"the *scene tree*, they lose these abilities."
msgstr ""
"노드는 *씬 트리*\\ 에 들어가면 활성화됩니다. 노드는 입력을 받거나 처리하고, "
"2D 및 3D 오브젝트를 화면에 표시하고, 알림을 송·수신하고, 소리를 재생하는 등 "
"필요한 모든 것에 접근할 수 있습니다. 노드가 *씬 트리*\\ 에서 제거되면 이러한 "
"능력을 잃게 됩니다."

msgid "Tree order"
msgstr "트리 순서"

msgid ""
"Most node operations in Godot, such as drawing 2D, processing, or getting "
"notifications are done in *tree order*, or top to bottom as seen in the "
"editor (also known as pre-order traversal):"
msgstr ""

msgid ""
"For example, the top node in a scene has its ``_process()`` function called "
"first, then the node below it has its ``_process()`` function called, then "
"the node below that and so on."
msgstr ""

msgid ""
"An important exception is the ``_ready()`` function: each parent node has "
"its ``_ready()`` function called only after all its child nodes have their "
"``_ready()`` functions called, so that the parent knows its children are "
"completely ready to be accessed. This is also known as post-order traversal. "
"In the above image, ``NameLabel`` would be notified first (but only after "
"its children, if it had any!), followed by ``Name``, etc., and ``Panel`` "
"would be notified last."
msgstr ""

msgid ""
"The order of operations can also be overridden using the "
"``process_priority`` node property. Nodes with a lower number are called "
"first. For example, nodes with the priorities \"0, 1, 2, 3\" would be called "
"in that order from left to right."
msgstr ""

msgid "\"Becoming active\" by entering the *Scene Tree*"
msgstr "*씬 트리*\\ 에 들어가서 \"활성화되기\""

msgid "A scene is loaded from disk or created by scripting."
msgstr "씬은 디스크에서 불러오거나 스크립트에 의해 만들어집니다."

#, fuzzy
msgid ""
"The root node of that scene (only one root, remember?) is added as either a "
"child of the \"root\" Viewport (from SceneTree), or to any of its "
"descendants."
msgstr ""
"씬의 루트 노드(단 하나의 루트, 기억하시나요?)는 (씬 트리의) \"루트\" 뷰포트"
"의 자식으로, 혹은 노드의 자식이나 손주로 추가됩니다."

#, fuzzy
msgid ""
"Every node of the newly added scene will receive the \"enter_tree\" "
"notification ( ``_enter_tree()`` callback in GDScript) in top-to-bottom "
"order (pre-order traversal)."
msgstr ""
"새로 추가된 장면의 모든 노드는 위에서 아래로 \"enter_tree\" 알림(GDScript의 "
"_enter_tree() 콜백)을 수신합니다."

#, fuzzy
msgid ""
"Every node will receive the \"ready\" notification ( ``_ready()`` callback "
"in GDScript) for convenience, once all its children have received the "
"\"ready\" notification (post-order traversal)."
msgstr ""
"노드와 모든 자식이 활성화된 씬 안에 있을 때 편의를 위해 \"ready\"(GDScript의 "
"_ready() 콜백)라는 추가 알림이 제공됩니다."

#, fuzzy
msgid ""
"When a scene (or part of it) is removed, they receive the \"exit scene\" "
"notification ( ``_exit_tree()`` callback in GDScript) in bottom-to-top order "
"(the exact reverse of top-to-bottom order)."
msgstr ""
"씬(또는 씬의 일부분)이 제거되면, 아래에서 위 순서로 \"exit scene\" 알림"
"(GDScript에서는 _exit_tree() 콜백)을 수신합니다"

msgid "Changing current scene"
msgstr "현재 씬 변경하기"

#, fuzzy
msgid ""
"After a scene is loaded, you may want to change this scene for another one. "
"One way to do this is to use the :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` function:"
msgstr ""
"씬을 불러온 후에 다른 씬으로 변경하고 싶을 수 있습니다. 이를 수행하는 간단한 "
"방법은 :ref:`SceneTree.change_scene() <class_SceneTree_method_change_scene>` "
"함수를 사용하는 것입니다:"

#, fuzzy
msgid ""
"Rather than using file paths, one can also use ready-made :ref:`PackedScene "
"<class_PackedScene>` resources using the equivalent function :ref:`SceneTree."
"change_scene_to_packed(PackedScene scene) "
"<class_SceneTree_method_change_scene_to_packed>`:"
msgstr ""
"파일 경로를 사용하는 대신 동일한 함수 :ref:`SceneTree."
"change_scene_to(PackedScene scene) "
"<class_SceneTree_method_change_scene_to>`\\ 를 사용해 이미 만들어진 :ref:"
"`PackedScene <class_PackedScene>` 리소스를 사용할 수 있습니다:"

#, fuzzy
msgid ""
"These are quick and useful ways to switch scenes but have the drawback that "
"the game will stall until the new scene is loaded and running. At some point "
"in the development of your game, it may be preferable to create proper "
"loading screens with progress bar, animated indicators or threaded "
"(background) loading. This must be done manually using :ref:"
"`doc_singletons_autoload` and :ref:`doc_background_loading`."
msgstr ""
"이는 씬을 전환하는 빠르고 유용한 방법이지만 새 씬을 불러와 실행할 때까지 게임"
"이 중단된다는 단점이 있습니다. 게임 개발의 어느 시점에 프로그레스 바, 애니메"
"이션 표시기나 스레드(배경) 로딩을 사용한 적절한 로딩 화면을 만드는 것이 바람"
"직합니다. 오토로드(다음 장 참조) 및 :ref:`doc_background_loading`\\ 을 사용해"
"서 수동으로 작업해야 합니다."

msgid "Translation status"
msgstr "번역 상태"
