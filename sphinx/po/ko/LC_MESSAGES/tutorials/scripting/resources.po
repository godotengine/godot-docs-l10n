# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Resources"
msgstr "리소스"

msgid "Nodes and resources"
msgstr "노드와 리소스"

msgid ""
"Up to this tutorial, we focused on the :ref:`Node <class_Node>` class in "
"Godot as that's the one you use to code behavior and most of the engine's "
"features rely on it. There is another datatype that is just as important: :"
"ref:`Resource <class_Resource>`."
msgstr ""
"지금까지 우리는 Godot에서 동작을 코딩하는 데 쓰이고 엔진 대부분의 기능이 의존"
"하는 :ref:`Node <class_Node>` 클래스에 초점을 두었습니다. 이와 마찬가지로 중"
"요한 데이터 타입: :ref:`Resource <class_Resource>`\\ 가 있습니다."

msgid ""
"*Nodes* give you functionality: they draw sprites, 3D models, simulate "
"physics, arrange user interfaces, etc. **Resources** are **data "
"containers**. They don't do anything on their own: instead, nodes use the "
"data contained in resources."
msgstr ""
"*노드(Node)*\\ 는 스프라이트, 3D 모델, 물리 시뮬레이션, 유저 인터페이스 정렬 "
"등의 기능을 제공합니다. **리소스(Resource)**\\ 는 **데이터 컨테이너**\\ 입니"
"다. 리소스 자체적으로는 아무 것도 하지 않습니다. 대신 노드는 리소스에 포함된 "
"데이터를 사용합니다."

#, fuzzy
msgid ""
"Anything Godot saves or loads from disk is a resource. Be it a scene (a ``."
"tscn`` or an ``.scn`` file), an image, a script... Here are some :ref:"
"`Resource <class_Resource>` examples:"
msgstr ""
"Godot가 디스크에 저장하거나 디스크에서 불러오는 모든 것은 리소스입니다. 씬"
"(``.tscn`` 또는 ``.scn`` 파일), 이미지, 스크립트 등이 있습니다. 다음은 몇 가"
"지 ``리소스``\\ 의 예입니다: :ref:`텍스처(Texture) <class_Texture>` , :ref:`"
"스크립트(Script) <class_Script>`, :ref:`메시(Mesh) <class_Mesh>`, :ref:`애니"
"메이션(Animation) <class_Animation>`, :ref:`오디오스트림(AudioStream) "
"<class_AudioStream>`, :ref:`폰트(Font) <class_Font>` , :ref:`번역"
"(Translation) <class_Translation>`."

#, fuzzy
msgid ":ref:`Texture <class_Texture>`"
msgstr ":ref:`Vector2 <class_Vector2>`"

#, fuzzy
msgid ":ref:`Script <class_Script>`"
msgstr ":ref:`Sprite <class_Sprite>`"

#, fuzzy
msgid ":ref:`Mesh <class_Mesh>`"
msgstr ":ref:`CSGMesh <class_CSGMesh>`"

#, fuzzy
msgid ":ref:`Animation <class_Animation>`"
msgstr ":ref:`AnimatedSprite <class_AnimatedSprite>`"

#, fuzzy
msgid ":ref:`AudioStream <class_AudioStream>`"
msgstr ":ref:`Area2D <class_Area2D>`"

#, fuzzy
msgid ":ref:`Font <class_Font>`"
msgstr ":ref:`int <class_int>`"

#, fuzzy
msgid ":ref:`Translation <class_Translation>`"
msgstr ":ref:`Transform <class_Transform>`"

msgid ""
"When the engine loads a resource from disk, **it only loads it once**. If a "
"copy of that resource is already in memory, trying to load the resource "
"again will return the same copy every time. As resources only contain data, "
"there is no need to duplicate them."
msgstr ""
"엔진이 디스크에서 리소스를 불러올 때 **항상 한 번만 불러옵니다**. 해당 리소스"
"의 복사본이 이미 메모리에 있는 경우 리소스를 다시 불러오려고 하면 매번 같은 "
"복사본을 반환합니다. 리소스에는 데이터만 포함되어 있으므로 리소스를 복제할 필"
"요가 없습니다."

msgid ""
"Every object, be it a Node or a Resource, can export properties. There are "
"many types of Properties, like String, integer, Vector2, etc., and any of "
"these types can become a resource. This means that both nodes and resources "
"can contain resources as properties:"
msgstr ""
"노드 또는 리소스와 같은 모든 개체는 속성을 내보낼 수 있습니다. String, "
"integer, Vector2 등과 같은 많은 타입의 속성 중 하나가 리소스가 될 수 있습니"
"다. 즉, 노드와 리소스 모두 리소스를 속성으로 포함할 수 있습니다:"

msgid "External vs built-in"
msgstr "외부(External) vs 내장(built-in)"

msgid "There are two ways to save resources. They can be:"
msgstr ""
"리소스를 저장하는 두 가지 방법이 있습니다. 두 가지 방법은 다음과 같습니다:"

msgid "**External** to a scene, saved on the disk as individual files."
msgstr "씬의 **외부** 에 개별 파일로 저장."

msgid ""
"**Built-in**, saved inside the ``.tscn`` or the ``.scn`` file they're "
"attached to."
msgstr "``.tscn``\\ 이나 ``.scn`` 파일 안에 **내장**\\ 된 채로 저장."

#, fuzzy
msgid ""
"To be more specific, here's a :ref:`Texture2D <class_Texture2D>` in a :ref:"
"`Sprite2D <class_Sprite2D>` node:"
msgstr ""
"좀 더 구체적으로 말하면, 다음은 :ref:`Sprite <class_Sprite>` 노드의 :ref:"
"`Texture <class_Texture>`\\ 입니다:"

#, fuzzy
msgid ""
"Clicking the resource preview allows us to view the resource's properties."
msgstr "리소스 미리보기를 클릭해서 리소스를 보고 속성을 편집할 수 있습니다."

msgid ""
"The path property tells us where the resource comes from. In this case, it "
"comes from a PNG image called ``robi.png``. When the resource comes from a "
"file like this, it is an external resource. If you erase the path or this "
"path is empty, it becomes a built-in resource."
msgstr ""
"Path 속성은 리소스의 경로를 알려줍니다. 이 경우 리소스는 ``robi.png``\\ 라는 "
"PNG 이미지에서 가져옵니다. 이와 같이 파일에서 리소스를 불러오는 경우 외부 리"
"소스라고 합니다. Path를 지우거나 비워 두면 내장 리소스가 됩니다."

msgid ""
"The switch between built-in and external resources happens when you save the "
"scene. In the example above, if you erase the path ``\"res://robi.png\"`` "
"and save, Godot will save the image inside the ``.tscn`` scene file."
msgstr ""
"내장 리소스와 외부 리소스 간의 전환은 씬을 저장할 때 발생합니다. 위의 예시에"
"서 경로 ``\"res://robi.png\"``\\ 를 지우고 저장한다면, Godot는 ``.tscn`` 씬 "
"파일 안에 이미지를 저장합니다."

msgid ""
"Even if you save a built-in resource, when you instance a scene multiple "
"times, the engine will only load one copy of it."
msgstr ""
"내장 리소스로 저장하더라도 씬을 여러 번 인스턴스화하면 엔진은 해당 복사본을 "
"하나만 불러옵니다."

msgid "Loading resources from code"
msgstr "코드에서 리소스 불러오기"

msgid ""
"There are two ways to load resources from code. First, you can use the "
"``load()`` function anytime:"
msgstr ""
"코드에서 리소스를 불러오는 방법은 두 가지가 있습니다. 첫 번째로, 언제든지 "
"``load()`` 함수를 사용해 불러올 수 있습니다:"

#, fuzzy
msgid ""
"You can also ``preload`` resources. Unlike ``load``, this function will read "
"the file from disk and load it at compile-time. As a result, you cannot call "
"``preload`` with a variable path: you need to use a constant string."
msgstr ""
"리소스를 ``미리 불러올(preload)``\\ 수도 있습니다. ``load``\\ 와는 다르게, "
"이 함수는 디스크에서 파일을 읽고 컴파일 시간에 파일을 불러옵니다. 결과적으"
"로, 변수 경로로 미리 불러오기를 호출할 수 없고 경로에 상수 문자열을 사용해야 "
"합니다."

msgid "Loading scenes"
msgstr "씬 불러오기"

#, fuzzy
msgid ""
"Scenes are also resources, but there is a catch. Scenes saved to disk are "
"resources of type :ref:`PackedScene <class_PackedScene>`. The scene is "
"packed inside a :ref:`Resource <class_Resource>`."
msgstr ""
"씬도 리소스이지만 함정이 있습니다. 씬은 디스크에 :ref:`PackedScene "
"<class_PackedScene>` 타입 리소스로 저장됩니다. 씬은 리소스 안에 압축되어 있습"
"니다."

#, fuzzy
msgid ""
"To get an instance of the scene, you have to use the :ref:`PackedScene."
"instantiate() <class_PackedScene_method_instantiate>` method."
msgstr ""
"씬의 인스턴스를 얻으려면 :ref:`PackedScene.instance() "
"<class_PackedScene_method_instance>` 메서드를 사용해야 합니다."

msgid ""
"This method creates the nodes in the scene's hierarchy, configures them, and "
"returns the root node of the scene. You can then add it as a child of any "
"other node."
msgstr ""
"이 메서드는 씬의 계층 구조에 노드를 만들고, 구성하고, 씬의 루트 노드를 반환합"
"니다. 그런 다음 이것을 다른 노드의 자식으로 추가할 수 있습니다."

#, fuzzy
msgid ""
"The approach has several advantages. As the :ref:`PackedScene.instantiate() "
"<class_PackedScene_method_instantiate>` function is fast, you can create new "
"enemies, bullets, effects, etc. without having to load them again from disk "
"each time. Remember that, as always, images, meshes, etc. are all shared "
"between the scene instances."
msgstr ""
"이 접근 방식에는 몇 가지 장점이 있습니다. :ref:`PackedScene.instance() "
"<class_PackedScene_method_instance>` 함수가 빠르기 때문에 매번 디스크에서 다"
"시 불러올 필요 없이 새로운 적, 총알, 효과 등을 만들 수 있습니다. 항상 그렇듯"
"이 이미지, 메시 등은 씬 인스턴스 간에 모두 공유됩니다."

msgid "Freeing resources"
msgstr "리소스 해제(Free)하기"

#, fuzzy
msgid ""
"When a :ref:`Resource <class_Resource>` is no longer in use, it will "
"automatically free itself. Since, in most cases, Resources are contained in "
"Nodes, when you free a node, the engine frees all the resources it owns as "
"well if no other node uses them."
msgstr ""
"``리소스``\\ 가 더 이상 사용되지 않으면 자동으로 해제됩니다. 대부분의 경우 리"
"소스는 노드에 포함되어 있기 때문에 노드가 소유한 리소스를 다른 노드에서 사용"
"하지 않는 경우 노드를 해제하면 해당 리소스도 해제합니다."

msgid "Creating your own resources"
msgstr "여러분만의 리소스 만들기"

msgid ""
"Like any Object in Godot, users can also script Resources. Resource scripts "
"inherit the ability to freely translate between object properties and "
"serialized text or binary data (\\*.tres, \\*.res). They also inherit the "
"reference-counting memory management from the Reference type."
msgstr ""
"Godot의 어떤 오브젝트나 마찬가지로 유저는 리소스를 스크립트로 작성할 수도 있"
"습니다. 리소스 스크립트는 개체 속성과 직렬화된 텍스트 또는 이진 데이터(/*."
"tres, /*.res) 간에 자유롭게 변환하는 기능을 상속받습니다. 또한 참조 타입으로"
"부터 참조 카운팅(reference-counting) 메모리 관리를 상속받습니다."

#, fuzzy
msgid ""
"This comes with many distinct advantages over alternative data structures, "
"such as JSON, CSV, or custom TXT files. Users can only import these assets "
"as a :ref:`Dictionary <class_Dictionary>` (JSON) or as a :ref:`FileAccess "
"<class_FileAccess>` to parse. What sets Resources apart is their inheritance "
"of :ref:`Object <class_Object>`, :ref:`RefCounted <class_RefCounted>`, and :"
"ref:`Resource <class_Resource>` features:"
msgstr ""
"이는 JSON, CSV 또는 커스텀 TXT 파일과 같은 대체 데이터 구조에 비해 많은 뚜렷"
"한 이점이 있습니다. 사용자는 이러한 애셋을 구문 분석(parse)하기 위해 :ref:"
"`Dictionary <class_Dictionary>` (JSON) 또는 :ref:`File <class_File>`\\ 로만 "
"가져올 수 있습니다. 리소스를 구분하는 것은 :ref:`Object <class_Object>`, :"
"ref:`Reference <class_Reference>`, :ref:`Resource <class_Resource>` 기능의 상"
"속입니다:"

msgid ""
"They can define constants, so constants from other data fields or objects "
"are not needed."
msgstr ""
"상수를 정의할 수 있으므로 다른 데이터 필드나 오브젝트의 상수가 필요하지 않습"
"니다."

msgid ""
"They can define methods, including setter/getter methods for properties. "
"This allows for abstraction and encapsulation of the underlying data. If the "
"Resource script's structure needs to change, the game using the Resource "
"need not also change."
msgstr ""
"속성에 대한 setter/getter 메서드를 포함한 메서드를 정의할 수 있습니다. 이를 "
"통해 기본 데이터를 추상화하고 캡슐화할 수 있습니다. 리소스 스크립트의 구조를 "
"변경해야 하는 경우 리소스를 사용하는 게임을 변경할 필요가 없습니다."

msgid ""
"They can define signals, so Resources can trigger responses to changes in "
"the data they manage."
msgstr ""
"시그널을 정의할 수 있으므로 리소스가 관리하는 데이터의 변경 사항에 대한 응답"
"을 트리거할 수 있습니다."

msgid ""
"They have defined properties, so users know 100% that their data will exist."
msgstr ""
"정의된 속성이 있으므로 유저는 자신의 데이터가 존재한다는 것을 100% 알 수 있습"
"니다."

msgid ""
"Resource auto-serialization and deserialization is a built-in Godot Engine "
"feature. Users do not need to implement custom logic to import/export a "
"resource file's data."
msgstr ""
"리소스 자동 직렬화 및 역직렬화는 Godot 엔진에 내장된 기능입니다. 유저는 리소"
"스 파일의 데이터를 가져오거나 내보내기 위해 사용자 정의 로직을 구현할 필요가 "
"없습니다."

msgid ""
"Resources can even serialize sub-Resources recursively, meaning users can "
"design even more sophisticated data structures."
msgstr ""
"리소스는 하위 리소스를 재귀적으로 직렬화할 수도 있습니다. 이는 유저가 훨씬 "
"더 정교한 데이터 구조를 설계할 수 있음을 의미합니다."

msgid ""
"Users can save Resources as version-control-friendly text files (\\*.tres). "
"Upon exporting a game, Godot serializes resource files as binary files (\\*."
"res) for increased speed and compression."
msgstr ""
"유저는 리소스를 버전 관리에 적합한 텍스트 파일(\\*.tres)로 저장할 수 있습니"
"다. 게임을 내보낼 때 Godot는 리소스 파일을 바이너리 파일(\\*.res)로 직렬화해"
"서 속도와 압축률을 높입니다."

msgid ""
"Godot Engine's Inspector renders and edits Resource files out-of-the-box. As "
"such, users often do not need to implement custom logic to visualize or edit "
"their data. To do so, double-click the resource file in the FileSystem dock "
"or click the folder icon in the Inspector and open the file in the dialog."
msgstr ""
"Godot 엔진의 인스펙터(Inspector)는 리소스 파일을 즉시 렌더링하고 편집합니다. "
"따라서 사용자는 데이터를 시각화하거나 편집하기 위해 사용자 정의 로직을 구현"
"할 필요가 없는 경우가 많습니다. 이렇게 하려면 파일시스템(FileSystem) 독에서 "
"리소스 파일을 두 번 클릭하거나 인스펙터(Inspector)에서 폴더 아이콘을 클릭하"
"고 대화 상자에서 파일을 여세요."

msgid ""
"They can extend **other** resource types besides just the base Resource."
msgstr "기본 리소스 외에 **다른** 리소스 타입을 확장할 수 있습니다."

msgid "Godot makes it easy to create custom Resources in the Inspector."
msgstr ""
"Godot의 인스펙터(Inspecter)에서는 커스텀 리소스를 쉽게 만들 수 있습니다."

msgid ""
"Create a plain Resource object in the Inspector. This can even be a type "
"that derives Resource, so long as your script is extending that type."
msgstr ""
"인스펙터(Inspecter)에서 일반 Resource 오브젝트를 만듭니다. 스크립트가 해당 타"
"입을 확장하는 동안 리소스를 파생하는 타입일 수도 있습니다."

msgid "Set the ``script`` property in the Inspector to be your script."
msgstr ""
"인스펙터(Inspecter)에서 ``script`` 속성을 여러분의 스크립트로 설정합니다."

msgid ""
"The Inspector will now display your Resource script's custom properties. If "
"one edits those values and saves the resource, the Inspector serializes the "
"custom properties too! To save a resource from the Inspector, click the "
"Inspector's tools menu (top right), and select \"Save\" or \"Save As...\"."
msgstr ""
"인스펙터(Inspector)는 이제 여러분의 리소스 스크립트의 사용자 정의 속성을 표시"
"합니다. 해당 값을 편집하고 리소스를 저장하면 인스펙터(Inspector)는 사용자 정"
"의 속성도 직렬화합니다! 인스펙터(Inspector)에서 리소스를 저장하려면 인스펙터"
"(Inspector)의 툴 메뉴(오른쪽 위)를 클릭하고 \"저장\" 또는 \"다른 이름으로 저"
"장...\"을 선택하세요."

#, fuzzy
msgid ""
"If the script's language supports :ref:`script classes "
"<doc_gdscript_basics_class_name>`, then it streamlines the process. Defining "
"a name for your script alone will add it to the Inspector's creation dialog. "
"This will auto-add your script to the Resource object you create."
msgstr ""
"스크립트 언어가 :ref:`스크립트 클래스 "
"<doc_scripting_continued_class_name>`\\ 를 지원하는 경우 프로세스가 간소화됩"
"니다. 스크립트 이름만 정의하면 인스펙터(Inspector)의 생성 대화 상자에 추가됩"
"니다. 이렇게 하면 생성한 리소스 오브젝트에 스크립트가 자동으로 추가됩니다."

msgid ""
"Let's see some examples. Create a :ref:`Resource <class_Resource>` and name "
"it ``bot_stats``. It should appear in your file tab with the full name "
"``bot_stats.tres``. Without a script, it's useless, so let's add some data "
"and logic! Attach a script to it named ``bot_stats.gd`` (or just create a "
"new script, and then drag it to it)."
msgstr ""

msgid ""
"Now, create a :ref:`CharacterBody3D <class_CharacterBody3D>`, name it "
"``Bot``, and add the following script to it:"
msgstr ""

msgid ""
"Now, select the :ref:`CharacterBody3D <class_CharacterBody3D>` node which we "
"named ``bot``, and drag&drop the ``bot_stats.tres`` resource onto the "
"Inspector. It should print 10! Obviously, this setup can be used for more "
"advanced features than this, but as long you really understand *how* it all "
"worked, you should figure out everything else related to Resources."
msgstr ""

msgid ""
"Resource scripts are similar to Unity's ScriptableObjects. The Inspector "
"provides built-in support for custom resources. If desired though, users can "
"even design their own Control-based tool scripts and combine them with an :"
"ref:`EditorPlugin <class_EditorPlugin>` to create custom visualizations and "
"editors for their data."
msgstr ""
"리소스 스크립트는 Unity의 ScriptableObjects와 유사합니다. 인스펙터(Inspector)"
"는 커스텀 리소스를 위한 내장 지원을 제공합니다. 원한다면 유저만의 Control 기"
"반 도구 스크립트를 디자인하고 이를 :ref:`EditorPlugin "
"<class_EditorPlugin>`\\ 과 결합해서 데이터에 대한 커스텀 시각화 및 에디터를 "
"만들 수도 있습니다."

#, fuzzy
msgid ""
"Unreal Engine's DataTables and CurveTables are also easy to recreate with "
"Resource scripts. DataTables are a String mapped to a custom struct, similar "
"to a Dictionary mapping a String to a secondary custom Resource script."
msgstr ""
"언리얼 엔진 4의 DataTables와 CurveTables도 리소스 스크립트를 사용해 쉽게 다"
"시 만들 수 있습니다. DataTables은 커스텀 구조체에 매핑된 문자열로, 이차적인 "
"커스텀 리소스 스크립트에 문자열을 매핑하는 딕셔너리와 유사합니다."

#, fuzzy
msgid ""
"Instead of inlining the Dictionary values, one could also, alternatively:"
msgstr "딕셔너리 값을 인라이닝(inlining)하는 대신에..."

#, fuzzy
msgid ""
"Import a table of values from a spreadsheet and generate these key-value "
"pairs."
msgstr ""
"스프레드시트에서 테이블 값을 가져와서 키 값 쌍을 생성할 수 있습니다. 또는..."

#, fuzzy
msgid ""
"Design a visualization within the editor and create a plugin that adds it to "
"the Inspector when you open these types of Resources."
msgstr ""
"에디터 안에서 시각화를 설계하고 해당 타입 리소스를 열 때 인스펙터(Inspecter)"
"에 리소스를 추가하는 간단한 플러그인을 제작할 수 있습니다."

msgid ""
"CurveTables are the same thing, except mapped to an Array of float values or "
"a :ref:`Curve <class_Curve>`/:ref:`Curve2D <class_Curve2D>` resource object."
msgstr ""
"CurveTable은 float 배열 또는 :ref:`Curve <class_Curve>`/:ref:`Curve2D "
"<class_Curve2D>` 리소스 개체에 매핑된다는 점을 제외하고는 동일합니다."

msgid ""
"Beware that resource files (\\*.tres/\\*.res) will store the path of the "
"script they use in the file. When loaded, they will fetch and load this "
"script as an extension of their type. This means that trying to assign a "
"subclass, i.e. an inner class of a script (such as using the ``class`` "
"keyword in GDScript) won't work. Godot will not serialize the custom "
"properties on the script subclass properly."
msgstr ""
"리소스 파일(\\*.tres/\\*.res)은 파일에서 사용하는 스크립트의 경로를 저장합니"
"다. 리소스를 불러오면 이 스크립트를 해당 타입의 확장으로 가져와 로드합니다. "
"이는 하위 클래스, 즉 스크립트의 내부 클래스(예: GDScript에서 ``class`` 키워"
"드 사용)를 할당할 수 없다는 의미입니다. Godot는 스크립트 서브클래스의 사용자 "
"정의 속성을 적절하게 직렬화하지 않을 것입니다."

msgid ""
"In the example below, Godot would load the ``Node`` script, see that it "
"doesn't extend ``Resource``, and then determine that the script failed to "
"load for the Resource object since the types are incompatible."
msgstr ""
"아래 예시에서, Godot는 ``Node`` 스크립트를 불러오고, ``Resource``\\ 를 확장"
"(extend)하지 않는지 확인한 다음, 이 경우 타입이 호환되지 않으므로 스크립트가 "
"Resource 오브젝트를 불러오는 데 실패했다고 판단합니다."

msgid "Translation status"
msgstr "번역 상태"
