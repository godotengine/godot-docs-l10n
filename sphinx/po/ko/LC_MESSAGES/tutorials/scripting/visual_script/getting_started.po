# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Getting started with Visual Scripting"
msgstr "Visual Scripting 시작하기"

msgid ""
"As with everything in Godot, we prioritize a good experience over copying or "
"integrating third party solutions which might not fit nicely in the current "
"workflow. This led us to write our own version of how we believe this "
"feature would work best with the engine."
msgstr ""
"Godot의 모든 기능처럼, Visual Scripting도 좋은 경험을 우선 순위로 두고 개발했"
"습니다. 현재 작업 흐름에 잘 맞지 않는 제 3자 솔루션과 결합하거나 복사하는 것 "
"이상으로 말이죠. 이렇게 해서 엔진에 가장 적합한 기능이라고 생각되는 독자적인 "
"버전을 작성하게 됐습니다."

msgid ""
"In Godot, a Visual Script fits smoothly together with regular scripts in the "
"Editor tab"
msgstr ""
"Godot에서 Visual Script는 일반 스크립트와 함께 편집기 탭에 잘 들어 맞습니다"

msgid ""
"In fact, Visual Scripting integrates so well to Godot that it's hard to "
"believe it was added only in version 3.0. This is because, when editing, the "
"rest of Godot panels and docks act like a palette from where you can drag "
"and drop all sorts of information to the script canvas:"
msgstr ""
"실제로 Visual Scripting이 Godot와 아주 잘 통합해서 버전 3.0만에 추가되었다고 "
"믿기 어려울 것입니다. 스크립트 편집 중에 Godot 패널과 독은 팔래트처럼 스크랩"
"트 캔버스로 모든 종류의 정보를 드래그 앤 드롭할 수 있기 때문입니다:"

msgid "Creating a script"
msgstr "스크립트 만들기(Creating a script)"

msgid ""
"Creating scripts works the same as with other scripting languages: Select "
"any node in the scene and push the \"New Script\" button at the top right "
"corner of the Scene Tree dock:"
msgstr ""
"스크립트 만들기는 다른 스크립팅 언어와 같은 방식입니다: 씬에서 아무 노드나 선"
"택하고, 씬 트리 독의 오른쪽 위에 있는 \"새 스크립트(New Script)\" 버튼을 누르"
"세요:"

msgid ""
"Once it opens, the script type \"Visual Script\" must be selected from the "
"drop down list. The script extension must be \".vs\" (for Visual Script!)."
msgstr ""
"만들기 창이 열리면 스크립트 유형의 드롭 다운 메뉴에서 \"Visual Script\"로 선"
"택해야 합니다. 스크립트 확장자 이름은 (Visual Script를 의미하는) \".vs\"가 됩"
"니다."

msgid ""
"Finally, the Script Editor will open, allowing you to start editing the "
"visual script:"
msgstr ""
"그러면 이제 Script 편집기가 열리고 Visual Script를 편집할 수 있게 됩니다:"

msgid "Adding a function"
msgstr "함수 추가하기(Adding a function)"

msgid ""
"Unlike other visual scripting implementations, Visual Scripting in Godot is "
"heavily based on functions. This happens because it uses the same interface "
"to communicate with the engine as other scripting engines. In Godot, the "
"scripting interface is universal and all implementations conform to it."
msgstr ""
"다른 Visual Scripting 구현 방식과 달리, Godot의 Visual Scripting은 함수와 깊"
"게 연관되어 있습니다. 이는 다른 스크립팅 엔진처럼 엔진과 소통하도록 같은 인터"
"페이스를 사용하기 때문입니다. Godot에서 스크립팅 인터페이스는 범용적이고 이 "
"인터페이스 내에서 전부 구현합니다."

msgid "A function is an individual canvas with nodes connected."
msgstr "함수는 노드가 연결된 개별 캔버스입니다."

msgid ""
"A single script can contain many functions, each of which will have a canvas "
"of its own, allowing for more organization."
msgstr ""
"하나의 스크립트에는 많은 함수를 가질 수 있고, 각 함수는 고유의 캔버스를 갖고 "
"있기 때문에 더 조직적으로 만들 수 있습니다."

msgid "There are three main ways to add functions in a script:"
msgstr "스크립트에 함수를 추가하는 세 가지 주요 방법이 있습니다:"

msgid "Overriding a virtual function"
msgstr "가상 함수 다시 정의하기(Override)"

msgid ""
"Most types of nodes and other types of objects in Godot contain virtual "
"functions. These are functions that will be called (run your code) when "
"something happens and can be looked up in the reference. Virtual functions "
"are listed when pressing the \"Override\" icon in the member panel:"
msgstr ""
"Godot의 대부분의 노드 유형과 오브젝트의 유형은 가상 함수를 갖고 있습니다. 이"
"벤트가 일어나면 함수는 호출되며 (코드를 실행하며), 그 이벤트는 참조에서 볼 "
"수 있습니다. 가상 함수는 멤버(Members) 패널의 \"다시 정의하기(Override)\" 아"
"이콘을 클릭하면 나열됩니다:"

msgid ""
"In the following example, a function will be executed when the node is "
"loaded and added to the running scene. For this, the _ready() virtual method "
"will be overridden:"
msgstr ""
"다음 예시는 노드를 불러오고 실행하는 씬에 추가될 때 실행하는 함수입니다. "
"_ready() 가상 메서드가 다시 정의됩니다:"

msgid "Finally, a canvas appears for this function, showing the override:"
msgstr "그러면 이제 이 함수의 캔버스가 나타나고, 재정의를 표시합니다:"

msgid ""
"As some functions expect you to return a value, they will also add a return "
"node where such value is supposed to be provided:"
msgstr ""
"일부 함수는 반환 값을 추측하기 때문에, 해당 값을 제공하도록 return 노드를 추"
"가해야 합니다:"

msgid "Connecting a signal to a function"
msgstr "함수에 시그널(Signal) 연결하기"

msgid ""
"Nodes in a tree emit signals when something happens. Godot uses signals for "
"all sorts of things. A typical example would be a button that emits a "
"\"pressed\" signal when actually pressed."
msgstr ""
"노드는 트리에서 무언가 발생하면 시그널을 방출합니다. Godot는 시그널로 모든 작"
"업을 합니다. 전형적인 예제로 \"pressed\" 시그널을 방출하는 버튼으로, 버튼을 "
"누를 때 방출합니다."

msgid ""
"For this, a node must be selected and the Node tab opened. This will allow "
"inspecting the signals. Once they are displayed, connect the \"pressed\" "
"signal:"
msgstr ""
"그렇게 하려면, 시그널을 방출할 노드를 선택한 채로 노드(Node) 탭을 여세요. 거"
"기에는 시그널을 확인할 수 있습니다. 시그널을 확인한 뒤, \"pressed\" 시그널을 "
"연결하세요:"

msgid ""
"This will open the connection dialog. In this dialog, you must select the "
"node where the signal will be connected to, and the function that will "
"receive the signal:"
msgstr ""
"그러면 연결 대화 상자가 열립니다. 대화 상자에서 시그널을 연결할 노드를 선택하"
"고 시그널을 받는 함수를 선택해야 합니다:"

msgid ""
"If this is done right, a new function will be created in our script and a "
"signal will automatically be connected to it:"
msgstr ""
"잘 설정했다면, 새 함수가 스크립트에 만들어지고 자동으로 시그널이 연결됩니다:"

msgid "Creating a function manually"
msgstr "수동으로 함수 만들기"

msgid ""
"The last way to create functions is to do it manually. In general, this is "
"not as common unless you really need it. Custom functions work when another "
"(or the same) script calls them manually. The main use cases for this are "
"breaking a larger function up into several manageable chunks and reusing "
"your visual code."
msgstr ""
"함수를 만드는 마지막 방법은 수동으로 만드는 것입니다. 일반적으로 정말 필요한 "
"경우가 아니라면 수동으로 만들지 않을 것입니다. 다른 (혹은 같은) 스크립트에서 "
"함수를 수동으로 호출할 때 맞춤(Custom) 함수는 작동합니다. 주된 사용 예로는 커"
"다란 함수를 여러 개의 덩어리로 만드는 것입니다. 관리하기 좋으면서도 다른 "
"Visual 코드에 다시 쓸 수 있도록 만드는 것이죠."

msgid ""
"To create a function manually, push the big \"Plus\" button, and a new "
"function will be added with a default name:"
msgstr ""
"함수를 수동으로 만들려면, 큰 \"더하기\" 버튼을 누르세요. 그러면 새 함수가 기"
"본 이름으로 추가됩니다:"

msgid ""
"This will add a new function, which can be renamed by simply double clicking "
"its name:"
msgstr "함수는 이름에서 더블 클릭하면 이름을 새로 지을 수 있습니다:"

msgid ""
"To edit the \"arguments\" this function can get (the values you pass to it "
"when you call this function), simply click the Function node and check the "
"inspector:"
msgstr ""
"이 함수가 갖는 (함수를 호출할 때 값을 전달하는) \"인수(Argument)\"를 편집하려"
"면, 간단히 Function(함수) 노드를 클릭하고 인스펙터(Inspector)를 확인하세요:"

msgid "More on that will be explained later in this document."
msgstr "자세한 내용은 이 문서의 뒷부분에서 설명합니다."

msgid "Translation status"
msgstr "번역 상태"
