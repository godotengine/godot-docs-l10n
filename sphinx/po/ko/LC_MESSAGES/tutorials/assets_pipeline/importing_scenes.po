# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Importing 3D scenes"
msgstr "3D 씬 가져오기"

msgid "Godot scene importer"
msgstr "Godot 씬 임포터"

msgid ""
"When dealing with 3D assets, Godot has a flexible and configurable importer."
msgstr ""
"3D 애셋을 다룰 때, Godot는 유연하면서 설정할 수 있는 임포터를 가지고 있습니"
"다."

msgid ""
"Godot works with *scenes*. This means that the entire scene being worked on "
"in your favorite 3D DCC will be transferred as close as possible."
msgstr ""
"Godot는 *씬*\\ 으로 작업합니다. 이는 즉, 좋아하는 3D DCC에서 작업한 전체 씬"
"을 최대한 가깝게 전송한다는 것입니다."

msgid "Godot supports the following 3D *scene file formats*:"
msgstr "Godot는 아래와 같은 3D *씬 파일 형식* 을 지원합니다:"

msgid ""
"glTF 2.0 **(recommended)**. Godot has full support for both text (``.gltf``) "
"and binary (``.glb``) formats."
msgstr ""
"glTF 2.0 **(권장)**. Godot은 텍스트(``.gltf``)와 이진 파일 형식 (``.glb``) 모"
"두를 지원합니다."

msgid "DAE (COLLADA), an older format that is fully supported."
msgstr "DAE (COLLADA), 완전히 지원되는 오래단 파일 형식입니다."

msgid ""
"OBJ (Wavefront) format + their MTL material files. This is also fully "
"supported, but pretty limited (no support for pivots, skeletons, animations, "
"PBR materials, ...)."
msgstr ""
"OBJ (Wavefront) 형식 + MTL 재질 파일. 완전히 지원하지만, 꽤 제한적입니다 (피"
"봇, 스켈레톤, 애니메이션, PBR 재질 등을 지원하지 않음)."

msgid "ESCN, a Godot-specific format that Blender can export with a plugin."
msgstr ""
"ESCN, Blender에서 플러그인으로 내보낼 수 있는 Godot-specific한 형식입니다."

msgid ""
"FBX, supported via the Open Asset Import library. However, FBX is "
"proprietary, so we recommend using other formats listed above, if suitable "
"for your workflow."
msgstr ""
"FBX, 공개 에셋 가져오기 라이브러리를 통해 지원됩니다. 하지만, FBX는 사유 소프"
"트웨어이므로 워크플로우에 적합한 경우, 위에 나열된 다른 형식을 사용하는 것이 "
"좋습니다."

msgid ""
"Just copy the scene file together with the texture to the project "
"repository, and Godot will do a full import."
msgstr ""
"텍스처와 씬 파일을 함께 프로젝트 저장소에 복사하면 Godot가 완전히 가져올 것입"
"니다."

msgid ""
"It is important that the mesh is not deformed by bones when exporting. Make "
"sure that the skeleton is reset to its T-pose or default rest pose before "
"exporting with your favorite 3D editor."
msgstr ""
"메시를 내보낼 때, 메시가 본에 의해 형태가 변하지 않는 것이 중요합니다. 좋아하"
"는 3D 편집기에서 메시를 내보낼 때, 스켈레톤이 기존의 T 포즈나 기본 휴식 포즈"
"로 되어있는지 확인하세요."

msgid "Exporting DAE files from Maya and 3DS Max"
msgstr "Maya와 3DS Max에서 DAE 파일 내보내기"

msgid ""
"Autodesk added built-in COLLADA support to Maya and 3DS Max, but it's broken "
"by default and should not be used. The best way to export this format is by "
"using the `OpenCollada <https://github.com/KhronosGroup/OpenCOLLADA/wiki/"
"OpenCOLLADA-Tools>`__ plugins. They work well, although they are not always "
"up-to date with the latest version of the software."
msgstr ""
"Autodesk는 Maya와 3DS Max를 위한 내장 COLLADA 지원을 추가했습니다, 하지만 기"
"본적으로 고장나고 사용하지 않아야 합니다. 이 형식을 내보내는 최선의 방법은 "
"`OpenCollada <https://github.com/KhronosGroup/OpenCOLLADA/wiki/OpenCOLLADA-"
"Tools>`__ 플러그인을 사용하는 것입니다. 항상 소프트웨어의 최신 버전으로 업데"
"이트 되진 않지만 잘 작동합니다."

msgid "Exporting glTF 2.0 files from Blender"
msgstr "블렌더에서 glTF 2.0 파일 내보내기"

msgid ""
"There are three ways to export glTF files from Blender. As a glTF binary (``."
"glb`` file), glTF embedded (``.gltf`` file), and with textures (``gltf`` + "
"``.bin`` + textures)."
msgstr ""
"glTF를 Blender로 내보내는 방법은 세 가지가 있습니다. glTF 이진 파일 "
"(``glb``), glTF 임베디드 파일 (``.gltf``), 그리고 텍스처 파일 (``gltf`` + ``."
"bin`` + 텍스처) 입니다."

msgid ""
"glTF binary files are the smallest of the three options. They include the "
"mesh and textures set up in Blender. When brought into Godot the textures "
"are part of the object's material file."
msgstr ""
"glTF 이진 파일은 세 선택지중 용량이 가장 작습니다. Blender에서 설정된 메시와 "
"텍스처를 포함하고 있습니다. Godot에 불러왔을 때 텍스처는 오브젝트의 재질 파일"
"의 일부입니다."

msgid ""
"glTF embedded files function the same way as binary files. They don't "
"provide extra functionality in Godot, and shouldn't be used since they have "
"a larger file size."
msgstr ""
"glTF 임베디드 파일은 이진 파일과 같은 방식으로 동작합니다. Godot에서 추가적"
"인 기능을 제공하지 않으며 파일의 크기도 크므로 사용하지 않는 것이 좋습니다."

msgid ""
"There are two reasons to use glTF with the textures separate. One is to have "
"the scene description in a text based format and the binary data in a "
"separate binary file. This can be useful for version control if you want to "
"review changes in a text based format. The second is you need the texture "
"files separate from the material file. If you don't need either of those "
"glTF binary files are fine."
msgstr ""
"glTF을 텍스처와 분리해 사용해야하는 이유는 두 가지가 있습니다. 첫 번째는 씬"
"의 설명을 텍스트 기반의 포맷과 이진 데이터로 각각의 이진 파일에 저장하기 위함"
"입니다. 이 경우 버전 관리에서 텍스트 기반 포맷의 변경점을 검토해야 할 때 유용"
"합니다. 두 번째는 텍스처 파일을 재질 파일과 분리하기 위해서 입니다. 위 두 가"
"지 이점이 필요하지 않다면 glTF 이진 파일을 사용하는 것도 좋습니다."

msgid ""
"Blend shape animations cannot be imported - they require manual animation "
"within Godot."
msgstr ""

#, fuzzy
msgid ""
"Blender versions older than 3.2 do not export emissive textures with the "
"glTF file. If your model uses one and you're using an older version of "
"Blender, it must be brought in separately."
msgstr ""
"Blender는 emissive 텍스처를 glTF 파일로 내보내는 것을 지원하지 않습니다. 만"
"약 모델이 emmisive 텍스처를 사용한다면 glTF를 나누어 불러와야 합니다."

msgid ""
"By default, Blender has backface culling disabled on materials and will "
"export materials to match how they render in Blender. This means that "
"materials in Godot will have their cull mode set to **Disabled**. This can "
"decrease performance since backfaces will be rendered, even when they are "
"being culled by other faces. To resolve this, enable **Backface Culling** in "
"Blender's Materials tab, then export the scene to glTF again."
msgstr ""
"Blender는 기본적으로 재질의 backface culling이 비활성화 되어 있으며 Blender에"
"서 렌더링되는 것과 같이 재질을 내보내려고 할 것입니다. 따라서 Godot에서도 재"
"질의 cull mode 옵션을 **Disabled** 로 설정해야 합니다. 이 경우 다른 면에 가려"
"질 때에도 backface가 렌더링 되므로 성능을 떨어뜨릴 수 있습니다. 이를 해결하려"
"면 Blender의 재질 탭에서 **Backface culling** 옵션을 활성화하십시오."

msgid "Exporting DAE files from Blender"
msgstr "블렌더에서 DAE 파일 내보내기"

msgid ""
"Blender has built-in COLLADA support, but it does not work properly for the "
"needs of game engines and should not be used as is."
msgstr ""
"블렌더도 내장 COLLADA를 지원하지만, 게임 엔진의 필요에 맞게 동작하지 않으므"
"로 그대로 사용하지 않는 것이 좋습니다."

msgid ""
"Godot provides a `Blender plugin <https://github.com/godotengine/collada-"
"exporter>`_ that will correctly export COLLADA scenes for use in Godot. It "
"does not work in Blender 2.8 or newer, but there are plans to update it in "
"the future."
msgstr ""
"Godot는 Godot에 맞게 COLLADA 씬을 제대로 내보낼 수 있도록 `Blender 플러그인 "
"<https://github.com/godotengine/collada-exporter>`_ 을 지원합니다. Blender "
"2.8 이상의 버전에서는 동작하지 않지만 추후 업데이트가 있을 예정입니다."

msgid "Exporting ESCN files from Blender"
msgstr "블렌더에서 ESCN 파일 내보내기"

msgid ""
"The most powerful one, called `godot-blender-exporter <https://github.com/"
"godotengine/godot-blender-exporter>`__. It uses a .escn file, which is kind "
"of another name for a .tscn file (Godot scene file); it keeps as much "
"information as possible from a Blender scene. However, it is considered "
"experimental."
msgstr ""
"가장 강력한 기능은 `godot-blender-exporter <https://github.com/godotengine/"
"godot-blender-exporter>`__ 입니다. .tscn 파일 (Godot 씬 파일)의 일종인 .escn "
"파일을 사용하며, 블렌더 씬의 정보를 가능한 많이 보존해줍니다. 하지만 아직은 "
"실험적인 기능입니다."

msgid ""
"The ESCN exporter has a detailed `document <escn_exporter/index.html>`__ "
"describing its functionality and usage."
msgstr ""
"ESCN 내보내기는 기능과 사용법을 설명하는 세부적인 `문서 <escn_exporter/index."
"html>`__\\ 를 갖고 있습니다."

msgid "Exporting textures separately"
msgstr "텍스처를 각각 내보내기"

msgid ""
"While textures can be exported with a model in certain file formats, such as "
"glTF 2.0, you can also export them separately. Godot uses PBR (physically "
"based rendering) for its materials, so if a texturing program can export PBR "
"textures, they can work in Godot. This includes the `Substance suite "
"<https://www.substance3d.com/>`__, `ArmorPaint (open source) <https://"
"armorpaint.org/>`__, and `Material Maker (open source) <https://github.com/"
"RodZill4/material-maker>`__."
msgstr ""
"glTF 2.0같은 몇몇 파일 포맷에서는 텍스처를 모델과 함께 내보낼 수 있지만, 따"
"로 내보내는 것도 가능합니다. Godot은 재질에 PBR(물리 기반 렌더링)을 사용하는"
"데, 텍스처 프로그램이 PBR 텍스처를 내보낼 수 있다면 Godot에서도 사용이 가능합"
"니다. `Substance suite <https://www.substance3d.com/>`__, `ArmorPaint (오픈 "
"소스) <https://armorpaint.org/>`__, 그리고`Material Maker (오픈 소스) "
"<https://github.com/RodZill4/material-maker>`__ 가 이에 해당됩니다."

msgid ""
"For more information on Godot's materials, see :ref:`doc_spatial_material`."
msgstr "자세한 정보는 :ref:`doc_spatial_material` 페이지를 참고하십시오."

msgid "Exporting considerations"
msgstr "내보내기 고려 사항"

msgid ""
"Since GPUs can only render triangles, meshes that contain quads or N-gons "
"have to be *triangulated* before they can be rendered. Godot can triangulate "
"meshes on import, but results may be unpredictable or incorrect, especially "
"with N-gons. Regardless of the target application, triangulating *before* "
"exporting the scene will lead to more consistent results and should be done "
"whenever possible."
msgstr ""
"GPU가 삼각형만을 렌더링 할 수 있기 때문에 사각형 혹은 초과의 n각형을 포함하"
"는 메시는 렌더링 이전에 *triangulate* 되어야 합니다. Godot은 가져오기 과정에"
"서 메시를 triangulate 할 수 있지만, 특히 n각형의 경우는 예측 불가능하거나 잘"
"못된 결과가 나올 수 있습니다. 목표 애플리케이션에 관계 없이 씬을 내보내기 이"
"전에 triangulate하는 편이 더 안정적인 결과물을 만들기 때문에 가능하면 내보내"
"기 이전에 수행해야 합니다."

msgid ""
"To avoid issues with incorrect triangulation after importing in Godot, it is "
"recommended to make the 3D DCC triangulate objects on its own. In Blender, "
"this can be done by adding a Triangulate modifier to your objects and making "
"sure **Apply Modifiers** is checked in the export dialog. Alternatively, "
"depending on the exporter, you may be able to find and enable a "
"**Triangulate Faces** option in the export dialog."
msgstr ""
"Godot에 가져오기 이후 잘못된 triangulation이 수행되는 것을 방지하기 위해 오브"
"젝트 자신의 3D DCC triangulate 오브젝트를 만드는 것을 권장합니다. Blender의 "
"경우 오브젝트에 Triangulate modifier를 추가한 뒤 내보내기 창에서 **Apply "
"Modifiers** 에 체크해 이 작업을 수행할 수 있습니다."

msgid ""
"To avoid issues with 3D selection in the editor, it is recommended to apply "
"the object transform in the 3D DCC before exporting the scene."
msgstr ""
"에디터에서 3D 선택 항목에 문제가 생기는 것을 방지하기 위해 씬을 내보내기 전"
"에 3D DCC에 오브젝트 변환을 적용하는 것을 권장합니다."

msgid "Import workflows"
msgstr "워크플로 가져오기"

msgid ""
"Godot scene importer allows different workflows regarding how data is "
"imported. Depending on many options, it is possible to import a scene with:"
msgstr ""
"Godot 씬 임포터는 어떻게 데이터를 가져오는지에 따라 서로 다른 워크플로를 허용"
"합니다. 많은 옵션에 따라, 다음을 통해 씬을 가져올 수 있습니다:"

msgid ""
"External materials (default): Where each material is saved to a file "
"resource. Modifications to them are kept."
msgstr ""
"외부 머티리얼 (기본 값): 각 머티리얼은 파일 리소스에 저장됩니다. 모디파이어"
"는 유지됩니다."

msgid ""
"External meshes: Where each mesh is saved to a different file. Many users "
"prefer to deal with meshes directly."
msgstr ""
"외부 메시: 각 메시는 다른 파일로 저장됩니다. 많은 사용자는 메시를 직접 처리하"
"는 것을 선호합니다."

msgid ""
"External animations: Allowing saved animations to be modified and merged "
"when sources change."
msgstr ""
"외부 애니메이션: 원본이 변경될 때 저장된 애니메이션을 수정하고 병합할 수 있도"
"록 합니다."

msgid ""
"External scenes: Save each of the root nodes of the imported scenes as a "
"separate scene."
msgstr "외부 씬: 가져온 씬의 각 루트 노드를 별도의 씬으로 저장합니다."

msgid "Single scene: A single scene file with everything built in."
msgstr "단일 씬: 모든 것이 내장된 하나의 씬 파일입니다."

msgid ""
"As different developers have different needs, this import process is highly "
"customizable."
msgstr ""
"다른 개발자가 다른 요구가 있듯이, 이 가져오기 처리는 많이 커스터마이징 할 수 "
"있습니다."

msgid "Import options"
msgstr "옵션 가져오기"

msgid "The importer has several options, which will be discussed below:"
msgstr "임포터에는 여러 설정이 있는데, 아래에서 논의합니다:"

msgid "Nodes"
msgstr "노드"

msgid "Root Type"
msgstr "루트 유형"

msgid ""
"By default, the type of the root node in imported scenes is \"Spatial\", but "
"this can be modified."
msgstr ""
"기본적으로, 가져온 씬의 루트 노드 타입은 \"Spatial\"이지만, 수정될 수 있습니"
"다."

msgid "Root Name"
msgstr "루트 이름"

msgid "Allows setting a specific name to the generated root node."
msgstr "생성된 루트 노드에 특정 이름을 설정할 수 있습니다."

msgid "Root Scale"
msgstr "루트 스케일"

msgid "The scale of the root node."
msgstr "루트 노드의 크기입니다."

msgid "Custom Script"
msgstr "사용자 정의 스크립트"

msgid ""
"A special script to process the whole scene after import can be provided. "
"This is great for post processing, changing materials, doing funny stuff "
"with the geometry etc."
msgstr ""
"특수한 스크립트로 가져오기 이후 전체 씬을 처리하는 것도 가능합니다. 후처리, "
"재질 변경, 도형으로 장난을 치는 일 등에 유용합니다."

msgid "Create a script like this:"
msgstr "다음과 같은 스크립트를 만드세요:"

msgid ""
"The ``post_import`` function takes the imported scene as argument (the "
"parameter is actually the root node of the scene). The scene that will "
"finally be used must be returned. It can be a different one."
msgstr ""
"``post_import`` 함수는 가져온 씬을 인수로 받습니다 (매개변수는 사실 씬의 루"
"트 노드입니다). 마지막으로 사용되는 씬은 반환되어야 합니다. 그것은 다른 것일 "
"수 있습니다."

msgid "Storage"
msgstr "보관소"

msgid ""
"By default, Godot imports a single scene. This option allows specifying that "
"nodes below the root will each be a separate scene and instanced into the "
"imported one."
msgstr ""
"기본적으로, Godot은 하나의 씬을 가져옵니다. 이 옵션으로 루트 아래의 노드들이 "
"각각 별개의 씬으로 되고 가져온 씬에 인스턴스화되는 것을 명시할 수 있게 해줍니"
"다."

msgid ""
"Of course, instancing such imported scenes in other places manually works, "
"too."
msgstr "물론 가져온 씬을 다른 곳에서 인스턴스화하는 것도 수동으로 작동합니다."

msgid "Materials"
msgstr "머티리얼"

msgid "Location"
msgstr "위치"

msgid ""
"Godot supports materials in meshes or nodes. By default, materials will be "
"put on each node."
msgstr ""
"Godot는 메시나 노드에서 머티리얼을 지원합니다. 기본적으로, 머티리얼은 각 노드"
"에 들어갑니다."

msgid ""
"Materials can be stored within the scene or in external files. By default, "
"they are stored in external files so editing them is possible. This is "
"because most 3D DCCs don't have the same material options as those present "
"in Godot."
msgstr ""
"머티리얼은 씬이나 외부 파일 안에 저장될 수 있습니다. 기본적으로, 외부 파일에 "
"저장되므로 편집하는 것이 가능합니다. 대부분의 3D DCC가 Godot와 같은 머티리얼 "
"설정을 갖고 있지 않기 때문입니다."

msgid ""
"When materials are built-in, they will be lost each time the source scene is "
"modified and re-imported."
msgstr ""
"머티리얼이 내장형이라면, 원본 씬을 수정하고 다시 가져올 때마다 없어질 것입니"
"다."

msgid ""
"Godot will not reimport materials that are stored in external files unless "
"you remove the associated ``.material`` file before reimporting."
msgstr ""
"``.material`` 파일을 다시 가져오기 이전에 제거하지 않는 이상 Godot은 외부 파"
"일에 저장된 머티리얼들을 다시 가져오지 않습니다."

msgid ""
"To force reimporting materials every time the 3D scene is reimported, change "
"the material storage mode in the 3D scene by selecting it in the FileSystem "
"dock, going to the Import dock then setting **Material > Storage** to "
"**Built-In** instead of **Files**."
msgstr ""
"3D 씬을 다시 가져올 때마다 다시 가져오도록 강제하려면 파일 시스템 독에서 머티"
"리얼 저장 모드를 선택한 후 가져오기 독에서 **Material > Storage** 를 "
"**Files** 대신 **Built-In** 으로 변경하십시오."

msgid "Keep On Reimport"
msgstr "계속 다시 가져오기"

msgid ""
"Once materials are edited to use Godot features, the importer will keep the "
"edited ones and ignore the ones coming from the source scene. This option is "
"only present if materials are saved as files."
msgstr ""
"한번 Godot 기능을 사용하기 위해 머티리얼을 편집하면, 임포터는 편집한 것을 유"
"지하고 원본 씬에서 나오는 것은 무시합니다. 이 옵션은 머티리얼이 파일로 저장"
"된 경우에만 존재합니다."

msgid "Meshes"
msgstr "메쉬"

msgid "Compress"
msgstr "컴프레스"

msgid ""
"Makes meshes use less precise numbers for multiple aspects of the mesh in "
"order to save space."
msgstr ""
"공간을 절약하기 위해 메시의 여러 측면에 덜 정확한 수치를 사용하도록 합니다."

msgid "These are:"
msgstr "이렇게 됩니다:"

msgid ""
"Transform Matrix (Location, rotation, and scale)             : 32-bit float "
"to 16-bit signed integer."
msgstr ""
"Transform Matrix (Location, rotation, and scale)             : 32비트 실수에"
"서 16비트 부호 있는 정수로."

msgid ""
"Vertices                                                     : 32-bit float "
"to 16-bit signed integer."
msgstr ""
"Vertices                                                     : 32비트 실수에"
"서 16비트 부호 있는 정수로."

msgid ""
"Normals                                                      : 32-bit float "
"to 32-bit unsigned integer."
msgstr ""
"Normals                                                      : 32비트 실수에"
"서 32비트 부호 있는 정수로."

msgid ""
"Tangents                                                     : 32-bit float "
"to 32-bit unsigned integer."
msgstr ""
"Tangents                                                     : 32비트 실수에"
"서 32비트 부호 있는 정수로."

msgid ""
"Vertex Colors                                                : 32-bit float "
"to 32-bit unsigned integer."
msgstr ""
"Vertex Colors                                                : 32비트 실수에"
"서 32비트 부호 있는 정수로."

msgid ""
"UV                                                           : 32-bit float "
"to 32-bit unsigned integer."
msgstr ""
"UV                                                           : 32비트 실수에"
"서 32비트 부호 있는 정수로."

msgid ""
"UV2                                                          : 32-bit float "
"to 32-bit unsigned integer."
msgstr ""
"UV2                                                          : 32비트 실수에"
"서 32비트 부호 있는 정수로."

msgid ""
"Vertex weights                                               : 32-bit float "
"to 16-bit unsigned integer."
msgstr ""
"Vertex weights                                               : 32비트 실수에"
"서 16비트 부호 있는 정수로."

msgid ""
"Armature bones                                               : 32-bit float "
"to 16-bit unsigned integer."
msgstr ""
"Armature bones                                               : 32비트 실수에"
"서 16비트 부호 있는 정수로."

msgid ""
"Array index                                                  : 32-bit or 16-"
"bit unsigned integer based on how many elements there are."
msgstr ""
"Array index                                                  : 얼마나 많은 원"
"소가 있는 지에 따라 32비트나 16비트 부호 있는 정수로."

msgid "Additional info:"
msgstr "추가 정보:"

msgid ""
"UV2 = The second UV channel for detail textures and baked lightmap textures."
msgstr "UV2 = 세부적인 텍스처와 구워진 텍스처를 위한 두 번째 UV 채널."

msgid ""
"Array index = An array of numbers that number each element of the arrays "
"above; i.e. they number the vertices and normals."
msgstr ""
"Array index = 위 배열의 각 요소에 순서를 매기는 배열; 즉, 꼭짓점과 노말에 순"
"서를 매깁니다."

msgid ""
"In some cases, this might lead to loss of precision, so disabling this "
"option may be needed. For instance, if a mesh is very big or there are "
"multiple meshes being imported that cover a large area, compressing the "
"import of this mesh(es) may lead to gaps in geometry or vertices not being "
"exactly where they should be."
msgstr ""
"이로 인해 몇몇 상황에서 정밀도가 떨어질 수 있으니, 필요하다면 이 옵션을 비활"
"성화할 수 있습니다. 예를 들어, 메시가 매우 크거나 큰 영역을 포함하는 여러 메"
"시를 가져온다면, 메시 가져오기를 압축하는 것이 기하 사이의 간격 생성, 꼭짓점"
"이 있어야 할 자리에 없는 현상이 발생할 수 있습니다."

msgid "Ensure Tangents"
msgstr "접선 확인"

#, fuzzy
msgid ""
"If textures with normal mapping are to be used, meshes need to have tangent "
"arrays. This option ensures that these are generated if not present in the "
"source scene. Godot uses `Mikktspace <http://www.mikktspace.com/>`__ for "
"this, but it's always better to have them generated in the exporter."
msgstr ""
"노말 맵핑 된 텍스처가 사용된다면, 메시는 탄젠트 배열을 가져야 합니다. 이 설정"
"으로 원본 씬에서 탄젠트 배열이 없다면 생성하게 해줍니다. Godot는 Mikktspace"
"를 사용하지만, 익스포터에서 생성하는 것이 항상 더 좋습니다."

msgid ""
"Meshes can be stored in separate files (resources) instead of built-in. This "
"does not have much practical use unless one wants to build objects with them "
"directly."
msgstr ""
"메시는 내장 대신 별개의 파일 (리소스)로 저장될 수 있습니다. 직접 오브젝트를 "
"짓는 것이 아니라면 이것은 꽤 실용적인 사용을 갖지는 않습니다."

msgid ""
"This option is provided to help those who prefer working directly with "
"meshes instead of scenes."
msgstr ""
"이 설정은 씬 대신 메시로 직접 작업하기를 선호하는 사람들을 돕기 위해 제공됩니"
"다."

msgid "Light Baking"
msgstr "라이트 베이킹"

msgid "Whether or not the mesh is used in baked lightmaps."
msgstr "메시가 베이킹된 라이트맵에서 사용되는지 여부입니다."

msgid "**Disabled:** The mesh is not used in baked lightmaps."
msgstr "**Disabled:** 메시가 베이킹된 라이트맵에서 사용되지 않습니다."

msgid "**Enable:** The mesh is used in baked lightmaps."
msgstr "**Enable:** 메시가 베이킹된 라이트맵에서 사용됩니다."

msgid ""
"**Gen Lightmaps:** The mesh is used in baked lightmaps, and unwraps a second "
"UV layer for lightmaps."
msgstr ""
"**Gen Lightmaps:** 메시가 베이킹된 라이트맵에서 사용되고 라이트맵에 사용할 "
"두 번째 UV 레이어를 폅니다."

msgid "For more information on light baking see :ref:`doc_baked_lightmaps`."
msgstr ""
"광원 베이킹에 대한 자세한 내용은 :ref:`doc_baked_lightmap` 페이지를 참고하세"
"요."

msgid "External Files"
msgstr "외부 파일"

msgid ""
"Generated meshes and materials can be optionally stored in a subdirectory "
"with the name of the scene."
msgstr ""
"생성된 메시와 머티리얼은 하위 디렉토리에 씬의 이름을 가지면서 선택적으로 저장"
"될 수 있습니다."

msgid "Animation options"
msgstr "애니메이션 설정"

msgid ""
"Godot provides many options regarding how animation data is dealt with. Some "
"exporters (such as Blender) can generate many animations in a single file. "
"Others, such as 3DS Max or Maya, need many animations put into the same "
"timeline or, at worst, put each animation in a separate file."
msgstr ""
"Godot는 애니메이션 데이터를 어떻게 다루는 지에 따라 많은 설정을 제공합니다. "
"(블렌더처럼) 일부 내보내기는 하나의 파일에 많은 애니메이션을 생성할 수 있습니"
"다. 3DS Max나 Maya와 같은 것은 같은 타임라인에 많은 애니메이션을 넣어야 하거"
"나, 최악의 경우, 애니메이션을 별도의 파일에 넣어야 합니다."

msgid "Import of animations is enabled by default."
msgstr "애니메이션 가져오기는 기본적으로 활성화되어 있습니다."

msgid ""
"To modify animations from an imported 3D scene, you need to change the "
"animation storage option from **Built-In** to **Files** in the Import dock. "
"Otherwise, changes made to animations from Godot will be lost when the "
"project is run."
msgstr ""
"가져온 3D 씬의 애니메이션을 수정하려면 가져오기 독에서 애니메이션 저장 옵션"
"을 **Built-In**에서 **Files** 로 변경해야 합니다. 그렇지 않으면 프로젝트가 실"
"행될 때 Godot에서의 변경사항은 사라집니다."

msgid "FPS"
msgstr "초당 프레임"

msgid ""
"Most 3D export formats store animation timeline in seconds instead of "
"frames. To ensure animations are imported as faithfully as possible, please "
"specify the frames per second used to edit them. Failing to do this may "
"result in shaky animations."
msgstr ""
"대부분의 3D 내보내기 형식은 프레임 대신 초당 타임라인으로 애니메이션을 저장합"
"니다. 애니메이션을 가능한 한 충실하게 가져오기 위해서는, 편집에 사용된 초 당 "
"프레임을 명시하세요. 이를 잘못하면 떨리는 애니메이션을 만들게 됩니다."

msgid "Filter Script"
msgstr "필터 스크립트"

msgid ""
"It is possible to specify a filter script in a special syntax to decide "
"which tracks from which animations should be kept."
msgstr ""
"어떤 애니메이션의 어떤 트랙을 골라낼 지 결정하기 위해 필터 스크립트를 특수한 "
"문법으로 정의할 수 있습니다."

msgid ""
"The filter script is executed against each imported animation. The syntax "
"consists of two types of statements, the first for choosing which animations "
"to filter, and the second for filtering individual tracks within the matched "
"animation. All name patterns are performed using a case insensitive "
"expression match, using ``?`` and ``*`` wildcards (using ``String.matchn()`` "
"under the hood)."
msgstr ""
"필터 스크립트는 가져온 모든 애니메이션에 수행됩니다. 문법은 두 가지 문항으로 "
"이루어졌는데, 첫 번째는 어떤 애니메이션을 필터링 하는지 결정하는 것이고, 두 "
"번째는 해당하는 애니메이션에서 개별의 트랙을 필터링 하는 것 입니다. 이름 패턴"
"은 ``?`` 와 ``*`` 와일드카드를 사용해서 대소문자 구분 없는 표현식으로 매칭이 "
"수행됩니다(내부적으로 ``String.matchn()`` 을 사용합니다)."

msgid ""
"The script must start with an animation filter statement (as denoted by the "
"line beginning with an ``@``). For example, if we would like to apply "
"filters to all imported animations which have a name ending in "
"``\"_Loop\"``::"
msgstr ""
"스크립트는 항상 애니메이션 필터 문항으로 시작해야 합니다(``@`` 로 라인이 시작"
"이 표시된 바로 뒤에). 예를 들어 ``\"_Loop\"`` 로 끝나는 모든 애니메이션에 필"
"터를 적용하려면 다음과 같이 해야 합니다::"

msgid ""
"Similarly, additional patterns can be added to the same line, separated by "
"commas. Here is a modified example to additionally *include* all animations "
"with names that begin with ``\"Arm_Left\"``, but also *exclude* all "
"animations which have names ending in ``\"Attack\"``::"
msgstr ""
"비슷한 맥락에서 같은 줄에 쉼표로 구분되도록 패턴을 추가할 수도 있습니다. "
"``\"Arm_Left\"``로 시작하는 애니메이션을 모두 *포함* 시키고 ``\"Attack\"`` 으"
"로 끝나는 애니메이션은 모두 *제외* 시키는 예제는 다음과 같습니다::"

msgid ""
"Following the animation selection filter statement, we add track filtering "
"patterns to indicate which animation tracks should be kept or discarded. If "
"no track filter patterns are specified, then all tracks within the matched "
"animations will be discarded!"
msgstr ""
"애니메이션 필터 문항 다음에는 어떤 애니메이션의 트랙을 골라낼 지 결정하는 트"
"랙 필터 패턴을 추가해야 합니다. 만약 필터 패턴을 정하지 않으면 골라낸 애니메"
"이션의 모든 트랙이 그냥 버려집니다!"

msgid ""
"It's important to note that track filter statements are applied in order for "
"each track within the animation, this means that one line may include a "
"track, a later rule can still discard it. Similarly, a track excluded by an "
"early rule may then be re-included once again by a filter rule further down "
"in the filter script."
msgstr ""
"트랙 필터문이 애니메이션의 모든 개별 트랙에 적용된다는 사실을 이해하는 것이 "
"중요합니다. 이는 한 문항에 의해 트랙이 포함되었더라도 이후에 나오는 문항에 의"
"해 다시 제외될 수 있다는 뜻이니까요. 같은 맥락으로 앞의 문항에 의해 제외된 트"
"랙 역시 나중에 나오는 문항에 의해 다시 포함될 수 있습니다."

msgid ""
"For example: include all tracks in animations with names ending in "
"``\"_Loop\"``, but discard any tracks affecting a ``\"Skeleton\"`` which end "
"in ``\"Control\"``, unless they have ``\"Arm\"`` in their name::"
msgstr ""
"예를 들어서 ``\"_Loop\"`` 으로 끝나는 애니메이션의 모든 트랙을 추가한 뒤 "
"``\"Skeleton\"`` 으로 시작하는 트랙 중 ``\"Control\"`` 로 끝나는 트랙은 "
"``\"Arm\"`` 이 포함되지 않으면 제외하는 필터문은 다음과 같습니다::"

msgid ""
"In the above example, tracks like ``\"Skeleton:Leg_Control\"`` would be "
"discarded, while tracks such as ``\"Skeleton:Head\"`` or ``\"Skeleton:"
"Arm_Left_Control\"`` would be retained."
msgstr ""
"위 예제에서 ``\"Skeleton:Leg_Control\"`` 은 제외되지만 ``\"Skeleton:Head\"`` "
"나 ``\"Skeleton:Arm_Left_Control\"`` 는 포함될 것입니다."

msgid ""
"Any track filter lines that do not begin with a ``+`` or ``-`` are ignored."
msgstr "트랙 필터 중 ``+`` 또는 ``-`` 로 시작하지 않는 줄은 모두 제외됩니다."

msgid ""
"By default, animations are saved as built-in. It is possible to save them to "
"a file instead. This allows adding custom tracks to the animations and "
"keeping them after a reimport."
msgstr ""
"기본적으로, 애니메이션은 내장되어 저장됩니다. 대신 파일로 애니메이션을 저장"
"할 수도 있습니다. 이렇게 하면 맞춤 트랙을 애니메이션에 추가할 수 있고, 다시 "
"가져온 후에도 이를 유지할 수 있습니다."

msgid "Optimizer"
msgstr "최적화 도구"

msgid ""
"When animations are imported, an optimizer is run, which reduces the size of "
"the animation considerably. In general, this should always be turned on "
"unless you suspect that an animation might be broken due to it being enabled."
msgstr ""
"애니메이션을 가져올 때 옵티마이저(optimizer)가 실행되어 애니메이션의 크기는 "
"상당히 줄어듭니다. 일반적으로, 옵티마이저가 활성화되어 있기 때문에 애니메이션"
"이 손상되었다고 의심되는 상황이 아니라면 항상 활성화되어 있어야 합니다."

msgid "Clips"
msgstr "클립"

msgid ""
"It is possible to specify multiple animations from a single timeline as "
"clips. For this to work, the model must have only one animation that is "
"named ``default``. To create clips, change the clip amount to something "
"greater than zero. You can then name a clip, specify which frames it starts "
"and stops on, and choose whether the animation loops or not."
msgstr ""
"클립의 형태로 하나의 타임라인에 여러 개의 애니메이션을 지정하는 것 역시 가능"
"합니다. 이를 위해서는 모델에 ``default`` 로 작명된 애니메이션은 단 하나만 존"
"재해야 합니다. 클립을 생성하려면 클립 개수를 0보다 큰 값으로 변경하면 됩니"
"다. 이후 클립의 이름, 시작 프레임과 끝 프레임 및 애니메이션의 반복 여부를 정"
"할 수 있습니다."

msgid "Scene inheritance"
msgstr "씬 상속"

msgid ""
"In many cases, it may be desired to make modifications to the imported "
"scene. By default, this is not possible because if the source asset changes "
"(source ``.dae``, ``.gltf``, ``.obj`` file re-exported from 3D modelling "
"app), Godot will re-import the whole scene."
msgstr ""
"많은 상황에서, 가져온 씬을 수정하고 싶을 것입니다. 기본적으로 원본 애셋(3D 모"
"델링 앱에서 다시 내보낸 원본 .dae, .gltf, .obj 파일)이 바뀌기 때문에 그렇게 "
"할 수는 없고 , Godot는 전체 씬을 다시 가져올 것입니다."

msgid ""
"It is possible, however, to make local modifications by using *Scene "
"Inheritance*. Try to open the imported scene and the following dialog will "
"appear:"
msgstr ""
"하지만, *씬 상속*\\ 을 사용하면 로컬로 수정하는 것이 가능합니다. 가져온 씬을 "
"열면 다음 대화 상자가 나타납니다:"

msgid "In inherited scenes, the only limitations for modifications are:"
msgstr "상속된 씬에서, 수정에 대한 유일한 제한은 다음과 같습니다:"

msgid "Nodes can't be removed (but can be added anywhere)."
msgstr "노드는 삭제될 수 없습니다 (하지만 어디에나 추가될 수 있습니다)."

msgid ""
"Sub-Resources can't be edited (save them externally as described above for "
"this)"
msgstr ""
"하위 리소스를 편집할 수 없습니다 (이를 위해선 위에서 설명했듯 외부로 저장해"
"야 합니다)"

msgid "Other than that, everything is allowed!"
msgstr "그 외에는 모든 것이 허용됩니다!"

msgid "Import hints"
msgstr "가져오기 힌트"

msgid ""
"Many times, when editing a scene, there are common tasks that need to be "
"done after exporting:"
msgstr "여러번 씬을 편집할 때, 내보낸 후 해야 하는 일반적인 작업이 있습니다:"

msgid "Adding collision detection to objects."
msgstr "오브젝트에 콜리전 감지를 추가하기."

msgid "Setting objects as navigation meshes."
msgstr "오브젝트를 내비게이션 메시로 설정하기."

#, fuzzy
msgid ""
"Deleting nodes that are not used in the game engine (like specific lights "
"used for modelling)."
msgstr ""
"(모델링에 사용되는 특정 빛과 같이) 게임 엔진에 사용되는 않는 노드 지우기"

msgid ""
"To simplify this workflow, Godot offers several suffixes that can be added "
"to the names of the objects in your 3D modelling software. When imported, "
"Godot will detect suffixes in object names and will perform actions "
"automatically."
msgstr ""
"이 워크플로를 간단히 하기 위해, Godot는 3D 모델링 소프트웨어에서 오브젝트의 "
"이름에 붙일 수 있는 몇몇 접미사를 제공합니다. 가져올 때, Godot는 이를 감지하"
"고 자동으로 동작을 수행합니다:"

msgid "All the suffixes described below are *case-sensitive*."
msgstr "아래에 설명된 모든 접미사들은 *대소문자를 구분합니다*."

msgid "Remove nodes (-noimp)"
msgstr "노드 삭제 (-noimp)"

msgid ""
"Objects that have the ``-noimp`` suffix will be removed at import-time no "
"matter what their type is. They will not appear in the imported scene."
msgstr ""
"``-noimp`` 접미사를 갖고 있는 오브젝트가 어떤 타입이든지 가져올 때 제거될 것"
"입니다. 가져온 씬에서 나타나지 않습니다."

msgid "Create collisions (-col, -convcol, -colonly, -convcolonly)"
msgstr "콜리전 생성 (-col, -convcol, -colonly, -convcolonly)"

msgid ""
"The option ``-col`` will work only for Mesh objects. If it is detected, a "
"child static collision node will be added, using the same geometry as the "
"mesh. This will create a triangle mesh collision shape, which is a slow, but "
"accurate option for collision detection. This option is usually what you "
"want for level geometry (but see also ``-colonly`` below)."
msgstr ""
"``-col`` 옵션은 메시 오브젝트에만 적용됩니다. 만약 접미사가 감지되면 동일한 "
"도형을 메시로 사용해 자식 정적 콜리전 노드가 추가됩니다. 이 옵션에서는 느리지"
"만 충돌 감지가 정확한 삼각형 메시 콜리전 모양이 생성됩니다. 레벨 지형을 만드"
"는데 적합한 옵션입니다 (하지만 하단의 ``-colony`` 또한 확인해보십시오)."

msgid ""
"The option ``-convcol`` will create a :ref:`class_convexpolygonshape` "
"instead of a :ref:`class_concavepolygonshape`. Unlike triangle meshes which "
"can be concave, a convex shape can only accurately represent a shape that "
"doesn't have any concave angles (a pyramid is convex, but a hollow box is "
"concave). Due to this, convex collision shapes are generally not suited for "
"level geometry. When representing simple enough meshes, convex collision "
"shapes can result in better performance compared to a triangle collision "
"shape. This option is ideal for simple or dynamic objects that require "
"mostly-accurate collision detection."
msgstr ""
"``-convcol`` 옵션은 :ref:`class_concavepolygonshape` 대신 :ref:"
"`class_convexpolygonshape`를 생성합니다. 오목한 부분을 묘사할 수 있는 삼각형 "
"메시와는 달리 볼록 다면체 형상은 오목한 각이 없는(예를 들어 피라미드는 볼록 "
"다면체 형상이지만 빈 박스는 오목한 형상입니다) 도형만을 정확히 묘사할 수 있습"
"니다. 때문에 볼록 다면체 콜리전 형상은 레벨 지형을 묘사하는데에는 적합하지 않"
"습니다. 충분히 간단한 메시를 표현하고자 할 때는 볼록 다면체 콜리전 형상을 사"
"용하는 것이 삼각형 콜리전 형상보다 성능 면에서 원활합니다. 이 옵션은 비교적 "
"정확한 충돌 감지가 필요한 간단하고 동적인 오브젝트에 적합합니다."

#, fuzzy
msgid ""
"However, in both cases, the visual geometry may be too complex or not smooth "
"enough for collisions. This can create physics glitches and slow down the "
"engine unnecessarily."
msgstr ""
"하지만 충돌 감지를 적용할 도형이 너무 복잡하거나 각진 경우에 두 옵션 모두 물"
"리 계산에 오류를 일으키거나 엔진을 느리게 만들 수 있습니다."

msgid ""
"To solve this, the ``-colonly`` modifier exists. It will remove the mesh "
"upon importing and will create a :ref:`class_staticbody` collision instead. "
"This helps the visual mesh and actual collision to be separated."
msgstr ""
"이를 해결하기 위해, ``-colonly`` 모디파이어(modifier)가 존재합니다, 가져올 "
"때 메시를 제거하고 대신 :ref:`class_staticbody` 콜리전을 생성합니다. 이렇게 "
"하면 시각적 메시와 실제 콜리전을 분리할 수 있습니다."

msgid ""
"The option ``-convcolonly`` works in a similar way, but will create a :ref:"
"`class_convexpolygonshape` instead."
msgstr ""
"``-convcolonly`` 옵션 또한 위와 유사하지만 :ref:`class_convexpolygonshape`를 "
"생성한다는 차이가 있습니다."

msgid ""
"The option ``-colonly`` can also be used with Blender's empty objects. On "
"import, it will create a :ref:`class_staticbody` with a collision node as a "
"child. The collision node will have one of a number of predefined shapes, "
"depending on Blender's empty draw type:"
msgstr ""
"``-colonly`` 옵션은 블렌더의 empty 오브젝트와 함께 사용될 수도 있습니다. 가져"
"올 때, 자손으로 콜리전 노드가 있는 :ref:`class_staticbody`\\ 를 생성할 것입니"
"다. 콜리전 노드는 미리 정의된 모양 중 하나를 가지며, 블렌더의 empty 드로우 타"
"입에 따라 다릅니다:"

msgid "Single arrow will create a :ref:`class_rayshape`."
msgstr "Single arrow는 :ref:`class_rayshape`를 생성합니다."

msgid "Cube will create a :ref:`class_boxshape`."
msgstr "Cube는 :ref:`class_boxshape` 를 생성합니다."

msgid "Image will create a :ref:`class_planeshape`."
msgstr "Image는 :ref:`class_planeshape` 를 생성합니다."

msgid ""
"Sphere (and the others not listed) will create a :ref:`class_sphereshape`."
msgstr ""
"Sphere (그리고 나열되지 않은 나머지)는 :ref:`class_sphereshape` 를 생성합니"
"다."

msgid ""
"When possible, **try to use a few primitive collision shapes** instead of "
"triangle mesh or convex shapes. Primitive shapes often have the best "
"performance and reliability."
msgstr ""
"가능하다면 삼각형이나 볼록 다면체 대신 **primitive 충돌 감지 형상을 사용해보"
"십시오**. Primitive 형상이 많은 경우 성능 및 안전성 면에서 더 뛰어납니다."

#, fuzzy
msgid ""
"For better visibility in Blender's editor, you can set the \"X-Ray\" option "
"on collision empties and set some distinct color for them in Blender's "
"**User Preferences > Themes > 3D View > Empty**."
msgstr ""
"블렌더의 편집기에서 더 좋은 가시성을 위해, 콜리전 Empty에 \"X-Ray\"를 설정하"
"고 **User Preferences / Themes / 3D View / Empty**\\ 에서 뚜렷한 색상을 설정"
"할 수 있습니다."

msgid ""
"See :ref:`doc_collision_shapes_3d` for a comprehensive overview of collision "
"shapes."
msgstr ""
"모든 콜리전 형상을 확인하고 싶다면 :ref:`doc_collision_shapes_3d`을 참고하십"
"시오."

msgid "Create navigation (-navmesh)"
msgstr "내비게이션 생성 (-navmesh)"

msgid ""
"A mesh node with the ``-navmesh`` suffix will be converted to a navigation "
"mesh. The original Mesh object will be removed at import-time."
msgstr ""
"``-navmesh`` 접미사를 가진 메시 노드는 내비게이션 메시로 변환되고 기존 메시 "
"오브젝트는 import-time 때 삭제될 것입니다."

msgid "Create a VehicleBody (-vehicle)"
msgstr "VehicleBody 만들기 (-vehicle)"

msgid ""
"A mesh node with the ``-vehicle`` suffix will be imported as a child to a :"
"ref:`class_VehicleBody` node."
msgstr ""
"``-vehicle`` 접미사를 가진 메시 노드는 :ref:`VehicleBody "
"<class_VehicleBody>` 노드의 자손으로 가져오게 됩니다."

msgid "Create a VehicleWheel (-wheel)"
msgstr "VehicleWheel 만들기 (-wheel)"

msgid ""
"A mesh node with the ``-wheel`` suffix will be imported as a child to a :ref:"
"`class_VehicleWheel` node."
msgstr ""
"``-wheel`` 접미사를 가진 메시 노드는 :ref:`VehicleWheel "
"<class_VehicleWheel>` 노드의 자손으로 가져오게 됩니다."

msgid "Rigid Body (-rigid)"
msgstr "리지드 바디 (-rigid)"

msgid ""
"A mesh node with the ``-rigid`` suffix will be imported as a :ref:"
"`class_RigidBody`."
msgstr ""
"``-rigid`` 접미사를 가진 메시 노드는 :ref:`VehicleBody <class_VehicleBody>` "
"노드의 자손으로 가져오게 됩니다."

msgid "Animation loop (-loop, -cycle)"
msgstr "애니메이션 루프 (-loop, -cycle)"

msgid ""
"Animation clips in the COLLADA document that start or end with the token "
"``loop`` or ``cycle`` will be imported as a Godot Animation with the loop "
"flag set. **Unlike the other suffixes described above, this does not require "
"a hyphen.**"
msgstr ""
"COLLADA 문서에서 ``loop``\\ 나 ``cycle``\\ 토큰으로 시작하거나 끝나는 애니메"
"이션 클립은 루프 플래그가 설정된 Godot 애니메이션으로 가져와질 것입니다. **위"
"에서 설명된 다른 접미사와 다르게, 하이픈(-)이 필요하지 않습니다.**"

#, fuzzy
msgid ""
"In Blender, this requires using the NLA Editor and naming the Action with "
"the ``loop`` or ``cycle`` prefix or suffix."
msgstr ""
"블렌더에서, 이를 위해 NLA 편집기를 사용하여 Action 이름에 \"loop\"나 "
"\"cycle\" 접두사 혹은 접미사를 붙여야 합니다."

msgid "Translation status"
msgstr "번역 상태"
