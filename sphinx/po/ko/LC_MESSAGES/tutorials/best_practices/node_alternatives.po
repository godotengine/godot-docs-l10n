# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "When and how to avoid using nodes for everything"
msgstr "노드를 모든 용도로 사용하는 것을 피하는 시기와 방법"

msgid ""
"Nodes are cheap to produce, but even they have their limits. A project may "
"have tens of thousands of nodes all doing things. The more complex their "
"behavior though, the larger the strain each one adds to a project's "
"performance."
msgstr ""
"노드는 생산하기 저렴하지만 한계가 있습니다. 한 프로젝트는 모든 작업을 하는 "
"수 만 개의 노드로 이루어질 수 있습니다. 행동이 더 복잡할 수록, 프로젝트 성능"
"에 추가하는 각 변형은 더 커집니다."

msgid ""
"Godot provides more lightweight objects for creating APIs which nodes use. "
"Be sure to keep these in mind as options when designing how you wish to "
"build your project's features."
msgstr ""
"Godot는 노드가 사용하는 API를 만들기 위한 더 가벼운 오브젝트를 제공합니다. 어"
"떻게 프로젝트의 기능을 만들고 싶은 지를 설계할 때 옵션으로 다음을 명심하세요."

msgid ""
":ref:`Object <class_Object>`: The ultimate lightweight object, the original "
"Object must use manual memory management. With that said, it isn't too "
"difficult to create one's own custom data structures, even node structures, "
"that are also lighter than the :ref:`Node <class_Node>` class."
msgstr ""
":ref:`오브젝트 <class_Object>`: 궁극의 경량 오브젝트로, 오리지널 오브젝트는 "
"수동으로 메모리 관리를 하는데 사용해야 합니다. 말인 즉슨, 자체 맞춤 데이터 구"
"조를 만드는 것이 그리 어렵지 않습니다, 심지어 맞춤 노드 구조도 만들 수 있는"
"데 :ref:`노드 <class_Node>`\\ 클래스보다 가볍죠."

msgid ""
"**Example:** See the :ref:`Tree <class_Tree>` node. It supports a high level "
"of customization for a table of content with an arbitrary number of rows and "
"columns. The data that it uses to generate its visualization though is "
"actually a tree of :ref:`TreeItem <class_TreeItem>` Objects."
msgstr ""
"**예시:** :ref:`트리 <class_Tree>` 노드를 참고하세요. 이 노드는 임의의 수의 "
"행과 열이 있는 콘텐츠 테이블의 하이 레벨 맞춤 설정을 제공합니다. 시각화에 사"
"용하는 데이터는 사실 :ref:`TreeItem <class_TreeItem>` 오브젝트들의 트리입니"
"다."

#, fuzzy
msgid ""
"**Advantages:** Simplifying one's API to smaller scoped objects helps "
"improve its accessibility and improve iteration time. Rather than working "
"with the entire Node library, one creates an abbreviated set of Objects from "
"which a node can generate and manage the appropriate sub-nodes."
msgstr ""
"**이점:** API를 더 작은 유효 범위의 오브젝트로 단순화하여 접근성과 반복 시간"
"을 향상시켜 줍니다. 전체 노드 라이브러리에서 작업하는 대신, 한 노드가 적절한 "
"하위 노드를 생성하고 관리할 수 있는 단축된 오브젝트들의 집합을 만듭니다."

msgid ""
"One should be careful when handling them. One can store an Object into a "
"variable, but these references can become invalid without warning. For "
"example, if the object's creator decides to delete it out of nowhere, this "
"would trigger an error state when one next accesses it."
msgstr ""
"오브젝트들을 다룰 때는 조심해야 합니다. 오브젝트를 변수 안에 저장할 수 있지"
"만, 오브젝트의 참조는 경고 없이 올바르지 않게 될 수 있습니다. 예를 들어 오브"
"젝트의 생성자가 오브젝트를 아무 곳에도 삭제하지 않기로 결정하면, 다음에 오브"
"젝트에 접근하려 하면 오류 상태가 발동합니다."

#, fuzzy
msgid ""
":ref:`RefCounted <class_RefCounted>`: Only a little more complex than "
"Object. They track references to themselves, only deleting loaded memory "
"when no further references to themselves exist. These are useful in the "
"majority of cases where one needs data in a custom class."
msgstr ""
":ref:`참조 <class_Reference>`: 오브젝트보다 오직 조금 더 복잡함. 참조는 자신"
"을 참조하는 지를 추적해서 더 이상 참조하지 않으면 불러온 메모리를 삭제합니"
"다. 이는 데이터가 필요한 맞춤 클래스에 있어 대부분의 경우에 유용합니다."

#, fuzzy
msgid ""
"**Example:** See the :ref:`FileAccess <class_FileAccess>` object. It "
"functions just like a regular Object except that one need not delete it "
"themselves."
msgstr ""
"**예시:** :ref:`파일 <class_File>` 오브젝트를 참고하세요. 이것은 자기 자신을 "
"삭제할 필요가 없다는 것 빼면 보통 오브젝트처럼 작동합니다."

msgid "**Advantages:** same as the Object."
msgstr "**이점:** 오브젝트와 같음."

#, fuzzy
msgid ""
":ref:`Resource <class_Resource>`: Only slightly more complex than "
"RefCounted. They have the innate ability to serialize/deserialize (i.e. save "
"and load) their object properties to/from Godot resource files."
msgstr ""
":ref:`리소스 <class_Resource>`: 참조보다 오직 조금 더 복잡함. 리소스는 그들"
"의 오브젝트 속성을 Godot 리소스 파일로 직렬화, 혹은 그 반대로 비직렬화하는데 "
"타고났습니다 (예를 들어, 저장 및 불러오기)."

msgid ""
"**Example:** Scripts, PackedScene (for scene files), and other types like "
"each of the :ref:`AudioEffect <class_AudioEffect>` classes. Each of these "
"can be save and loaded, therefore they extend from Resource."
msgstr ""
"**예시:** 스크립트, PackedScene (씬 파일 용), 그리고 각 :ref:`AudioEffect "
"<class_AudioEffect>` 클래스와 같은 다른 타입들. 각각은 저장되고 불러와 질 수 "
"있습니다. 따라서 이들은 리소스에서 분화된 것들입니다."

#, fuzzy
msgid ""
"**Advantages:** Much has :ref:`already been said <doc_resources>` on :ref:"
"`Resource <class_Resource>`'s advantages over traditional data storage "
"methods. In the context of using Resources over Nodes though, their main "
"advantage is in Inspector-compatibility. While nearly as lightweight as "
"Object/RefCounted, they can still display and export properties in the "
"Inspector. This allows them to fulfill a purpose much like sub-Nodes on the "
"usability front, but also improve performance if one plans to have many such "
"Resources/Nodes in their scenes."
msgstr ""
"**이점:** 기본의 데이터 저장 방법보다 :ref:`리소스 <class_Resource>`\\ 가 갖"
"는 이점 대부분은 :ref:`이미 말했습니다 <doc_resources>`\\ . 노드를 통한 리소"
"스 사용의 관점에서, 주요 이점은 인스펙터(Inspecter) 호환성에 있습니다. 오브젝"
"트/참조처럼 가벼우면서도, 리소스는 인스펙터(Inspecter)에서 볼 수 있고, 속성"
"을 내보낼 수 있습니다. 이를 통해 사용성 측면에서 하위 노드와 같은 목적을 달성"
"할 수 있으면서도, 씬에 그러한 리소스/노드를 갖게 한다면 성능을 향상시킬 수 있"
"습니다."

msgid "Translation status"
msgstr "번역 상태"
