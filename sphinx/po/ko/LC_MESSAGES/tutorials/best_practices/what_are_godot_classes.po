# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Applying object-oriented principles in Godot"
msgstr "Godot에 객체 지향 원리 적용하기"

msgid ""
"The engine offers two main ways to create reusable objects: scripts and "
"scenes. Neither of these technically define classes under the hood."
msgstr ""
"엔진에서는 재사용 가능한 코드를 작성하기 위해 스크립트와 씬 두 가지를 사용할 "
"수 있습니다. 둘 모두 클래스의 기술적인 개념을 내부적으로 정의하는 것은 아닙니"
"다."

msgid ""
"Still, many best practices using Godot involve applying object-oriented "
"programming principles to the scripts and scenes that compose your game. "
"That is why it's useful to understand how we can think of them as classes."
msgstr ""
"하지만 많은 Godot에서의 모범 사례들에서 게임을 제작할 때 스크립트와 씬에 객"
"체 지향 프로그래밍 원리를 적용했습니다. 때문에 이 둘을 클래스처럼 여길 수 있"
"다는 점을 이해하는 것이 유용합니다."

msgid ""
"This guide briefly explains how scripts and scenes work in the engine's core "
"to help you understand how they work under the hood."
msgstr ""
"이 가이드에서는 여러분이 스크립트와 씬의 내부적인 동작을 이해할 수 있도록 이"
"들어 어떻게 엔진 내부에서 동작하는지 간단히 설명합니다."

msgid "How scripts work in the engine"
msgstr "스크립트가 엔진에서 동작하는 방식"

msgid ""
"The engine provides built-in classes like :ref:`Node <class_Node>`. You can "
"extend those to create derived types using a script."
msgstr ""
"엔진은 :ref:`Node <class_Node>`같은 내장 클래스를 제공합니다. 스크립트를 이용"
"하면 이를 상속해 파생 타입들을 만들 수 있도록 해줍니다."

msgid ""
"These scripts are not technically classes. Instead, they are resources that "
"tell the engine a sequence of initializations to perform on one of the "
"engine's built-in classes."
msgstr ""
"스크립트들은 기술적으로는 클래스에 해당하지 않습니다. 대신 스크립트는 엔진의 "
"내장 클래스에 어떤 초기화 절차를 진행해야 하는지 엔진에게 알려주는 리소스입니"
"다."

msgid ""
"Godot's internal classes have methods that register a class's data with a :"
"ref:`ClassDB <class_ClassDB>`. This database provides runtime access to "
"class information. ``ClassDB`` contains information about classes like:"
msgstr ""
"Godot의 내장 클래스는 :ref:`ClassDB <class_ClassDB>`에 클래스의 데이터를 등록"
"하는 메서드를 갖습니다. 이 데이터베이스는 런타임에 클래스 정보에 액세스 할 "
"수 있도록 해줍니다. ``ClassDB``는 다음과 같은 클래스들의 정보를 포함합니다:"

msgid "Properties."
msgstr "속성(property)"

#, fuzzy
msgid "Methods."
msgstr "메서드"

#, fuzzy
msgid "Constants."
msgstr "상수"

#, fuzzy
msgid "Signals."
msgstr "시그널"

msgid ""
"This ``ClassDB`` is what objects check against when performing an operation "
"like accessing a property or calling a method. It checks the database's "
"records and the object's base types' records to see if the object supports "
"the operation."
msgstr ""
"오브젝트들은 속성(property)에 액세스하거나 메서드를 호출할 때 ``ClassDB`` 를 "
"확인합니다. 데이터베이스의 기록 및 오브젝트의 부모 타입의 기록을 확인해 오브"
"젝트가 하고자 하는 연산을 지원하는지 확인합니다."

msgid ""
"Attaching a :ref:`Script <class_Script>` to your object extends the methods, "
"properties, and signals available from the ``ClassDB``."
msgstr ""
":ref:`Script <class_Script>`를 오브젝트에 붙이면 ``ClassDB`` 에 있는 메서드, "
"속성(property) 및 시그널을 상속합니다."

#, fuzzy
msgid ""
"Even scripts that don't use the ``extends`` keyword implicitly inherit from "
"the engine's base :ref:`RefCounted <class_RefCounted>` class. As a result, "
"you can instantiate scripts without the ``extends`` keyword from code. Since "
"they extend ``RefCounted`` though, you cannot attach them to a :ref:`Node "
"<class_Node>`."
msgstr ""
"``extends`` 키워드를 사용하지 않는 스크립트도 묵시적으로 엔진의 기본 :ref:"
"`Reference <class_Reference>` 클래스를 상속합니다. 결과적으로 ``extends`` 키"
"워드를 사용하지 않고 스크립트를 인스턴스화 할 수 있습니다. 스크립트가 "
"``Reference`` 를 상속하기 때문에 :ref:`Node <class_Node>`에는 붙일 수 없습니"
"다."

msgid "Scenes"
msgstr "씬"

msgid ""
"The behavior of scenes has many similarities to classes, so it can make "
"sense to think of a scene as a class. Scenes are reusable, instantiable, and "
"inheritable groups of nodes. Creating a scene is similar to having a script "
"that creates nodes and adds them as children using ``add_child()``."
msgstr ""
"씬의 동작도 클래스와 여러 유사점을 갖고 있으므로 씬을 클래스처럼 여기는 것도 "
"타당합니다. 씬은 재사용이 가능하고, 인스턴스화 할 수 있고, 상속이 가능한 노드"
"들의 집합입니다. 씬을 생성하는 것은 스크립트가 노드를 생성한 후 이를 "
"``add_child()`` 를 사용해 자식으로 추가하는 것과 유사합니다."

#, fuzzy
msgid ""
"We often pair a scene with a scripted root node that makes use of the "
"scene's nodes. As such, the script extends the scene by adding behavior "
"through imperative code."
msgstr ""
"종종 씬과 씬의 노드들을 사용하는 스크립트가 붙은 루트 노드를 짝지어 생각해볼 "
"수 있는 경우가 있습니다. 이런 관점에서 씬은 스크립트의 코드를 상속하는 것처"
"럼 볼 수 있습니다."

msgid "The content of a scene helps to define:"
msgstr "씬의 구성물은 다음을 정의하는데 도움이 됩니다:"

#, fuzzy
msgid "What nodes are available to the script."
msgstr "어떤 노드를 스크립트에서 사용할 수 있는가"

#, fuzzy
msgid "How they are organized."
msgstr "어떻게 그들이 조직되어 있는지"

#, fuzzy
msgid "How they are initialized."
msgstr "어떻게 그들이 초기화되는지"

#, fuzzy
msgid "What signal connections they have with each other."
msgstr "서로 어떤 시그널 연결을 갖고 있는지"

msgid ""
"Why is any of this important to scene organization? Because instances of "
"scenes *are* objects. As a result, many object-oriented principles that "
"apply to written code also apply to scenes: single responsibility, "
"encapsulation, and others."
msgstr ""
"자, 왜 이렇게 씬 조직이 중요할까요? 씬의 인스턴스가 *바로* 오브젝트라는 것을 "
"이해해야합니다. 결과적으로 단일 책임 원칙, 캡슐화 등 코드에 적용할 수 있는 객"
"체 지향 기법을 씬에도 적용할 수 있습니다."

msgid ""
"The scene is *always an extension of the script attached to its root node*, "
"so you can interpret it as part of a class."
msgstr ""
"씬은 *항상 자신의 루트 노트에 붙은 스크립트를 상속합니다*. 따라서 이를 클래스"
"의 일종으로 생각할 수 있습니다."

msgid ""
"Most of the techniques explained in this best practices series build on this "
"point."
msgstr "모범 사례에서 설명된 여러 기법들은 이런 점을 이용합니다."

msgid "Translation status"
msgstr "번역 상태"
