# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Ray-casting"
msgstr "광선 투사(Ray Cast)하기"

msgid "Introduction"
msgstr "소개"

msgid ""
"One of the most common tasks in game development is casting a ray (or custom "
"shaped object) and checking what it hits. This enables complex behaviors, "
"AI, etc. to take place. This tutorial will explain how to do this in 2D and "
"3D."
msgstr ""
"게임 개발에서 일반적인 과제로 광선을 (혹은 맞춤 모양 오브젝트를) 투사하고, 닿"
"은 것이 무엇인지 확인하는 것입니다. 광선 투사를 하면 복잡한 동작도 만들 수 있"
"는데, 예를 들면 AI가 있습니다. 이 튜토리얼에서는 어떻게 광선 추적을 하는지 2D"
"와 3D에서 설명하겠습니다."

#, fuzzy
msgid ""
"Godot stores all the low level game information in servers, while the scene "
"is only a frontend. As such, ray casting is generally a lower-level task. "
"For simple raycasts, nodes like :ref:`RayCast3D <class_RayCast3D>` and :ref:"
"`RayCast2D <class_RayCast2D>` will work, as they return every frame what the "
"result of a raycast is."
msgstr ""
"Godot는 서버에 로우 레벨 게임 정보를 저장합니다. 씬은 단지 프론트엔드입니다. "
"마찬가지로 광선 추적은 일반적으로 더 로우 레벨의 과제입니다. 간단한 광선 추적"
"으로 :ref:`RayCast <class_RayCast>`\\ 와 :ref:`RayCast2D <class_RayCast2D>` "
"노드로 가능합니다. 매 프레임마다 광선 추적의 결과를 반환하죠."

msgid ""
"Many times, though, ray-casting needs to be a more interactive process so a "
"way to do this by code must exist."
msgstr ""
"하지만 많은 경우에서 광선 추적은 더 상호작용적인 처리가 필요하기에, 코드로 해"
"결해야 합니다."

msgid "Space"
msgstr "공간(Space)"

#, fuzzy
msgid ""
"In the physics world, Godot stores all the low level collision and physics "
"information in a *space*. The current 2d space (for 2D Physics) can be "
"obtained by accessing :ref:`CanvasItem.get_world_2d().space "
"<class_CanvasItem_method_get_world_2d>`. For 3D, it's :ref:`Node3D."
"get_world_3d().space <class_Node3D_method_get_world_3d>`."
msgstr ""
"물리 세계에서, Godot는 모든 로우 레벨 콜리전과 물리 정보를 *공간(Space)*\\ "
"에 저장합니다. (2D 물리의) 현재 2d 공간은 :ref:`CanvasItem.get_world_2d()."
"space <class_CanvasItem_method_get_world_2d>`\\ 으로 접근해서 가져올 수 있습"
"니다. 3D의 경우는 :ref:`Spatial.get_world().space "
"<class_Spatial_method_get_world>`\\ 으로 가져올 수 있습니다."

#, fuzzy
msgid ""
"The resulting space :ref:`RID <class_RID>` can be used in :ref:"
"`PhysicsServer3D <class_PhysicsServer3D>` and :ref:`PhysicsServer2D "
"<class_PhysicsServer2D>` respectively for 3D and 2D."
msgstr ""
"결과 공간인 :ref:`RID <class_RID>`\\ 는, 3D에는 :ref:`PhysicsServer "
"<class_PhysicsServer>`\\ 에, 2D에는 :ref:`Physics2DServer "
"<class_Physics2DServer>`\\ 에 각각 사용할 수 있습니다."

msgid "Accessing space"
msgstr "공간에 접근하기"

#, fuzzy
msgid ""
"Godot physics runs by default in the same thread as game logic, but may be "
"set to run on a separate thread to work more efficiently. Due to this, the "
"only time accessing space is safe is during the :ref:`Node."
"_physics_process() <class_Node_private_method__physics_process>` callback. "
"Accessing it from outside this function may result in an error due to space "
"being *locked*."
msgstr ""
"Godot은 기본적으로 게임 로직과 동일한 스레드에서 실행되지만, 보다 효율적으로 "
"작동하기 위해 별도의 스레드에서 실행되도록 설정할 수 있습니다. 이러한 이유"
"로, 공간에 접근하는 시간은 :ref:`Node._physics_process() "
"<class_Node_method__physics_process>` 콜백 함수 동안은 안전합니다. 이 함수 외"
"부에서 접근할 경우 공간이 *잠겨* 있기 때문에 오류가 발생할 수 있습니다."

#, fuzzy
msgid ""
"To perform queries into physics space, the :ref:`PhysicsDirectSpaceState2D "
"<class_PhysicsDirectSpaceState2D>` and :ref:`PhysicsDirectSpaceState3D "
"<class_PhysicsDirectSpaceState3D>` must be used."
msgstr ""
"물리 공간에 대한 쿼리를 수행하려면 :ref:`Physics2DDirectSpaceState "
"<class_Physics2DDirectSpaceState>` 및 :ref:`PhysicsDirectSpaceState "
"<class_PhysicsDirectSpaceState>` 를 사용해야 합니다."

msgid "Use the following code in 2D:"
msgstr "2D에서는 다음 코드를 사용합니다:"

msgid "Or more directly:"
msgstr "더욱더 직접적인 코드:"

msgid "And in 3D:"
msgstr "3D에서는 다음 코드를 사용합니다:"

msgid "Raycast query"
msgstr "광선 투사 쿼리"

#, fuzzy
msgid ""
"For performing a 2D raycast query, the method :ref:"
"`PhysicsDirectSpaceState2D.intersect_ray() "
"<class_PhysicsDirectSpaceState2D_method_intersect_ray>` may be used. For "
"example:"
msgstr ""
"2D 광선 투사 쿼리를 수행하려면 :ref:`Physics2DDirectSpaceState."
"intersect_ray() <class_Physics2DDirectSpaceState_method_intersect_ray>` 방법"
"을 사용할 수 있습니다. 예를 들면 다음과 같습니다:"

#, fuzzy
msgid ""
"The result is a dictionary. If the ray didn't hit anything, the dictionary "
"will be empty. If it did hit something, it will contain collision "
"information:"
msgstr ""
"결과는 딕셔너리입니다. 만약 광선이 아무 것도 건드리지 않으면, 딕셔너리는 텅 "
"비게 될 것입니다. 만약 무언가에 맞는다면 콜리전 정보가 포함됩니다:"

msgid ""
"The ``result`` dictionary when a collision occurs contains the following "
"data:"
msgstr "콜리전이 발생할 경우 ``결과`` 딕셔너리에는 다음 데이터가 포함됩니다:"

msgid ""
"The data is similar in 3D space, using Vector3 coordinates. Note that to "
"enable collisions with Area3D, the boolean parameter ``collide_with_areas`` "
"must be set to ``true``."
msgstr ""

msgid "Collision exceptions"
msgstr "콜리전 예외"

msgid ""
"A common use case for ray casting is to enable a character to gather data "
"about the world around it. One problem with this is that the same character "
"has a collider, so the ray will only detect its parent's collider, as shown "
"in the following image:"
msgstr ""
"광선 투사의 일반적인 용도는 캐릭터가 주변 세계에 대한 데이터를 수집할 수 있도"
"록 하는 것입니다. 이것의 한 가지 문제점은 다음 이미지와 같이 같은 캐릭터가 충"
"돌체를 가지고 있어서, 광선은 부모의 충돌체만 감지한다는 것입니다:"

#, fuzzy
msgid ""
"To avoid self-intersection, the ``intersect_ray()`` parameters object can "
"take an array of exceptions via its ``exclude`` property. This is an example "
"of how to use it from a CharacterBody2D or any other collision object node:"
msgstr ""
"자체 교차를 방지하기 위해, ``intersect_ray()`` 함수는 예외 배열인 선택적 세 "
"번째 파라미터를 취할 수 있습니다. 이것은 KinematicBody2D 또는 다른 콜리전 오"
"브젝트 노드에서 사용하는 방법의 예입니다:"

msgid "The exceptions array can contain objects or RIDs."
msgstr "예외 배열에는 오브젝트 또는 RID가 포함될 수 있습니다."

msgid "Collision Mask"
msgstr "충돌 마스크"

#, fuzzy
msgid ""
"While the exceptions method works fine for excluding the parent body, it "
"becomes very inconvenient if you need a large and/or dynamic list of "
"exceptions. In this case, it is much more efficient to use the collision "
"layer/mask system."
msgstr ""
"예외 방법은 부모 body를 제외하고도 잘 작동하지만, 많은 and/or 동적 예외 목록"
"이 필요한 경우 매우 불편하게 됩니다. 이 경우 콜리전 레이어/마스크 시스템을 사"
"용하는 것이 훨씬 효율적입니다."

#, fuzzy
msgid ""
"The ``intersect_ray()`` parameters object can also be supplied a collision "
"mask. For example, to use the same mask as the parent body, use the "
"``collision_mask`` member variable. The array of exceptions can be supplied "
"as the last argument as well:"
msgstr ""
"``intersect_ray()``\\ 의 네 번째 선택적인 인수는 콜리전 마스크입니다. 예를 들"
"어 부모 body와 동일한 마스크를 사용하려면 ``collision_mask`` 멤버 변수를 사용"
"해야 합니다:"

msgid ""
"See :ref:`doc_physics_introduction_collision_layer_code_example` for details "
"on how to set the collision mask."
msgstr ""

msgid "3D ray casting from screen"
msgstr "화면에서의 3D ray casting(광선 투사)"

#, fuzzy
msgid ""
"Casting a ray from screen to 3D physics space is useful for object picking. "
"There is not much need to do this because :ref:`CollisionObject3D "
"<class_CollisionObject3D>` has an \"input_event\" signal that will let you "
"know when it was clicked, but in case there is any desire to do it manually, "
"here's how."
msgstr ""
"화면에서 3D 물리학 공간으로 광선을 투사하는 것은 물체를 선택하는 데 유용합니"
"다. :ref:`CollisionObject <class_CollisionObject>` 에는 \"input_event\" 신호"
"가 있어 클릭 시 이를 알 수 있지만, 수동으로 수행할 수 있는 방법이 있습니다."

#, fuzzy
msgid ""
"To cast a ray from the screen, you need a :ref:`Camera3D <class_Camera3D>` "
"node. A ``Camera3D`` can be in two projection modes: perspective and "
"orthogonal. Because of this, both the ray origin and direction must be "
"obtained. This is because ``origin`` changes in orthogonal mode, while "
"``normal`` changes in perspective mode:"
msgstr ""
"화면에서 광선을 캐스팅하려면 :ref:`Camera <class_Camera>` 노드가 필요합니다. "
"``카메라`` 는 두 가지 투영 모드일 수 있습니다: 원근법과 직교. 이로 인해 광선 "
"원점과 방향을 모두 얻어야 합니다. 이는 직교 모드의 ``원래`` 변화, 원근법 모드"
"에서의 ``정상`` 변화 때문입니다:"

msgid "To obtain it using a camera, the following code can be used:"
msgstr "카메라를 사용하여 얻기 위해선, 다음 코드를 사용할 수 있습니다:"

msgid ""
"Remember that during ``_input()``, the space may be locked, so in practice "
"this query should be run in ``_physics_process()``."
msgstr ""
"``_input()`` 동안 공간이 잠겨 있을 수 있으므로 실제로 이 쿼리는 "
"``_physics_process()``에서 실행해야 한다는 점을 기억하십시오."

msgid "Translation status"
msgstr "번역 상태"
