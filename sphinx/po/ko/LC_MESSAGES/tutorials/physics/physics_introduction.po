# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Physics introduction"
msgstr "물리 소개"

msgid ""
"In game development, you often need to know when two objects in the game "
"intersect or come into contact. This is known as **collision detection**. "
"When a collision is detected, you typically want something to happen. This "
"is known as **collision response**."
msgstr ""
"게임 개발 중 종종 게임의 두 물체가 교차하거나 접촉할 때를 알아야 합니다. 이"
"를 **콜리전 감지**\\ 라고 합니다. 콜리전이 감지될 때, 일반적이라면 무언가가 "
"발생하길 원할겁니다. 이를 **콜리전 응답**\\ 이라고 합니다."

msgid ""
"Godot offers a number of collision objects in 2D and 3D to provide both "
"collision detection and response. Trying to decide which one to use for your "
"project can be confusing. You can avoid problems and simplify development if "
"you understand how each works and what their pros and cons are."
msgstr ""
"Godot는 콜리전 감지와 반응을 모두 제공하기 위해 2D와 3D로 구성된 다수의 콜리"
"전 오브젝트를 제공합니다. 프로젝트에 이 중 어떠한 것을 사용할지 결정하려는 것"
"은 혼란스러울 수 있습니다. 하지만 각각의 작동 방식과 장단점을 이해한다면 이러"
"한 문제를 피하고 개발을 간소화할 수 있습니다."

msgid "In this guide, you will learn:"
msgstr "이 가이드에서 다음 내용을 배울 것입니다:"

msgid "Godot's four collision object types"
msgstr "Godot의 4가지 콜리전 오브젝트 유형"

msgid "How each collision object works"
msgstr "각 콜리전 오브젝트의 작동 방식"

msgid "When and why to choose one type over another"
msgstr "한 유형을 다른 유형보다 선택해야 하는 시기 및 이유"

msgid ""
"This document's examples will use 2D objects. Every 2D physics object and "
"collision shape has a direct equivalent in 3D and in most cases they work in "
"much the same way."
msgstr ""
"이 문서의 예제에서는 2D 오브젝트를 사용합니다. 모든 2D 물리 오브젝트와 콜리"
"전 모양은 3D에서 직접적으로 동등하며 대부분의 경우 거의 동일한 방식으로 작동"
"합니다."

msgid "Collision objects"
msgstr "콜리전 오브젝트"

msgid ""
"Godot offers four kinds of physics bodies, extending :ref:`CollisionObject2D "
"<class_CollisionObject2D>`:"
msgstr ""
"Godot는 :ref:`CollisionObject2D <class_CollisionObject2D>`\\ 에서 확장된 4가"
"지 종류의 물리 바디(body)를 제공합니다:"

msgid ":ref:`Area2D <class_Area2D>`"
msgstr ":ref:`Area2D <class_Area2D>`"

msgid ""
"``Area2D`` nodes provide **detection** and **influence**. They can detect "
"when objects overlap and can emit signals when bodies enter or exit. An "
"``Area2D`` can also be used to override physics properties, such as gravity "
"or damping, in a defined area."
msgstr ""
"``Area2D`` 노드는 **감지(detection)**\\ 와 **영향력(influence)**\\ 을 제공합"
"니다. 그들은 오브젝트들이 언제 겹치는지를 감지할 수 있고, 바디가 들어가거나 "
"나올 때 시그널을 보낼 수 있습니다. ``Area2D``\\ 는 또한 정의된 영역에서 중력"
"이나 제동과 같은 물리적 특성을 치환하는데 사용될 수도 있습니다."

msgid ""
"The other three bodies extend :ref:`PhysicsBody2D <class_PhysicsBody2D>`:"
msgstr ""
"나머지 3개의 body는 :ref:`PhysicsBody2D <class_PhysicsBody2D>`\\ 에서 확장됩"
"니다:"

msgid ":ref:`StaticBody2D <class_StaticBody2D>`"
msgstr ""

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. They are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"정적 바디는 물리 엔진에 의해 움직이지 않는 물체입니다. 그것은 콜리전 감지에"
"는 관여하지만, 콜리전에 대응하여 움직이지는 않습니다. 이것들은 환경의 일부이"
"거나 동적 동작이 필요하지 않은 오브젝트에 가장 많이 사용됩니다."

msgid ":ref:`RigidBody2D <class_RigidBody2D>`"
msgstr ""

msgid ""
"This is the node that implements simulated 2D physics. You do not control a "
"``RigidBody2D`` directly, but instead you apply forces to it (gravity, "
"impulses, etc.) and the physics engine calculates the resulting movement. :"
"ref:`Read more about using rigid bodies. <doc_rigid_body>`"
msgstr ""
"이것은 시뮬레이션된 2D 물리를 구현하는 노드입니다. ``RigidBody2D``\\ 를 직접"
"적으로 제어하지는 않지만, 그대신 (중력, 충격 등) 힘을 가하며 물리 엔진은 그것"
"의 결과적인 움직임을 계산합니다. :ref:`리지드 바디 사용에 대해 더 알아보기. "
"<doc_rigid_body>`"

msgid ":ref:`KinematicBody2D <class_KinematicBody2D>`"
msgstr ""

msgid ""
"A body that provides collision detection, but no physics. All movement and "
"collision response must be implemented in code."
msgstr ""
"콜리전 감지 기능을 제공하지만, 물리는 제공하지 않는 body입니다. 모든 이동 및 "
"콜리전 반응은 코드로 구현되어야 합니다."

msgid "Physics material"
msgstr "물리 머티리얼"

msgid ""
"Static bodies and rigid bodies can be configured to use a :ref:`physics "
"material <class_PhysicsMaterial>`. This allows adjusting the friction and "
"bounce of an object, and set if it's absorbent and/or rough."
msgstr ""

msgid "Collision shapes"
msgstr "콜리전 모양"

msgid ""
"A physics body can hold any number of :ref:`Shape2D <class_Shape2D>` objects "
"as children. These shapes are used to define the object's collision bounds "
"and to detect contact with other objects."
msgstr ""
"물리 바디는 원하는 수의 :ref:`Shape2D <class_Shape2D>` 오브젝트를 자손으로 수"
"용할 수 있습니다. 이러한 모양은 오브젝트의 콜리전 경계를 정의하고 다른 오브젝"
"트와의 접촉을 감지하는 데 사용됩니다."

msgid ""
"In order to detect collisions, at least one ``Shape2D`` must be assigned to "
"the object."
msgstr ""
"콜리전을 감지하기 위해, 최소한 하나 이상의 ``Shape2D``\\ 가 오브젝트에 할당되"
"어야 합니다."

msgid ""
"The most common way to assign a shape is by adding a :ref:`CollisionShape2D "
"<class_CollisionShape2D>` or :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>` as a child of the object. These nodes allow you "
"to draw the shape directly in the editor workspace."
msgstr ""
"모양을 지정하는 가장 일반적인 방법은 오브젝트의 자손으로 :ref:"
"`CollisionShape2D <class_CollisionShape2D>`\\ 또는 :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>`\\ 를 추가하는 것입니다. 이러한 노드들은 편집기 작"
"업 공간에서 직접 모양을 그릴 수 있도록 합니다."

msgid ""
"Be careful to never scale your collision shapes in the editor. The \"Scale\" "
"property in the Inspector should remain ``(1, 1)``. When changing the size "
"of the collision shape, you should always use the size handles, **not** the "
"``Node2D`` scale handles. Scaling a shape can result in unexpected collision "
"behavior."
msgstr ""
"편집기에서 콜리전 모양을 변경하지 않도록 주의하십시오. 인스펙터(Inspecter)의 "
"\"Scale\" 속성은 ``(1, 1)``\\ 로 유지되어야 합니다. 콜리전 모양을 변경할 때"
"는 항상 ``Node2D`` 크기 핸들이 **아닌** 크기 핸들을 사용해야 합니다. 도형의 "
"크기를 조절하는 것은 예기치 않은 콜리전 행동이 일어날 수 있습니다."

msgid "Physics process callback"
msgstr "물리 프로세스 콜백"

msgid ""
"The physics engine may spawn multiple threads to improve performance, so it "
"can use up to a full frame to process physics. Because of this, the value of "
"a body's state variables such as ``position`` or ``linear velocity`` may not "
"be accurate for the current frame."
msgstr ""
"물리 엔진은 성능을 향상시키기 위해 여러 개의 스레드를 생성할 수 있으므로, 물"
"리 작업을 처리하는 데 최대 프레임까지 사용할 수 있습니다. 이로 인해, ``위치"
"(position)`` 또는 ``선형 속도(linear velocity)``\\ 와 같은 바디의 상태 변수"
"의 값이 현재 프레임에 정확하지 않을 수 있습니다."

#, fuzzy
msgid ""
"In order to avoid this inaccuracy, any code that needs to access a body's "
"properties should be run in the :ref:`Node._physics_process() "
"<class_Node_method__physics_process>` callback, which is called before each "
"physics step at a constant frame rate (60 times per second by default). This "
"method will be passed a ``delta`` parameter, which is a floating-point "
"number equal to the time passed in *seconds* since the last step. When using "
"the default 60 Hz physics update rate, it will typically be equal to "
"``0.01666...`` (but not always, see below)."
msgstr ""
"이러한 부정확성을 피하기 위해, 바디의 속성에 접근해야 하는 모든 코드는 각 물"
"리 단계 전에 일정한 프레임률 (기본 초당 60회)로 호출되는 :ref:`Node."
"_physics_process() <class_Node_method__physics_process>` 콜백에서 실행되어야 "
"합니다."

msgid ""
"It's recommended to always use the ``delta`` parameter when relevant in your "
"physics calculations, so that the game behaves correctly if you change the "
"physics update rate or if the player's device can't keep up."
msgstr ""

msgid "Collision layers and masks"
msgstr "콜리전 레이어와 마스크"

msgid ""
"One of the most powerful, but frequently misunderstood, collision features "
"is the collision layer system. This system allows you to build up complex "
"interactions between a variety of objects. The key concepts are **layers** "
"and **masks**. Each ``CollisionObject2D`` has 20 different physics layers it "
"can interact with."
msgstr ""
"가장 강력하지만 자주 오해되는 콜리전 기능로 콜리전 레이어 시스템이 있습니다. "
"이 시스템을 사용하면 다양한 오브젝트 간의 복잡한 상호 작용을 구축할 수 있습니"
"다. 주요 개념은 **레이어**\\ 와 **마스크**\\ 입니다. 각 "
"``CollisionObject2D`` 에는 서로 상호 작용할 수 있는 20개의 서로 다른 물리 레"
"이어가 있습니다."

msgid "Let's look at each of the properties in turn:"
msgstr "각 속성을 차례대로 살펴보겠습니다:"

msgid "collision_layer"
msgstr ""

msgid ""
"This describes the layers that the object appears **in**. By default, all "
"bodies are on layer ``1``."
msgstr ""
"이것은 오브젝트가 **나타나는** 레이어를 형성합니다. 기본적으로 모든 바디는 레"
"이어 ``1``에 있습니다."

msgid "collision_mask"
msgstr ""

msgid ""
"This describes what layers the body will **scan** for collisions. If an "
"object isn't in one of the mask layers, the body will ignore it. By default, "
"all bodies scan layer ``1``."
msgstr ""
"이것은 바디가 콜리전을 위해 **스캔**\\ 하는 레이어를 뜻합니다. 오브젝트가 마"
"스크 레이어 중 하나에 있지 않으면, 바디는 이를 무시합니다. 기본적으로 모든 바"
"디는 레이어 ``1``\\ 을 스캔합니다."

msgid ""
"These properties can be configured via code, or by editing them in the "
"Inspector."
msgstr ""
"이러한 속성은 코드를 통해, 혹은 인스펙터(Inspecter)에서 편집하여 구성할 수 있"
"습니다."

msgid ""
"Keeping track of what you're using each layer for can be difficult, so you "
"may find it useful to assign names to the layers you're using. Names can be "
"assigned in Project Settings -> Layer Names."
msgstr ""
"각 레이어를 사용하는 대상을 추적하는 것은 어려울 수 있으므로, 사용 중인 레이"
"어에 이름을 지정하는 것이 유용할 수 있습니다. 이름은 프로젝트 설정 -> Layer "
"Names에서 지정할 수 있습니다."

#, fuzzy
msgid "GUI example"
msgstr "예:"

msgid ""
"You have four node types in your game: Walls, Player, Enemy, and Coin. Both "
"Player and Enemy should collide with Walls. The Player node should detect "
"collisions with both Enemy and Coin, but Enemy and Coin should ignore each "
"other."
msgstr ""
"당신의 게임에는 4가지의 노드 타입이 있습니다: 벽, 플레이어, 적, 코인. 플레이"
"어와 적 모두 벽과 충돌해야 합니다. 플레이어 노드는 적과 코인의 콜리전을 모두 "
"감지해야 하지만, 적과 코인은 서로 무시해야 합니다."

msgid ""
"Start by naming layers 1-4 \"walls\", \"player\", \"enemies\", and \"coins\" "
"and place each node type in its respective layer using the \"Layer\" "
"property. Then set each node's \"Mask\" property by selecting the layers it "
"should interact with. For example, the Player's settings would look like "
"this:"
msgstr ""
"레이어 1-4를 \"walls\", \"player\", \"enemies\", 그리고 \"coins\"으로 이름을 "
"지정하는 걸로 시작하고, \"Layer\" 속성을 사용하여 각 노드 타입을 각각의 레이"
"어에 배치합니다. 그런 다음 각 노드가 상호 작용할 레이어를 선택하여 각 노드의 "
"\"Mask\" 속성을 설정합니다. 예를 들어, 플레이어의 설정은 다음과 같습니다:"

#, fuzzy
msgid "Code example"
msgstr "Timer 예제"

msgid ""
"In function calls, layers are specified as a bitmask. Where a function "
"enables all layers by default, the layer mask will be given as "
"``0x7fffffff``. Your code can use binary, hexadecimal, or decimal notation "
"for layer masks, depending on your preference."
msgstr ""

msgid ""
"The code equivalent of the above example where layers 1, 3 and 4 were "
"enabled would be as follows::"
msgstr ""

msgid "Area2D"
msgstr ""

msgid ""
"Area nodes provide **detection** and **influence**. They can detect when "
"objects overlap and emit signals when bodies enter or exit. Areas can also "
"be used to override physics properties, such as gravity or damping, in a "
"defined area."
msgstr ""
"Area 노드는 **감지**\\ 와 **영향력**\\ 을 제공합니다. 그들은 물체가 중복되는 "
"때를 감지하고 바디가 들어가거나 나올 때 시그널을 방출할 수 있습니다.  Area는 "
"정의된 영역에서 중력 또는 제동과 같은 물리적 특성을 치환하는 데 사용될 수도 "
"있습니다."

msgid "There are three main uses for :ref:`Area2D <class_Area2D>`:"
msgstr ":ref:`Area2D <class_Area2D>`\\ 에는 3가지 주요 용도가 있습니다:"

msgid "Overriding physics parameters (such as gravity) in a given region."
msgstr "특정 지역에서 (중력과 같은) 물리적 매개변수를 재정의 합니다."

msgid ""
"Detecting when other bodies enter or exit a region or what bodies are "
"currently in a region."
msgstr ""
"다른 바디가 특정 지역에 들어오거나 나가는 때를 감지하거나 현재 지역에 있는 바"
"디가 무엇인 지를 탐지합니다."

msgid "Checking other areas for overlap."
msgstr "다른 영역들이 겹치는지 확인합니다."

msgid "By default, areas also receive mouse and touchscreen input."
msgstr "기본적으로, 영역은 마우스 및 터치스크린 입력도 받습니다."

msgid "StaticBody2D"
msgstr ""

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. However, it can impart motion or rotation to a colliding body "
"**as if** it were moving, using its ``constant_linear_velocity`` and "
"``constant_angular_velocity`` properties."
msgstr ""
"정적 바디는 물리 엔진에 의해 움직이지 않는 물체입니다. 그것은 콜리전 감지에"
"는 참여하지만 콜리전에 대응하여 움직이지 않습니다. 그러나, "
"``constant_linear_velocity``\\ 와 ``constant_angular_velocity``\\ 의 특성을 "
"이용하여 **마치** 움직이는 것처럼 충돌하는 바디에 움직임이나 회전을 전달할 "
"수 있습니다."

msgid ""
"``StaticBody2D`` nodes are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"``StaticBody2D`` 노드는 환경에 속하거나 동적 동작을 수행할 필요가 없는 오브젝"
"트에 가장 많이 사용됩니다."

msgid "Example uses for ``StaticBody2D``:"
msgstr "``StaticBody2D`` 이용 예시:"

msgid "Platforms (including moving platforms)"
msgstr "플랫폼 (이동 플랫폼 포함)"

msgid "Conveyor belts"
msgstr "컨베이어 벨트"

msgid "Walls and other obstacles"
msgstr "벽 및 기타 장애물"

msgid "RigidBody2D"
msgstr ""

msgid ""
"This is the node that implements simulated 2D physics. You do not control a :"
"ref:`RigidBody2D <class_RigidBody2D>` directly. Instead, you apply forces to "
"it and the physics engine calculates the resulting movement, including "
"collisions with other bodies, and collision responses, such as bouncing, "
"rotating, etc."
msgstr ""
"이것은 시뮬레이션 된 2D 물리를 구현하는 노드입니다. 당신은 :ref:`RigidBody2D "
"<class_RigidBody2D>`\\ 를 직접 제어하지는 않습니다. 대신 힘을 가하게 되면 물"
"리 엔진은 다른 물체와의 콜리전을 포함한 결과 움직임과 바운스, 회전 등의 콜리"
"전 반응을 계산합니다."

#, fuzzy
msgid ""
"You can modify a rigid body's behavior via properties such as \"Mass\", "
"\"Friction\", or \"Bounce\", which can be set in the Inspector."
msgstr ""
"인스펙터(Inspecter)에서 설정할 수 있는 \"Mass\", \"Friction\", 또는 "
"\"Bounce\"와 같은 특성을 통해 리지드 바디의 동작을 수정할 수 있습니다."

msgid ""
"The body's behavior is also affected by the world's properties, as set in "
"`Project Settings -> Physics`, or by entering an :ref:`Area2D "
"<class_Area2D>` that is overriding the global physics properties."
msgstr ""
"바디의 행동은 또한 `프로젝트 설정 -> Physics`\\ 에서 설정한 월드 속성의 영향"
"을 받거나 전역 물리 특성을 오버라이딩 하는 :ref:`Area2D <class_Area2D>`\\ 를 "
"입력한 것에 영향을 받습니다."

msgid ""
"When a rigid body is at rest and hasn't moved for a while, it goes to sleep. "
"A sleeping body acts like a static body, and its forces are not calculated "
"by the physics engine. The body will wake up when forces are applied, either "
"by a collision or via code."
msgstr ""
"리지드 바디가 쉬는 상태이고 한동안 움직이지 않으면, 잠들게 됩니다. 잠든 바디"
"는 정적 바디처럼 작용하며, 그 힘은 물리 엔진에 의해 계산되지 않습니다. 콜리"
"전 또는 코드를 통해 힘이 가해지면 바디가 깨어나게 됩니다."

msgid "Rigid body modes"
msgstr "리지드 바디 모드"

msgid "A rigid body can be set to one of four modes:"
msgstr "리지드 바디는 다음 네 가지 모드 중 하나로 설정할 수 있습니다:"

msgid ""
"**Rigid** - The body behaves as a physical object. It collides with other "
"bodies and responds to forces applied to it. This is the default mode."
msgstr ""
"**Rigid** - 이 바디는 물리적 물체처럼 작동합니다. 그것은 다른 바디들과 충돌하"
"고 그것에 적용되는 힘에 반응합니다. 기본 모드입니다."

msgid ""
"**Static** - The body behaves like a :ref:`StaticBody2D "
"<class_StaticBody2D>` and does not move."
msgstr ""
"**Static** - 이 바디는 :ref:`StaticBody2D <class_StaticBody2D>`\\ 처럼 동작하"
"며 움직이지 않습니다."

msgid "**Character** - Similar to \"Rigid\" mode, but the body cannot rotate."
msgstr ""
"**Character** - \"Rigid\" 모드와 유사하지만 바디를 회전할 수는 없습니다."

msgid ""
"**Kinematic** - The body behaves like a :ref:`KinematicBody2D "
"<class_KinematicBody2D>` and must be moved by code."
msgstr ""
"**Kinematic** - 이 바디는 :ref:`KinematicBody2D <class_KinematicBody2D>`\\ 처"
"럼 작동하며 코드를 통해 움직여야 한다."

msgid "Using RigidBody2D"
msgstr "RigidBody2D 사용하기"

msgid ""
"One of the benefits of using a rigid body is that a lot of behavior can be "
"had \"for free\" without writing any code. For example, if you were making "
"an \"Angry Birds\"-style game with falling blocks, you would only need to "
"create RigidBody2Ds and adjust their properties. Stacking, falling, and "
"bouncing would automatically be calculated by the physics engine."
msgstr ""
"리지드 바디를 사용하는 것의 이점 중 하나는 코드를 쓰지 않고도 많은 행동을 "
"\"자유롭게\" 할 수 있다는 것입니다. 예를 들어, 떨어지는 블록으로 \"앵그리 버"
"드\"-스타일의 게임을 만드는 경우, RigidBody2D들을 만들고 해당 속성을 조정하기"
"만 하면 됩니다. 쌓기, 낙하 및 튕김은 물리 엔진에 의해 자동으로 계산됩니다."

msgid ""
"However, if you do wish to have some control over the body, you should take "
"care - altering the ``position``, ``linear_velocity``, or other physics "
"properties of a rigid body can result in unexpected behavior. If you need to "
"alter any of the physics-related properties, you should use the :ref:"
"`_integrate_forces() <class_RigidBody2D_method__integrate_forces>` callback "
"instead of ``_physics_process()``. In this callback, you have access to the "
"body's :ref:`Physics2DDirectBodyState <class_Physics2DDirectBodyState>`, "
"which allows for safely changing properties and synchronizing them with the "
"physics engine."
msgstr ""
"하지만, 만약 여러분이 바디를 어느 정도 통제하고 싶다면, 조심히 다루어야 합니"
"다 - ``position``, ``linear_velocity`` 또는 리지드 바디의 다른 물리적 특성들"
"을 바꾸면 예상치 못한 행동을 초래할 수 있습니다. 물리학 관련 속성을 변경해야 "
"하는 경우 ``_physics_process()`` 대신 :ref:`_integrate_forces() "
"<class_RigidBody2D_method__integrate_forces>` 콜백을 사용해야 합니다. 이 콜백"
"에서는 안전하게 속성을 변경하고 물리 엔진과 동기화할 수 있는 :ref:"
"`Physics2DDirectBodyState <class_Physics2DDirectBodyState>`\\ 에 접근할 수 있"
"습니다."

msgid "For example, here is the code for an \"Asteroids\" style spaceship:"
msgstr "예를 들어, 다음은 \"소행성\" 스타일 우주선의 코드입니다:"

msgid ""
"Note that we are not setting the ``linear_velocity`` or ``angular_velocity`` "
"properties directly, but rather applying forces (``thrust`` and ``torque``) "
"to the body and letting the physics engine calculate the resulting movement."
msgstr ""
"``linear_velocity`` 또는 ``angular_velocity``\\ 를 직접 설정하는 것이 아니라 "
"바디에 힘을 (``thrust``\\ 과 ``torque``) 적용하고 그 결과적인 움직임을 물리 "
"엔진이 계산하도록 한다는 점에 유의해야 합니다."

msgid ""
"When a rigid body goes to sleep, the ``_integrate_forces()`` function will "
"not be called. To override this behavior, you will need to keep the body "
"awake by creating a collision, applying a force to it, or by disabling the :"
"ref:`can_sleep <class_RigidBody2D_property_can_sleep>` property. Be aware "
"that this can have a negative effect on performance."
msgstr ""
"리지드 바디가 잠에 들 때 ``_integrate_forces()`` 함수는 호출되지 않을 것입니"
"다. 이 동작을 오버라이드 하려면 콜리전을 만들거나, 콜리전을 적용하거나, 힘을 "
"가하거나, :ref:`can_sleep <class_RigidBody2D_property_can_sleep>` 속성을 비활"
"성화하여 바디를 깨어 있게 해야 합니다. 이것이 퍼포먼스에 안 좋은 영향을 줄 "
"수 있으니 조심하세요."

msgid "Contact reporting"
msgstr "접촉 알림"

msgid ""
"By default, rigid bodies do not keep track of contacts, because this can "
"require a huge amount of memory if many bodies are in the scene. To enable "
"contact reporting, set the :ref:`contacts_reported "
"<class_RigidBody2D_property_contacts_reported>` property to a non-zero "
"value. The contacts can then be obtained via :ref:`Physics2DDirectBodyState."
"get_contact_count() "
"<class_Physics2DDirectBodyState_method_get_contact_count>` and related "
"functions."
msgstr ""
"기본적으로 리지드 바디는 접촉면을 추적하지 않는데, 많은 바디가 씬 내에 있을 "
"경우 엄청난 양의 메모리가 요구되기 때문입니다. 접촉 알림를 사용하려면 :ref:"
"`contacts_reported <class_RigidBody2D_property_contacts_reported>` 속성을 0"
"이 아닌 값으로 설정합니다. 그렇게 하면 접촉 알림은 :ref:"
"`Physics2DDirectBodyState.get_contact_count() "
"<class_Physics2DDirectBodyState_method_get_contact_count>`\\ 이나 관련된 기능"
"을 통해 얻을 수 있습니다."

msgid ""
"Contact monitoring via signals can be enabled via the :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>` property. See :ref:"
"`RigidBody2D <class_RigidBody2D>` for the list of available signals."
msgstr ""
"시그널을 통한 접촉 모니터링은 :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>` 속성을 통해 활성화할 수 있습니"
"다. 사용 가능한 시그널 목록은 :ref:`RigidBody2D <class_RigidBody2D>`\\ 를 참"
"조하십시오."

msgid "KinematicBody2D"
msgstr ""

msgid ""
":ref:`KinematicBody2D <class_KinematicBody2D>` bodies detect collisions with "
"other bodies, but are not affected by physics properties like gravity or "
"friction. Instead, they must be controlled by the user via code. The physics "
"engine will not move a kinematic body."
msgstr ""
":ref:`KinematicBody2D <class_KinematicBody2D>` 바디는 다른 물체와의 콜리전을 "
"감지하지만 중력이나 마찰과 같은 물리적 성질의 영향을 받지 않습니다. 대신 코드"
"를 통해 사용자가 제어해야 합니다. 물리 엔진은 키네마틱 바디를 움직이지 않습니"
"다."

msgid ""
"When moving a kinematic body, you should not set its ``position`` directly. "
"Instead, you use the ``move_and_collide()`` or ``move_and_slide()`` methods. "
"These methods move the body along a given vector, and it will instantly stop "
"if a collision is detected with another body. After the body has collided, "
"any collision response must be coded manually."
msgstr ""
"키네마틱 바디를 옮길 때는 ``위치``\\ 를 직접 정해서는 안 됩니다. 대신 "
"``move_and_collide()`` 또는 ``move_and_slide()`` 메서드를 사용합니다. 이 메서"
"드들은 주어진 벡터를 따라 바디를 움직이며, 다른 바디와의 콜리전이 감지되면 즉"
"시 정지합니다. 바디가 충돌한 후에는 모든 콜리전 응답을 수동으로 코딩해야 합니"
"다."

msgid "Kinematic collision response"
msgstr "키네마틱 콜리전 응답"

msgid ""
"After a collision, you may want the body to bounce, to slide along a wall, "
"or to alter the properties of the object it hit. The way you handle "
"collision response depends on which method you used to move the "
"KinematicBody2D."
msgstr ""
"콜리전 후 바디가 튀어 오르거나, 벽을 따라 미끄러지거나, 부딪힌 오브젝트의 속"
"성을 변경하기를 원할 수 있습니다. 콜리전 응답을 다루기 위해선 KinematicBody2D"
"을 움직이기 위해 사용된 메서드에 의해 결정됩니다."

msgid ":ref:`move_and_collide <class_KinematicBody2D_method_move_and_collide>`"
msgstr ""

msgid ""
"When using ``move_and_collide()``, the function returns a :ref:"
"`KinematicCollision2D <class_KinematicCollision2D>` object, which contains "
"information about the collision and the colliding body. You can use this "
"information to determine the response."
msgstr ""
"이 함수는 ``move_and_collide()``\\ 를 사용할 때 콜리전과 충돌하는 물체에 대"
"한 정보가 포함된 :ref:`KinematicCollision2D <class_KinematicCollision2D>` 오"
"브젝트를 반환합니다. 이 정보를 사용하여 응답을 확인할 수 있습니다."

msgid ""
"For example, if you want to find the point in space where the collision "
"occurred:"
msgstr ""
"예를 들어, 콜리전이 발생한 공간의 지점을 찾으려면 다음과 같이 하면 됩니다:"

msgid "Or to bounce off of the colliding object:"
msgstr "혹은 충돌 오브젝트가 튀어나오도록 하려면 다음과 같습니다:"

msgid ":ref:`move_and_slide <class_KinematicBody2D_method_move_and_slide>`"
msgstr ""

msgid ""
"Sliding is a common collision response; imagine a player moving along walls "
"in a top-down game or running up and down slopes in a platformer. While it's "
"possible to code this response yourself after using ``move_and_collide()``, "
"``move_and_slide()`` provides a convenient way to implement sliding movement "
"without writing much code."
msgstr ""
"슬라이딩은 일반적인 콜리전 반응입니다; 플레이어가 탑뷰 게임에서 벽을 따라 움"
"직이거나 플랫폼 안에서 오르내리는 경사를 상상해 보십시오. "
"``move_and_collide()``\\ 를 사용한 후 직접 이를 코딩할 수 있지만 "
"``move_and_slide()``\\ 는 많은 코드를 작성하지 않고 슬라이딩 이동을 실행할 "
"수 있는 편리한 방법입니다."

msgid ""
"``move_and_slide()`` automatically includes the timestep in its calculation, "
"so you should **not** multiply the velocity vector by ``delta``."
msgstr ""
"``move_and_slide()`` 는 자동으로 타임 스텝를 계산에 포함하므로, 속도 벡터에 "
"``delta``\\ 를 곱하면 **안 됩니다**."

msgid ""
"For example, use the following code to make a character that can walk along "
"the ground (including slopes) and jump when standing on the ground:"
msgstr ""
"예를 들어, 다음 코드를 사용하여 지면 (경사 포함)을 따라 걸을 수 있고 지면에 "
"있을 때 점프할 수 있는 캐릭터를 만들 수 있습니다:"

msgid ""
"See :ref:`doc_kinematic_character_2d` for more details on using "
"``move_and_slide()``, including a demo project with detailed code."
msgstr ""
"자세한 코드가 포함된 데모 프로젝트를 포함하여 ``move_and_slide()`` 사용에 대"
"한 자세한 내용은 :ref:`doc_kinematic_character_2d`\\ 를 참조하십시오."

msgid "Translation status"
msgstr "번역 상태"
