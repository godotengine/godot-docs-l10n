# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Introduction to 3D"
msgstr "3D 소개"

#, fuzzy
msgid ""
"Creating a 3D game can be challenging. That extra Z coordinate makes many of "
"the common techniques that helped to make 2D games simple no longer work. To "
"aid in this transition, it is worth mentioning that Godot uses similar APIs "
"for 2D and 3D. Most nodes are the same and are present in both 2D and 3D "
"versions. In fact, it is worth checking the 3D platformer tutorial, or the "
"3D kinematic character tutorials, which are almost identical to their 2D "
"counterparts."
msgstr ""
"3D 게임을 만드는 것은 어려울 수 있습니다. 추가 Z 좌표는 2D 게임을 단순하게 만"
"드는 데 도움이 되었던 많은 일반적인 기술들을 더 이상 작동하지 않게 만듭니다. "
"이러한 전환을 돕기 위해 Godot은 2D와 3D에 유사한 API를 사용한다는 점을 언급"
"할 필요가 있습니다. 대부분의 노드는 동일하며 2D 버전과 3D 버전 모두에 존재합"
"니다. 실제로 3D 플랫포머 튜토리얼 또는 2D 튜토리얼과 거의 동일한 3D "
"kinematic 튜토리얼을 검토할 만합니다."

msgid ""
"In 3D, math is a little more complex than in 2D, so also checking the :ref:"
"`doc_vector_math` entry in the wiki (which was especially created for game "
"developers, not mathematicians or engineers) will help pave the way for you "
"to develop 3D games efficiently."
msgstr ""
"3D에서 수학은 2D보다 조금 더 복잡하기 때문에 위키에서의 벡터 항목(특히 수학자"
"나 엔지니어가 아닌 게임 개발자를 위해 만들어진 것)을 확인하는 것도 3D 게임을 "
"효율적으로 개발할 수 있는 길을 닦는 데 도움이 될 것입니다."

msgid "Spatial node"
msgstr ""

#, fuzzy
msgid ""
":ref:`Node2D <class_Node2D>` is the base node for 2D. :ref:`Control "
"<class_Control>` is the base node for everything GUI. Following this "
"reasoning, the 3D engine uses the :ref:`Spatial <class_Spatial>` node for "
"everything 3D."
msgstr ""
":ref:`Node2D <class_Node2D>` 는 2D의 기본 노드입니다. :ref:`Control "
"<class_Control>` 는 모든 GUI의 기본 노드입니다. 이러한 추론에 따라 3D 엔진은 "
"모든 3D에 :ref:`Spatial <class_Spatial>` 를 사용합니다."

#, fuzzy
msgid ""
"Spatial nodes have a local transform, which is relative to the parent node "
"(as long as the parent node is also of **or inherits from** the type "
"Spatial). This transform can be accessed as a 4×3 :ref:`Transform "
"<class_Transform>`, or as 3 :ref:`Vector3 <class_Vector3>` members "
"representing location, Euler rotation (X, Y and Z angles) and scale."
msgstr ""
"Spatial 노드는 부모 노드에 상대적인 지역 변형을 가집니다(부모 노드도 Spatial "
"유형의 노드를 상속받는 경우). 이 변형은 4x3 :ref:`Transform "
"<class_Transform>` 또는 위치, 오일러 회전 (x,y 와 z 각도) 그리고 스케일을 나"
"타내는 세 :ref:`Vector3 <class_Vector3>` 로 접근할 수 있습니다."

msgid "3D content"
msgstr ""

#, fuzzy
msgid ""
"Unlike 2D, where loading image content and drawing is straightforward, 3D is "
"a little more difficult. The content needs to be created with special 3D "
"tools (usually referred to as Digital Content Creation tools, or DCCs) and "
"exported to an exchange file format to be imported in Godot. This is "
"required since 3D formats are not as standardized as images."
msgstr ""
"이미지 컨텐츠를 불러오고 그리는 것이 직설적인 2D와는 다르게 3D는 약간 더 어렵"
"습니다. 컨텐츠는 Godot으로 가져오려면 특수한 3D 툴(일반적으로 DCCs 라고 함)"
"로 만들고 교환 파일 형식으로 내보내야 합니다(3D 형식이 이미지만큼 표준화되지 "
"않음)."

msgid "DCC-created models"
msgstr ""

msgid ""
"There are two pipelines to import 3D models in Godot. The first and most "
"common one is by :ref:`doc_importing_3d_scenes`, which allows you to import "
"entire scenes (just as they look in the DCC), including animation, skeletal "
"rigs, blend shapes, etc."
msgstr ""
"Godot에서 3D 모델을 가져오기 위한 두 가지 파이프라인이 있습니다. 가장 보편적"
"인 첫번째는 :ref:`doc_importing_3d_scenes`\\ 와 같이 애니메이션, 골격 리그"
"(skeletal rigs), 모양 혼합(blend shapes) 등을 포함한 전체 씬을 (DCC에서 보이"
"는 것과 같이) 가져옵니다."

msgid ""
"The second pipeline is by importing simple .OBJ files as mesh resources, "
"which can be then put inside a :ref:`MeshInstance <class_MeshInstance>` node "
"for display."
msgstr ""
"두 번째 파이프라인은 간단한 .OBJ 파일을 메시 리소스로 가져오는 것입니다. 이"
"는 디스플레이를 위해 :ref:`MeshInstance <class_MeshInstance>` 노드에 넣을 수"
"도 있습니다."

msgid "Generated geometry"
msgstr ""

#, fuzzy
msgid ""
"It is possible to create custom geometry by using the :ref:`ArrayMesh "
"<class_ArrayMesh>` resource directly. Simply create your arrays and use the :"
"ref:`ArrayMesh.add_surface_from_arrays() "
"<class_ArrayMesh_method_add_surface_from_arrays>` function. A helper class "
"is also available, :ref:`SurfaceTool <class_SurfaceTool>`, which provides a "
"more straightforward API and helpers for indexing, generating normals, "
"tangents, etc."
msgstr ""
":ref:`ArrayMesh <class_ArrayMesh>` 리소스를 바로 사용하여 사용자 정의 지오메"
"트리를 만들 수 있습니다.. 간단하게 당신의 배열을 만들고 :ref:`ArrayMesh."
"add_surface_from_arrays() <class_ArrayMesh_method_add_surface_from_arrays>` "
"함수를 사용하세요. 또한 :ref:`SurfaceTool <class_SurfaceTool>` 도우미 클래스"
"를 이용할 수 있습니다. 더 간단한 API와 indexing, generating normals, "
"tangents 등을 위한 도우미를 제공합니다."

msgid ""
"In any case, this method is meant for generating static geometry (models "
"that will not be updated often), as creating vertex arrays and submitting "
"them to the 3D API has a significant performance cost."
msgstr ""
"어쨌든, 이 메서드는 정적 기하(자주 업데이트되지 않는 모델)를 생성하기 위한 것"
"입니다. 정점 배열을 만들고 3D API에 배열을 제출하는 것은 상당한 성능 비용이 "
"있습니다"

msgid "Immediate geometry"
msgstr "즉각적인 지오메트리(Immediate geometry)"

#, fuzzy
msgid ""
"If, instead, there is a requirement to generate simple geometry that will be "
"updated often, Godot provides a special node, :ref:`ImmediateGeometry "
"<class_ImmediateGeometry>`, which provides an OpenGL 1.x style immediate-"
"mode API to create points, lines, triangles, etc."
msgstr ""
"대신에 자주 업데이트 되는 간단한 지오메트리를 생성해야 할 경우 Godot은 점, "
"선, 삼각형 등을 만드는 OpenGL 1.x 스타일의 즉시-모드(immediate-mode) API를 제"
"공하는 특수 노드 :ref:`ImmediateGeometry <class_ImmediateGeometry>` 를 제공합"
"니다."

msgid "2D in 3D"
msgstr ""

#, fuzzy
msgid ""
"While Godot packs a powerful 2D engine, many types of games use 2D in a 3D "
"environment. By using a fixed camera (either orthogonal or perspective) that "
"does not rotate, nodes such as :ref:`Sprite3D <class_Sprite3D>` and :ref:"
"`AnimatedSprite3D <class_AnimatedSprite3D>` can be used to create 2D games "
"that take advantage of mixing with 3D backgrounds, more realistic parallax, "
"lighting/shadow effects, etc."
msgstr ""
"Godot은 강력한 2D 엔진을 탑재하고 있지만, 게임들 중 많은 유형들이 3D 환경에"
"서 2D를 사용합니다. 회전하지 않는 고정된 카메라(직교 또는 원근법)를 사용함으"
"로써 :ref:`Sprite3D <class_Sprite3D>` 와 :ref:`AnimatedSprite3D "
"<class_AnimatedSprite3D>` 같은 노드로 3D 배경, 더 현실적인 시차(Parallax), 조"
"명/그림자(lighting/shadow) 효과 등을 혼합하는 이점을 가진 2D 게임들을 만드는"
"데 사용할 수 있습니다."

msgid ""
"The disadvantage is, of course, that added complexity and reduced "
"performance in comparison to plain 2D, as well as the lack of reference of "
"working in pixels."
msgstr ""

msgid "Environment"
msgstr "환경"

msgid ""
"Besides editing a scene, it is often common to edit the environment. Godot "
"provides a :ref:`WorldEnvironment <class_WorldEnvironment>` node that allows "
"changing the background color, mode (as in, put a skybox), and applying "
"several types of built-in post-processing effects. Environments can also be "
"overridden in the Camera."
msgstr ""

msgid "3D viewport"
msgstr ""

msgid ""
"Editing 3D scenes is done in the 3D tab. This tab can be selected manually, "
"but it will be automatically enabled when a Spatial node is selected."
msgstr ""

msgid ""
"Default 3D scene navigation controls are similar to Blender (aiming to have "
"some sort of consistency in the free software pipeline..), but options are "
"included to customize mouse buttons and behavior to be similar to other "
"tools in the Editor Settings:"
msgstr ""

msgid "Coordinate system"
msgstr ""

msgid ""
"Godot uses the `metric <https://en.wikipedia.org/wiki/Metric_system>`__ "
"system for everything in 3D, with 1 unit being equal to 1 meter. Physics and "
"other areas are tuned for this scale. Therefore, attempting to use a "
"different scale is usually a bad idea (unless you know what you are doing)."
msgstr ""

msgid ""
"When working with 3D assets, it's always best to work in the correct scale "
"(set your DCC to metric). Godot allows scaling post-import and, while this "
"works in most cases, in rare situations it may introduce floating-point "
"precision issues (and thus, glitches or artifacts) in delicate areas such as "
"rendering or physics. Make sure your artists always work in the right scale!"
msgstr ""

msgid ""
"The Y coordinate is used for \"up\", though for most objects that need "
"alignment (like lights, cameras, capsule collider, vehicle, etc.), the Z "
"axis is used as a \"pointing towards\" direction. This convention roughly "
"means that:"
msgstr ""

msgid "**X** is sides"
msgstr ""

msgid "**Y** is up/down"
msgstr ""

msgid "**Z** is front/back"
msgstr ""

msgid "Space and manipulation gizmos"
msgstr ""

msgid ""
"Moving objects in the 3D view is done through the manipulator gizmos. Each "
"axis is represented by a color: Red, Green, Blue represent X, Y, Z "
"respectively. This convention applies to the grid and other gizmos too (and "
"also to the shader language, ordering of components for Vector3, Color, "
"etc.)."
msgstr ""

msgid "Some useful keybindings:"
msgstr ""

msgid ""
"To snap placement or rotation, press :kbd:`Ctrl` while moving, scaling or "
"rotating."
msgstr ""

msgid "To center the view on the selected object, press :kbd:`F`."
msgstr ""

msgid "View menu"
msgstr ""

msgid ""
"The view options are controlled by the \"View\" menu in the viewport's "
"toolbar."
msgstr "뷰 옵션은 뷰포트의 툴바에서 \"보기\" 메뉴에 의해 제어됩니다."

msgid "You can hide the gizmos in the 3D view of the editor through this menu:"
msgstr ""

msgid ""
"To hide a specific type of gizmos, you can toggle them off in the \"View\" "
"menu."
msgstr ""

msgid "Default environment"
msgstr ""

msgid ""
"When created from the Project Manager, the 3D environment has a default sky."
msgstr ""

msgid ""
"Given how physically based rendering works, it is advised to always try to "
"work with a default environment in order to provide indirect and reflected "
"light to your objects."
msgstr ""

msgid "Cameras"
msgstr "카메라"

msgid ""
"No matter how many objects are placed in the 3D space, nothing will be "
"displayed unless a :ref:`Camera <class_Camera>` is also added to the scene. "
"Cameras can work in either orthogonal or perspective projections:"
msgstr ""

msgid ""
"Cameras are associated with (and only display to) a parent or grandparent "
"viewport. Since the root of the scene tree is a viewport, cameras will "
"display on it by default, but if sub-viewports (either as render target or "
"picture-in-picture) are desired, they need their own children cameras to "
"display."
msgstr ""

msgid ""
"When dealing with multiple cameras, the following rules are enforced for "
"each viewport:"
msgstr ""

msgid ""
"If no cameras are present in the scene tree, the first one that enters it "
"will become the active camera. Further cameras entering the scene will be "
"ignored (unless they are set as *current*)."
msgstr ""

msgid ""
"If a camera has the \"*current*\" property set, it will be used regardless "
"of any other camera in the scene. If the property is set, it will become "
"active, replacing the previous camera."
msgstr ""

msgid ""
"If an active camera leaves the scene tree, the first camera in tree-order "
"will take its place."
msgstr ""

msgid "Lights"
msgstr "빛"

msgid ""
"Godot has a limit of up to 8 lights per mesh. Aside from that, there is no "
"limitation on the number of lights, nor of types of lights, in Godot. As "
"many as desired can be added, as long as performance allows, and no more "
"than 8 lights shine on a single mesh."
msgstr ""

msgid "Translation status"
msgstr "번역 상태"
