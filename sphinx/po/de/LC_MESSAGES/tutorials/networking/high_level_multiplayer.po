# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2022, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-08 13:53+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "High-level multiplayer"
msgstr "High-Level Mehrspieler"

msgid "High-level vs low-level API"
msgstr "High-level vs low-level API"

msgid ""
"The following explains the differences of high- and low-level networking in "
"Godot as well as some fundamentals. If you want to jump in head-first and "
"add networking to your first nodes, skip to `Initializing the network`_ "
"below. But make sure to read the rest later on!"
msgstr ""
"Im Folgenden werden die Unterschiede zwischen High- und Low-Level-Netzwerken "
"in Godot sowie einige Grundlagen erläutert. Wenn Sie direkt durchstarten und "
"Ihren ersten Node ein Netzwerk hinzufügen möchten, fahren Sie mit "
"`Initializing the network`_ weiter unten fort. Aber lesen Sie den Rest "
"später!"

msgid ""
"Godot always supported standard low-level networking via UDP, TCP and some "
"higher level protocols such as SSL and HTTP. These protocols are flexible "
"and can be used for almost anything. However, using them to synchronize game "
"state manually can be a large amount of work. Sometimes that work can't be "
"avoided or is worth it, for example when working with a custom server "
"implementation on the backend. But in most cases, it's worthwhile to "
"consider Godot's high-level networking API, which sacrifices some of the "
"fine-grained control of low-level networking for greater ease of use."
msgstr ""
"Godot unterstützte immer Standard-Low-Level-Netzwerke über UDP, TCP und "
"einige übergeordnete Protokolle wie SSL und HTTP. Diese Protokolle sind "
"flexibel und können für fast alles verwendet werden. Die manuelle "
"Synchronisierung des Spielstatus kann jedoch eine Menge Arbeit bedeuten. "
"Manchmal kann diese Arbeit nicht vermieden werden oder lohnt sich, "
"beispielsweise wenn Sie mit einer benutzerdefinierten Serverimplementierung "
"im Backend arbeiten. In den meisten Fällen lohnt es sich jedoch, die High-"
"Level-Netzwerk-API von Godot in Betracht zu ziehen, die einen Teil der fein "
"abgestimmten Steuerung von Low-Level-Netzwerken für eine einfachere "
"Benutzbarkeit eintauscht."

msgid "This is due to the inherent limitations of the low-level protocols:"
msgstr ""
"Das ist auf die eingebauten Einschränkungen von Low-Level Protokollen "
"zurückzuführen:"

msgid ""
"TCP ensures packets will always arrive reliably and in order, but latency is "
"generally higher due to error correction. It's also quite a complex protocol "
"because it understands what a \"connection\" is, and optimizes for goals "
"that often don't suit applications like multiplayer games. Packets are "
"buffered to be sent in larger batches, trading less per-packet overhead for "
"higher latency. This can be useful for things like HTTP, but generally not "
"for games. Some of this can be configured and disabled (e.g. by disabling "
"\"Nagle's algorithm\" for the TCP connection)."
msgstr ""
"TCP stellt sicher, dass Pakete immer zuverlässig und in der richtigen "
"Reihenfolge ankommen, allerdings ist die Latenz durch Fehlerkorrektur in der "
"Regel höher. Es ist auch ein etwas komplexeres Protokoll, da es versteht, "
"was eine \"Verbindung\" ist, und für Ziele optimiert wird, die häufig nicht "
"für Anwendungen wie Multiplayer-Spiele geeignet sind. Pakete werden "
"gepuffert, um in größeren Stapeln gesendet zu werden, wobei weniger Aufwand "
"pro Paket für eine höhere Latenz getauscht wird. Dies kann für Anwendungen "
"wie HTTP nützlich sein, aber im Allgemeinen nicht für Spiele. Einige davon "
"können konfiguriert und deaktiviert werden (z.B. durch Deaktivieren des "
"\"Nagle-Algorithmus\" für die TCP-Verbindung)."

msgid ""
"UDP is a simpler protocol, which only sends packets (and has no concept of a "
"\"connection\"). No error correction makes it pretty quick (low latency), "
"but packets may be lost along the way or received in the wrong order. Added "
"to that, the MTU (maximum packet size) for UDP is generally low (only a few "
"hundred bytes), so transmitting larger packets means splitting them, "
"reorganizing them and retrying if a part fails."
msgstr ""
"UDP ist ein einfacheres Protokoll, das nur Pakete sendet (und kein Konzept "
"einer \"Verbindung\" hat). Keine Fehlerkorrektur macht es ziemlich schnell "
"(geringe Latenz), aber Pakete können auf dem Weg verloren gehen oder in der "
"falschen Reihenfolge empfangen werden. Hinzu kommt, dass die MTU (maximale "
"Paketgröße) für UDP im Allgemeinen niedrig ist (nur einige hundert Bytes). "
"Wenn Sie also größere Pakete übertragen, müssen Sie diese aufteilen, neu "
"organisieren und erneut versuchen, falls etwas fehlschlägt."

msgid ""
"In general, TCP can be thought of as reliable, ordered, and slow; UDP as "
"unreliable, unordered and fast. Because of the large difference in "
"performance, it often makes sense to re-build the parts of TCP wanted for "
"games (optional reliability and packet order), while avoiding the unwanted "
"parts (congestion/traffic control features, Nagle's algorithm, etc). Due to "
"this, most game engines come with such an implementation, and Godot is no "
"exception."
msgstr ""
"Im Allgemeinen kann TCP als zuverlässig, geordnet und langsam und UDP als "
"unzuverlässig, ungeordnet und schnell charakterisiert werden. Wegen dem "
"großen Performance-Unterschied macht es häufig Sinn, die Teile von TCP "
"wiederzuverwenden, die für Spiele gewollt sind (optionale Zuverlässigkeit "
"und Paketordnung) , während die ungewollten Teile (Paketstau/Übertragungs-"
"Kontroll-Features, Nagle-Algorithmus, etc.) weggelassen werden. Aus diesem "
"Grund liefern die meisten Spiele-Engines solche Implementationen direkt mit "
"und Godot ist da keine Ausnahme."

msgid ""
"In summary, you can use the low-level networking API for maximum control and "
"implement everything on top of bare network protocols or use the high-level "
"API based on :ref:`SceneTree <class_SceneTree>` that does most of the heavy "
"lifting behind the scenes in a generally optimized way."
msgstr ""
"Zusammengefasst kann die Low-Level Netzwerk API für maximale Kontrolle "
"genutzt werden, wobei alles darüber von Grund auf selbst implementiert "
"werden muss, oder man nutzt die High-Level API basierend auf dem :ref:"
"`Szenenbaum <class_SceneTree>`, die den Großteil der Arbeit im Hintergrund "
"leistet und das im Allgemeinen auf optimierte Weise."

msgid ""
"Most of Godot's supported platforms offer all or most of the mentioned high- "
"and low-level networking features. As networking is always largely hardware "
"and operating system dependent, however, some features may change or not be "
"available on some target platforms. Most notably, the HTML5 platform "
"currently only offers WebSocket support and lacks some of the higher level "
"features as well as raw access to low-level protocols like TCP and UDP."
msgstr ""
"Die meisten von Godot unterstützten Plattformen liefern alle oder die "
"meisten der angesprochenen High- und Low-Level Netzwerk-Features. Da "
"Netzwerken allerdings sehr plattformabhängig ist, könnten manche "
"Funktionalitäten auf manchen Plattformen nicht verfügbar sein. Besonders die "
"HTML5-Plattform unterstützt zurzeit nur WebSocket und manche High-Level "
"Features als auch der Zugriff auf Low-Level-Protokolle wie TCP und UDP fehlt."

msgid ""
"More about TCP/IP, UDP, and networking: https://gafferongames.com/post/"
"udp_vs_tcp/"
msgstr ""
"Mehr über TCP/IP, UDP und Netzwerke Allgemein finden Sie hier: https://"
"gafferongames.com/post/udp_vs_tcp/"

msgid ""
"Gaffer On Games has a lot of useful articles about networking in Games "
"(`here <https://gafferongames.com/categories/game-networking/>`__), "
"including the comprehensive `introduction to networking models in games "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."
msgstr ""
"Gaffer On Games hat viele nützliche Artikel über Netzwerke in Spielen (`hier "
"<https://gafferongames.com/categories/game-networking/>`__), darunter die "
"umfassende `Introduction to networking models in games <https://"
"gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."

msgid ""
"If you want to use your low-level networking library of choice instead of "
"Godot's built-in networking, see here for an example: https://github.com/"
"PerduGames/gdnet3"
msgstr ""
"Wenn Sie die Low-Level Netzwerkbibliothek Ihrer Wahl anstatt der Godot-"
"eigenen nutzen wollen, finden Sie hier ein Beispiel: https://github.com/"
"PerduGames/gdnet3"

msgid ""
"Adding networking to your game comes with some responsibility. It can make "
"your application vulnerable if done wrong and may lead to cheats or "
"exploits. It may even allow an attacker to compromise the machines your "
"application runs on and use your servers to send spam, attack others or "
"steal your users data if they play your game."
msgstr ""
"Das Hinzufügen von Netzwerk-Funktionen zu Ihrem Spiel ist mit einer gewissen "
"Verantwortung verbunden. Es kann Ihre Anwendung angreifbar machen, wenn es "
"falsch gemacht wird, und kann zu Cheats oder Exploits führen. Es kann sogar "
"einem Angreifer ermöglichen, die Computer zu kompromittieren, auf denen Ihre "
"Anwendung ausgeführt wird, und Ihre Server zu verwenden, um Spam zu senden, "
"andere anzugreifen oder die Daten Ihrer Benutzer zu stehlen, wenn diese Ihr "
"Spiel spielen."

msgid ""
"This is always the case when networking is involved and has nothing to do "
"with Godot. You can of course experiment, but when you release a networked "
"application, always take care of any possible security concerns."
msgstr ""
"Das ist mit Netzwerkanwendungen immer der Fall, ganz unabhängig ob Godot "
"genutzt wird oder nicht. Sie können natürlich experimentieren, aber wenn Sie "
"eine Netzwerkanwendung freigeben, berücksichtigen Sie immer mögliche "
"Sicherheitsbedenken."

msgid "Mid level abstraction"
msgstr "Abstraktion auf mittlerer Ebene"

msgid ""
"Before going into how we would like to synchronize a game across the "
"network, it can be helpful to understand how the base network API for "
"synchronization works."
msgstr ""

msgid ""
"Godot uses a mid-level object :ref:`NetworkedMultiplayerPeer "
"<class_NetworkedMultiplayerPeer>`. This object is not meant to be created "
"directly, but is designed so that several C++ implementations can provide it."
msgstr ""

msgid ""
"This object extends from :ref:`PacketPeer <class_PacketPeer>`, so it "
"inherits all the useful methods for serializing, sending and receiving data. "
"On top of that, it adds methods to set a peer, transfer mode, etc. It also "
"includes signals that will let you know when peers connect or disconnect."
msgstr ""

msgid ""
"This class interface can abstract most types of network layers, topologies "
"and libraries. By default, Godot provides an implementation based on ENet (:"
"ref:`NetworkedMultiplayerEnet <class_NetworkedMultiplayerENet>`), one based "
"on WebRTC (:ref:`WebRTCMultiplayer <class_WebRTCMultiplayer>`), and one "
"based on WebSocket (:ref:`WebSocketMultiplayerPeer "
"<class_WebSocketMultiplayerPeer>`), but this could be used to implement "
"mobile APIs (for ad hoc WiFi, Bluetooth) or custom device/console-specific "
"networking APIs."
msgstr ""

msgid ""
"For most common cases, using this object directly is discouraged, as Godot "
"provides even higher level networking facilities. Yet it is made available "
"in case a game has specific needs for a lower level API."
msgstr ""

msgid "Initializing the network"
msgstr "Netzwerk initialisieren"

msgid ""
"The object that controls networking in Godot is the same one that controls "
"everything tree-related: :ref:`SceneTree <class_SceneTree>`."
msgstr ""

msgid ""
"To initialize high-level networking, the SceneTree must be provided a "
"NetworkedMultiplayerPeer object."
msgstr ""
"Um das Netzwerk auf hoher Ebene zu initialisieren, muss dem Szenenbaum ein "
"NetworkedMultiplayerPeer-Objekt bereitgestellt werden."

msgid ""
"To create that object, it first has to be initialized as a server or client."
msgstr ""
"Um dieses Objekt zu erstellen, muss es zuerst als Server oder Client "
"initialisiert werden."

msgid ""
"Initializing as a server, listening on the given port, with a given maximum "
"number of peers:"
msgstr ""

msgid "Initializing as a client, connecting to a given IP and port:"
msgstr ""
"Initialisierung als Client, Verbindung zu einer bestimmten IP und einem "
"bestimmten Port:"

msgid "Get the previously set network peer:"
msgstr "Den zuvor gesetzten Netzwerk Peer erhalten:"

msgid "Checking whether the tree is initialized as a server or client:"
msgstr "Prüfen, ob der Baum als Server oder Client initialisiert ist:"

msgid "Terminating the networking feature:"
msgstr "Beenden der Netzwerkfunktion:"

msgid ""
"(Although it may make sense to send a message first to let the other peers "
"know you're going away instead of letting the connection close or timeout, "
"depending on your game.)"
msgstr ""

msgid ""
"When exporting to Android, make sure to enable the ``INTERNET`` permission "
"in the Android export preset before exporting the project or using one-click "
"deploy. Otherwise, network communication of any kind will be blocked by "
"Android."
msgstr ""

msgid "Managing connections"
msgstr "Verbindungen verwalten"

msgid ""
"Some games accept connections at any time, others during the lobby phase. "
"Godot can be requested to no longer accept connections at any point (see "
"``set_refuse_new_network_connections(bool)`` and related methods on :ref:"
"`SceneTree <class_SceneTree>`). To manage who connects, Godot provides the "
"following signals in SceneTree:"
msgstr ""

msgid "Server and Clients:"
msgstr "Server und Clients:"

msgid "``network_peer_connected(int id)``"
msgstr "``network_peer_connected(int id)``"

msgid "``network_peer_disconnected(int id)``"
msgstr "``network_peer_disconnected(int id)``"

msgid ""
"The above signals are called on every peer connected to the server "
"(including on the server) when a new peer connects or disconnects. Clients "
"will connect with a unique ID greater than 1, while network peer ID 1 is "
"always the server. Anything below 1 should be handled as invalid. You can "
"retrieve the ID for the local system via :ref:`SceneTree."
"get_network_unique_id() <class_SceneTree_method_get_network_unique_id>`. "
"These IDs will be useful mostly for lobby management and should generally be "
"stored, as they identify connected peers and thus players. You can also use "
"IDs to send messages only to certain peers."
msgstr ""

msgid "Clients:"
msgstr "Clients:"

msgid "``connected_to_server``"
msgstr "``connected_to_server``"

msgid "``connection_failed``"
msgstr "``connection_failed``"

msgid "``server_disconnected``"
msgstr "``server_disconnected``"

msgid ""
"Again, all these functions are mainly useful for lobby management or for "
"adding/removing players on the fly. For these tasks, the server clearly has "
"to work as a server and you have to perform tasks manually such as sending a "
"newly connected player information about other already connected players (e."
"g. their names, stats, etc)."
msgstr ""

msgid ""
"Lobbies can be implemented any way you want, but the most common way is to "
"use a node with the same name across scenes in all peers. Generally, an "
"autoloaded node/singleton is a great fit for this, to always have access to, "
"e.g. \"/root/lobby\"."
msgstr ""

msgid "RPC"
msgstr "RPC"

msgid ""
"To communicate between peers, the easiest way is to use RPCs (remote "
"procedure calls). This is implemented as a set of functions in :ref:`Node "
"<class_Node>`:"
msgstr ""

msgid "``rpc(\"function_name\", <optional_args>)``"
msgstr "``rpc(\"function_name\", <optional_args>)``"

msgid "``rpc_id(<peer_id>,\"function_name\", <optional_args>)``"
msgstr "``rpc_id(<peer_id>,\"function_name\", <optional_args>)``"

msgid "``rpc_unreliable(\"function_name\", <optional_args>)``"
msgstr "``rpc_unreliable(\"function_name\", <optional_args>)``"

msgid "``rpc_unreliable_id(<peer_id>, \"function_name\", <optional_args>)``"
msgstr "``rpc_unreliable_id(<peer_id>, \"function_name\", <optional_args>)``"

msgid "Synchronizing member variables is also possible:"
msgstr "Das Synchronisieren von Mitgliedsvariablen ist ebenfalls möglich:"

msgid "``rset(\"variable\", value)``"
msgstr "``rset(\"variable\", value)``"

msgid "``rset_id(<peer_id>, \"variable\", value)``"
msgstr "``rset_id(<peer_id>, \"variable\", value)``"

msgid "``rset_unreliable(\"variable\", value)``"
msgstr "``rset_unreliable(\"variable\", value)``"

msgid "``rset_unreliable_id(<peer_id>, \"variable\", value)``"
msgstr "``rset_unreliable_id(<peer_id>, \"variable\", value)``"

msgid "Functions can be called in two fashions:"
msgstr "Funktionen können auf zwei Arten aufgerufen werden:"

msgid ""
"Reliable: the function call will arrive no matter what, but may take longer "
"because it will be re-transmitted in case of failure."
msgstr ""
"Zuverlässig: Der Funktionsaufruf kommt auf jeden Fall an, kann jedoch länger "
"dauern, da er im Fehlerfall erneut übertragen wird."

msgid ""
"Unreliable: if the function call does not arrive, it will not be re-"
"transmitted; but if it arrives, it will do it quickly."
msgstr ""
"Unzuverlässig: Wenn der Funktionsaufruf nicht eintrifft, wird er nicht "
"erneut übertragen. aber wenn er ankommt, geschieht dies schnell."

msgid ""
"In most cases, reliable is desired. Unreliable is mostly useful when "
"synchronizing object positions (sync must happen constantly, and if a packet "
"is lost, it's not that bad because a new one will eventually arrive and it "
"would likely be outdated because the object moved further in the meantime, "
"even if it was resent reliably)."
msgstr ""
"In den meisten Fällen ist Zuverlässigkeit erwünscht. Unzuverlässig ist "
"meistens nützlich, wenn Objektpositionen synchronisiert werden (die "
"Synchronisierung muss ständig erfolgen und wenn ein Paket verloren geht ist "
"es nicht so schlimm, da irgendwann ein neues ankommt und es wahrscheinlich "
"veraltet ist, weil sich das Objekt in der Zwischenzeit weiter bewegt hat, "
"selbst wenn es erneut zuverlässig gesendet wurde)."

msgid ""
"There is also the ``get_rpc_sender_id`` function in ``SceneTree``, which can "
"be used to check which peer (or peer ID) sent an RPC."
msgstr ""

msgid "Back to lobby"
msgstr "Zurück in die Lobby"

msgid ""
"Let's get back to the lobby. Imagine that each player that connects to the "
"server will tell everyone about it."
msgstr ""
"Kehren wir noch einmal zum Anfang zurück. Stellen Sie sich vor jeder "
"Spieler, der eine Verbindung zum Server herstellt, wird allen davon erzählen."

msgid ""
"You might have already noticed something different, which is the usage of "
"the ``remote`` keyword on the ``register_player`` function:"
msgstr ""

msgid ""
"This keyword has two main uses. The first is to let Godot know that this "
"function can be called from RPC. If no keywords are added, Godot will block "
"any attempts to call functions for security. This makes security work a lot "
"easier (so a client can't call a function to delete a file on another "
"client's system)."
msgstr ""

msgid ""
"The second use is to specify how the function will be called via RPC. There "
"are four different keywords:"
msgstr ""
"Die zweite Verwendung besteht darin, anzugeben, wie die Funktion über RPC "
"aufgerufen wird. Es gibt vier verschiedene Schlüsselwörter:"

msgid "``remote``"
msgstr "``remote``"

msgid "``remotesync``"
msgstr "``remotesync``"

msgid "``master``"
msgstr "``master``"

msgid "``puppet``"
msgstr "``puppet``"

msgid ""
"The ``remote`` keyword means that the ``rpc()`` call will go via network and "
"execute remotely."
msgstr ""

msgid ""
"The ``remotesync`` keyword means that the ``rpc()`` call will go via network "
"and execute remotely, but will also execute locally (do a normal function "
"call)."
msgstr ""

msgid ""
"The others will be explained further down. Note that you could also use the "
"``get_rpc_sender_id`` function on ``SceneTree`` to check which peer actually "
"made the RPC call to ``register_player``."
msgstr ""

msgid ""
"With this, lobby management should be more or less explained. Once you have "
"your game going, you will most likely want to add some extra security to "
"make sure clients don't do anything funny (just validate the info they send "
"from time to time, or before game start). For the sake of simplicity and "
"because each game will share different information, this is not shown here."
msgstr ""

msgid "Starting the game"
msgstr "Das Spiel starten"

msgid ""
"Once enough players have gathered in the lobby, the server should probably "
"start the game. This is nothing special in itself, but we'll explain a few "
"nice tricks that can be done at this point to make your life much easier."
msgstr ""
"Sobald sich genügend Spieler in der Lobby versammelt haben, sollte der "
"Server das Spiel wahrscheinlich starten. Dies ist an sich nichts Besonderes, "
"aber wir werden ein paar nette Tricks erklären, die an dieser Stelle "
"ausgeführt werden können, um Ihr Leben viel einfacher zu machen."

msgid "Player scenes"
msgstr "Spielerszene"

msgid ""
"In most games, each player will likely have its own scene. Remember that "
"this is a multiplayer game, so in every peer you need to instance **one "
"scene for each player connected to it**. For a 4 player game, each peer "
"needs to instance 4 player nodes."
msgstr ""
"In den meisten Spielen hat wahrscheinlich jeder Spieler seine eigene Szene. "
"Denken Sie daran, dass dies ein Multiplayer-Spiel ist. In jedem Peer müssen "
"Sie also **eine Szene für jeden damit verbundenen Spieler instanziieren**. "
"Für ein 4-Spieler-Spiel muss jeder Peer 4-Spieler-Nodes instanziieren."

msgid ""
"So, how to name such nodes? In Godot, nodes need to have a unique name. It "
"must also be relatively easy for a player to tell which node represents each "
"player ID."
msgstr ""
"Wie benennt man solche Nodes? In Godot müssen Nodes einen eindeutigen Namen "
"haben. Es muss für einen Spieler auch relativ einfach zu erkennen sein, "
"welcher Node welche Spieler-ID repräsentiert."

msgid ""
"The solution is to simply name the *root nodes of the instanced player "
"scenes as their network ID*. This way, they will be the same in every peer "
"and RPC will work great! Here is an example:"
msgstr ""
"Die Lösung besteht darin, einfach die *Wurzel-Nodes der instanziierten "
"Playerszenen als Netzwerk-ID* zu benennen. Auf diese Weise sind sie bei "
"jedem Peer gleich und RPC funktioniert hervorragend! Hier ist ein Beispiel:"

msgid ""
"Depending on when you execute pre_configure_game(), you may need to change "
"any calls to ``add_child()`` to be deferred via ``call_deferred()``, as the "
"SceneTree is locked while the scene is being created (e.g. when ``_ready()`` "
"is being called)."
msgstr ""

msgid "Synchronizing game start"
msgstr "Spielstart synchronisieren"

msgid ""
"Setting up players might take different amounts of time for every peer due "
"to lag, different hardware, or other reasons. To make sure the game will "
"actually start when everyone is ready, pausing the game until all players "
"are ready can be useful:"
msgstr ""
"Spieler einzurichten kann aufgrund von Verzögerungen, unterschiedlicher "
"Hardware oder aus anderen Gründen für jeden Peer unterschiedlich lange "
"dauern. Um sicherzustellen, dass das Spiel tatsächlich startet wenn alle "
"bereit sind, kann es nützlich sein das Spiel anzuhalten, bis alle Spieler "
"bereit sind:"

msgid ""
"When the server gets the OK from all the peers, it can tell them to start, "
"as for example:"
msgstr ""
"Wenn der Server von allen Peers das OK erhält, kann er sie anweisen zu "
"starten, wie zum Beispiel:"

msgid "Synchronizing the game"
msgstr "Das Spiel synchronisieren"

msgid ""
"In most games, the goal of multiplayer networking is that the game runs "
"synchronized on all the peers playing it. Besides supplying an RPC and "
"remote member variable set implementation, Godot adds the concept of network "
"masters."
msgstr ""

msgid "Network master"
msgstr "Netzwerk-Master"

msgid ""
"The network master of a node is the peer that has the ultimate authority "
"over it."
msgstr ""

msgid ""
"When not explicitly set, the network master is inherited from the parent "
"node, which if not changed, is always going to be the server (ID 1). Thus "
"the server has authority over all nodes by default."
msgstr ""

msgid ""
"The network master can be set with the function :ref:`Node."
"set_network_master(id, recursive) <class_Node_method_set_network_master>` "
"(recursive is ``true`` by default and means the network master is "
"recursively set on all child nodes of the node as well)."
msgstr ""

msgid ""
"Checking that a specific node instance on a peer is the network master for "
"this node for all connected peers is done by calling :ref:`Node."
"is_network_master() <class_Node_method_is_network_master>`. This will return "
"``true`` when executed on the server and ``false`` on all client peers."
msgstr ""

msgid ""
"If you have paid attention to the previous example, it's possible you "
"noticed that each peer was set to have network master authority for their "
"own player (Node) instead of the server:"
msgstr ""

msgid ""
"Each time this piece of code is executed on each peer, the peer makes itself "
"master on the node it controls, and all other nodes remain as puppets with "
"the server being their network master."
msgstr ""

msgid ""
"To clarify, here is an example of how this looks in the `bomber demo "
"<https://github.com/godotengine/godot-demo-projects/tree/master/networking/"
"multiplayer_bomber>`_:"
msgstr ""
"Zur Verdeutlichung hier ein Beispiel, wie dies in der `Bomberdemo <https://"
"github.com/godotengine/godot-demo-projects/tree/master/networking/"
"multiplayer_bomber>`_ aussieht:"

msgid "Master and puppet keywords"
msgstr "Master- und Marionettenschlüsselwörter"

msgid ""
"The real advantage of this model is when used with the ``master``/``puppet`` "
"keywords in GDScript (or their equivalent in C# and Visual Script). "
"Similarly to the ``remote`` keyword, functions can also be tagged with them:"
msgstr ""

msgid "Example bomb code:"
msgstr "Beispiel für einen Bombencode:"

msgid "Example player code:"
msgstr "Beispiel für einen Spielercode:"

msgid ""
"In the above example, a bomb explodes somewhere (likely managed by whoever "
"is the master of this bomb-node, e.g. the host). The bomb knows the bodies "
"(player nodes) in the area, so it checks that they contain an ``exploded`` "
"method before calling it."
msgstr ""

msgid ""
"Recall that each peer has a complete set of instances of player nodes, one "
"instance for each peer (including itself and the host). Each peer has set "
"itself as the master of the instance corresponding to itself, and it has set "
"a different peer as the master for each of the other instances."
msgstr ""

msgid ""
"Now, going back to the call to the ``exploded`` method, the bomb on the host "
"has called it remotely on all bodies in the area that have the method. "
"However, this method is in a player node and has a ``master`` keyword."
msgstr ""

msgid ""
"The ``master`` keyword on the ``exploded`` method in the player node means "
"two things for how this call is made. Firstly, from the perspective of the "
"calling peer (the host), the calling peer will only attempt to remotely call "
"the method on the peer that it has set as the network master of the player "
"node in question. Secondly, from the perspective of the peer the host is "
"sending the call to, the peer will only accept the call if it set itself as "
"the network master of the player node with the method being called (which "
"has the ``master`` keyword). This works well as long as all peers agree on "
"who is the master of what."
msgstr ""

msgid ""
"The above setup means that only the peer who owns the affected body will be "
"responsible for telling all the other peers that its body was stunned, after "
"being remotely instructed to do so by the host's bomb. The owning peer "
"therefore (still in the ``exploded`` method) tells all the other peers that "
"its player node was stunned. The peer does this by remotely calling the "
"``stun`` method on all instances of that player node (on the other peers). "
"Because the ``stun`` method has the ``puppet`` keyword, only peers who did "
"not set themselves as the network master of the node will call it (in other "
"words, those peers are set as puppets for that node by virtue of not being "
"the network master of it)."
msgstr ""
"Das obige Setup bedeutet, dass nur der Peer, dem der betroffene Körper "
"gehört, dafür verantwortlich ist, allen anderen Peers mitzuteilen, dass sein "
"Körper betäubt wurde, nachdem er von der Bombe des Hosts aus der Ferne dazu "
"angewiesen wurde. Der besitzende Peer (immer noch in der ``exploded`` "
"Methode) teilt allen anderen Peers mit, dass sein Spieler-Node betäubt "
"wurde. Der Peer ruft dazu die ``stun`` Methode auf allen Instanzen dieses "
"Spieler-Nodes (auf den anderen Peers) aus der Ferne auf. Da die ``stun`` "
"Methode das Schlüsselwort ``puppet`` hat, wird es nur von Peers aufgerufen, "
"die sich nicht als Netzwerkmaster des Nodes festgelegt haben (mit anderen "
"Worten, diese Peers werden aufgrund dieses Nodes als Puppets für diesen Node "
"festgelegt, nicht der Netzwerk-Master davon zu sein)."

msgid ""
"The result of this call to ``stun`` is to make the player look stunned on "
"the screen of all the peers, including the current network master peer (due "
"to the local call to ``stun`` after ``rpc(\"stun\")``)."
msgstr ""

msgid ""
"The master of the bomb (the host) repeats the above steps for each of the "
"bodies in the area, such that all the instances of any player in the bomb "
"area get stunned on the screens of all the peers."
msgstr ""
"Der Meister der Bombe (der Wirt) wiederholt die obigen Schritte für jeden "
"der Körper in dem Gebiet, so dass alle Instanzen eines Spielers im "
"Bombengebiet auf den Bildschirmen aller Peers betäubt werden."

msgid ""
"Note that you could also send the ``stun()`` message only to a specific "
"player by using ``rpc_id(<id>, \"exploded\", bomb_owner)``. This may not "
"make much sense for an area-of-effect case like the bomb, but might in other "
"cases, like single target damage."
msgstr ""

msgid "Exporting for dedicated servers"
msgstr "Exportieren für dedizierte Server"

msgid ""
"Once you've made a multiplayer game, you may want to export it to run it on "
"a dedicated server with no GPU available. See :ref:"
"`doc_exporting_for_dedicated_servers` for more information."
msgstr ""
"Sobald Sie ein Multiplayer-Spiel erstellt haben, möchten Sie es "
"möglicherweise exportieren, um es auf einem dedizierten Server ohne "
"verfügbare GPU auszuführen. Weitere Informationen finden Sie unter :ref:"
"`doc_exporting_for_dedicated_servers`."

msgid ""
"The code samples on this page aren't designed to run on a dedicated server. "
"You'll have to modify them so the server isn't considered to be a player. "
"You'll also have to modify the game starting mechanism so that the first "
"player who joins can start the game."
msgstr ""
"Die Codebeispiele auf dieser Seite können nicht auf einem dedizierten Server "
"ausgeführt werden. Sie müssen sie ändern, damit der Server nicht als Spieler "
"betrachtet wird. Sie müssen auch den Spielstartmechanismus ändern, damit der "
"erste Spieler, der beitritt, das Spiel starten kann."

msgid ""
"The bomberman example here is largely for illustrational purposes, and does "
"not do anything on the host-side to handle the case where a peer uses a "
"custom client to cheat by for example refusing to stun itself. In the "
"current implementation such cheating is perfectly possible because each "
"client is the network master of its own player, and the network master of a "
"player is the one which decides whether to call the I-was-stunned method "
"(``stun``) on all of the other peers and itself."
msgstr ""

msgid "Translation status"
msgstr "Übersetzungsstatus"
