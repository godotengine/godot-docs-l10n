# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2022, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-08 13:53+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced vector math"
msgstr "Fortgeschrittene Vektor-Mathematik"

msgid "Planes"
msgstr "Flächen"

msgid ""
"The dot product has another interesting property with unit vectors. Imagine "
"that perpendicular to that vector (and through the origin) passes a plane. "
"Planes divide the entire space into positive (over the plane) and negative "
"(under the plane), and (contrary to popular belief) you can also use their "
"math in 2D:"
msgstr ""
"Das Skalarprodukt hat eine weitere interessante Eigenschaft mit "
"Einheitsvektoren. Stellen Sie sich vor, dass senkrecht zu diesem Vektor (und "
"durch den Ursprung) eine Ebene verläuft. Ebenen teilen den gesamten Raum in "
"positive (über der Ebene) und negative (unter der Ebene), und (entgegen der "
"landläufigen Meinung) können Sie ihre Mathematik auch in 2D verwenden:"

msgid ""
"Unit vectors that are perpendicular to a surface (so, they describe the "
"orientation of the surface) are called **unit normal vectors**. Though, "
"usually they are just abbreviated as *normals*. Normals appear in planes, 3D "
"geometry (to determine where each face or vertex is siding), etc. A "
"**normal** *is* a **unit vector**, but it's called *normal* because of its "
"usage. (Just like we call (0,0) the Origin!)."
msgstr ""
"Einheitsvektoren, die senkrecht zu einer Oberfläche stehen (sie beschreiben "
"also die Ausrichtung der Oberfläche), werden als "
"**Einheitsnormalenvektoren** bezeichnet. Normalerweise werden sie jedoch nur "
"als *Normalen* abgekürzt. Normalen erscheinen in Ebenen, 3D-Geometrie (um zu "
"bestimmen, wo sich jede Fläche oder jeder Scheitelpunkt befindet) usw. Ein "
"**Normal** *ist*ein **Einheitsvektor**, wird aber aufgrund seiner Verwendung "
"*Normal* genannt. (Genau wie wir (0,0) den Ursprung nennen!)."

msgid ""
"It's as simple as it looks. The plane passes by the origin and the surface "
"of it is perpendicular to the unit vector (or *normal*). The side towards "
"the vector points to is the positive half-space, while the other side is the "
"negative half-space. In 3D this is exactly the same, except that the plane "
"is an infinite surface (imagine an infinite, flat sheet of paper that you "
"can orient and is pinned to the origin) instead of a line."
msgstr ""
"Es ist so einfach wie es aussieht. Die Ebene verläuft am Ursprung vorbei und "
"ihre Oberfläche ist senkrecht zum Einheitsvektor (oder *normal*). Die Seite, "
"auf die der Vektor zeigt, ist der positive Halbraum, während die andere "
"Seite der negative Halbraum ist. In 3D ist dies genau das Gleiche, außer "
"dass die Ebene eine unendliche Oberfläche anstelle einer Linie ist (stellen "
"Sie sich ein unendliches, flaches Blatt Papier vor, das Sie ausrichten "
"können und das am Ursprung befestigt ist)."

msgid "Distance to plane"
msgstr "Abstand zur Fläche"

msgid ""
"Now that it's clear what a plane is, let's go back to the dot product. The "
"dot product between a **unit vector** and any **point in space** (yes, this "
"time we do dot product between vector and position), returns the **distance "
"from the point to the plane**:"
msgstr ""
"Nachdem klar ist, was eine Ebene ist, kehren wir zum Skalarprodukt zurück. "
"Das Skalarprodukt zwischen einem **Einheitsvektor** und einem beliebigen "
"**Punkt im Raum** (ja, diesmal machen wir ein Skalarprodukt zwischen Vektor "
"und Position) gibt den **Abstand vom Punkt zur Ebene** zurück:"

msgid ""
"But not just the absolute distance, if the point is in the negative half "
"space the distance will be negative, too:"
msgstr ""
"Aber nicht nur die absolute Entfernung: wenn sich der Punkt im negativen "
"Halbraum befindet, ist auch die Entfernung negativ:"

msgid "This allows us to tell which side of the plane a point is."
msgstr "Dies erlaubt uns zu sagen, auf welcher Seite der Ebene ein Punkt ist."

msgid "Away from the origin"
msgstr "Wegbewegen vom Ursprung"

msgid ""
"I know what you are thinking! So far this is nice, but *real* planes are "
"everywhere in space, not only passing through the origin. You want real "
"*plane* action and you want it *now*."
msgstr ""
"Ich weiß was Sie denken! Schön und gut, aber *echte* Ebenen sind überall im "
"Raum und nicht nur den Ursprung durchquerend. Sie wollen echte *Ebenen* und "
"Sie möchten sie *jetzt*."

msgid ""
"Remember that planes not only split space in two, but they also have "
"*polarity*. This means that it is possible to have perfectly overlapping "
"planes, but their negative and positive half-spaces are swapped."
msgstr ""
"Bedenke dass Ebenen nicht nur den Raum teilen, sie haben auch eine "
"*Polarität*. Das bedeutet, es können zwei perfekt überlappende Ebenen "
"vorhanden sein, aber deren positiven und negativen Halb-Räume sind "
"vertauscht."

msgid ""
"With this in mind, let's describe a full plane as a **normal** *N* and a "
"**distance from the origin** scalar *D*. Thus, our plane is represented by N "
"and D. For example:"
msgstr ""
"Mit diesem Wissen können wir nun eine komplette Ebene als **normale** *N* "
"und eine **Distanz vom Ursprung** Skalar *D* bezeichnen. Somit wird unsere "
"Ebene mittels N und D repräsentiert, zum Beispiel:"

msgid ""
"For 3D math, Godot provides a :ref:`Plane <class_Plane>` built-in type that "
"handles this."
msgstr ""
"Für 3D Mathematik bietet Godot einen eingebauten Typ :ref:`Plane "
"<class_Plane>` der dies handhabt."

msgid ""
"Basically, N and D can represent any plane in space, be it for 2D or 3D "
"(depending on the amount of dimensions of N) and the math is the same for "
"both. It's the same as before, but D is the distance from the origin to the "
"plane, travelling in N direction. As an example, imagine you want to reach a "
"point in the plane, you will just do:"
msgstr ""
"Grundsätzlich können N und D jede Ebene im Raum darstellen, sei es für 2D "
"oder 3D (abhängig von der Anzahl der Dimensionen von N), und die Mathematik "
"ist für beide gleich. Es ist das gleiche wie zuvor, aber D ist die "
"Entfernung vom Ursprung zur Ebene in N-Richtung. Stellen Sie sich als "
"Beispiel vor, Sie möchten einen Punkt in der Ebene erreichen. Sie tun "
"einfach Folgendes:"

msgid ""
"This will stretch (resize) the normal vector and make it touch the plane. "
"This math might seem confusing, but it's actually much simpler than it "
"seems. If we want to tell, again, the distance from the point to the plane, "
"we do the same but adjusting for distance:"
msgstr ""
"Dadurch wird der normale Vektor gedehnt (seine Größe geändert) und er "
"berührt die Ebene. Diese Mathematik mag verwirrend erscheinen, ist aber "
"tatsächlich viel einfacher als es scheint. Wenn wir noch einmal die "
"Entfernung vom Punkt zur Ebene angeben möchten, tun wir dasselbe, passen "
"jedoch die Entfernung an:"

msgid "The same thing, using a built-in function:"
msgstr "Das gleiche, diesmal wird eine eingebaute Funktion genutzt:"

msgid "This will, again, return either a positive or negative distance."
msgstr ""
"Dies wird wiederum entweder eine positive oder negative Distanz "
"zurückliefern."

msgid ""
"Flipping the polarity of the plane can be done by negating both N and D. "
"This will result in a plane in the same position, but with inverted negative "
"and positive half spaces:"
msgstr ""
"Das Umdrehen der Polarität der Ebene kann durch Negieren von N und D "
"erfolgen. Dies führt zu einer Ebene an derselben Position, jedoch mit "
"invertierten negativen und positiven Halbräumen:"

msgid ""
"Of course, Godot also implements this operator in :ref:`Plane "
"<class_Plane>`, so doing:"
msgstr ""
"Natürlich implementiert Godot diesen Operator auch in :ref:`Plane "
"<class_Plane>`, also schreiben wir:"

msgid "Will work as expected."
msgstr "Funktioniert wie erwartet."

msgid ""
"So, remember, a plane is just that and its main practical use is calculating "
"the distance to it. So, why is it useful to calculate the distance from a "
"point to a plane? It's extremely useful! Let's see some simple examples.."
msgstr ""
"Denken Sie also daran, eine Ebene ist genau das und ihre hauptsächliche "
"praktische Verwendung besteht darin, die Entfernung zu ihr zu berechnen. "
"Warum ist es also sinnvoll, die Entfernung von einem Punkt zu einer Ebene zu "
"berechnen? Es ist sehr nützlich! Schauen wir uns einige einfache Beispiele "
"an."

msgid "Constructing a plane in 2D"
msgstr "Eine Fläche in 2D erstellen"

msgid ""
"Planes clearly don't come out of nowhere, so they must be built. "
"Constructing them in 2D is easy, this can be done from either a normal (unit "
"vector) and a point, or from two points in space."
msgstr ""
"Ebenen kommen eindeutig nicht aus dem Nichts, also müssen sie gebaut werden. "
"Das Konstruieren in 2D ist einfach. Dies kann entweder aus einem Normalen "
"(Einheitsvektor) und einem Punkt oder aus zwei Punkten im Raum erfolgen."

msgid ""
"In the case of a normal and a point, most of the work is done, as the normal "
"is already computed, so just calculate D from the dot product of the normal "
"and the point."
msgstr ""
"Im Fall einer Normalen und eines Punktes ist der größte Teil der Arbeit "
"erledigt, da die Normalen bereits berechnet wurden. Berechnen Sie also "
"einfach D aus dem Skalarprodukt der Normalen und des Punkts."

msgid ""
"For two points in space, there are actually two planes that pass through "
"them, sharing the same space but with normal pointing to the opposite "
"directions. To compute the normal from the two points, the direction vector "
"must be obtained first, and then it needs to be rotated 90° degrees to "
"either side:"
msgstr ""
"Für zwei Punkte im Raum gibt es tatsächlich zwei Ebenen, die durch sie "
"hindurchgehen und denselben Raum teilen, aber normal in die "
"entgegengesetzten Richtungen zeigen. Um die Normale aus den beiden Punkten "
"zu berechnen, muss zuerst der Richtungsvektor ermittelt und dann um 90 ° "
"nach beiden Seiten gedreht werden:"

msgid ""
"The rest is the same as the previous example, either point_a or point_b will "
"work since they are in the same plane:"
msgstr ""
"Der Rest ist der gleiche wie im vorherigen Beispiel. Entweder point_a oder "
"point_b funktionieren, da sie sich in derselben Ebene befinden:"

msgid ""
"Doing the same in 3D is a little more complex and will be explained further "
"down."
msgstr ""
"Dasselbe in 3D zu tun, ist etwas komplexer und wird weiter unten erläutert."

msgid "Some examples of planes"
msgstr "Einige Beispiele von Flächen"

msgid ""
"Here is a simple example of what planes are useful for. Imagine you have a "
"`convex <https://www.mathsisfun.com/definitions/convex.html>`__ polygon. For "
"example, a rectangle, a trapezoid, a triangle, or just any polygon where no "
"faces bend inwards."
msgstr ""
"Hier ist ein einfaches Beispiel dafür, wofür Ebenen nützlich sind. Stellen "
"Sie sich vor, Sie haben ein `konvexes <https://www.mathsisfun.com/"
"definitions/convex.html>`__ Polygon. Zum Beispiel ein Rechteck, ein Trapez, "
"ein Dreieck oder ein beliebiges Polygon, bei dem sich keine Flächen nach "
"innen biegen."

msgid ""
"For every segment of the polygon, we compute the plane that passes by that "
"segment. Once we have the list of planes, we can do neat things, for example "
"checking if a point is inside the polygon."
msgstr ""
"Für jedes Segment des Polygons berechnen wir die Ebene, die an diesem "
"Segment vorbeigeht. Sobald wir die Liste der Ebenen haben, können wir tolle "
"Dinge tun, zum Beispiel prüfen, ob sich ein Punkt innerhalb des Polygons "
"befindet."

msgid ""
"We go through all planes, if we can find a plane where the distance to the "
"point is positive, then the point is outside the polygon. If we can't, then "
"the point is inside."
msgstr ""
"Wir gehen alle Ebenen durch. Wenn wir eine Ebene finden, in der der Abstand "
"zum Punkt positiv ist, liegt der Punkt außerhalb des Polygons, andernfalls "
"ist der Punkt innerhalb."

msgid "Code should be something like this:"
msgstr "Der Code sollte ungefähr so aussehen:"

msgid ""
"Pretty cool, huh? But this gets much better! With a little more effort, "
"similar logic will let us know when two convex polygons are overlapping too. "
"This is called the Separating Axis Theorem (or SAT) and most physics engines "
"use this to detect collision."
msgstr ""
"Ziemlich cool, oder? Aber das wird noch viel besser! Mit etwas mehr Aufwand "
"lässt uns eine ähnliche Logik wissen, wann sich zwei konvexe Polygone "
"überlappen. Dies wird als Separating Axis Theorem (SAT) bezeichnet, und die "
"meisten Physik-Engines verwenden dies, um Kollisionen zu erkennen."

msgid ""
"With a point, just checking if a plane returns a positive distance is enough "
"to tell if the point is outside. With another polygon, we must find a plane "
"where *all* *the* *other* *polygon* *points* return a positive distance to "
"it. This check is performed with the planes of A against the points of B, "
"and then with the planes of B against the points of A:"
msgstr ""
"Bei einem Punkt reicht es aus nur zu überprüfen, ob eine Ebene eine positive "
"Entfernung zurückgibt, um festzustellen, ob der Punkt außerhalb liegt. Bei "
"einem anderen Polygon müssen wir eine Ebene finden, in der *alle* *anderen* "
"*Polygon-Punkte* einen positiven Abstand zurückgeben. Diese Prüfung wird mit "
"den Ebenen von A gegen die Punkte von B und dann mit den Ebenen von B gegen "
"die Punkte von A durchgeführt:"

msgid ""
"As you can see, planes are quite useful, and this is the tip of the iceberg. "
"You might be wondering what happens with non convex polygons. This is "
"usually just handled by splitting the concave polygon into smaller convex "
"polygons, or using a technique such as BSP (which is not used much nowadays)."
msgstr ""
"Wie Sie sehen können, sind Ebenen sehr nützlich, und dies ist erst die "
"Spitze des Eisbergs. Sie fragen sich vielleicht, was mit nicht konvexen "
"Polygonen passiert. Dies geschieht normalerweise durch Aufteilen des "
"konkaven Polygone in kleinere konvexe Polygone oder durch Verwendung einer "
"Technik wie BSP (die heutzutage nicht viel Verwendung findet)."

msgid "Collision detection in 3D"
msgstr "Kollisionserkennung in 3D"

msgid ""
"This is another bonus bit, a reward for being patient and keeping up with "
"this long tutorial. Here is another piece of wisdom. This might not be "
"something with a direct use case (Godot already does collision detection "
"pretty well) but it's used by almost all physics engines and collision "
"detection libraries :)"
msgstr ""
"Dies ist ein weiterer Bonus, eine Belohnung dafür, dass Sie geduldig sind "
"und mit dieser langen Anleitung Schritt halten. Hier ist ein weiteres Stück "
"Weisheit. Dies ist möglicherweise kein direkter Anwendungsfall (Godot macht "
"die Kollisionserkennung bereits ziemlich gut), aber es wird von fast allen "
"Physik-Engines und Kollisionserkennungsbibliotheken verwendet :)"

msgid ""
"Remember that converting a convex shape in 2D to an array of 2D planes was "
"useful for collision detection? You could detect if a point was inside any "
"convex shape, or if two 2D convex shapes were overlapping."
msgstr ""
"Erinnern Sie sich, dass das Konvertieren einer konvexen Form in 2D in ein "
"Array von 2D-Ebenen für die Kollisionserkennung hilfreich war? Sie konnten "
"feststellen, ob sich ein Punkt innerhalb einer konvexen Form befand oder ob "
"sich zwei konvexe 2D-Formen überlappten."

msgid ""
"Well, this works in 3D too, if two 3D polyhedral shapes are colliding, you "
"won't be able to find a separating plane. If a separating plane is found, "
"then the shapes are definitely not colliding."
msgstr ""
"Nun, dies funktioniert auch in 3D. Wenn zwei vielflächige 3D-Formen "
"kollidieren, können Sie keine Trennebene finden. Wenn eine Trennebene "
"gefunden wird, kollidieren die Formen definitiv nicht."

msgid ""
"To refresh a bit a separating plane means that all vertices of polygon A are "
"in one side of the plane, and all vertices of polygon B are in the other "
"side. This plane is always one of the face-planes of either polygon A or "
"polygon B."
msgstr ""
"Zur Erinnerung: Trennebene bedeutet, dass sich alle Scheitelpunkte des "
"Polygons A auf einer Seite der Ebene und alle Scheitelpunkte des Polygons B "
"auf der anderen Seite befinden. Diese Ebene ist immer eine der Flächenebenen "
"von Polygon A oder Polygon B."

msgid ""
"In 3D though, there is a problem to this approach, because it is possible "
"that, in some cases a separating plane can't be found. This is an example of "
"such situation:"
msgstr ""
"In 3D gibt es jedoch ein Problem bei diesem Ansatz, da es möglich ist, dass "
"in einigen Fällen keine Trennebene gefunden werden kann. Dies ist ein "
"Beispiel für eine solche Situation:"

msgid ""
"To avoid it, some extra planes need to be tested as separators, these planes "
"are the cross product between the edges of polygon A and the edges of "
"polygon B"
msgstr ""
"Um dies zu vermeiden, müssen einige zusätzliche Ebenen als Trennobjekte "
"getestet werden. Diese Ebenen sind das Kreuzprodukt zwischen den Kanten des "
"Polygons A und den Kanten des Polygons B."

msgid "So the final algorithm is something like:"
msgstr "Der endgültige Algorithmus ist also ungefähr so:"

msgid "More information"
msgstr "Mehr Informationen"

msgid ""
"For more information on using vector math in Godot, see the following "
"article:"
msgstr ""
"Für weitere Informationen zur Benutzung von Vektoren-Mathematik in Godot, "
"siehe folgenden Artikel:"

msgid ":ref:`doc_matrices_and_transforms`"
msgstr ":ref:`doc_matrices_and_transforms`"

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video series \"Essence of Linear Algebra\": https://www.youtube."
"com/watch?v=fNk_zzaMoSs&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab"
msgstr ""
"Für weiterführende Erklärungen siehe 3Blue1Brown's excellente Video Serie "
"\"Essence of Linear Algebra\": https://www.youtube.com/watch?"
"v=fNk_zzaMoSs&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab"

msgid "Translation status"
msgstr "Übersetzungsstatus"
