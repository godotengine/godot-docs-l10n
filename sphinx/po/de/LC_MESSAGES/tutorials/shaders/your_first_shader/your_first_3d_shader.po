# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#, fuzzy
msgid "Your first 3D shader"
msgstr "Ein erstes Shader-Spiel"

#, fuzzy
msgid ""
"You have decided to start writing your own custom Spatial shader. Maybe you "
"saw a cool trick online that was done with shaders, or you have found that "
"the :ref:`SpatialMaterial <class_SpatialMaterial>` isn't quite meeting your "
"needs. Either way, you have decided to write your own and now you need to "
"figure out where to start."
msgstr ""
"Sie haben beschlossen, Ihren eigenen Spatial-Shader zu schreiben. Vielleicht "
"haben Sie online einen coolen Trick gesehen, der mit Shadern gemacht wurde, "
"oder Sie haben festgestellt, dass das :ref:`SpatialMaterial "
"<class_SpatialMaterial>` Ihren Anforderungen nicht ganz entspricht. In jedem "
"Fall haben Sie beschlossen, Ihre eigenen zu schreiben, und jetzt müssen Sie "
"herausfinden, wo Sie anfangen sollen."

msgid ""
"This tutorial will explain how to write a Spatial shader and will cover more "
"topics than the :ref:`CanvasItem <doc_your_first_canvasitem_shader>` "
"tutorial."
msgstr ""
"Diese Anleitung erklärt wie Spatial-Shader erstellt werden und gehen mehr "
"ins Detail als :ref:`CanvasItem <doc_your_first_canvasitem_shader>`."

msgid ""
"Spatial shaders have more built-in functionality than CanvasItem shaders. "
"The expectation with spatial shaders is that Godot has already provided the "
"functionality for common use cases and all the user needs to do in the "
"shader is set the proper parameters. This is especially true for a PBR "
"(physically based rendering) workflow."
msgstr ""
"Spatial-Shader verfügen über mehr integrierte Funktionen als CanvasItem-"
"Shader. Bei räumlichen Shadern wird erwartet, dass Godot bereits die "
"Funktionalität für allgemeine Anwendungsfälle besitzt und der Benutzer im "
"Shader lediglich die richtigen Parameter festlegen muss. Dies gilt "
"insbesondere für einen PBR-Ablauf (Physical Based Rendering)."

msgid ""
"This is a two-part tutorial. In this first part we are going to go through "
"how to make a simple terrain using vertex displacement from a heightmap in "
"the vertex function. In the :ref:`second part "
"<doc_your_second_spatial_shader>` we are going to take the concepts from "
"this tutorial and walk through how to set up custom materials in a fragment "
"shader by writing an ocean water shader."
msgstr ""

msgid ""
"This tutorial assumes some basic shader knowledge such as types (``vec2``, "
"``float``, ``sampler2D``), and functions. If you are uncomfortable with "
"these concepts it is best to get a gentle introduction from `The Book of "
"Shaders <https://thebookofshaders.com>`_ before completing this tutorial."
msgstr ""

msgid "Where to assign my material"
msgstr "Wo kann man Material zuweisen"

msgid ""
"In 3D, objects are drawn using :ref:`Meshes <class_Mesh>`. Meshes are a "
"resource type that store geometry (the shape of your object) and materials "
"(the color and how the object reacts to light) in units called \"surfaces\". "
"A Mesh can have multiple surfaces, or just one. Typically, you would import "
"a mesh from another program (e.g. Blender). But Godot also has a few :ref:"
"`PrimitiveMeshes <class_primitivemesh>` that allow you to add basic geometry "
"to a scene without importing Meshes."
msgstr ""

msgid ""
"There are multiple node types that you can use to draw a mesh. The main one "
"is :ref:`MeshInstance <class_meshinstance>`, but you can also use :ref:"
"`Particles <class_particles>`, :ref:`MultiMeshes <class_MultiMesh>` (with a :"
"ref:`MultiMeshInstance <class_multimeshinstance>`), or others."
msgstr ""

msgid ""
"Typically, a material is associated with a given surface in a mesh, but some "
"nodes, like MeshInstance, allow you to override the material for a specific "
"surface, or for all surfaces."
msgstr ""

msgid ""
"If you set a material on the surface or mesh itself, then all MeshInstances "
"that share that mesh will share that material. However, if you want to reuse "
"the same mesh across multiple mesh instances, but have different materials "
"for each instance then you should set the material on the Meshinstance."
msgstr ""

msgid ""
"For this tutorial we will set our material on the mesh itself rather than "
"taking advantage of the MeshInstance's ability to override materials."
msgstr ""

msgid "Setting up"
msgstr "Einrichtung"

msgid "Add a new :ref:`MeshInstance <class_meshinstance>` node to your scene."
msgstr ""
"Fügen Sie einen neuen Node :ref:`MeshInstance <class_meshinstance>` zu Ihrer "
"Szene hinzu."

msgid ""
"In the inspector tab beside \"Mesh\" click \"[empty]\" and select \"New "
"PlaneMesh\". Then click on the image of a plane that appears."
msgstr ""

msgid "This adds a :ref:`PlaneMesh <class_planemesh>` to our scene."
msgstr ""
"Dies fügt ein :ref:`PlaneMesh <class_planemesh>` zu unserer Szene hinzu."

msgid ""
"Then, in the viewport, click in the upper left corner on the button that "
"says \"Perspective\". A menu will appear. In the middle of the menu are "
"options for how to display the scene. Select 'Display Wireframe'."
msgstr ""

msgid "This will allow you to see the triangles making up the plane."
msgstr ""
"Auf diese Weise können Sie die Dreiecke sehen, aus denen die Ebene entstellt "
"ist."

msgid "Now set ``Subdivide Width`` and ``Subdivide Depth`` to ``32``."
msgstr "Setzen Sie nun ``Subdivide Width`` und ``Subdivide Depth`` auf ``32``."

msgid ""
"You can see that there are now many more triangles in the :ref:"
"`Mesh<class_MeshInstance>`. This will give us more vertices to work with and "
"thus allow us to add more detail."
msgstr ""

msgid ""
":ref:`PrimitiveMeshes <class_primitivemesh>`, like PlaneMesh, only have one"
msgstr ""

msgid ""
"surface, so instead of an array of materials there is only one. Click beside "
"\"Material\" where it says \"[empty]\" and select \"New ShaderMaterial\". "
"Then click the sphere that appears."
msgstr ""

msgid ""
"Now click beside \"Shader\" where it says \"[empty]\" and select \"New "
"Shader\"."
msgstr ""
"Klicken Sie nun neben \"Shader\" auf \"[leer]\" und wählen Sie \"Neuer "
"Shader\"."

msgid ""
"The shader editor should now pop up and you are ready to begin writing your "
"first Spatial shader!"
msgstr ""
"Der Shader Editor sollte nun erscheinen und alles ist bereit um Ihren ersten "
"Spatial-Shader zu schreiben!"

msgid "Shader magic"
msgstr "Shader Magie"

msgid ""
"Notice how there is already error? This is because the shader editor reloads "
"shaders on the fly. The first thing Godot shaders need is a declaration of "
"what type of shader they are. We set the variable ``shader_type`` to "
"``spatial`` because this is a spatial shader."
msgstr ""
"Beachten Sie, wie es bereits Fehler gibt? Dies liegt daran, dass der Shader-"
"Editor die Shader im laufenden Betrieb neu lädt. Das erste, was Godot-Shader "
"brauchen, ist eine Erklärung, welche Art von Shader sie sind. Wir setzen die "
"Variable ``shader_type`` auf ``spatial``, da dies ein räumlicher Shader ist."

msgid ""
"Next we will define the ``vertex()`` function. The ``vertex()`` function "
"determines where the vertices of your :ref:`Mesh<class_MeshInstance>` appear "
"in the final scene. We will be using it to offset the height of each vertex "
"and make our flat plane appear like a little terrain."
msgstr ""

msgid "We define the vertex shader like so:"
msgstr "So definieren wir den Vertex-Shader:"

msgid ""
"With nothing in the ``vertex()`` function, Godot will use its default vertex "
"shader. We can easily start to make changes by adding a single line:"
msgstr ""

msgid "Adding this line, you should get an image like the one below."
msgstr ""
"Wenn Sie diese Zeile hinzufügen, sollten Sie ein Bild wie das folgende "
"erhalten."

msgid ""
"Okay, let's unpack this. The ``y`` value of the ``VERTEX`` is being "
"increased. And we are passing the ``x`` and ``z`` components of the "
"``VERTEX`` as arguments to ``cos`` and ``sin``; that gives us a wave-like "
"appearance across the ``x`` and ``z`` axes."
msgstr ""

msgid ""
"What we want to achieve is the look of little hills; after all. ``cos`` and "
"``sin`` already look kind of like hills. We do so by scaling the inputs to "
"the ``cos`` and ``sin`` functions."
msgstr ""

msgid ""
"This looks better, but it is still too spiky and repetitive, let's make it a "
"little more interesting."
msgstr ""

msgid "Noise heightmap"
msgstr "Rauschen Höhenkarte"

msgid ""
"Noise is a very popular tool for faking the look of terrain. Think of it as "
"similar to the cosine function where you have repeating hills except, with "
"noise, each hill has a different height."
msgstr ""

msgid ""
"Godot provides the :ref:`NoiseTexture <class_noisetexture>` resource for "
"generating a noise texture that can be accessed from a shader."
msgstr ""

msgid ""
"To access a texture in a shader add the following code near the top of your "
"shader, outside the ``vertex()`` function."
msgstr ""

msgid ""
"This will allow you to send a noise texture to the shader. Now look in the "
"inspector under your material. You should see a section called \"Shader "
"Params\". If you open it up, you'll see a section called \"noise\"."
msgstr ""

msgid ""
"Click beside it where it says \"[empty]\" and select \"New NoiseTexture\". "
"Then in your NoiseTexture click beside where it says \"Noise\" and select "
"\"New OpenSimplexNoise\"."
msgstr ""

msgid ""
":ref:`OpenSimplexNoise <class_opensimplexnoise>` is used by the NoiseTexture "
"to"
msgstr ""
":ref:`OpenSimplexNoise <class_opensimplexnoise>` wird von der NoiseTexture "
"verwendet, um"

msgid "generate a heightmap."
msgstr "eine Höhenkarte erzeugen."

msgid "Once you set it up and should look like this."
msgstr "Sobald Sie es eingerichtet haben und so aussehen sollten."

msgid ""
"Now, access the noise texture using the ``texture()`` function. "
"``texture()`` takes a texture as the first argument and a ``vec2`` for the "
"position on the texture as the second argument. We use the ``x`` and ``z`` "
"channels of ``VERTEX`` to determine where on the texture to look up. Note "
"that the PlaneMesh coordinates are within the [-1,1] range (for a size of "
"2), while the texture coordinates are within [0,1], so to normalize we "
"divide by the size of the PlaneMesh 2.0 and add 0.5. ``texture()`` returns a "
"``vec4`` of the ``r, g, b, a`` channels at the position. Since the noise "
"texture is grayscale, all of the values are the same, so we can use any one "
"of the channels as the height. In this case we'll use the ``r``, or ``x`` "
"channel."
msgstr ""

msgid ""
"Note: ``xyzw`` is the same as ``rgba`` in GLSL, so instead of ``texture()."
"x`` above, we could use ``texture().r``. See the `OpenGL documentation "
"<https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Vectors>`_ for more "
"details."
msgstr ""

msgid "Using this code you can see the texture creates random looking hills."
msgstr ""
"Mit diesem Code können Sie sehen, wie die Textur zufällig aussehende Hügel "
"erzeugt."

msgid ""
"Right now it is too spiky, we want to soften the hills a bit. To do that, we "
"will use a uniform. You already used a uniform above to pass in the noise "
"texture, now let's learn how they work."
msgstr ""

msgid "Uniforms"
msgstr "Uniforms"

msgid ""
"Uniform variables allow you to pass data from the game into the shader. They "
"are very useful for controlling shader effects. Uniforms can be almost any "
"datatype that can be used in the shader. To use a uniform, you declare it in "
"your :ref:`Shader<class_Shader>` using the keyword ``uniform``."
msgstr ""

msgid "Let's make a uniform that changes the height of the terrain."
msgstr "Lasst uns ein Uniform herstellen, das die Höhe des Geländes verändert."

msgid ""
"Godot lets you initialize a uniform with a value; here, ``height_scale`` is "
"set to ``0.5``. You can set uniforms from GDScript by calling the function "
"``set_shader_param()`` on the material corresponding to the shader. The "
"value passed from GDScript takes precedence over the value used to "
"initialize it in the shader."
msgstr ""

msgid ""
"Changing uniforms in Spatial-based nodes is different from CanvasItem-based "
"nodes. Here, we set the material inside the PlaneMesh resource. In other "
"mesh resources you may need to first access the material by calling "
"``surface_get_material()``. While in the MeshInstance you would access the "
"material using ``get_surface_material()`` or ``material_override``."
msgstr ""

msgid ""
"Remember that the string passed into ``set_shader_param()`` must match the "
"name of the uniform variable in the :ref:`Shader<class_Shader>`. You can use "
"the uniform variable anywhere inside your :ref:`Shader<class_Shader>`. Here, "
"we will use it to set the height value instead of arbitrarily multiplying by "
"``0.5``."
msgstr ""

msgid "Now it looks  much better."
msgstr "Nun sieht es viel besser aus."

msgid ""
"Using uniforms, we can even change the value every frame to animate the "
"height of the terrain. Combined with :ref:`Tweens <class_Tween>`, this can "
"be especially useful for simple animations."
msgstr ""

msgid "Interacting with light"
msgstr "Mit Licht interagieren"

msgid ""
"First, turn wireframe off. To do so, click in the upper-left of the Viewport "
"again, where it says \"Perspective\", and select \"Display Normal\"."
msgstr ""

msgid ""
"Note how the mesh color goes flat. This is because the lighting on it is "
"flat. Let's add a light!"
msgstr ""

msgid "First, we will add an :ref:`OmniLight<class_OmniLight>` to the scene."
msgstr ""
"Zuerst werden wir der Szene ein :ref:`OmniLight<class_OmniLight>` hinzufügen."

msgid ""
"You can see the light affecting the terrain, but it looks odd. The problem "
"is the light is affecting the terrain as if it were a flat plane. This is "
"because the light shader uses the normals from the :ref:`Mesh <class_mesh>` "
"to calculate light."
msgstr ""

msgid ""
"The normals are stored in the Mesh, but we are changing the shape of the "
"Mesh in the shader, so the normals are no longer correct. To fix this, we "
"can recalculate the normals in the shader or use a normal texture that "
"corresponds to our noise. Godot makes both easy for us."
msgstr ""

msgid ""
"You can calculate the new normal manually in the vertex function and then "
"just set ``NORMAL``. With ``NORMAL`` set, Godot will do all the difficult "
"lighting calculations for us. We will cover this method in the next part of "
"this tutorial, for now we will read normals from a texture."
msgstr ""

msgid ""
"Instead we will rely on the NoiseTexture again to calculate normals for us. "
"We do that by passing in a second noise texture."
msgstr ""

msgid ""
"Set this second uniform texture to another NoiseTexture with another "
"OpenSimplexNoise. But this time, check off \"As Normalmap\"."
msgstr ""

msgid ""
"Now, because this is a normalmap and not a per-vertex normal, we are going "
"to assign it in the ``fragment()`` function. The ``fragment()`` function "
"will be explained in more detail in the next part of this tutorial."
msgstr ""

msgid ""
"When we have normals that correspond to a specific vertex we set ``NORMAL``, "
"but if you have a normalmap that comes from a texture, set the normal using "
"``NORMALMAP``. This way Godot will handle the wrapping the texture around "
"the mesh automatically."
msgstr ""

msgid ""
"Lastly, in order to ensure that we are reading from the same places on the "
"noise texture and the normalmap texture, we are going to pass the ``VERTEX."
"xz`` position from the ``vertex()`` function to the ``fragment()`` function. "
"We do that with varyings."
msgstr ""

msgid ""
"Above the ``vertex()`` define a ``vec2`` called ``tex_position``. And inside "
"the ``vertex()`` function assign ``VERTEX.xz`` to ``tex_position``."
msgstr ""

msgid ""
"And now we can access ``tex_position`` from the ``fragment()`` function."
msgstr ""
"Und jetzt können wir auf ``tex_position`` von der ``fragment()`` Funktion "
"aus zugreifen."

msgid ""
"With the normals in place the light now reacts to the height of the mesh "
"dynamically."
msgstr ""

msgid ""
"We can even drag the light around and the lighting will update automatically."
msgstr ""
"Wir können das Licht sogar herumziehen und die Beleuchtung wird automatisch "
"aktualisiert."

msgid ""
"Here is the full code for this tutorial. You can see it is not very long as "
"Godot handles most of the difficult stuff for you."
msgstr ""

msgid ""
"That is everything for this part. Hopefully, you now understand the basics "
"of vertex shaders in Godot. In the next part of this tutorial we will write "
"a fragment function to accompany this vertex function and we will cover a "
"more advanced technique to turn this terrain into an ocean of moving waves."
msgstr ""

msgid "Translation status"
msgstr "Übersetzungsstatus"
