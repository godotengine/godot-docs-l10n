# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Designing the mob scene"
msgstr "Gestaltung der Mob-Szene"

msgid ""
"In this part, you're going to code the monsters, which we'll call mobs. In "
"the next lesson, we'll spawn them randomly around the playable area."
msgstr ""
"In diesem Teil werden Sie die Monster programmieren, welche wir Mobs nennen "
"werden. In der nächsten Lektion werden wir sie zufällig im Spielbereich "
"spawnen."

msgid ""
"Let's design the monsters themselves in a new scene. The node structure is "
"going to be similar to the *Player* scene."
msgstr ""
"Lassen Sie uns die Monster in einer neuen Szene entwerfen. Die Node Struktur "
"wird ähnlich wie die der *Player*-Szene."

msgid ""
"Create a scene with, once again, a *KinematicBody* node as its root. Name it "
"*Mob*. Add a *Spatial* node as a child of it, name it *Pivot*. And drag and "
"drop the file ``mob.glb`` from the *FileSystem* dock onto the *Pivot* to add "
"the monster's 3D model to the scene. You can rename the newly created *mob* "
"node into *Character*."
msgstr ""
"Erstellen Sie eine weitere neue Szene mit einer *KinematicBody* Node als "
"Wurzel. Benennen Sie ihn zu *Mob* um. Fügen sie ein *Spatial* Node als "
"Unternode hinzu und nennen Sie es *Pivot*. Ziehen Sie die Datei ``mob.glb`` "
"von dem *Dateisystem*-Panel auf den *Pivot* um das 3D-Modell des Monsters "
"der Szene hinzuzufügen. Sie können das neu erstellte Node *mob* in "
"*Character* umbenennen."

msgid "|image0|"
msgstr "|image0|"

msgid "image0"
msgstr "image0"

msgid ""
"We need a collision shape for our body to work. Right-click on the *Mob* "
"node, the scene's root, and click *Add Child Node*."
msgstr ""
"Wir brauchen eine Kollisionsform damit unser Körper funktioniert. Klicken "
"Sie mit der rechten Maustaste auf das *Mob* Node, die Wurzel der Szene, und "
"klicken sie auf *Node hier Anhängen*."

msgid "|image1|"
msgstr "|image1|"

msgid "image1"
msgstr "image1"

msgid "Add a *CollisionShape*."
msgstr "Füge eine *CollisionShape* hinzu."

msgid "|image2|"
msgstr "|image2|"

msgid "image2"
msgstr "image2"

msgid "In the *Inspector*, assign a *BoxShape* to the *Shape* property."
msgstr "Weisen Sie im *Inspektor* der *Shape* Eigenschaft eine *BoxShape* zu."

msgid "|image3|"
msgstr "|image3|"

msgid "image3"
msgstr "image3"

msgid ""
"We should change its size to fit the 3D model better. You can do so "
"interactively by clicking and dragging on the orange dots."
msgstr ""
"Wir sollten die Größe ändern damit die Form besser an das 3D-Modell passt. "
"Sie können dies interaktiv tun, indem sie auf die orangen Punkte klicken und "
"ziehen."

msgid ""
"The box should touch the floor and be a little thinner than the model. "
"Physics engines work in such a way that if the player's sphere touches even "
"the box's corner, a collision will occur. If the box is a little too big "
"compared to the 3D model, you may die at a distance from the monster, and "
"the game will feel unfair to the players."
msgstr ""
"Die Box sollte den Boden berühren und ein wenig dünner als das Modell sein. "
"Physik-Engines arbeiten so, dass eine Kollision stattfindet, wenn die Kugel "
"des Spielers auch nur eine Ecke des Kastens berührt. Wenn die Kiste im "
"vergleich zum 3D-Modell nur ein wenig zu groß ist, könnte man trotz "
"sichtbarer entfernung von einem Monster sterben, was das Spiel auf die "
"Spieler unfair wirken lässt."

msgid "|image4|"
msgstr "|image4|"

msgid "image4"
msgstr "image4"

msgid ""
"Notice that my box is taller than the monster. It is okay in this game "
"because we're looking at the scene from above and using a fixed perspective. "
"Collision shapes don't have to match the model exactly. It's the way the "
"game feels when you test it that should dictate their form and size."
msgstr ""
"Beachten Sie dass meine Box höher ist als das Monster. Das ist in diesem "
"Spiel in Ordnung, weil wir von oben auf die Szene herabschauen und eine "
"feste Perspektive verwenden. Die Kollisionsformen müssen nicht genau mit dem "
"Modell übereinstimmen. Ihre Form und Größe sollten davon abhängig sein wie "
"sie sich beim testen des Spiels anfühlen."

msgid "Removing monsters off-screen"
msgstr "Monster außerhalb des Bildschirms entfernen"

msgid ""
"We're going to spawn monsters at regular time intervals in the game level. "
"If we're not careful, their count could increase to infinity, and we don't "
"want that. Each mob instance has both a memory and a processing cost, and we "
"don't want to pay for it when the mob's outside the screen."
msgstr ""
"Wir werden in regelmäßigen abständen Monster in dem Level erscheinen lassen. "
"Wenn wir dabei nicht aufpassen, könnte ihre anzahl ins Unendliche steigen "
"und das wollen wir nicht. Jede Mob-Instanz hat sowohl Speicher als auch "
"Verarbeitungs Kosten und wir wollen nicht für sie zahlen wenn der Gegner "
"außerhalb des Buildschirmbereichs ist."

msgid ""
"Once a monster leaves the screen, we don't need it anymore, so we can delete "
"it. Godot has a node that detects when objects leave the screen, "
"*VisibilityNotifier*, and we're going to use it to destroy our mobs."
msgstr ""
"Sobald ein Monster den Bildschirmbereich verlässt, brauchen wir es nicht "
"mehr, also können wir es einfach löschen. Godot hat ein Node das erkennt "
"wenn ein Objekt den Bildschirmbereich verlässt, namens *VisibilityNotifier* "
"und wir werden es dafür benutzen um unsere Mobs zu zerstören."

msgid ""
"When you keep instancing an object in games, there's a technique you can use "
"to avoid the cost of creating and destroying instances all the time called "
"pooling. It consists of pre-creating an array of objects and reusing them "
"over and over."
msgstr ""
"Wenn Sie ein bestimmtes Objekt in einem Spiel immer wieder instanzieren, "
"gibt es eine Technik mit der wir die Kosten für das ständige Erstellen und "
"Zerstören von Instanzen vermeiden können, die sich Pooling nennt. Sie "
"besteht darin ein Array an Objekten vorab zu erstellen und diese dann immer "
"wieder zu verwenden."

msgid ""
"When working with GDScript, you don't need to worry about this. The main "
"reason to use pools is to avoid freezes with garbage-collected languages "
"like C# or Lua. GDScript uses a different technique to manage memory, "
"reference counting, which doesn't have that caveat. You can learn more about "
"that here :ref:`doc_gdscript_basics_memory_management`."
msgstr ""
"Wenn Sie mit GDScript arbeiten, müssen Sie sich darüber keine Gedanken "
"machen. Der Hauptgrund für die verwendung von pools ist Standbilder bei "
"Sprachen die Freispeichersammlung verwenden wie C# oder Lua zu vermeiden. "
"GDScript nutzt eine andere Technik um den Speicher zu verwalten, nämlich das "
"Referenzzählen, bei dem es diese Einschränkung nicht gibt. Sie können hier "
"mehr darüber erfahren :ref:`doc_gdscript_basics_memory_management`."

msgid ""
"Select the *Mob* node and add a *VisibilityNotifier* as a child of it. "
"Another box, pink this time, appears. When this box completely leaves the "
"screen, the node will emit a signal."
msgstr ""
"Wählen sie das *Mob* Node aus und fügen sie einen *VisibilityNotifier* als "
"Unternode hinzu. Eine weitere box, diesmal in pink, erscheint. Wenn diese "
"Box den Bildschirmbereich komplett verlässt, wird das Node ein Signal senden."

msgid "|image5|"
msgstr "|image5|"

msgid "image5"
msgstr "image5"

msgid "Resize it using the orange dots until it covers the entire 3D model."
msgstr ""
"Ändern Sie die Größe der Box mithilfe der orangen Punkte, bis sie das "
"gesamte 3D-Modell abdeckt."

msgid "|image6|"
msgstr "|image6|"

msgid "image6"
msgstr "|image6|"

msgid "Coding the mob's movement"
msgstr "Die Bewegung des Gegners coden"

msgid ""
"Let's implement the monster's motion. We're going to do this in two steps. "
"First, we'll write a script on the *Mob* that defines a function to "
"initialize the monster. We'll then code the randomized spawn mechanism in "
"the *Main* scene and call the function from there."
msgstr ""
"Lassen Sie uns nun die Bewegung der Monster implementieren. Wir werden dies "
"in zwei Schritten tun. Als erstes, werden wir ein Skript für den *Mob* "
"schreiben, das eine Funktion zum Initialisieren des Monsters beinhaltet. "
"Dann werden wir einen zufälligen Spawn-Mechanismus in der Szene *Main* "
"erstellen und diese Funktion von dort aufrufen."

msgid "Attach a script to the *Mob*."
msgstr "Hängen Sie ein Skript an den *Mob* an."

msgid "|image7|"
msgstr "|image7|"

msgid "image7"
msgstr "|image7|"

msgid ""
"Here's the movement code to start with. We define two properties, "
"``min_speed`` and ``max_speed``, to define a random speed range. We then "
"define and initialize the ``velocity``."
msgstr ""
"Hier ist zu aller erst der Bewegungs Code. Wir definieren zwei "
"Eigenschaften, ``min_speed`` und ``max_speed``, um eine zufällige "
"Geschwindigkeitsspanne zu definieren. Dann definieren und initialisieren wir "
"die ``velocity``."

msgid ""
"Similarly to the player, we move the mob every frame by calling "
"``KinematicBody``\\ 's ``move_and_slide()`` method. This time, we don't "
"update the ``velocity`` every frame: we want the monster to move at a "
"constant speed and leave the screen, even if it were to hit an obstacle."
msgstr ""
"Ähnlich wie bei dem Spieler, bewegen wir den Mob jeden Frame indem wir die "
"Methode des ``KinematicBody``\\s ``move_and_slide()`` aufrufen. Dieses mal "
"aktualisieren wir die ``velocity`` aber nicht jeden Frame: wir wollen dass "
"das Monster sich mit einer konstanten Geschwindigkeit bewegt und den "
"Bildschirm verlässt, selbst wenn es auf ein Hindernis trifft."

msgid ""
"You may see a warning in GDScript that the return value from "
"``move_and_slide()`` is unused. This is expected. You can simply ignore the "
"warning or, if you want to hide it entirely, add the comment ``# warning-"
"ignore:return_value_discarded`` just above the ``move_and_slide(velocity)`` "
"line. To read more about the GDScript warning system, see :ref:"
"`doc_gdscript_warning_system`."
msgstr ""
"Möglicherweise wird in GDScript eine Warnung angezeigt, dass der "
"Rückgabewert von ``move_and_slide()`` unbenutzt ist. Dies ist zu erwarten. "
"Sie können die Warnung einfach ignorieren, oder wenn Sie sie ganz ausblenden "
"wollen, können Sie den Kommentar ``#warning-ignore:return_value_discarded`` "
"direkt über der Zeile ``move_and_slide(velocity)`` einfügen. Um mehr über "
"das GDScript-Warnsystem zu erfahren, siehe :ref:"
"`doc_gdscript_warning_system`."

msgid ""
"We need to define another function to calculate the start velocity. This "
"function will turn the monster towards the player and randomize both its "
"angle of motion and its velocity."
msgstr ""
"Wir sollten eine weitere Funktion definieren um die Startgeschwindigkeit zu "
"berechnen. Diese Funktion wird das Monster in die Richtung des Spielers "
"drehen und sowohl den Bewegunswinkel als auch die Geschwindigkeit auf einen "
"zufälligen Wert setzen."

msgid ""
"The function will take a ``start_position``, the mob's spawn position, and "
"the ``player_position`` as its arguments."
msgstr ""
"Die Funktion nimmt eine ``start_position``, also die Spawn-Position des Mobs "
"und die ``player_position`` als Argumente."

msgid ""
"We position the mob at ``start_position`` and turn it towards the player "
"using the ``look_at_from_position()`` method, and randomize the angle by "
"rotating a random amount around the Y axis. Below, ``rand_range()`` outputs "
"a random value between ``-PI / 4`` radians and ``PI / 4`` radians."
msgstr ""
"Wir positionieren den Mob auf ``start_position`` und drehen ihn mit der "
"Methode ``look_at_from_position()`` in die Richtung des Spielers, wobei wir "
"ihn zusätzlich um einen zufälligen Betrag um die Y-Achse drehen. In dem "
"unteren Code Abschnitt, wird ``rand_range()`` verwendet um einen zufälligen "
"Wert zwischen ``-PI / 4`` Radiant und ``PI / 4`` Radiant zu erhalten."

msgid ""
"We then calculate a random speed using ``rand_range()`` once again and we "
"use it to calculate the velocity."
msgstr ""
"Wir berechnen dann eine zufällige Geschwindigkeit mit einer weiteren "
"Verwendung von ``rand_range()`` und benutzen sie anschließend um den "
"Bewegungs-Vektor zu berechnen."

msgid ""
"We start by creating a 3D vector pointing forward, multiply it by our "
"``random_speed``, and finally rotate it using the ``Vector3`` class's "
"``rotated()`` method."
msgstr ""
"Wir beginnen mit der Erstellung eines 3D-Vektors, der nach vorne zeigt, "
"multiplizieren ihn mit unserem ``random_speed`` und drehen ihn schließlich "
"mit der Methode ``rotated()`` aus der Klasse ``Vector3``."

msgid "Leaving the screen"
msgstr "Verlassen des Bildschirms"

msgid ""
"We still have to destroy the mobs when they leave the screen. To do so, "
"we'll connect our *VisibilityNotifier* node's ``screen_exited`` signal to "
"the *Mob*."
msgstr ""
"Wir müssen noch die Mobs zerstören wenn sie den Bildschirmbereich verlassen. "
"Um dies zu tun, verbinden wir das ``screen_exited`` Signal unserer "
"*VisibilityNotifier* Node mit dem *Mob*."

msgid ""
"Head back to the 3D viewport by clicking on the *3D* label at the top of the "
"editor. You can also press :kbd:`Ctrl + F2` (:kbd:`Alt + 2` on macOS)."
msgstr ""
"Kehren Sie zum 3D-Ansichtsfenster zurück, indem sie auf die Beschriftung "
"*3D* am oberen Rand des Editors klicken. Sie können auch :kbd:`Ctrl + F2`(:"
"kbd:`Alt + 2` auf macOS) drücken."

msgid "|image8|"
msgstr "|image8|"

msgid "image8"
msgstr "|image8|"

msgid ""
"Select the *VisibilityNotifier* node and on the right side of the interface, "
"navigate to the *Node* dock. Double-click the *screen_exited()* signal."
msgstr ""
"Wählen Sie das *VisibilityNotifier* Node aus und navigieren sie auf der "
"rechten Seite des Interface zu dem *Node* Panel. Doppelklicken Sie auf das "
"Signal *screen_exited()*."

msgid "|image9|"
msgstr "|image9|"

msgid "image9"
msgstr "|image9|"

msgid "Connect the signal to the *Mob*."
msgstr "Verbinden Sie das Signal mit dem *Gegner*."

msgid "|image10|"
msgstr "|image10|"

msgid "image10"
msgstr "|image10|"

msgid ""
"This will take you back to the script editor and add a new function for you, "
"``_on_VisibilityNotifier_screen_exited()``. From it, call the "
"``queue_free()`` method. This will destroy the mob instance when the "
"*VisibilityNotifier* \\'s box leaves the screen."
msgstr ""
"Dies wird Sie zurück zu dem Script-Editor bringen und für Sie eine neue "
"Funktion hinzufügen: ``_on_VisibilityNotifier_screen_exited()``. Rufen sie "
"von dort die Methode ``queue_free()`` auf. Dies wird die Mob-Instanz "
"zerstören sobald die Box des *VisibilityNotifier* den Bildschirmbereich "
"verlässt."

msgid ""
"Our monster is ready to enter the game! In the next part, you will spawn "
"monsters in the game level."
msgstr ""
"Unser Monster ist endlich bereit das Spiel zu betreten! I'm nächsten Teil "
"werden Sie Monster im Spiellevel spawnen."

msgid "Here is the complete ``Mob.gd`` script for reference."
msgstr "Hier ist das vollständige ``Mob.gd`` Skript als Referenz."

msgid "Translation status"
msgstr "Übersetzungsstatus"
