# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Heads up display"
msgstr "Anzeigesystem"

msgid ""
"The final piece our game needs is a User Interface (UI) to display things "
"like score, a \"game over\" message, and a restart button."
msgstr ""
"Das Letzte, was unser Spiel noch benötigt, ist eine Benutzeroberfläche (UI) "
"um Dinge anzeigen wie die Punktzahl, ein \"Spiel Vorbei\" Text und einen "
"Neustart Knopf."

msgid ""
"Create a new scene, and add a :ref:`CanvasLayer <class_CanvasLayer>` node "
"named ``HUD``. \"HUD\" stands for \"heads-up display\", an informational "
"display that appears as an overlay on top of the game view."
msgstr ""
"Erstellen Sie eine neue Szene und fügen Sie ein :ref:`CanvasLayer "
"<class_CanvasLayer>`-Node mit dem Namen ``HUD`` hinzu. \"HUD\" steht für "
"\"heads-up display\", eine Informationsanzeige, die als Overlay über der "
"Spielansicht erscheint."

msgid ""
"The :ref:`CanvasLayer <class_CanvasLayer>` node lets us draw our UI elements "
"on a layer above the rest of the game, so that the information it displays "
"isn't covered up by any game elements like the player or mobs."
msgstr ""
"Mit dem Node :ref:`CanvasLayer <class_CanvasLayer>` können wir unsere "
"Oberflächenelemente auf einer Ebene über dem Rest des Spiels zeichnen, so "
"dass die angezeigten Informationen nicht durch irgendwelche Spielelemente "
"wie den Spieler oder Gegner verdeckt werden."

msgid "The HUD needs to display the following information:"
msgstr "Das HUD sollte die folgenden Informationen anzeigen:"

msgid "Score, changed by ``ScoreTimer``."
msgstr "Punktzahl, geändert durch ``ScoreTimer``."

msgid "A message, such as \"Game Over\" or \"Get Ready!\""
msgstr "Eine Nachricht, wie z.B. \"Game Over\" oder \"Get Ready!\""

msgid "A \"Start\" button to begin the game."
msgstr "Eine \"Start\"-Taste, um das Spiel zu starten."

msgid ""
"The basic node for UI elements is :ref:`Control <class_Control>`. To create "
"our UI, we'll use two types of :ref:`Control <class_Control>` nodes: :ref:"
"`Label <class_Label>` and :ref:`Button <class_Button>`."
msgstr ""
"Der Basis-Node für UI-Elemente ist :ref:`Control <class_Control>`. Um unsere "
"Benutzeroberfläche zu erstellen, verwenden wir zwei Arten vom :ref:`Control "
"<class_Control>` Node: :ref:`Label <class_Label>` und :ref:`Button "
"<class_Button>`."

msgid "Create the following as children of the ``HUD`` node:"
msgstr "Erstelle das Folgende als Unterobjekte des ``HUD``-Nodes:"

msgid ":ref:`Label <class_Label>` named ``ScoreLabel``."
msgstr ":ref:`Label <class_Label>` genannt ``ScoreLabel``."

msgid ":ref:`Label <class_Label>` named ``Message``."
msgstr ":ref:`Label <class_Label>` genannt ``Message``."

msgid ":ref:`Button <class_Button>` named ``StartButton``."
msgstr ":ref:`Button <class_Button>` genannt ``StartButton``."

msgid ":ref:`Timer <class_Timer>` named ``MessageTimer``."
msgstr ":ref:`Timer <class_Timer>` genannt ``MessageTimer``."

msgid ""
"Click on the ``ScoreLabel`` and type a number into the ``Text`` field in the "
"Inspector. The default font for ``Control`` nodes is small and doesn't scale "
"well. There is a font file included in the game assets called \"Xolonium-"
"Regular.ttf\". To use this font, do the following:"
msgstr ""
"Klicken Sie auf das ``ScoreLabel`` und geben eine Zahl in das ``Text``-Feld "
"im Inspektor ein. Die Standardschriftart für ``Control``-Nodes ist klein und "
"lässt sich nicht gut skalieren. In den Spielassets ist eine Schriftdatei "
"namens \"Xolonium-Regular.ttf\" enthalten. Um diese Schriftart zu verwenden, "
"gehen Sie für jeden der drei ``Control``-Nodes wie folgt vor:"

msgid ""
"Under **Theme overrides > Fonts** click on the empty box and select \"New "
"DynamicFont\""
msgstr ""
"Klicken Sie auf die leere Box unter **Theme overrides > Fonts** und wählen "
"sie \"New DynamicFont\""

msgid ""
"Click on the \"DynamicFont\" you added, and under **Font > FontData**, "
"choose \"Load\" and select the \"Xolonium-Regular.ttf\" file."
msgstr ""
"Klicken Sie auf die von Ihnen hinzugefügte \"DynamicFont\" und wählen unter "
"\"Font/Font Data\" erst den Menüeintrag \"Lade\" und dann die Datei "
"\"Xolonium-Regular.ttf\"."

msgid "Set the \"Size\" property under ``Settings``, ``64`` works well."
msgstr ""
"Lege die Eigenschaft \"Size\" unter ``Settings`` fest, ``64`` funktioniert "
"gut."

msgid ""
"Once you've done this on the ``ScoreLabel``, you can click the down arrow "
"next to the Font property and choose \"Copy\", then \"Paste\" it in the same "
"place on the other two Control nodes."
msgstr ""
"Sobald Sie dies auf ``ScoreLabel`` getan haben, können Sie auf den "
"Abwärtspfeil neben der Eigenschaft \"Schriftart\" klicken und \"Kopieren\" "
"wählen, dann \"Einfügen\" an der gleichen Stelle auf den beiden anderen "
"Kontrollnodes."

msgid ""
"**Anchors and Margins:** ``Control`` nodes have a position and size, but "
"they also have anchors and margins. Anchors define the origin - the "
"reference point for the edges of the node. Margins update automatically when "
"you move or resize a control node. They represent the distance from the "
"control node's edges to its anchor."
msgstr ""
"**Anker und Ränder:** ``Control`` Nodes haben eine Position und eine Größe, "
"aber sie haben auch Anker und Ränder. Anker definieren den Ursprung - den "
"Referenzpunkt für die Kanten des Nodes. Die Ränder werden automatisch "
"aktualisiert, wenn Sie ein Steuernode verschieben oder dessen Größe ändern. "
"Sie stellen den Abstand zwischen den Kanten des Steuernodes und dessen Anker "
"dar."

msgid ""
"Arrange the nodes as shown below. Click the \"Layout\" button to set a "
"Control node's layout:"
msgstr ""
"Ordnen Sie die Nodes wie unten gezeigt an. Klicken Sie auf den \"Layout\"-"
"Knopf, um das Layout eines Control-Nodes festzulegen:"

msgid ""
"You can drag the nodes to place them manually, or for more precise "
"placement, use the following settings:"
msgstr ""
"Sie können die Nodes manuell verschieben um sie zu platzieren oder verwenden "
"Sie die folgenden Einstellungen für eine genauere Platzierung:"

msgid "ScoreLabel"
msgstr "ScoreLabel (HighScore)"

msgid "*Layout* : \"Top Wide\""
msgstr "*Layout* : \"Oben groß\""

msgid "*Text* : ``0``"
msgstr "*Text* : ``0``"

msgid "*Align* : \"Center\""
msgstr "*Align* : \"Center\""

msgid "Message"
msgstr "Nachricht"

msgid "*Layout* : \"HCenter Wide\""
msgstr "*Layout* : \"HCenter groß\""

msgid "*Text* : ``Dodge the Creeps!``"
msgstr "*Text* : ``Dodge the Creeps!``"

msgid "*Autowrap* : \"On\""
msgstr "*Autowrap* : \"An\""

msgid "StartButton"
msgstr "StartButton (Startknopf)"

msgid "*Text* : ``Start``"
msgstr "*Text* : ``Start``"

msgid "*Layout* : \"Center Bottom\""
msgstr "*Layout* : \"Mitte unten\""

msgid "*Margin* :"
msgstr "*Margin* :"

msgid "Top: ``-200``"
msgstr "Top: ``-200``"

msgid "Bottom: ``-100``"
msgstr "Bottom: ``-100``"

msgid ""
"On the ``MessageTimer``, set the ``Wait Time`` to ``2`` and set the ``One "
"Shot`` property to \"On\"."
msgstr ""
"Stellen Sie im ``MessageTimer`` die ``Wait Time`` auf ``2`` und stellen Sie "
"die ``One Shot`` Eigenschaft auf \"An\"."

msgid "Now add this script to ``HUD``:"
msgstr "Fügen Sie nun dieses Skript zu ``HUD`` hinzu:"

msgid ""
"The ``start_game`` signal tells the ``Main`` node that the button has been "
"pressed."
msgstr ""
"Das Signal ``start_game`` signalisiert dem Node ``Main``, dass die Taste "
"gedrückt wurde."

msgid ""
"This function is called when we want to display a message temporarily, such "
"as \"Get Ready\"."
msgstr ""
"Diese Funktion wird aufgerufen, wenn wir eine Nachricht vorübergehend "
"anzeigen möchten, z.B. \"Get Ready\"."

msgid ""
"This function is called when the player loses. It will show \"Game Over\" "
"for 2 seconds, then return to the title screen and, after a brief pause, "
"show the \"Start\" button."
msgstr ""
"Diese Funktion wird aufgerufen, wenn der Spieler verliert. \"Game Over\" "
"wird für 2 Sekunden angezeigt und wechselt dann zum Titelbildschirm. Nach "
"einer kurzen Pause wird die \"Start\"-Schaltfläche angezeigt."

msgid ""
"When you need to pause for a brief time, an alternative to using a Timer "
"node is to use the SceneTree's ``create_timer()`` function. This can be very "
"useful to add delays such as in the above code, where we want to wait some "
"time before showing the \"Start\" button."
msgstr ""
"Falls eine kurze Pause benötigt wird, kann als Alternative zum Timer-Node "
"die Funktion ``create_timer()`` von SceneTree verwendet werden. Das kann "
"sehr nützlich sein, um eine Verzögerung hinzuzufügen. Wie im obigen Code, wo "
"wir ein wenig warten wollen, bevor der \"Start\"-Knopf angezeigt wird."

msgid "This function is called by ``Main`` whenever the score changes."
msgstr ""
"Diese Funktion wird von ``Main`` aufgerufen, wenn sich der Punktestand "
"ändert."

msgid ""
"Connect the ``timeout()`` signal of ``MessageTimer`` and the ``pressed()`` "
"signal of ``StartButton`` and add the following code to the new functions:"
msgstr ""
"Verbinden Sie jeweils das ``timeout()``-Signal von ``MessageTimer`` und das "
"``pressed()``-Signal von ``StartButton`` und fügen Sie den folgenden Code in "
"die neuen Funktionen ein:"

msgid "Connecting HUD to Main"
msgstr "Das HUD mit Main verbinden"

msgid ""
"Now that we're done creating the ``HUD`` scene, go back to ``Main``. "
"Instance the ``HUD`` scene in ``Main`` like you did the ``Player`` scene. "
"The scene tree should look like this, so make sure you didn't miss anything:"
msgstr ""
"Jetzt, da wir die ``HUD``-Szene erstellt haben, gehen Sie zurück zu ``Main`` "
"und platziere die ``HUD``-Szene in ``Main`` genauso wie die ``Player``-"
"Szene. Der gesamte Szenenbaum sollte so aussehen, also stellen Sie sicher, "
"dass nichts fehlt:"

msgid ""
"Now we need to connect the ``HUD`` functionality to our ``Main`` script. "
"This requires a few additions to the ``Main`` scene:"
msgstr ""
"Nun müssen wir die ``HUD``-Funktionalität mit unserem ``Main``-Skript "
"verbinden. Dies erfordert einige Ergänzungen in der ``Main``-Szene:"

msgid ""
"In the Node tab, connect the HUD's ``start_game`` signal to the "
"``new_game()`` function of the Main node by typing \"new_game\" in the "
"\"Receiver Method\" in the \"Connect a Signal\" window. Verify that the "
"green connection icon now appears next to ``func new_game()`` in the script."
msgstr ""
"Verbinden Sie auf der Registerkarte \"Node\" das Signal ``start_game`` des "
"HUD mit der Funktion ``new_game()`` des Main-Nodes, indem Sie \"new_game\" "
"in die \"Empfängermethode\" im Fenster \"Ein Signal mit einer Methode "
"verbinden\" eingeben. Stellen Sie sicher, dass das grüne Verbindungssymbol "
"jetzt neben ``func new_game()`` im Skript angezeigt wird."

msgid ""
"In ``new_game()``, update the score display and show the \"Get Ready\" "
"message:"
msgstr ""
"Aktualisieren Sie in ``new_game()`` die Punkteanzeige und zeigen Sie die "
"Meldung \"Get Ready\" an:"

msgid "In ``game_over()`` we need to call the corresponding ``HUD`` function:"
msgstr ""
"In ``game_over()`` müssen wir die entsprechende ``HUD`` Funktion aufrufen:"

msgid ""
"Finally, add this to ``_on_ScoreTimer_timeout()`` to keep the display in "
"sync with the changing score:"
msgstr ""
"Abschließend fügen Sie nachfolgendes in ``_on_ScoreTimer_timeout()`` hinzu, "
"um die Anzeige mit den sich ändernden Punkten zu synchronisieren:"

msgid ""
"Now you're ready to play! Click the \"Play the Project\" button. You will be "
"asked to select a main scene, so choose ``Main.tscn``."
msgstr ""
"Jetzt können Sie spielen! Klicken Sie auf die Schaltfläche \"Projekt "
"abspielen (F5)\". Sie werden aufgefordert, eine Hauptszene auszuwählen. "
"Wählen Sie dann ``Main.tscn`` aus."

msgid "Removing old creeps"
msgstr "Alte Gegner entfernen"

msgid ""
"If you play until \"Game Over\" and then start a new game right away, the "
"creeps from the previous game may still be on the screen. It would be better "
"if they all disappeared at the start of a new game. We just need a way to "
"tell *all* the mobs to remove themselves. We can do this with the \"group\" "
"feature."
msgstr ""
"Wenn Sie bis zum \"Game Over\" spielen und dann ein neues Spiel starten, "
"befinden sich die Gegner des vorherigen Spiel noch auf dem Bildschirm. Es "
"wäre besser wenn diese beim Start eines neuen Spiels verschwinden würden. "
"Wir benötigen einen Weg um *alle* Gegner zu entfernen und dies geschieht mit "
"der \"Gruppen\" Funktion."

msgid ""
"In the ``Mob`` scene, select the root node and click the \"Node\" tab next "
"to the Inspector (the same place where you find the node's signals). Next to "
"\"Signals\", click \"Groups\" and you can type a new group name and click "
"\"Add\"."
msgstr ""
"Wählen Sie in der Szene ``Mob`` den Wurzel-Node und klicken Sie auf die "
"Registerkarte \"Node\" neben dem Inspektor (die gleiche Stelle, an der Sie "
"die Signale des Nodes finden). Klicken Sie neben \"Signale\" auf "
"\"Gruppen\", und Sie können einen neuen Gruppennamen eingeben und auf "
"\"Hinzufügen\" klicken."

msgid ""
"Now all mobs will be in the \"mobs\" group. We can then add the following "
"line to the ``new_game()`` function in ``Main``:"
msgstr ""
"Nun sind alle Gegner in der Gruppe\"mobs\". Jetzt können wir folgende Zeile "
"zur Funktion ``new_game()`` in ``Main`` hinzufügen:"

msgid ""
"The ``call_group()`` function calls the named function on every node in a "
"group - in this case we are telling every mob to delete itself."
msgstr ""
"Die Funktion ``call_group()`` ruft die benannte Funktion auf jedem Node in "
"einer Gruppe auf - in diesem Fall sagen wir jedem Gegner, dass er sich "
"selbst löschen soll."

msgid ""
"The game's mostly done at this point. In the next and last part, we'll "
"polish it a bit by adding a background, looping music, and some keyboard "
"shortcuts."
msgstr ""
"Das Spiel ist nun zum größten Teil fertig. Im nächsten letzten Teil werden "
"wir es etwas aufpolieren, indem wir einen Hintergrund, eine Musikschleife "
"und einige Tastenkombinationen hinzufügen."

msgid "Translation status"
msgstr "Übersetzungsstatus"
