# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Jumping and squashing monsters"
msgstr "跳跃与踩扁怪物"

msgid ""
"In this part, we'll add the ability to jump and squash the monsters. In the "
"next lesson, we'll make the player die when a monster hits them on the "
"ground."
msgstr ""
"在这一部分中，我们将添加跳跃、踩扁怪物的能力。在下一节课中，我们会让怪物在地"
"面上击中玩家时让玩家死亡。"

msgid ""
"First, we have to change a few settings related to physics interactions. "
"Enter the world of :ref:`physics layers "
"<doc_physics_introduction_collision_layers_and_masks>`."
msgstr ""
"首先我们要修改一些物理交互相关的设置。请进入\\ :ref:`物理层 "
"<doc_physics_introduction_collision_layers_and_masks>`\\ 的世界。"

msgid "Controlling physics interactions"
msgstr "控制物理交互"

msgid ""
"Physics bodies have access to two complementary properties: layers and "
"masks. Layers define on which physics layer(s) an object is."
msgstr ""
"物理实体可以访问两个互补的属性：层和遮罩。层（Layer）定义的是该对象位于哪些物"
"理层上。"

msgid ""
"Masks control the layers that a body will listen to and detect. This affects "
"collision detection. When you want two bodies to interact, you need at least "
"one to have a mask corresponding to the other."
msgstr ""
"遮罩（Mask）控制的是该实体会监听并检测的层，会影响碰撞检测。希望两个实体能够"
"发生交互时，你需要让其中至少一个的遮罩与另一个（的层）相对应。"

msgid "If that's confusing, don't worry, we'll see three examples in a second."
msgstr "可能有点绕，但请别担心，我们马上就会看到三个例子。"

msgid ""
"The important point is that you can use layers and masks to filter physics "
"interactions, control performance, and remove the need for extra conditions "
"in your code."
msgstr ""
"重要的知识点是，你能够使用层和遮罩来过滤物理交互、控制性能、让代码中不需要再"
"做额外的条件检测。"

msgid ""
"By default, all physics bodies and areas are set to both layer and mask "
"``1``. This means they all collide with each other."
msgstr ""
"默认情况下，所有物理体和区域的层和遮罩都被设成了 ``1``\\ 。也就是说它们会互相"
"碰撞。"

msgid ""
"Physics layers are represented by numbers, but we can give them names to "
"keep track of what's what."
msgstr "物理层由数字表示，但我们也可以为它们命名，记录什么是什么。"

msgid "Setting layer names"
msgstr "设置层名称"

msgid ""
"Let's give our physics layers a name. Go to *Project -> Project Settings*."
msgstr "让我们来为物理层命名。打开\\ *项目 -> 项目设置*\\ 。"

msgid "|image0|"
msgstr "|image0|"

msgid "image0"
msgstr "image0"

msgid ""
"In the left menu, navigate down to *Layer Names -> 3D Physics*. You can see "
"a list of layers with a field next to each of them on the right. You can set "
"their names there. Name the first three layers *player*, *enemies*, and "
"*world*, respectively."
msgstr ""
"在左侧的菜单中，找到 *Layer Names -> 3D Physics*\\ （层名称 -> 3D 物理）。你"
"可以在右侧看到层的列表，每一层右侧都有一个字段，可以用来设置名称。将前三层分"
"别命名为“player”“enemies”“world”（玩家、敌人、世界）。"

msgid "|image1|"
msgstr "|image1|"

msgid "image1"
msgstr "image1"

msgid "Now, we can assign them to our physics nodes."
msgstr "现在，我们就可以将它们分配给我们的物理节点了。"

msgid "Assigning layers and masks"
msgstr "层和遮罩的分配"

msgid ""
"In the *Main* scene, select the ``Ground`` node. In the *Inspector*, expand "
"the *Collision* section. There, you can see the node's layers and masks as a "
"grid of buttons."
msgstr ""
"在 *Main* 场景中选中 ``Ground`` 节点。在\\ *检查器*\\ 中展开 *Collision*\\ "
"（碰撞）部分。你可以看到，该节点的层和遮罩在这里以按钮网格的形式排列。"

msgid "|image2|"
msgstr "|image2|"

msgid "image2"
msgstr "image2"

msgid ""
"The ground is part of the world, so we want it to be part of the third "
"layer. Click the lit button to toggle **off** the first *Layer* and toggle "
"**on** the third one. Then, toggle **off** the *Mask* by clicking on it."
msgstr ""
"地面是世界的一部分，所以我们希望它属于第三层。点击 *Layer* 中的第一个点亮的按"
"钮将其\\ **关闭**\\ ，\\ **打开**\\ 第三层。然后点击\\ **关闭** *Mask*\\ 。"

msgid "|image3|"
msgstr "|image3|"

msgid "image3"
msgstr "image3"

msgid ""
"As mentioned before, the *Mask* property allows a node to listen to "
"interaction with other physics objects, but we don't need it to have "
"collisions. ``Ground`` doesn't need to listen to anything; it's just there "
"to prevent creatures from falling."
msgstr ""
"上面说到过，\\ *Mask* 属性可以让节点监听与其他物理对象的交互，但它不是实现碰"
"撞所必须的。\\ ``Ground`` 不需要监听任何东西；它存在的意义是防止生物下落。"

msgid ""
"Note that you can click the \"...\" button on the right side of the "
"properties to see a list of named checkboxes."
msgstr "请注意，点击右侧的“...”按钮会将该属性以带名称的复选框的形式展示。"

msgid "|image4|"
msgstr "|image4|"

msgid "image4"
msgstr "image4"

msgid ""
"Next up are the ``Player`` and the ``Mob``. Open ``player.tscn`` by double-"
"clicking the file in the *FileSystem* dock."
msgstr ""
"接下来就是 ``Player`` 和 ``Mob``\\ 。在\\ *文件系统*\\ 面板中双击打开 "
"``player.tscn`` 文件。"

msgid ""
"Select the *Player* node and set its *Collision -> Mask* to both \"enemies\" "
"and \"world\". You can leave the default *Layer* property as it is, because "
"the first layer is the \"player\" layer."
msgstr ""
"选中 *Player* 节点，将其 *Collision -> Mask* 设为“enemies”和“world”。\\ "
"*Layer* 属性可以保持默认，因为第一个层就是“player”层。"

msgid "|image5|"
msgstr "|image5|"

msgid "image5"
msgstr "image5"

msgid ""
"Then, open the *Mob* scene by double-clicking on ``mob.tscn`` and select the "
"``Mob`` node."
msgstr "然后双击 ``mob.tscn`` 打开 *Mob* 场景，选中 ``Mob`` 节点。"

msgid ""
"Set its *Collision -> Layer* to \"enemies\" and unset its *Collision -> "
"Mask*, leaving the mask empty."
msgstr ""
"将其 *Collision -> Layer* 设为“enemies”，然后取消 *Collision -> Mask* 的设"
"置，让遮罩为空。"

msgid "|image6|"
msgstr "|image6|"

msgid "image6"
msgstr "image6"

msgid ""
"These settings mean the monsters will move through one another. If you want "
"the monsters to collide with and slide against each other, turn **on** the "
"\"enemies\" mask."
msgstr ""
"这些设置意味着怪物可以互相穿越。如果你希望怪物之间会发生碰撞和滑动，请\\ **打"
"开**\\ “enemies”遮罩。"

msgid ""
"The mobs don't need to mask the \"world\" layer because they only move on "
"the XZ plane. We don't apply any gravity to them by design."
msgstr ""
"小怪并不需要遮罩“world”层，因为它们只会沿着 XZ 平面移动。我们是故意不去为它们"
"添加重力影响的。"

msgid "Jumping"
msgstr "跳跃"

msgid ""
"The jumping mechanic itself requires only two lines of code. Open the "
"*Player* script. We need a value to control the jump's strength and update "
"``_physics_process()`` to code the jump."
msgstr ""
"跳跃机制本身只需要两行代码。打开 *Player* 脚本。我们需要一个值来控制跳跃的强"
"度，并更新 ``_physics_process()`` 来对跳跃进行编码。"

msgid ""
"After the line that defines ``fall_acceleration``, at the top of the script, "
"add the ``jump_impulse``."
msgstr ""
"在定义 ``fall_acceleration`` 这一行之后，在脚本的顶部，添加 "
"``jump_impulse``\\ 。"

msgid ""
"Inside ``_physics_process()``, add the following code before the "
"``move_and_slide()`` codeblock."
msgstr ""
"在 ``_physics_process()`` 内，请在调用 ``move_and_slide()`` 那块代码之前添加"
"以下代码。"

msgid "That's all you need to jump!"
msgstr "这就是跳跃所需的所有东西！"

msgid ""
"The ``is_on_floor()`` method is a tool from the ``CharacterBody3D`` class. "
"It returns ``true`` if the body collided with the floor in this frame. "
"That's why we apply gravity to the *Player*: so we collide with the floor "
"instead of floating over it like the monsters."
msgstr ""
"``is_on_floor()`` 方法是来自 ``CharacterBody3D`` 类的工具。如果物体在这一帧中"
"与地板发生碰撞返回 ``true``\\ 。这就是为什么我们要对 *Player* 施加重力的原"
"因：这样我们就会与地板相撞，而不是像怪物一样漂浮在地板上。"

msgid ""
"If the character is on the floor and the player presses \"jump\", we "
"instantly give them a lot of vertical speed. In games, you really want "
"controls to be responsive and giving instant speed boosts like these, while "
"unrealistic, feels great."
msgstr ""
"如果角色在地板上并且玩家按下跳跃，立即给予角色较大的垂直速度，因为在游戏中，"
"玩家通常希望控制能得到响应，就像这样提供的即时速度提升，虽然不切实际，但会令"
"玩家感觉很好。"

msgid ""
"Notice that the Y axis is positive upwards. That's unlike 2D, where the Y "
"axis is positive downwards."
msgstr ""
"请注意，Y 轴的正方向是朝上的。这与 2D 有所不同， 2D的Y 轴的正方向是朝下的。"

msgid "Squashing monsters"
msgstr "踩扁怪物"

msgid ""
"Let's add the squash mechanic next. We're going to make the character bounce "
"over monsters and kill them at the same time."
msgstr ""
"接下来让我们来添加踩扁机制。我们会让玩家在怪物身上弹起，并同时消灭它们。"

msgid ""
"We need to detect collisions with a monster and to differentiate them from "
"collisions with the floor. To do so, we can use Godot's :ref:`group "
"<doc_groups>` tagging feature."
msgstr ""
"我们需要检测与怪物的碰撞，并和与地板的碰撞相区分。要这么做，我们可以使用 "
"Godot 的\\ :ref:`分组 <doc_groups>`\\ 标签功能。"

msgid ""
"Open the scene ``mob.tscn`` again and select the *Mob* node. Go to the "
"*Node* dock on the right to see a list of signals. The *Node* dock has two "
"tabs: *Signals*, which you've already used, and *Groups*, which allows you "
"to assign tags to nodes."
msgstr ""
"再次打开 ``mob.tscn`` 场景，选中 *Mob* 节点，就能在右侧的\\ *Node*\\ 面板中看"
"到信号的列表。\\ *Node*\\ 面板有两个选项卡：你已经使用过的\\ *Signals*\\ ，以"
"及\\ *Groups*\\ 它允许你为节点添加标签。"

msgid ""
"Click on it to reveal a field where you can write a tag name. Enter \"mob\" "
"in the field and click the *Add* button."
msgstr ""
"单击这个选项卡就会出现一个输入框，可以填写标签的名称。在这个输入框中输"
"入“mob”（小怪）并单击\\ *添加*\\ 按钮。"

msgid "|image7|"
msgstr "|image7|"

msgid "image7"
msgstr "image7"

msgid ""
"An icon appears in the *Scene* dock to indicate the node is part of at least "
"one group."
msgstr "*场景*\\ 面板中会出现一个图标，表示该节点至少处在一个分组之中。"

msgid "|image8|"
msgstr "|image8|"

msgid "image8"
msgstr "image8"

msgid ""
"We can now use the group from the code to distinguish collisions with "
"monsters from collisions with the floor."
msgstr "我们现在就可以在代码中使用分组来区分与怪物的碰撞和与地板的碰撞了。"

msgid "Coding the squash mechanic"
msgstr "编写踩扁机制"

msgid "Head back to the *Player* script to code the squash and bounce."
msgstr "回到 *Player* 脚本来编写踩扁和弹跳。"

msgid ""
"At the top of the script, we need another property, ``bounce_impulse``. When "
"squashing an enemy, we don't necessarily want the character to go as high up "
"as when jumping."
msgstr ""
"在脚本顶部，我们需要添加一个属性 ``bounce_impulse``\\ 。踩扁敌人时，我们不必"
"让角色弹得比跳跃一样高。"

msgid ""
"Then, after the **Jumping** codeblock we added above in "
"``_physics_process()``, add the following loop. With ``move_and_slide()``, "
"Godot makes the body move sometimes multiple times in a row to smooth out "
"the character's motion. So we have to loop over all collisions that may have "
"happened."
msgstr ""
"然后，在 ``_physics_process()`` 中添加的 **Jumping** 代码块之后，添加以下循"
"环。使用 ``move_and_slide()`` 时，Godot 有时会连续多次移动角色身体来平滑运"
"动。因此，我们必须循环遍历所有可能发生的碰撞。"

msgid ""
"In every iteration of the loop, we check if we landed on a mob. If so, we "
"kill it and bounce."
msgstr ""
"在循环的每次迭代中，我们会检查是否落在了小怪身上。如果是的话，我们就消灭它并"
"进行弹跳。"

msgid ""
"With this code, if no collisions occurred on a given frame, the loop won't "
"run."
msgstr "如果某一帧没有发生碰撞，那么这段代码中的循环就不会执行。"

msgid "That's a lot of new functions. Here's some more information about them."
msgstr "新函数很多。下面我们来进一步介绍一下。"

msgid ""
"The functions ``get_slide_collision_count()`` and ``get_slide_collision()`` "
"both come from the :ref:`CharacterBody3D <class_CharacterBody3D>` class and "
"are related to ``move_and_slide()``."
msgstr ""
"函数 ``get_slide_collision_count()`` 和 ``get_slide_collision()`` 都来自于 :"
"ref:`CharacterBody3D <class_CharacterBody3D>` 类，他们与 "
"``move_and_slide()`` 有关。"

msgid ""
"``get_slide_collision()`` returns a :ref:"
"`KinematicCollision3D<class_KinematicCollision3D>` object that holds "
"information about where and how the collision occurred. For example, we use "
"its ``get_collider`` property to check if we collided with a \"mob\" by "
"calling ``is_in_group()`` on it: ``collision.get_collider()."
"is_in_group(\"mob\")``."
msgstr ""
"``get_slide_collision()`` 返回的是 :ref:"
"`KinematicCollision3D<class_KinematicCollision3D>` 对象，包含碰撞在哪里发生、"
"如何发生等信息。例如，我们对它的 ``get_collider`` 属性调用 ``is_in_group()`` "
"来检查我们是否是和“mob”发生了碰撞：\\ ``collision.collider."
"is_in_group(\"mob\")``\\ 。"

msgid ""
"The method ``is_in_group()`` is available on every :ref:`Node<class_Node>`."
msgstr "每一个 :ref:`Node<class_Node>` 都可以使用 ``is_in_group()`` 方法。"

msgid ""
"To check that we are landing on the monster, we use the vector dot product: "
"``Vector3.UP.dot(collision.get_normal()) > 0.1``. The collision normal is a "
"3D vector that is perpendicular to the plane where the collision occurred. "
"The dot product allows us to compare it to the up direction."
msgstr ""
"我们使用向量点积 ``Vector3.UP.dot(collision.get_normal()) > 0.1`` 来检查我们"
"是不是降落在怪物身上。碰撞法线（normal）是垂直于碰撞平面的 3D 向量。可以通过"
"点积与上方向进行比较。"

msgid ""
"With dot products, when the result is greater than ``0``, the two vectors "
"are at an angle of fewer than 90 degrees. A value higher than ``0.1`` tells "
"us that we are roughly above the monster."
msgstr ""
"点积结果大于 ``0`` 时，两个向量的夹角小于 90 度。大于 ``0.1`` 表示我们大概位"
"于怪物上方。"

msgid ""
"After handling the squash and bounce logic, we terminate the loop early via "
"the ``break`` statement to prevent further duplicate calls to ``mob."
"squash()``, which may otherwise result in unintended bugs such as counting "
"the score multiple times for one kill."
msgstr ""
"处理完踩扁和反弹逻辑后，我们通过 ``break`` 语句提前终止循环，以防止进一步重复"
"调用 ``mob.squash()`` ，否则这可能会导致意外的错误，例如将一次击杀获得的分数"
"算成好几倍。"

msgid ""
"We are calling one undefined function, ``mob.squash()``, so we have to add "
"it to the Mob class."
msgstr ""
"我们调用了一个尚未定义的函数 ``mob.squash()``\\ 。所以我们需要把它加入到 Mob "
"类中。"

msgid ""
"Open the script ``Mob.gd`` by double-clicking on it in the *FileSystem* "
"dock. At the top of the script, we want to define a new signal named "
"``squashed``. And at the bottom, you can add the squash function, where we "
"emit the signal and destroy the mob."
msgstr ""
"在\\ *文件系统*\\ 面板中双击打开 ``Mob.gd`` 脚本。在脚本顶部，我们要定义一个"
"新的信号叫作 ``squashed``\\ （被踩扁）。你可以在底部添加 squash 函数，在里面"
"发出这个信号并销毁这个小怪。"

msgid ""
"When using C#, Godot will create the appropriate events automatically for "
"all Signals ending with `EventHandler`, see :ref:`C# Signals "
"<doc_c_sharp_signals>`."
msgstr ""
"使用 C# 时，Godot 将为所有以 `EventHandler` 结尾的信号自动创建适当的事件，请"
"参阅 :ref:`C# 信号 <doc_c_sharp_signals>`。"

msgid "We will use the signal to add points to the score in the next lesson."
msgstr "下一节课中，我们会使用这个信号来加分数。"

msgid ""
"With that, you should be able to kill monsters by jumping on them. You can "
"press :kbd:`F5` to try the game and set ``main.tscn`` as your project's main "
"scene."
msgstr ""
"好了，你应该可以跳在怪物身上把它们消灭了。你可以按 :kbd:`F5` 试玩游戏，并把 "
"``main.tscn`` 设成项目的主场景。"

msgid "However, the player won't die yet. We'll work on that in the next part."
msgstr "不过玩家现在还不会死。我们会在下一部分实现。"

msgid "Translation status"
msgstr "翻译状态"
