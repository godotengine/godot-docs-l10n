# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2022, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-11 15:14+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Signal"
msgstr "信号"

msgid "Using Signals"
msgstr "使用信号"

msgid ""
"In this lesson, we will look at signals. They are messages that nodes emit "
"when something specific happens to them, like a button being pressed. Other "
"nodes can connect to that signal and call a function when the event occurs."
msgstr ""
"在本课中，我们将介绍信号。它们是节点在发生特定事件时发出的消息，例如按下按"
"钮。其他节点可以连接到该信号，并在事件发生时调用函数。"

msgid ""
"It is a delegation mechanism built into Godot that allows one game object to "
"react to a change in another without them referencing one another. Using "
"signals limits `coupling <https://en.wikipedia.org/wiki/"
"Coupling_(computer_programming)>`_ and keeps your code flexible."
msgstr ""
"它是 Godot 内置的委派机制，允许一个游戏对象对另一个游戏对象的变化做出反应，而"
"无需相互引用。使用信号可以限制\\ `耦合 <https://zh.wikipedia.org/zh-cn/"
"%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)>`_\\ ，"
"并保持代码的灵活性。"

msgid ""
"For example, you might have a life bar on the screen that represents the "
"player’s health. When the player takes damage or uses a healing potion, you "
"want the bar to reflect the change. To do so, in Godot, you would use "
"signals."
msgstr ""
"例如，您可能在屏幕上有一个代表玩家生命值的生命条。当玩家受到伤害或使用治疗药"
"水时，您希望生命条反映变化。要做到这一点，在 Godot 中，你会使用到信号。"

msgid ""
"As mentioned in the introduction, signals are Godot's version of the "
"observer pattern. You can learn more about it here: https://"
"gameprogrammingpatterns.com/observer.html"
msgstr ""
"正如引言中提到的，信号是 Godot 版本的观察者模式。您可以在此处了解有关它的更多"
"信息：https://gameprogrammingpatterns.com/observer.html"

msgid ""
"We will now use a signal to make our Godot icon from last part move and stop "
"by pressing a button."
msgstr ""
"现在，我们将使用一个信号来使最后一部分的 Godot 图标移动，并通过按下按钮来停"
"止。"

msgid "Scene setup"
msgstr "场景设置"

msgid "Create a new scene by going to the menu Scene -> New Scene."
msgstr "通过转到菜单“场景 -> 新建场景”来创建新场景。"

msgid ""
"In the Scene dock, click the 2D Scene button. This will add a Node2D as our "
"root."
msgstr "在场景停靠栏中，单击 2D 场景按钮。这将添加一个 Node2D 作为我们的根。"

msgid ""
"In the FileSystem dock, click and drag the ``Sprite.tscn`` file you saved "
"previously onto the Node2D to instantiate it."
msgstr ""
"在文件系统停靠栏中，单击之前保存的 ``Sprite.tscn`` 文件并将其拖动到 Node2D 上"
"以对其进行实例化。"

msgid ""
"We want to add another node as a sibling of the Sprite. To do so, right-"
"click on Node2D and select Add Child Node."
msgstr ""
"我们想要添加另一个节点作为 Sprite 的同级节点。为此，请右键单击 Node2D，然后选"
"择“添加子节点”。"

msgid "Search for the Button node type and add it."
msgstr "寻找并添加按钮（Button）节点类型。"

msgid ""
"The node is small by default. Click and drag on the bottom-right handle of "
"the Button in the viewport to resize it."
msgstr "按钮默认大小为“小”。点击并拖拽按钮右下角的手柄在视窗中重新设置大小。"

msgid ""
"If you don't see the handles, ensure the select tool is active in the "
"toolbar."
msgstr "如果看不到手柄，请确保工具栏中的选择工具处于活动状态。"

msgid "Click and drag on the button itself to move it closer to the sprite."
msgstr "点击并拖拽按钮使其更接近精灵。"

msgid ""
"You can also write a label on the Button by editing its Text property in the "
"Inspector."
msgstr "你也可以通过在检查器中编辑 Text 属性在 Button 上写一个标签。"

msgid "Your scene tree and viewport should look like this."
msgstr "您的场景树和视窗应该是类似这样的。"

msgid "Connecting a signal in the editor"
msgstr "在编辑器中连接信号"

msgid ""
"Here, we want to connect the Button's \"pressed\" signal to our Sprite, and "
"we want to call a new function that will toggle its motion on and off. We "
"need to have a script attached to the Sprite node, which we do from the "
"previous lesson."
msgstr ""
"在这里，我们希望将按钮的“pressed”信号连接到我们的 Sprite，并且我们想要调用一"
"个新函数来打开和关闭其运动。我们需要将脚本附加到 Sprite 节点，这是我们在上一"
"课中所做的。"

msgid ""
"You can connect signals in the Node dock. Select the Button node and, on the "
"right side of the editor, click on the tab named \"Node\" next to the "
"Inspector."
msgstr ""
"您可以在“节点”面板中连接信号。选择 Button 节点，然后在编辑器的右侧，单击检查"
"器旁边名为“节点”的选项卡。"

msgid "The dock displays a list of signals available on the selected node."
msgstr "停靠栏显示所选节点上可用的信号列表。"

msgid "Double-click the \"pressed\" signal to open the node connection window."
msgstr "双击“pressed”信号，打开节点连接窗口。"

msgid ""
"There, you can connect the signal to the Sprite node. The node needs a "
"receiver method, a function that Godot will call when the Button emits the "
"signal. The editor generates one for you. By convention, we name these "
"callback methods \"_on_NodeName_signal_name\". Here, it'll be "
"\"_on_Button_pressed\"."
msgstr ""
"在那里，您可以将信号连接到 Sprite 节点。节点需要一个接收器方法，当按钮发出信"
"号时，Godot 将调用该函数。编辑器会为您生成一个。按照惯例，我们将这些回调方法"
"命名为“_on_节点名_信号名”。在这里，它将是“_on_Button_pressed”。"

msgid ""
"When connecting signals via the editor's Node dock, you can use two modes. "
"The simple one only allows you to connect to nodes that have a script "
"attached to them and creates a new callback function on them."
msgstr ""
"通过编辑器的节点面板连接信号时，可以使用两种模式。简单的一个只允许您连接到附"
"加了脚本的节点，并在它们上面创建一个新的回调函数。"

msgid ""
"The advanced view lets you connect to any node and any built-in function, "
"add arguments to the callback, and set options. You can toggle the mode in "
"the window's bottom-right by clicking the radio button."
msgstr ""
"高级视图允许您连接到任何节点和任何内置函数，向回调添加参数以及设置选项。您可"
"以通过单击单选按钮在窗口的右下角切换模式。"

msgid ""
"Click the connect button to complete the signal connection and jump to the "
"Script workspace. You should see the new method with a connection icon in "
"the left margin."
msgstr ""
"单击连接按钮以完成信号连接并跳转到脚本工作区。您应该会看到新方法，并在左边距"
"中带有连接图标。"

msgid ""
"If you click the icon, a window pops up and displays information about the "
"connection. This feature is only available when connecting nodes in the "
"editor."
msgstr ""
"如果单击该图标，将弹出一个窗口并显示有关连接的信息。此功能仅在编辑器中连接节"
"点时可用。"

msgid ""
"Let's replace the line with the ``pass`` keyword with code that'll toggle "
"the node's motion."
msgstr "让我们用代码替换带有 ``pass`` 关键字的一行，以切换节点的运动。"

msgid ""
"Our Sprite moves thanks to code in the ``_process()`` function. Godot "
"provides a method to toggle processing on and off: :ref:`Node.set_process() "
"<class_Node_method_set_process>`. Another method of the Node class, "
"``is_processing()``, returns ``true`` if idle processing is active. We can "
"use the ``not`` keyword to invert the value."
msgstr ""
"我们的 Sprite 由于 ``_process()`` 函数中的代码而移动。Godot 提供了一种打开和"
"关闭处理的方法：\\ :ref:`Node."
"set_process()<class_Node_method_set_process>`\\ 。Node 类的另一种方法 "
"``is_processing()``\\ ，如果空闲处理处于活动状态，则返回 ``true``\\ 。我们可"
"以使用 ``not`` 关键字来反转值。"

msgid ""
"This function will toggle processing and, in turn, the icon's motion on and "
"off upon pressing the button."
msgstr "此函数将切换处理，进而切换按下按钮时图标的移动。"

msgid ""
"Before trying the game, we need to simplify our ``_process()`` function to "
"move the node automatically and not wait for user input. Replace it with the "
"following code, which we saw two lessons ago:"
msgstr ""
"在尝试游戏之前，我们需要简化 ``_process()`` 函数，以自动移动节点，而不是等待"
"用户输入。将其替换为以下代码，这是我们在两课前看到的代码："

msgid "Your complete ``Sprite.gd`` code should look like the following."
msgstr "你的完整的 ``Sprite.gd`` 代码应该是类似下面这样的。"

msgid ""
"Run the scene now and click the button to see the sprite start and stop."
msgstr "运行该场景，然后点击按钮，就可以看到精灵开始或停止运行。"

msgid "Connecting a signal via code"
msgstr "用代码连接信号"

msgid ""
"You can connect signals via code instead of using the editor. This is "
"necessary when you create nodes or instantiate scenes inside of a script."
msgstr ""
"您可以通过代码连接信号，而不是使用编辑器。这在脚本中创建节点或实例化场景时是"
"必需的。"

msgid ""
"Let's use a different node here. Godot has a :ref:`Timer <class_Timer>` node "
"that's useful to implement skill cooldown times, weapon reloading, and more."
msgstr ""
"让我们在这里使用一个不同的节点。Godot 有一个 :ref:`Timer <class_Timer>` 节"
"点，可用于实现技能冷却时间、武器重装等。"

msgid ""
"Head back to the 2D workspace. You can either click the \"2D\" text at the "
"top of the window or press :kbd:`Ctrl + F1` (:kbd:`Alt + 1` on macOS)."
msgstr ""
"回到 2D 工作区。你可以点击窗口顶部的“2D”文字，或者按 :kbd:`Ctrl + F1`\\ "
"（macOS 上则是 :kbd:`Alt + 1`）。"

msgid ""
"In the Scene dock, right-click on the Sprite node and add a new node. Search "
"for Timer and add the corresponding node. Your scene should now look like "
"this."
msgstr ""
"在“场景”面板中，右键点击 Sprite 节点并添加新节点。找到 Timer 并添加对应节点。"
"你的场景现在应该类似这样。"

msgid ""
"With the Timer node selected, go to the Inspector and check the "
"**Autostart** property."
msgstr "选中 Timer 节点，在“检查器”中勾选 **Autostart**\\ （自动开启）属性。"

msgid ""
"Click the script icon next to Sprite to jump back to the scripting workspace."
msgstr "点击 Sprite 旁的脚本图标，返回脚本工作区。"

msgid "We need to do two operations to connect the nodes via code:"
msgstr "我们需要执行两个操作来通过代码连接节点："

msgid "Get a reference to the Timer from the Sprite."
msgstr "从 Sprite 获取 Timer 的引用。"

msgid "Call the Timer's ``connect()`` method."
msgstr "调用 Timer 的 ``connect()`` 方法。"

msgid ""
"To connect to a signal via code, you need to call the ``connect()`` method "
"of the node you want to listen to. In this case, we want to listen to the "
"Timer's \"timeout\" signal."
msgstr ""
"要使用代码来连接信号，你需要调用所需监听节点的 ``connect()`` 方法。这里我们要"
"监听的是 Timer 的“timeout”信号。"

msgid ""
"To get a reference to a node relative to the current one, we use the method :"
"ref:`Node.get_node() <class_Node_method_get_node>`. We can store the "
"reference in a variable."
msgstr ""
"为了获取相对于当前节点的引用，我们使用方法 :ref:`Node.get_node() "
"<class_Node_method_get_node>`\\ 。我们可以将引用存储在变量中。"

msgid ""
"The function ``get_node()`` looks at the Sprite's children and gets nodes by "
"their name. For example, if you renamed the Timer node to \"BlinkingTimer\" "
"in the editor, you would have to change the call to "
"``get_node(\"BlinkingTimer\")``."
msgstr ""
"``get_node()`` 函数会查看 Sprite 的子节点，并按节点的名称获取节点。例如，如果"
"在编辑器中将 Timer 节点重命名为“BlinkingTimer”，则必须将调用更改为 "
"``get_node(\"BlinkingTimer\")``\\ 。"

msgid ""
"We can now connect the Timer to the Sprite in the ``_ready()`` function."
msgstr "现在，我们可以在 ``_ready()`` 函数中将计时器连接到精灵。"

msgid ""
"The line reads like so: we connect the Timer's \"timeout\" signal to the "
"node to which the script is attached (``self``). When the Timer emits "
"\"timeout\", we want to call the function \"_on_Timer_timeout\", that we "
"need to define. Let's add it at the bottom of our script and use it to "
"toggle our sprite's visibility."
msgstr ""
"该行读起来是这样的：我们将计时器的“timeout”信号连接到脚本附加到的节点"
"（ ``self`` ）。当计时器发出“timeout”时，我们要调用我们需要定义的函"
"数“_on_Timer_timeout”。让我们将其添加到脚本的底部，并使用它来切换精灵的可见"
"性。"

msgid ""
"The ``visible`` property is a boolean that controls the visibility of our "
"node. The line ``visible = not visible`` toggles the value. If ``visible`` "
"is ``true``, it becomes ``false``, and vice-versa."
msgstr ""
"``visible`` 属性是一个布尔值，用于控制节点的可见性。\\ ``visible = not "
"visible`` 行切换该值。如果 ``visible`` 是 ``true``\\ ，它就会变成 "
"``false``\\ ，反之亦然。"

msgid "Custom signals"
msgstr "自定义信号"

msgid ""
"You can define custom signals in a script. Say, for example, that you want "
"to show a game over screen when the player's health reaches zero. To do so, "
"you could define a signal named \"died\" or \"health_depleted\" when their "
"health reaches 0."
msgstr ""
"您可以在脚本中定义自定义信号。例如，假设您希望在玩家的生命值为零时通过屏幕显"
"示游戏结束。为此，当他们的生命值达到 0 时，您可以定义一个名"
"为“died”或“health_depleted”的信号。"

msgid ""
"As signals represent events that just occurred, we generally use an action "
"verb in the past tense in their names."
msgstr "由于信号表示刚刚发生的事件，我们通常在其名称中使用过去时态的动作动词。"

msgid ""
"Your signals work the same way as built-in ones: they appear in the Node tab "
"and you can connect to them like any other."
msgstr ""
"自定义信号的工作方式与内置信号相同：它们显示在“节点”选项卡中，您可以像连接其"
"他信号一样连接到它们。"

msgid "To emit a signal in your scripts, call ``emit_signal()``."
msgstr "要通过代码发出信号，请调用 ``emit_signal()``\\ 。"

msgid ""
"A signal can optionally declare one or more arguments. Specify the argument "
"names between parentheses:"
msgstr "信号还可以选择声明一个或多个参数。在括号之间指定参数的名称："

msgid ""
"The signal arguments show up in the editor's node dock, and Godot can use "
"them to generate callback functions for you. However, you can still emit any "
"number of arguments when you emit signals. So it's up to you to emit the "
"correct values."
msgstr ""
"这些信号参数显示在编辑器的节点停靠面板中，Godot 可以使用它们为您生成回调函"
"数。但是，发出信号时仍然可以发出任意数量的参数；所以由你来决定是否发出正确的"
"值。"

msgid ""
"To emit values along with the signal, add them as extra arguments to the "
"``emit_signal()`` function:"
msgstr ""
"要在发出信号的同时传值，请将它们添加为 ``emit_signal()`` 函数的额外参数："

msgid "Summary"
msgstr "总结"

msgid ""
"Any node in Godot emits signals when something specific happens to them, "
"like a button being pressed. Other nodes can connect to individual signals "
"and react to selected events."
msgstr ""
"Godot 中的任何节点都会在发生特定事件时发出信号，例如按下按钮。其他节点可以连"
"接到单个信号并对所选事件做出反应。"

msgid ""
"Signals have many uses. With them, you can react to a node entering or "
"exiting the game world, to a collision, to a character entering or leaving "
"an area, to an element of the interface changing size, and much more."
msgstr ""
"信号有很多用途。有了它们，你可以对进入或退出游戏世界的节点、碰撞、角色进入或"
"离开某个区域、界面元素的大小变化等等做出反应。"

msgid ""
"For example, an :ref:`Area2D <class_Area2D>` representing a coin emits a "
"``body_entered`` signal whenever the player's physics body enters its "
"collision shape, allowing you to know when the player collected it."
msgstr ""
"例如，代表金币的 :ref:`Area2D <class_Area2D>` 会在玩家的物理实体进入其碰撞形"
"状时发出 ``body_entered`` 信号，让你知道玩家收集到了金币。"

msgid ""
"In the next section, :ref:`doc_your_first_2d_game`, you'll create a complete "
"2D game and put everything you learned so far into practice."
msgstr ""
"在下一节 :ref:`doc_your_first_2d_game` 中，你将创建一个完整的 2D 游戏，使用目"
"前为止学到的东西进行实战。"

msgid "Translation status"
msgstr "翻译状态"
