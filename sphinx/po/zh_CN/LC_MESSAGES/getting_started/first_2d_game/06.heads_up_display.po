# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Heads up display"
msgstr "游戏信息显示"

msgid ""
"The final piece our game needs is a User Interface (UI) to display things "
"like score, a \"game over\" message, and a restart button."
msgstr ""
"我们的游戏最后还需要用户界面（User Interface，UI），显示分数、“游戏结束”信"
"息、重启按钮。"

msgid ""
"Create a new scene, and add a :ref:`CanvasLayer <class_CanvasLayer>` node "
"named ``HUD``. \"HUD\" stands for \"heads-up display\", an informational "
"display that appears as an overlay on top of the game view."
msgstr ""
"创建新场景，然后添加一个 :ref:`CanvasLayer <class_CanvasLayer>` 节点并命名为 "
"``HUD``\\ 。“HUD”是“heads-up display”（游戏信息显示）的缩写，是覆盖在游戏视图"
"上显示的信息。"

msgid ""
"The :ref:`CanvasLayer <class_CanvasLayer>` node lets us draw our UI elements "
"on a layer above the rest of the game, so that the information it displays "
"isn't covered up by any game elements like the player or mobs."
msgstr ""
":ref:`CanvasLayer <class_CanvasLayer>` 节点可以让我们在游戏的其他部分的上一层"
"绘制 UI 元素，这样它所显示的信息就不会被任何游戏元素（如玩家或敌人）所覆盖。"

msgid "The HUD needs to display the following information:"
msgstr "HUD 中需要显示以下信息："

msgid "Score, changed by ``ScoreTimer``."
msgstr "得分，由 ``ScoreTimer`` 更改。"

msgid "A message, such as \"Game Over\" or \"Get Ready!\""
msgstr "消息，例如“Game Over”或“Get Ready!”"

msgid "A \"Start\" button to begin the game."
msgstr "“Start”按钮来开始游戏。"

msgid ""
"The basic node for UI elements is :ref:`Control <class_Control>`. To create "
"our UI, we'll use two types of :ref:`Control <class_Control>` nodes: :ref:"
"`Label <class_Label>` and :ref:`Button <class_Button>`."
msgstr ""
"UI 元素的基本节点是 :ref:`Control <class_Control>` 。要创建 UI，我们需使用 :"
"ref:`Control <class_Control>` 下的两种节点：\\ :ref:`Label <class_Label>` "
"和 :ref:`Button <class_Button>`。"

msgid "Create the following as children of the ``HUD`` node:"
msgstr "创建以下节点作为 ``HUD`` 的子节点："

msgid ":ref:`Label <class_Label>` named ``ScoreLabel``."
msgstr "名为分数标签 ``ScoreLabel`` 的 :ref:`Label <class_Label>`\\ 。"

msgid ":ref:`Label <class_Label>` named ``Message``."
msgstr "名为消息 ``Message`` 的 :ref:`Label <class_Label>`\\ 。"

msgid ":ref:`Button <class_Button>` named ``StartButton``."
msgstr "名为开始按钮 ``StartButton`` 的 :ref:`Button <class_Button>`\\ 。"

msgid ":ref:`Timer <class_Timer>` named ``MessageTimer``."
msgstr "名为信息计数器 ``MessageTimer`` 的 :ref:`Timer <class_Timer>`\\ 。"

msgid ""
"Click on the ``ScoreLabel`` and type a number into the ``Text`` field in the "
"Inspector. The default font for ``Control`` nodes is small and doesn't scale "
"well. There is a font file included in the game assets called \"Xolonium-"
"Regular.ttf\". To use this font, do the following:"
msgstr ""
"点击 ``ScoreLabel`` 并在“检查器”的 ``Text`` 字段中键入一个数字。 ``Control`` "
"节点的默认字体很小，不能很好地缩放。游戏资产包中有一个叫作“Xolonium-Regular."
"ttf”的字体文件。 使用此字体需要执行以下操作："

msgid ""
"Under **Theme overrides > Fonts** click on the empty box and select \"New "
"DynamicFont\""
msgstr ""
"在 **Theme Overrides > Fonts** 中，点击空白内容并选择“新建 DynamicFont”"

msgid ""
"Click on the \"DynamicFont\" you added, and under **Font > FontData**, "
"choose \"Load\" and select the \"Xolonium-Regular.ttf\" file."
msgstr ""
"点击您添加的“DynamicFont”，然后在 **Font > Font Data** 的下拉选项中选择“加"
"载”并选择“Xolonium-Regular.ttf”文件。"

msgid "Set the \"Size\" property under ``Settings``, ``64`` works well."
msgstr "设置 ``Settings`` 下的“Size”属性，设成 ``64`` 就可以。"

msgid ""
"Once you've done this on the ``ScoreLabel``, you can click the down arrow "
"next to the Font property and choose \"Copy\", then \"Paste\" it in the same "
"place on the other two Control nodes."
msgstr ""
"在 ``ScoreLabel`` 上完成此操作后，可以单击 Font 属性旁边向下的箭头，然后选"
"择“复制”，然后将其“粘贴”到其他两个 Control 节点的相同位置。"

msgid ""
"**Anchors and Margins:** ``Control`` nodes have a position and size, but "
"they also have anchors and margins. Anchors define the origin - the "
"reference point for the edges of the node. Margins update automatically when "
"you move or resize a control node. They represent the distance from the "
"control node's edges to its anchor."
msgstr ""
"**锚点和边距：**\\ ``Control`` 节点具有位置和大小，但它也有锚点（Anchor）和边"
"距（Margin）。锚点定义的是原点——节点边缘的参考点。移动或调整控件节点大小时，"
"边距会自动更新。边距表示的是控件节点的边缘与锚点的距离。"

msgid ""
"Arrange the nodes as shown below. Click the \"Layout\" button to set a "
"Control node's layout:"
msgstr "按如下图所示排列节点。点击“布局”按钮以设置 Control 节点的布局："

msgid ""
"You can drag the nodes to place them manually, or for more precise "
"placement, use the following settings:"
msgstr "你可以拖动节点以手动放置它们，或者要进行更精确的放置，请使用以下设置："

msgid "ScoreLabel"
msgstr "ScoreLabel"

msgid "*Layout* : \"Top Wide\""
msgstr "*布局*\\ ：“顶部全幅”"

msgid "*Text* : ``0``"
msgstr "*Text*\\ ：\\ ``0``"

msgid "*Align* : \"Center\""
msgstr "*Align*\\ ：“Center”"

msgid "Message"
msgstr "Message"

msgid "*Layout* : \"HCenter Wide\""
msgstr "*布局*\\ ：“水平居中全幅”"

msgid "*Text* : ``Dodge the Creeps!``"
msgstr "*Text*\\ ：\\ ``Dodge the Creeps!``"

msgid "*Autowrap* : \"On\""
msgstr "*Autowrap*\\ ：“启用”"

msgid "StartButton"
msgstr "StartButton"

msgid "*Text* : ``Start``"
msgstr "*Text*\\ ：\\ ``Start``"

msgid "*Layout* : \"Center Bottom\""
msgstr "*布局*\\ ：“底部居中”"

msgid "*Margin* :"
msgstr "*Margin*\\ ："

msgid "Top: ``-200``"
msgstr "Top：\\ ``-200``"

msgid "Bottom: ``-100``"
msgstr "Bottom：\\ ``-100``"

msgid ""
"On the ``MessageTimer``, set the ``Wait Time`` to ``2`` and set the ``One "
"Shot`` property to \"On\"."
msgstr ""
"在 ``MessageTimer`` 中，将 ``Wait Time`` 设置为 ``2`` 并将 ``One Shot`` 属性"
"设置为“启用”。"

msgid "Now add this script to ``HUD``:"
msgstr "现将这个脚本添加到 ``HUD``\\ ："

msgid ""
"The ``start_game`` signal tells the ``Main`` node that the button has been "
"pressed."
msgstr "``start_game`` 信号通知 ``Main`` 节点，按钮已经被按下。"

msgid ""
"This function is called when we want to display a message temporarily, such "
"as \"Get Ready\"."
msgstr "当想显示一条临时消息时，比如“Get Ready”，就会调用这个函数。"

msgid ""
"This function is called when the player loses. It will show \"Game Over\" "
"for 2 seconds, then return to the title screen and, after a brief pause, "
"show the \"Start\" button."
msgstr ""
"当玩家死亡时调用这个函数。将显示“Game Over”2 秒，然后返回标题屏幕并显"
"示“Start”按钮。"

msgid ""
"When you need to pause for a brief time, an alternative to using a Timer "
"node is to use the SceneTree's ``create_timer()`` function. This can be very "
"useful to add delays such as in the above code, where we want to wait some "
"time before showing the \"Start\" button."
msgstr ""
"当您需要暂停片刻时，可以使用场景树的 ``get_tree().create_timer(2)`` 函数替代"
"使用 ``Timer`` 节点。这对于延迟非常有用，例如在上述代码中，在这里我们需要在显"
"示“开始”按钮前等待片刻。"

msgid "This function is called by ``Main`` whenever the score changes."
msgstr "每当分数改变，这个函数会被 ``Main`` 调用。"

msgid ""
"Connect the ``timeout()`` signal of ``MessageTimer`` and the ``pressed()`` "
"signal of ``StartButton`` and add the following code to the new functions:"
msgstr ""
"连接 ``MessageTimer`` 的 ``timeout()`` 信号和 ``StartButton`` 的 "
"``pressed()`` 信号并添加以下代码到新函数中："

msgid "Connecting HUD to Main"
msgstr "将 HUD 场景连接到 Main 场景"

msgid ""
"Now that we're done creating the ``HUD`` scene, go back to ``Main``. "
"Instance the ``HUD`` scene in ``Main`` like you did the ``Player`` scene. "
"The scene tree should look like this, so make sure you didn't miss anything:"
msgstr ""
"现在我们完成了 ``HUD`` 场景，保存并返回 ``Main`` 场景。和 ``Player`` 场景的做"
"法一样，在 ``Main`` 场景中实例化 ``HUD`` 场景。如果您没有错过任何东西，完整的"
"场景树应该像这样："

msgid ""
"Now we need to connect the ``HUD`` functionality to our ``Main`` script. "
"This requires a few additions to the ``Main`` scene:"
msgstr ""
"现在我们需要将 ``HUD`` 功能与我们的 ``Main`` 脚本连接起来。这需要在 ``Main`` "
"场景中添加一些内容："

msgid ""
"In the Node tab, connect the HUD's ``start_game`` signal to the "
"``new_game()`` function of the Main node by typing \"new_game\" in the "
"\"Receiver Method\" in the \"Connect a Signal\" window. Verify that the "
"green connection icon now appears next to ``func new_game()`` in the script."
msgstr ""
"在节点选项卡中，通过在“连接信号”窗口的“接收方法”中键入 ``new_game``\\ ，将 "
"HUD 的 ``start_game`` 信号连接到主节点的 ``new_game()`` 函数。观察绿色的连接"
"图标现在是否在脚本中的 ``func new_game()`` 左边出现。"

msgid ""
"In ``new_game()``, update the score display and show the \"Get Ready\" "
"message:"
msgstr "在 ``new_game()`` 函数中，更新分数显示并显示“Get Ready”消息："

msgid "In ``game_over()`` we need to call the corresponding ``HUD`` function:"
msgstr "在 ``game_over()`` 中我们需要调用相应的 ``HUD`` 函数："

msgid ""
"Finally, add this to ``_on_ScoreTimer_timeout()`` to keep the display in "
"sync with the changing score:"
msgstr ""
"最后，将下面的代码添加到 ``_on_ScoreTimer_timeout()`` 以保持不断变化的分数的"
"同步显示："

msgid ""
"Now you're ready to play! Click the \"Play the Project\" button. You will be "
"asked to select a main scene, so choose ``Main.tscn``."
msgstr ""
"现在你可以开始游戏了！点击“运行项目”按钮。将要求你选择一个主场景，因此选择 "
"``Main.tscn``\\ 。"

msgid "Removing old creeps"
msgstr "删除旧的小怪"

msgid ""
"If you play until \"Game Over\" and then start a new game right away, the "
"creeps from the previous game may still be on the screen. It would be better "
"if they all disappeared at the start of a new game. We just need a way to "
"tell *all* the mobs to remove themselves. We can do this with the \"group\" "
"feature."
msgstr ""
"如果你一直玩到“游戏结束”，然后重新开始新游戏，上局游戏的小怪仍然显示在屏幕"
"上。更好的做法是在新游戏开始时清除它们。我们需要一个同时让\\ *所有*\\ 小怪删"
"除它自己的方法，为此可以使用“分组”功能。"

msgid ""
"In the ``Mob`` scene, select the root node and click the \"Node\" tab next "
"to the Inspector (the same place where you find the node's signals). Next to "
"\"Signals\", click \"Groups\" and you can type a new group name and click "
"\"Add\"."
msgstr ""
"在 ``Mob`` 场景中，选择根节点，然后单击检查器旁边的“节点”选项卡（在该位置可以"
"找到节点的信号）。 点击“信号”旁边的“分组”，然后可以输入新的组名称，点击“添"
"加”。"

msgid ""
"Now all mobs will be in the \"mobs\" group. We can then add the following "
"line to the ``new_game()`` function in ``Main``:"
msgstr ""
"现在，所有小怪都将属于“mobs”（小怪）分组。我们可以将以下行添加到 ``Main`` 中"
"的 ``new_game()`` 函数中："

msgid ""
"The ``call_group()`` function calls the named function on every node in a "
"group - in this case we are telling every mob to delete itself."
msgstr ""
"``call_group()`` 函数调用组中每个节点上的删除函数——让每个怪物删除其自身。"

msgid ""
"The game's mostly done at this point. In the next and last part, we'll "
"polish it a bit by adding a background, looping music, and some keyboard "
"shortcuts."
msgstr ""
"游戏在这一点上大部分已经完成。在下一部分和最后一部分中，我们将通过添加背景，"
"循环音乐和一些键盘快捷键来对其进行一些润色。"

msgid "Translation status"
msgstr "翻译状态"
