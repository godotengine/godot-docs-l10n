# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Coding the player"
msgstr "编写玩家代码"

msgid ""
"In this lesson, we'll add player movement, animation, and set it up to "
"detect collisions."
msgstr "在这一课中，我们将添加玩家的动作、动画，并将其设置为检测碰撞。"

msgid ""
"To do so, we need to add some functionality that we can't get from a built-"
"in node, so we'll add a script. Click the ``Player`` node and click the "
"\"Attach Script\" button:"
msgstr ""
"现在我们需要添加一些内置节点所不具备的功能，因此要添加一个脚本。点击 "
"``Player`` 节点然后点击“附加脚本”按钮："

msgid ""
"In the script settings window, you can leave the default settings alone. "
"Just click \"Create\":"
msgstr "在脚本设置窗口中，你可以维持默认设置。点击“创建”即可："

msgid ""
"If you're creating a C# script or other languages, select the language from "
"the `language` drop down menu before hitting create."
msgstr ""
"如果你要创建 C# 脚本或者其他语言的脚本，那就在创建之前在\\ `语言`\\ 下拉菜单"
"中选择语言。"

msgid ""
"If this is your first time encountering GDScript, please read :ref:"
"`doc_scripting` before continuing."
msgstr ""
"如果这是你第一次接触 GDScript，请在继续之前阅读 :ref:`doc_scripting`\\ 。"

msgid "Start by declaring the member variables this object will need:"
msgstr "首先声明该对象将需要的成员变量："

msgid ""
"Using the ``export`` keyword on the first variable ``speed`` allows us to "
"set its value in the Inspector. This can be handy for values that you want "
"to be able to adjust just like a node's built-in properties. Click on the "
"``Player`` node and you'll see the property now appears in the \"Script "
"Variables\" section of the Inspector. Remember, if you change the value "
"here, it will override the value written in the script."
msgstr ""
"在第一个变量 ``speed`` 上使用 ``export`` 关键字，这样我们就可以在“检查器”中设"
"置其值。对于希望能够像节点的内置属性一样进行调整的值，这可能很方便。点击 "
"``Player`` 节点，您将看到该属性现在显示在“检查器”的“Script Variables”（脚本变"
"量）部分。请记住，如果您在此处更改值，它将覆盖脚本中所写的值。"

msgid ""
"If you're using C#, you need to (re)build the project assemblies whenever "
"you want to see new export variables or signals. This build can be manually "
"triggered by clicking the word \"Mono\" at the bottom of the editor window "
"to reveal the Mono Panel, then clicking the \"Build Project\" button."
msgstr ""
"如果使用的是 C#，则每当要查看新的导出变量或信号时，都需要（重新）构建项目程序"
"集。点击编辑器窗口底部的“Mono”一词以显示 Mono 面板，然后单击“构建项目”按钮，"
"即可手动触发构建。"

msgid ""
"The ``_ready()`` function is called when a node enters the scene tree, which "
"is a good time to find the size of the game window:"
msgstr ""
"当节点进入场景树时，\\ ``_ready()`` 函数被调用，这是查看游戏窗口大小的好时"
"机："

msgid ""
"Now we can use the ``_process()`` function to define what the player will "
"do. ``_process()`` is called every frame, so we'll use it to update elements "
"of our game, which we expect will change often. For the player, we need to "
"do the following:"
msgstr ""
"现在我们可以使用 ``_process()`` 函数定义玩家将执行的操作。\\ ``_process()`` "
"在每一帧都被调用，因此我们将使用它来更新我们希望会经常变化的游戏元素。对于玩"
"家而言，我们需要执行以下操作："

msgid "Check for input."
msgstr "检查输入。"

msgid "Move in the given direction."
msgstr "沿给定方向移动。"

msgid "Play the appropriate animation."
msgstr "播放合适的动画。"

msgid ""
"First, we need to check for input - is the player pressing a key? For this "
"game, we have 4 direction inputs to check. Input actions are defined in the "
"Project Settings under \"Input Map\". Here, you can define custom events and "
"assign different keys, mouse events, or other inputs to them. For this game, "
"we will map the arrow keys to the four directions."
msgstr ""
"首先，我们需要检查输入——玩家是否正在按键？对于这个游戏，我们有 4 个方向的输入"
"要检查。输入动作在项目设置中的“输入映射”下定义。在这里，您可以定义自定义事"
"件，并为其分配不同的按键、鼠标事件、或者其他输入。对于此游戏，我们将把方向键"
"映射给四个方向。"

msgid ""
"Click on *Project -> Project Settings* to open the project settings window "
"and click on the *Input Map* tab at the top. Type \"move_right\" in the top "
"bar and click the \"Add\" button to add the ``move_right`` action."
msgstr ""
"点击\\ *项目 -> 项目设置*\\ 打开项目设置窗口，然后单击顶部的\\ *输入映射*\\ "
"选项卡。在顶部栏中键入“move_right”，然后单击“添加”按钮以添加该 "
"``move_right`` 动作。"

msgid ""
"We need to assign a key to this action. Click the \"+\" icon on the right, "
"then click the \"Key\" option in the drop-down menu. A dialog asks you to "
"type in the desired key. Press the right arrow on your keyboard and click "
"\"Ok\"."
msgstr ""
"我们需要给这个动作指定一个键。点击右边的“+”图标，然后点击下拉菜单中的“按键”选"
"项。会有一个对话框要求你键入所需的键。按键盘上的右箭头键，然后点击“确定”。"

msgid "Repeat these steps to add three more mappings:"
msgstr "重复这些步骤以再添加三个映射："

msgid "``move_left`` mapped to the left arrow key."
msgstr "``move_left`` 映射到左箭头键。"

msgid "``move_up`` mapped to the up arrow key."
msgstr "``move_up`` 映射到向上箭头键。"

msgid "And ``move_down`` mapped to the down arrow key."
msgstr "``move_down`` 映射到向下箭头键。"

msgid "Your input map tab should look like this:"
msgstr "按键映射选项卡应该看起来类似这样："

msgid "Click the \"Close\" button to close the project settings."
msgstr "单击“关闭”按钮关闭项目设置。"

msgid ""
"We only mapped one key to each input action, but you can map multiple keys, "
"joystick buttons, or mouse buttons to the same input action."
msgstr ""
"我们只将一个键映射到每个输入动作，但你可以将多个键、操纵杆按钮或鼠标按钮映射"
"到同一个输入动作。"

msgid ""
"You can detect whether a key is pressed using ``Input.is_action_pressed()``, "
"which returns ``true`` if it's pressed or ``false`` if it isn't."
msgstr ""
"您可以使用 ``Input.is_action_pressed()`` 来检测是否按下了键, 如果按下会返回 "
"``true``, 否则返回 ``false`` ."

msgid ""
"We start by setting the ``velocity`` to ``(0, 0)`` - by default, the player "
"should not be moving. Then we check each input and add/subtract from the "
"``velocity`` to obtain a total direction. For example, if you hold ``right`` "
"and ``down`` at the same time, the resulting ``velocity`` vector will be "
"``(1, 1)``. In this case, since we're adding a horizontal and a vertical "
"movement, the player would move *faster* diagonally than if it just moved "
"horizontally."
msgstr ""
"我们首先将 ``velocity`` 设置为 ``(0, 0)``\\ ——默认情况下玩家不应该移动。然后"
"我们检查每个输入并从 ``velocity`` 中进行加/减以获得总方向。例如，如果您同时按"
"住 ``右`` 和 ``下``\\ ，则生成的 ``velocity`` 向量将为 ``(1, 1)``\\ 。此时，"
"由于我们同时向水平和垂直两个方向进行移动，玩家斜向移动的速度将会比水平移动要"
"\\ *更快*\\ 。"

msgid ""
"We can prevent that if we *normalize* the velocity, which means we set its "
"*length* to ``1``, then multiply by the desired speed. This means no more "
"fast diagonal movement."
msgstr ""
"只要对速度进行\\ *归一化*\\ 就可以防止这种情况，也就是将速度的\\ *长度*\\ 设"
"置为 ``1``\\ ，然后乘以想要的速度。这样就不会有过快的斜向运动了。"

msgid ""
"If you've never used vector math before, or need a refresher, you can see an "
"explanation of vector usage in Godot at :ref:`doc_vector_math`. It's good to "
"know but won't be necessary for the rest of this tutorial."
msgstr ""
"如果您以前从未使用过向量数学，或者需要复习，可以在 Godot 中的 :ref:"
"`doc_vector_math` 上查看向量用法的解释。最好了解一下，但对于本教程的其余部分"
"而言，这不是必需的。"

msgid ""
"We also check whether the player is moving so we can call ``play()`` or "
"``stop()`` on the AnimatedSprite."
msgstr ""
"我们也要检查玩家是否在移动，以便在 AnimatedSprite 上调用 ``play()`` 或 "
"``stop()``\\ 。"

msgid ""
"``$`` is shorthand for ``get_node()``. So in the code above, "
"``$AnimatedSprite.play()`` is the same as ``get_node(\"AnimatedSprite\")."
"play()``."
msgstr ""
"``$`` 是 ``get_node()`` 的简写。因此在上面的代码中，\\ ``$AnimatedSprite."
"play()`` 与 ``get_node(\"AnimatedSprite\").play()`` 相同。"

msgid ""
"In GDScript, ``$`` returns the node at the relative path from the current "
"node, or returns ``null`` if the node is not found. Since AnimatedSprite is "
"a child of the current node, we can use ``$AnimatedSprite``."
msgstr ""
"在 GDScript 中，\\ ``$`` 返回相对于当前节点路径处的节点，如果找不到该节点，则"
"返回 ``null``\\ 。由于 AnimatedSprite 是当前节点的子项，因此我们可以使用 "
"``$AnimatedSprite``\\ 。"

msgid ""
"Now that we have a movement direction, we can update the player's position. "
"We can also use ``clamp()`` to prevent it from leaving the screen. "
"*Clamping* a value means restricting it to a given range. Add the following "
"to the bottom of the ``_process`` function (make sure it's not indented "
"under the `else`):"
msgstr ""
"现在我们有了一个运动方向，我们可以更新玩家的位置了。我们也可以使用 "
"``clamp()`` 来防止它离开屏幕。 *clamp* 一个值意味着将其限制在给定范围内。将以"
"下内容添加到 ``_process`` 函数的底部："

msgid ""
"The `delta` parameter in the `_process()` function refers to the *frame "
"length* - the amount of time that the previous frame took to complete. Using "
"this value ensures that your movement will remain consistent even if the "
"frame rate changes."
msgstr ""
"`_process()` 函数的 `delta` 参数是 *帧长度* ——完成上一帧所花费的时间. 使用这"
"个值的话, 可以保证你的移动不会被帧率的变化所影响."

msgid ""
"Click \"Play Scene\" (:kbd:`F6`, :kbd:`Cmd + R` on macOS) and confirm you "
"can move the player around the screen in all directions."
msgstr ""
"点击“运行场景”（\\ :kbd:`F6`\\ ，macOS 上为 :kbd:`Cmd + R`\\ ）并确认您能够在"
"屏幕中沿任一方向移动玩家。"

msgid "If you get an error in the \"Debugger\" panel that says"
msgstr "如果在“调试器”面板中出现错误"

msgid ""
"``Attempt to call function 'play' in base 'null instance' on a null "
"instance``"
msgstr ""
"``Attempt to call function 'play' in base 'null instance' on a null "
"instance``\\ （尝试调用空实例在基类“空实例”上的“play”函数）"

msgid ""
"this likely means you spelled the name of the AnimatedSprite node wrong. "
"Node names are case-sensitive and ``$NodeName`` must match the name you see "
"in the scene tree."
msgstr ""
"这可能意味着您拼错了 AnimatedSprite节点的名称。节点名称区分大小写，并且 "
"``$NodeName`` 必须与您在场景树中看到的名称匹配。"

msgid "Choosing animations"
msgstr "选择动画"

msgid ""
"Now that the player can move, we need to change which animation the "
"AnimatedSprite is playing based on its direction. We have the \"walk\" "
"animation, which shows the player walking to the right. This animation "
"should be flipped horizontally using the ``flip_h`` property for left "
"movement. We also have the \"up\" animation, which should be flipped "
"vertically with ``flip_v`` for downward movement. Let's place this code at "
"the end of the ``_process()`` function:"
msgstr ""
"现在玩家可以移动了，我们需要根据方向更改 AnimatedSprite 所播放的动画。我们"
"的“walk”动画显示的是玩家向右走。向左移动时就应该使用 ``flip_h`` 属性将这个动"
"画进行水平翻转。我们还有向上的“up”动画，向下移动时就应该使用 ``flip_v`` 将其"
"进行垂直翻转。让我们把这段代码放在 ``_process()`` 函数的末尾："

msgid ""
"The boolean assignments in the code above are a common shorthand for "
"programmers. Since we're doing a comparison test (boolean) and also "
"*assigning* a boolean value, we can do both at the same time. Consider this "
"code versus the one-line boolean assignment above:"
msgstr ""
"上面代码中的布尔赋值是程序员常用的缩写. 在做布尔比较同时, 同时可 *赋* 一个布"
"尔值. 参考这段代码与上面的单行布尔赋值:"

msgid ""
"Play the scene again and check that the animations are correct in each of "
"the directions."
msgstr "再次播放场景并检查每个方向上的动画是否正确."

msgid ""
"A common mistake here is to type the names of the animations wrong. The "
"animation names in the SpriteFrames panel must match what you type in the "
"code. If you named the animation ``\"Walk\"``, you must also use a capital "
"\"W\" in the code."
msgstr ""
"这里一个常见错误是打错了动画的名字。“动画帧”面板中的动画名称必须与在代码中键"
"入的内容匹配。如果你将动画命名成了 ``\"Walk\"``\\ ，就必须在代码中也使用大写"
"的“W”。"

msgid ""
"When you're sure the movement is working correctly, add this line to "
"``_ready()``, so the player will be hidden when the game starts:"
msgstr ""
"当您确定移动正常工作时， 请将此行添加到 ``_ready()`` 中，在游戏开始时隐藏玩"
"家："

msgid "Preparing for collisions"
msgstr "准备碰撞"

msgid ""
"We want ``Player`` to detect when it's hit by an enemy, but we haven't made "
"any enemies yet! That's OK, because we're going to use Godot's *signal* "
"functionality to make it work."
msgstr ""
"我们希望 ``Player`` 能够检测到何时被敌人击中, 但是我们还没有任何敌人！没关"
"系, 因为我们将使用Godot的 *信号* 功能来使其正常工作."

msgid "Add the following at the top of the script, after ``extends Area2D``:"
msgstr "在脚本开头, ``extends Area2d`` 下添加:"

msgid ""
"This defines a custom signal called \"hit\" that we will have our player "
"emit (send out) when it collides with an enemy. We will use ``Area2D`` to "
"detect the collision. Select the ``Player`` node and click the \"Node\" tab "
"next to the Inspector tab to see the list of signals the player can emit:"
msgstr ""
"这定义了一个叫作“hit”的自定义信号，当玩家与敌人碰撞时，我们会让他发出这个信"
"号。我们将使用 ``Area2D`` 来检测碰撞。选中 ``Player`` 节点，然后点击“检查"
"器”选项卡旁边的“节点”选项卡，就可以查看玩家可以发出的信号列表："

msgid ""
"Notice our custom \"hit\" signal is there as well! Since our enemies are "
"going to be ``RigidBody2D`` nodes, we want the ``body_entered(body: Node)`` "
"signal. This signal will be emitted when a body contacts the player. Click "
"\"Connect..\" and the \"Connect a Signal\" window appears. We don't need to "
"change any of these settings so click \"Connect\" again. Godot will "
"automatically create a function in your player's script."
msgstr ""
"请注意自定义的“hit”信号也在其中！由于敌人将是 ``RigidBody2D`` 节点，所以需要 "
"``body_entered(body: Node)`` 信号。当物体接触到玩家时就会发出这个信号。点"
"击“连接...”就会出现“连接信号”窗口。不需要改变这些设置，再次点击“连接”，Godot "
"会自动在你的玩家脚本中创建一个函数。"

msgid ""
"Note the green icon indicating that a signal is connected to this function. "
"Add this code to the function:"
msgstr ""
"请注意函数名旁的绿色图标, 这表示信号已经连接到这个函数. 将以下代码添加到函数"
"体中:"

msgid ""
"Each time an enemy hits the player, the signal is going to be emitted. We "
"need to disable the player's collision so that we don't trigger the ``hit`` "
"signal more than once."
msgstr ""
"敌人每次击中 玩家时都会发出一个信号。我们需要禁用玩家的碰撞检测，确保我们不会"
"多次触发 ``hit`` 信号。"

msgid ""
"Disabling the area's collision shape can cause an error if it happens in the "
"middle of the engine's collision processing. Using ``set_deferred()`` tells "
"Godot to wait to disable the shape until it's safe to do so."
msgstr ""
"如果在引擎的碰撞处理过程中禁用区域的碰撞形状可能会导致错误。使用 "
"``set_deferred()`` 告诉 Godot 等待可以安全地禁用形状时再这样做。"

msgid ""
"The last piece is to add a function we can call to reset the player when "
"starting a new game."
msgstr "最后再为玩家添加一个函数，用于在开始新游戏时调用来重置玩家。"

msgid "With the player working, we'll work on the enemy in the next lesson."
msgstr "在玩家部分的工作完成后，我们将在下一课中研究敌人。"

msgid "Translation status"
msgstr "翻译状态"
