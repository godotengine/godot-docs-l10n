# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 14:02+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Real Time Navigation (3D)"
msgstr "实时导航（3D）"

msgid "Introduction"
msgstr "前言"

msgid ""
"Pathfinding in a 3D environment is crucial for many games, it's commonly how "
"non directly controlled characters or entities find their way around an "
"environment. Godot provides several nodes for this purpose:"
msgstr ""
"很多游戏中 3D 环境的寻路都是非常重要的，常见的就是非直接控制的角色或者实体会"
"在环境中找到去路。Godot 为此提供了若干节点："

msgid ":ref:`Navigation<class_Navigation>` (deprecated)"
msgstr ":ref:`Navigation<class_Navigation>`\\ （已弃用）"

msgid ":ref:`NavigationMeshInstance<class_NavigationMeshInstance>`"
msgstr ":ref:`NavigationMeshInstance<class_NavigationMeshInstance>`"

msgid ":ref:`NavigationAgent<class_NavigationAgent>`"
msgstr ":ref:`NavigationAgent<class_NavigationAgent>`"

msgid ":ref:`NavigationObstacle<class_NavigationObstacle>`"
msgstr ":ref:`NavigationObstacle<class_NavigationObstacle>`"

msgid "The map and navigation regions"
msgstr "地图与导航地区"

msgid ""
"The \"map\" is the entire world for navigation, it's similar to \"space\" "
"for the physics engine. It's comprised of navigation regions, these regions "
"define parts of the world that can be navigated around by navigation agents."
msgstr ""
"“地图”是导航的完整世界，类似于物理引擎的“空间”。它由导航地区组成，这些地区定"
"义的是世界中导航代理能够到达的部分。"

msgid ""
"To create a navigation region add the :ref:"
"`NavigationMeshInstance<class_NavigationMeshInstance>` node to a 3D scene. "
"Next in the inspector for that mesh create or add a :ref:"
"`NavigationMesh<class_NavigationMesh>`. The navmesh contains options for how "
"it will be generated when it's baked. The geometry options control which "
"nodes, and types of nodes, are used to bake the mesh. A full description of "
"each setting and how it works can be found in the :ref:`NavigationMesh class "
"reference<class_NavigationMesh>`."
msgstr ""
"要创建导航地区，请在 3D 场景中添加 :ref:"
"`NavigationMeshInstance<class_NavigationMeshInstance>` 节点。然后，请在检查其"
"中为这个网格创建或者添加一个 :ref:`NavigationMesh<class_NavigationMesh>`。导"
"航网格包含了烘焙时应该如何将其生成的选项。几何体选项控制的是在烘焙网格的过程"
"中会用到哪些节点、哪些类型的节点。各个设置项的完整描述与工作原理可以在 :ref:"
"`NavigationMesh 类参考 <class_NavigationMesh>`\\ 中找到。"

msgid ""
"Once the settings have been properly configured press the \"Bake NavMesh\" "
"button at the top of the inspector to generate it."
msgstr "正确设置好之后，请在点击检查器顶部的“烘焙导航网格”按钮来生成网格。"

msgid ""
"It can also be generated at runtime using the `bake_navigation_region()` "
"method of the navigation region node."
msgstr "也可以在运行时使用导航网格的 `bake_navigation_region()` 方法来生成。"

msgid ""
"Once the mesh has finished generating you should see the transparent "
"navigation mesh above the areas in the scene that can be navigated to."
msgstr ""
"网格生成完后，你应该就能在场景中可以进行导航的位置上方看到半透明的导航网格"
"了。"

msgid ""
"Keep in mind that the navmesh shows where the center of an entity can go. "
"For example, if you set the agent radius to 0.5 then the navigation mesh "
"will have a distance of 0.5 from any ledges or walls to prevent clipping "
"into the wall or hanging off of the edge."
msgstr ""
"请注意，导航网格显示的是实体中心点所能到达的位置。例如，如果你将代理半径设为 "
"0.5，那么你的导航网格与台阶或者墙壁之间就会有 0.5 的距离，防止穿进墙壁或从边"
"缘掉下。"

msgid ""
"Navigation agents can moved from one region to another if they are next to "
"each other. Additionally a baked navmesh can be moved at runtime and agents "
"will still be able to navigate onto it from another region. For example, "
"navigating onto a moving platform that has stopped will work."
msgstr ""
"如果地区之间是紧挨着的，导航代理就可以从一个地区移动到另一个。另外烘焙出的导"
"航网格可以在运行时移动，代理仍然可以从其他地区导航到它上面。例如，导航到停止"
"的移动平台是可行的。"

#, fuzzy
msgid "NavigationAgent"
msgstr "NavigationAgent3D"

msgid ""
"Navigation agent nodes are what actually does the pathfinding in a scene, "
"one can be attached to the root node of an entity that needs to navigate."
msgstr ""
"导航代理节点是场景中实际进行寻路的东西，可以附加在需要导航的实体根节点下。"

msgid ""
"To have it pathfind use its `set_target_location` method. Once the target "
"has been set a path will be generated to the node using navigation regions, "
"with several points on the way to the final destination."
msgstr ""
"要让它进行寻路，请使用 `set_target_location` 方法。设置目的地之后，就会为使用"
"导航地区的节点生成一条路径，包含到达最终目的地一路上经过的点。"

msgid "RVO processing"
msgstr "RVO 处理"

msgid ""
"RVO stands for reciprocal velocity obstacle. RVO processing is a way to "
"pathfind while taking into account other agents and physics bodies that are "
"also moving."
msgstr ""
"RVO 即“相互速度障碍（Reciprocal Velocity Obstacle）”。RVO 处理是一种寻路方"
"法，会考虑其他代理以及同时在移动的物理实体。"

msgid ""
"To use it set a target like normal. Then an agent needs to fetch its next "
"nav path location, and compute its velocity to that location. Instead of "
"using that value to move use it to set the velocity on the agent with "
"`set_velocity`. Then a new velocity that takes into account other agents and "
"obstacles is generated and emitted with the signal `velocity_computed`."
msgstr ""
"使用方法是和平时一样设置目标，然后代理需要获取它导航路径上的下一个位置，计算"
"前往该位置所需的速度。这个值不用来移动，而是通过 `set_velocity` 将它设为代理"
"的速度。然后就会生成一个考虑了其他代理和障碍物的新速度，通过 "
"`velocity_computed` 信号发出。"

msgid ""
"However agents can only take into account a set number of other nearby "
"agents, this is the :ref:`max "
"neighbors<class_NavigationAgent_property_max_neighbors>` property of an "
"agent and can be adjusted. This is **not** a limit for how many agents can "
"use a navigation region at the same time."
msgstr ""
"不过代理只会考虑固定数量的周边代理，即代理的\\ :ref:`最大相邻数 "
"<class_NavigationAgent_property_max_neighbors>`\\ 属性，是可调的。这\\ *并不"
"是*\\ 对同时使用导航地区的代理数量的限制。"

#, fuzzy
msgid "NavigationObstacle"
msgstr "NavigationObstacle3D"

msgid ""
"This node is used to mark physics bodies that move around a navigation area "
"that agents need to avoid (this will only work if you use RVO processing). "
"For example, this node would be useful for pieces of debris in a "
"destructible environment. Add it as the child of a physics body and "
"navigation agent nodes will avoid it while pathfinding."
msgstr ""
"这个节点是用来标记物理实体的，表示它会在导航区域中移动，代理需要避让（只有在"
"使用 RVO 处理时才有效）。例如，这个节点可用于可破坏环境中的碎片。将它添加为物"
"理实体的子节点，导航代理节点就会在寻路时进行避让。"

msgid "Generating a path (old method)"
msgstr "生成路径（旧方法）"

msgid ""
"This is the old method for generating a navigation path, it will be removed "
"in Godot 4. First, add a navigation node to the scene, then add a navigation "
"mesh instance as it's child and set up a navigation mesh."
msgstr ""
"这是生成导航路径的旧方法，会在 Godot 4 中移除。首先在场景中添加一个导航节点，"
"然后再添加一个导航网格实例作为其子节点，并设置导航网格。"

msgid ""
"To get a path between two areas on a map you use the navigation node method "
"``get_simple_path()``. The first argument is a Vector3 of the starting "
"location, the next is a Vector3 of the end location. And the last argument "
"is a boolean for whether or not agent properties of a navmesh are considered "
"when generating a path."
msgstr ""
"要在地图上获取两个区域之间的路径，你可以使用导航节点的 ``get_simple_path()`` "
"方法。第一个参数是表示起始位置的 Vector3，接下来是表示结束位置的 Vector3。最"
"后一个参数是一个布尔值，表示是否需要在生成路径时考虑 agent 属性。"

msgid ""
"The method will return a :ref:`PoolVector3Array <class_PoolVector3Array>` "
"consisting of points that make a path. If there is no way to navigate to the "
"end location the method will return a blank :ref:`PoolVector3Array "
"<class_PoolVector3Array>`."
msgstr ""
"该方法返回的是一个 :ref:`PoolVector3Array <class_PoolVector3Array>`\\ ，由路"
"径上的点组成。如果无法导航至结束位置，该方法会返回一个空 :ref:"
"`PoolVector3Array <class_PoolVector3Array>`\\ 。"

msgid "Translation status"
msgstr "翻译状态"
