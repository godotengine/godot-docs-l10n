# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using AnimationTree"
msgstr "使用 AnimationTree"

msgid "Introduction"
msgstr "前言"

msgid ""
"With :ref:`AnimationPlayer <class_AnimationPlayer>`, Godot has one of the "
"most flexible animation systems that you can find in any game engine. The "
"ability to animate almost any property in any node or resource, as well as "
"having dedicated transform, bezier, function calling, audio and sub-"
"animation tracks, is pretty much unique."
msgstr ""
"通过 :ref:`AnimationPlayer <class_AnimationPlayer>`\\ ，Godot 拥有你在所有游"
"戏引擎中能找到的最灵活的动画系统之一。几乎可以在任何节点或资源中对任何属性进"
"行动画处理，以及专门的变换、贝塞尔、函数调用、音频和子动画轨道，这样的能力相"
"当独特。"

msgid ""
"However, the support for blending those animations via ``AnimationPlayer`` "
"is relatively limited, as only a fixed cross-fade transition time can be set."
msgstr ""
"然而, 通过 ``AnimationPlayer`` 混合这些动画的支持相对有限, 只能设置固定的交叉"
"渐变过渡时间."

msgid ""
":ref:`AnimationTree <class_AnimationTree>` is a new node introduced in Godot "
"3.1 to deal with advanced transitions. It supersedes the ancient "
"``AnimationTreePlayer``, while adding a huge amount of features and "
"flexibility."
msgstr ""
":ref:`AnimationTree <class_AnimationTree>` 是Godot 3.1中引入的一个新节点, 用"
"于处理更高级的变换, 它取代了旧的 ``AnimationTreePlayer`` , 同时增加了大量的功"
"能和灵活性."

msgid "Creating an AnimationTree"
msgstr "创建动画树"

msgid ""
"Before starting, it must be made clear that an ``AnimationTree`` node does "
"not contain its own animations. Instead, it uses animations contained in an "
"``AnimationPlayer`` node. This way, you can edit your animations (or import "
"them from a 3D scene) as usual and then use this extra node to control the "
"playback."
msgstr ""
"首先, 必须明确 ``AnimationTree`` 节点不包含它自己的动画. 相反, 它使用包含在 "
"``AnimationPlayer`` 节点中的动画. 通过这种形式, 您可以像往常一样编辑动画(或从"
"3D场景导入动画), 然后使用这个额外节点来控制播放."

msgid ""
"The most common way to use ``AnimationTree`` is in a 3D scene. When "
"importing your scenes from a 3D exchange format, they will usually come with "
"animations built-in (either multiple ones or split from a large one on "
"import). At the end, the imported Godot scene will contain the animations in "
"a ``AnimationPlayer`` node."
msgstr ""
"在3D场景中经常使用 ``AnimationTree`` . 当从3D交换格式导入场景时, 它们通常自带"
"动画(要么是多个, 要么是在导入时从一个大的动画中拆分出来). 最后, 导入的Godot场"
"景在 ``AnimationPlayer`` 节点中包含动画."

msgid ""
"As you rarely use imported scenes directly in Godot (they are either "
"instantiated or inherited from), you can place the ``AnimationTree`` node in "
"your new scene which contains the imported one. Afterwards, point the "
"``AnimationTree`` node to the ``AnimationPlayer`` that was created in the "
"imported scene."
msgstr ""
"很少在Godot中直接使用导入的场景(它们要么实例化, 要么来自继承), 您可以将 "
"``AnimationTree`` 节点放置在包含导入的新场景中. 然后, 将 ``AnimationTree`` 节"
"点指向导入场景内创建的 ``AnimationPlayer`` 节点."

msgid ""
"This is how it's done in the `Third Person Shooter demo <https://github.com/"
"godotengine/tps-demo>`_, for reference:"
msgstr ""
"这是在 `第三人称射击游戏演示 <https://github.com/godotengine/tps-demo>`_, 中"
"的设置, 参考下图:"

msgid ""
"A new scene was created for the player with a ``KinematicBody`` as root. "
"Inside this scene, the original ``.dae`` (Collada) file was instantiated and "
"an ``AnimationTree`` node was created."
msgstr ""
"为玩家创建了一个以 ``KinematicBody`` 为根节点的新场景. 在这个场景中, 已实例化"
"原来的 ``.dae`` (Collada)文件, 并创建 ``AnimationTree`` 节点."

msgid "Creating a tree"
msgstr "创建树"

msgid ""
"There are three main types of nodes that can be used in ``AnimationTree``:"
msgstr "可以在 ``AnimationTree`` 中使用三种主要节点类型:"

msgid ""
"Animation nodes, which reference an animation from the linked "
"``AnimationTree``."
msgstr "动画节点, 从链接的 ``AnimationTree`` 中引用动画."

msgid "Animation Root nodes, which are used to blend sub-nodes."
msgstr "动画根节点, 用于混合子节点."

msgid ""
"Animation Blend nodes, which are used within ``AnimationNodeBlendTree`` as "
"single-graph blending via multiple input ports."
msgstr ""
"动画混合节点，在 ``AnimationNodeBlendTree`` 中使用，通过多个输入端口进行单图"
"混合。"

msgid "To set a root node in ``AnimationTree``, a few types are available:"
msgstr "在 ``AnimationTree`` 中设置根节点, 如下几种类型可供选择:"

msgid ""
"``AnimationNodeAnimation``: Selects an animation from the list and plays it. "
"This is the simplest root node, and generally not used directly as root."
msgstr ""
"``AnimationNodeAnimation``\\ ：从列表中选择一个动画并播放它. 这是最简单的根节"
"点, 一般不直接用作根节点."

msgid ""
"``AnimationNodeBlendTree``: Contains many *blend* type nodes, such as mix, "
"blend2, blend3, one shot, etc. This is one of the most commonly used roots."
msgstr ""
"``AnimationNodeBlendTree``\\ ：包含许多\\ *混合*\\ 类型的节点，如调配, 混合"
"2, 混合3, 一对一等. 这是最常用的根节点之一."

msgid ""
"``AnimationNodeStateMachine``: Contains multiple root nodes as children in a "
"graph. Each node is used as a *state*, and provides multiple functions to "
"alternate between states."
msgstr ""
"``AnimationNodeStateMachine``\\ ：将多个根节点作为图中的子节点. 每个节点作为"
"一个 *状态* 使用, 并提供多个函数在状态之间进行切换."

msgid ""
"``AnimationNodeBlendSpace2D``: Allows placing root nodes in a 2D blend "
"space. Control the blend position in 2D to mix between multiple animations."
msgstr ""
"``AnimationNodeBlendSpace2D``\\ ：允许在二维混合空间中放置根节点. 在二维中控"
"制混合位置以混合多个动画."

msgid "``AnimationNodeBlendSpace1D``: Simplified version of the above (1D)."
msgstr "``AnimationNodeBlendSpace1D``\\ ：以上的简化版本（一维）。"

msgid "Blend tree"
msgstr "混合树"

msgid ""
"An ``AnimationNodeBlendTree`` can contain both root and regular nodes used "
"for blending. Nodes are added to the graph from a menu:"
msgstr ""
"``AnimationNodeBlendTree`` 可包含用于混合的根节点和常规节点。节点从菜单添加到"
"图中："

msgid ""
"All blend trees contain an ``Output`` node by default, and something has to "
"be connected to it in order for animations to play."
msgstr ""
"所有混合树默认都包含一个 ``Output``\\ （输出）节点，为了让动画播放，必须有个"
"东西与其相连。"

msgid ""
"The easiest way to test this functionality is to connect an ``Animation`` "
"node to it directly:"
msgstr "测试此功能最简单的方法是直接连接一个 ``Animation``\\ （动画）节点："

msgid ""
"This will simply play back the animation. Make sure that the "
"``AnimationTree`` is active for something to actually happen."
msgstr ""
"这会简单地回放动画. 确保 ``AnimationTree`` 节点对实际发生的事情是激活的."

msgid "Following is a short description of available nodes:"
msgstr "以下是可用节点的简短描述:"

msgid "Blend2 / Blend3"
msgstr "混合2/混合3"

msgid ""
"These nodes will blend between two or three inputs by a user-specified blend "
"value:"
msgstr "这些节点将通过用户指定输入的两个或三个混合值之间进行混合:"

msgid "For more complex blending, it is advised to use blend spaces instead."
msgstr "对于更复杂的混合, 建议使用混合空间."

msgid ""
"Blending can also use filters, i.e. you can control individually which "
"tracks go through the blend function. This is very useful for layering "
"animations on top of each other."
msgstr ""
"混合也可以使用过滤器, 也就是说, 您可以单独控制通过混合功能的轨道. 这对于动画"
"的层叠非常有用."

msgid "OneShot"
msgstr "OneShot"

msgid ""
"This node will execute a sub-animation and return once it finishes. Blend "
"times for fading in and out can be customized, as well as filters."
msgstr ""
"此节点将执行子动画, 并在完成后返回. 可以用于定制淡入淡出时间, 以及过滤器."

msgid "Seek"
msgstr "查找"

msgid ""
"This node can be used to cause a seek command to happen to any sub-children "
"of the animation graph. Use this node type to play an ``Animation`` from the "
"start or a certain playback position inside the ``AnimationNodeBlendTree``."
msgstr ""
"这个节点可以用来使寻找命令发生在动画图像的任何子代上。使用这个节点类型可以从 "
"``AnimationNodeBlendTree`` 中的开始或某个位置播放 ``Animation``\\ 。"

msgid ""
"After setting the time and changing the animation playback, the seek node "
"automatically goes into sleep mode on the next process frame by setting its "
"``seek_position`` value to ``-1.0``."
msgstr ""
"在设置时间和改变动画播放后，寻找节点通过设置其 ``seek_position`` 值为 "
"``-1.0``\\ ，在下一个进程帧自动进入睡眠模式。"

msgid "TimeScale"
msgstr "时间缩放"

msgid ""
"Allows scaling the speed of the animation (or reverse it) in any children "
"nodes. Setting it to 0 will pause the animation."
msgstr "允许缩放任何子节点的动画速度(或将其反转). 设置为0会暂停动画."

msgid "Transition"
msgstr "转换"

msgid ""
"Very simple state machine (when you don't want to cope with a "
"``StateMachine`` node). Animations can be connected to the outputs and "
"transition times can be specified."
msgstr ""
"非常简单的状态机（当您不想使用 ``StateMachine`` 节点时）。动画可以连接到输"
"出，并且可以指定过渡时间。"

msgid "BlendSpace2D"
msgstr "二维混合空间"

msgid ""
"``BlendSpace2D`` is a node to do advanced blending in two dimensions. Points "
"are added to a two-dimensional space and then a position can be controlled "
"to determine blending:"
msgstr ""
"``BlendSpace2D`` 是一个在二维空间进行高级混合的节点. 将点添加到一个二维空间, "
"然后可以控制位置来确定混合:"

msgid ""
"The ranges in X and Y can be controlled (and labeled for convenience). By "
"default, points can be placed anywhere (just right-click on the coordinate "
"system or use the *add point* button) and triangles will be generated "
"automatically using Delaunay."
msgstr ""
"可以控制X和Y的范围(为方便起见, 还可以标记它们). 默认情况下, 可以在任何位置放"
"置点(只需右键单击坐标系统或使用 *添加点* 按钮)将自动生成德洛内三角形."

msgid ""
"It is also possible to draw the triangles manually by disabling the *auto "
"triangle* option, though this is rarely necessary:"
msgstr ""
"也可以通过禁用 *自动三角形* 选项来手动绘制三角形, 虽然基本上没必要这么做:"

msgid ""
"Finally, it is possible to change the blend mode. By default, blending "
"happens by interpolating points inside the closest triangle. When dealing "
"with 2D animations (frame by frame), you may want to switch to *Discrete* "
"mode. Alternatively, if you want to keep the current play position when "
"switching between discrete animations, there is a *Carry* mode. This mode "
"can be changed in the *Blend* menu:"
msgstr ""
"最后, 可能会更改混合模式. 默认情况下, 混合是通过在最近的三角形内插点来实现"
"的. 当处理二维动画(逐帧)时, 您可能希望切换到 *离散* 模式. 此外, 如果您想在离"
"散动画之间切换时保持当前播放位置, 请使用 *进位* 模式. 此模式可在 *混合* 菜单"
"中更改:"

msgid "BlendSpace1D"
msgstr "一维混合空间"

msgid ""
"This is similar to 2D blend spaces, but in one dimension (so triangles are "
"not needed)."
msgstr "这类似于二维混合空间, 但在一维空间中(所以不需要三角形)."

msgid "StateMachine"
msgstr "状态机"

msgid ""
"This node acts as a state machine with root nodes as states. Root nodes can "
"be created and connected via lines. States are connected via *Transitions*, "
"which are connections with special properties. Transitions are uni-"
"directional, but two can be used to connect in both directions."
msgstr ""
"这个节点是一个状态机，根节点都是状态。根节点可以创建并通过线路连接。状态通过"
"\\ *转换*\\ 连接，它们是具有特殊性质的连接。转换是单向的，但是可以用两个来达"
"到双向连接。"

msgid "There are many types of transition:"
msgstr "有多种类型的转换："

msgid ""
"*Immediate*: Will switch to the next state immediately. The current state "
"will end and blend into the beginning of the new one."
msgstr ""
"*Immediate*\\ （立即）：将立即切换到下一个状态。当前状态将结束，并与新状态的"
"开头相混合。"

msgid ""
"*Sync*: Will switch to the next state immediately, but will seek the new "
"state to the playback position of the old state."
msgstr ""
"*Sync*\\ （同步）：立即切换到下一个状态，但会将新状态快进并到旧状态的播放位"
"置。"

msgid ""
"*At End*: Will wait for the current state playback to end, then switch to "
"the beginning of the next state animation."
msgstr ""
"*At End*\\ （末尾）：将等待当前状态播放结束，然后切换到下一个状态动画的开头。"

msgid ""
"Transitions also have a few properties. Click any transition and it will be "
"displayed in the inspector dock:"
msgstr "过渡也有一些属性。单击任何过渡，它就会显示在“检查器”面板中："

msgid ""
"*Switch Mode* is the transition type (see above), it can be modified after "
"creation here."
msgstr ""
"*Switch Mode*\\ （切换模式）为过渡类型（见上文），可以在此处创建后修改。"

msgid ""
"*Auto Advance* will turn on the transition automatically when this state is "
"reached. This works best with the *At End* switch mode."
msgstr ""
"*Auto Advance*\\ （自动前进）当达到此状态时将自动开启转换。最适合 *At End* 切"
"换模式。"

msgid ""
"*Advance Condition* will turn on auto advance when this condition is set. "
"This is a custom text field that can be filled with a variable name. The "
"variable can be modified from code (more on this later)."
msgstr ""
"*Advance Condition*\\ （前进条件）会在条件成立时打开自动前进。这是一个可以用"
"变量名填充的自定义文本字段。可以从代码中修改变量（稍后将对此进行详细介绍）。"

msgid "*Xfade Time* is the time to cross-fade between this state and the next."
msgstr ""
"*Xfade Time*\\ （叠化时间）是在这个状态和下一个状态之间交叉渐变的时间。"

msgid ""
"*Priority* is used together with the ``travel()`` function from code (more "
"on this later). Lower priority transitions are preferred when travelling "
"through the tree."
msgstr ""
"*Priority*\\ （优先级）与代码中的 ``travel()`` 函数一起使用（后述）。当从一个"
"状态到另一个状态时，会优先使用优先级较低的过渡。"

msgid ""
"*Disabled* toggles disabling this transition (when disabled, it will not be "
"used during travel or auto advance)."
msgstr ""
"*Disabled*\\ （禁用）允许禁用此转换（它不会在行程或自动前进期间使用）。"

msgid "Root motion"
msgstr "根骨骼运动"

msgid ""
"When working with 3D animations, a popular technique is for animators to use "
"the root skeleton bone to give motion to the rest of the skeleton. This "
"allows animating characters in a way where steps actually match the floor "
"below. It also allows precise interaction with objects during cinematics."
msgstr ""
"处理 3D 动画时，一种流行的技术是动画师利用根骨骼为其余部分骨骼制作运动动画。"
"这使得动画角色的脚步与下面的地板相匹配。并且允许在电影拍摄期间与物体进行精确"
"的交互。"

msgid ""
"When playing back the animation in Godot, it is possible to select this bone "
"as the *root motion track*. Doing so will cancel the bone transformation "
"visually (the animation will stay in place)."
msgstr ""
"在 Godot 中回放动画时，可以选择这根骨骼作为\\ *根运动轨迹*\\ 。这会在视觉上取"
"消这根骨骼的变换（动画将保持原状）。"

msgid ""
"Afterwards, the actual motion can be retrieved via the :ref:`AnimationTree "
"<class_AnimationTree>` API as a transform:"
msgstr ""
"然后, 实际运动可以通过 :ref:`AnimationTree <class_AnimationTree>` API 作为转"
"换:"

msgid ""
"This can be fed to functions such as :ref:`KinematicBody.move_and_slide "
"<class_KinematicBody_method_move_and_slide>` to control the character "
"movement."
msgstr ""
"可以提供给 :ref:`KinematicBody.move_and_slide "
"<class_KinematicBody_method_move_and_slide>` 等函数，用来控制角色移动。"

msgid ""
"There is also a tool node, ``RootMotionView``, that can be placed in a scene "
"and will act as a custom floor for your character and animations (this node "
"is disabled by default during the game)."
msgstr ""
"还有一个名为 ``RootMotionView`` 的工具节点，可以放置在场景中，作为你的角色和"
"动画的自定义地板（这个节点默认在游戏期间禁用）。"

msgid "Controlling from code"
msgstr "使用代码控制"

msgid ""
"After building the tree and previewing it, the only question remaining is "
"\"How is all this controlled from code?\"."
msgstr "创建树和预览之后，只剩下一个问题：“如何使用代码控制所有的节点？”。"

msgid ""
"Keep in mind that the animation nodes are just resources and, as such, they "
"are shared between all instances using them. Setting values in the nodes "
"directly will affect all instances of the scene that uses this "
"``AnimationTree``. This is generally undesirable, but does have some cool "
"use cases, e.g. you can copy and paste parts of your animation tree, or "
"reuse nodes with a complex layout (such as a state machine or blend space) "
"in different animation trees."
msgstr ""
"要注意动画节点就是资源，因此他们会在所有使用他们的实例之间共享。直接修改节点"
"中的值，将会影响到场景中所有使用这个 ``AnimationTree`` 的实例。通常是不希望这"
"样的，不过也有一些不错的用法，比如你可以复制粘贴你的动画树的一部分，或者在不"
"同的动画树中复用具有复杂布局的节点（例如状态机和混合树）。"

msgid ""
"The actual animation data is contained in the ``AnimationTree`` node and is "
"accessed via properties. Check the \"Parameters\" section of the "
"``AnimationTree`` node to see all the parameters that can be modified in "
"real-time:"
msgstr ""
"实际的动画数据包含在 ``AnimationTree`` 节点中, 并通过属性访问. 检查 "
"``AnimationTree`` 节点的 \"参数\" 部分, 查看所有可以实时修改的参数:"

msgid ""
"This is handy because it makes it possible to animate them from an "
"``AnimationPlayer``, or even the ``AnimationTree`` itself, allowing the "
"realization of very complex animation logic."
msgstr ""
"这很方便, 因为它可以通过 ``AnimationPlayer`` 获得动画效果, 甚至是 "
"``AnimationTree`` 本身, 允许实现非常复杂的动画逻辑."

msgid ""
"To modify these values from code, the property path must be obtained. This "
"is done easily by hovering the mouse over any of the parameters:"
msgstr ""
"想要通过代码修改这些值, 必须获得该属性的路径. 这是很容易做到的, 把鼠标悬停在"
"任何参数:"

msgid "Which allows setting them or reading them:"
msgstr "允许设置或读取它们:"

msgid "State machine travel"
msgstr "状态机行程"

msgid ""
"One of the nice features in Godot's ``StateMachine`` implementation is the "
"ability to travel. The graph can be instructed to go from the current state "
"to another one, while visiting all the intermediate ones. This is done via "
"the A\\* algorithm. In the absence of any viable set of transitions starting "
"at the current state and finishing at the destination state, the graph "
"teleports to the destination state."
msgstr ""
"Godot 的 ``StateMachine`` 实现提供了很多不错的功能，其中之一就是“行"
"程”（Travel）的能力。可以向图表发出指令，让其从当前状态转到另一个状态，所有的"
"中间状态都会被访问到。这是通过 A\\* 算法实现的。如果当前状态和目的状态之间不"
"存在任何可达的过渡路径集，图表就会立即传送到目的状态。"

msgid ""
"To use the travel ability, you should first retrieve the :ref:"
"`AnimationNodeStateMachinePlayback "
"<class_AnimationNodeStateMachinePlayback>` object from the ``AnimationTree`` "
"node (it is exported as a property)."
msgstr ""
"要使用行程能力, 您应该首先从 ``AnimationTree`` 节点中检索 :ref:"
"`AnimationNodeStateMachinePlayback "
"<class_AnimationNodeStateMachinePlayback>` 对象(其被导出为一个属性)."

msgid ""
"Once retrieved, it can be used by calling one of the many functions it "
"offers:"
msgstr "一旦检索到, 可以调用它提供的许多函数之一:"

msgid ""
"The state machine must be running before you can travel. Make sure to either "
"call ``start()`` or choose a node to **Autoplay on Load**."
msgstr ""
"状态机必须正在运行才能使用行程能力。确保调用 ``start()`` 或选择一个节点以\\ "
"**在加载时自动播放**\\ 。"

msgid "Translation status"
msgstr "翻译状态"
