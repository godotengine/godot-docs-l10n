# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using AnimationTree"
msgstr "使用 AnimationTree"

msgid "Introduction"
msgstr "前言"

msgid ""
"With :ref:`AnimationPlayer <class_AnimationPlayer>`, Godot has one of the "
"most flexible animation systems that you can find in any game engine. The "
"ability to animate almost any property in any node or resource, as well as "
"having dedicated transform, bezier, function calling, audio and sub-"
"animation tracks, is pretty much unique."
msgstr ""
"通过 :ref:`AnimationPlayer <class_AnimationPlayer>`\\ ，Godot 拥有你在所有游"
"戏引擎中能找到的最灵活的动画系统之一。几乎可以在任何节点或资源中对任何属性进"
"行动画处理，以及专门的变换、贝塞尔、函数调用、音频和子动画轨道，这样的能力相"
"当独特。"

msgid ""
"However, the support for blending those animations via ``AnimationPlayer`` "
"is relatively limited, as only a fixed cross-fade transition time can be set."
msgstr ""
"然而, 通过 ``AnimationPlayer`` 混合这些动画的支持相对有限, 只能设置固定的交叉"
"渐变过渡时间."

msgid ""
":ref:`AnimationTree <class_AnimationTree>` is a new node introduced in Godot "
"3.1 to deal with advanced transitions. It supersedes the ancient "
"``AnimationTreePlayer``, while adding a huge amount of features and "
"flexibility."
msgstr ""
":ref:`AnimationTree <class_AnimationTree>` 是Godot 3.1中引入的一个新节点, 用"
"于处理更高级的变换, 它取代了旧的 ``AnimationTreePlayer`` , 同时增加了大量的功"
"能和灵活性."

msgid "Creating an AnimationTree"
msgstr "创建动画树"

msgid ""
"Before starting, it must be made clear that an ``AnimationTree`` node does "
"not contain its own animations. Instead, it uses animations contained in an "
"``AnimationPlayer`` node. This way, you can edit your animations (or import "
"them from a 3D scene) as usual and then use this extra node to control the "
"playback."
msgstr ""
"首先, 必须明确 ``AnimationTree`` 节点不包含它自己的动画. 相反, 它使用包含在 "
"``AnimationPlayer`` 节点中的动画. 通过这种形式, 你可以像往常一样编辑动画(或从"
"3D场景导入动画), 然后使用这个额外节点来控制播放."

msgid ""
"The most common way to use ``AnimationTree`` is in a 3D scene. When "
"importing your scenes from a 3D exchange format, they will usually come with "
"animations built-in (either multiple ones or split from a large one on "
"import). At the end, the imported Godot scene will contain the animations in "
"a ``AnimationPlayer`` node."
msgstr ""
"在3D场景中经常使用 ``AnimationTree`` . 当从3D交换格式导入场景时, 它们通常自带"
"动画(要么是多个, 要么是在导入时从一个大的动画中拆分出来). 最后, 导入的Godot场"
"景在 ``AnimationPlayer`` 节点中包含动画."

msgid ""
"As you rarely use imported scenes directly in Godot (they are either "
"instantiated or inherited from), you can place the ``AnimationTree`` node in "
"your new scene which contains the imported one. Afterwards, point the "
"``AnimationTree`` node to the ``AnimationPlayer`` that was created in the "
"imported scene."
msgstr ""
"很少在Godot中直接使用导入的场景(它们要么实例化, 要么来自继承), 你可以将 "
"``AnimationTree`` 节点放置在包含导入的新场景中. 然后, 将 ``AnimationTree`` 节"
"点指向导入场景内创建的 ``AnimationPlayer`` 节点."

msgid ""
"This is how it's done in the `Third Person Shooter demo <https://github.com/"
"godotengine/tps-demo>`_, for reference:"
msgstr ""
"这是在 `第三人称射击游戏演示 <https://github.com/godotengine/tps-demo>`_, 中"
"的设置, 参考下图:"

msgid ""
"A new scene was created for the player with a ``CharacterBody3D`` as root. "
"Inside this scene, the original ``.dae`` (Collada) file was instantiated and "
"an ``AnimationTree`` node was created."
msgstr ""
"为玩家创建了一个以 ``KinematicBody`` 为根节点的新场景，在这个场景中，已实例化"
"原来的 ``.dae`` (Collada)文件，并创建 ``AnimationTree`` 节点。"

msgid "Creating a tree"
msgstr "创建树"

msgid ""
"There are three main types of nodes that can be used in ``AnimationTree``:"
msgstr "可以在 ``AnimationTree`` 中使用三种主要节点类型:"

msgid ""
"Animation nodes, which reference an animation from the linked "
"``AnimationPlayer``."
msgstr "动画节点，从链接的 ``AnimationTree`` 中引用动画。"

msgid "Animation Root nodes, which are used to blend sub-nodes."
msgstr "动画根节点, 用于混合子节点."

msgid ""
"Animation Blend nodes, which are used within ``AnimationNodeBlendTree`` as "
"single-graph blending via multiple input ports."
msgstr ""
"动画混合节点，在 ``AnimationNodeBlendTree`` 中使用，通过多个输入端口进行单图"
"混合。"

msgid "To set a root node in ``AnimationTree``, a few types are available:"
msgstr "在 ``AnimationTree`` 中设置根节点, 如下几种类型可供选择:"

msgid ""
"``AnimationNodeAnimation``: Selects an animation from the list and plays it. "
"This is the simplest root node, and generally not used directly as root."
msgstr ""
"``AnimationNodeAnimation``\\ ：从列表中选择一个动画并播放它. 这是最简单的根节"
"点, 一般不直接用作根节点."

msgid ""
"``AnimationNodeBlendTree``: Contains many *blend* type nodes, such as mix, "
"blend2, blend3, one shot, etc. This is one of the most commonly used roots."
msgstr ""
"``AnimationNodeBlendTree``\\ ：包含许多\\ *混合*\\ 类型的节点，如调配, 混合"
"2, 混合3, 一对一等. 这是最常用的根节点之一."

msgid ""
"``AnimationNodeStateMachine``: Contains multiple root nodes as children in a "
"graph. Each node is used as a *state*, and provides multiple functions to "
"alternate between states."
msgstr ""
"``AnimationNodeStateMachine``\\ ：将多个根节点作为图中的子节点. 每个节点作为"
"一个 *状态* 使用, 并提供多个函数在状态之间进行切换."

msgid ""
"``AnimationNodeBlendSpace2D``: Allows placing root nodes in a 2D blend "
"space. Control the blend position in 2D to mix between multiple animations."
msgstr ""
"``AnimationNodeBlendSpace2D``\\ ：允许在二维混合空间中放置根节点. 在二维中控"
"制混合位置以混合多个动画."

msgid "``AnimationNodeBlendSpace1D``: Simplified version of the above (1D)."
msgstr "``AnimationNodeBlendSpace1D``\\ ：以上的简化版本（一维）。"

msgid "Blend tree"
msgstr "混合树"

msgid ""
"An ``AnimationNodeBlendTree`` can contain both root and regular nodes used "
"for blending. Nodes are added to the graph from a menu:"
msgstr ""
"``AnimationNodeBlendTree`` 可包含用于混合的根节点和常规节点。节点从菜单添加到"
"图中："

msgid ""
"All blend trees contain an ``Output`` node by default, and something has to "
"be connected to it in order for animations to play."
msgstr ""
"所有混合树默认都包含一个 ``Output``\\ （输出）节点，为了让动画播放，必须有个"
"东西与其相连。"

msgid ""
"The easiest way to test this functionality is to connect an ``Animation`` "
"node to it directly:"
msgstr "测试此功能最简单的方法是直接连接一个 ``Animation``\\ （动画）节点："

msgid ""
"This will simply play back the animation. Make sure that the "
"``AnimationTree`` is active for something to actually happen."
msgstr ""
"这会简单地回放动画. 确保 ``AnimationTree`` 节点对实际发生的事情是激活的."

msgid "Following is a short description of available nodes:"
msgstr "以下是可用节点的简短描述:"

msgid "Blend2 / Blend3"
msgstr "混合2/混合3"

msgid ""
"These nodes will blend between two or three inputs by a user-specified blend "
"value:"
msgstr "这些节点将通过用户指定输入的两个或三个混合值之间进行混合:"

msgid "For more complex blending, it is advised to use blend spaces instead."
msgstr "对于更复杂的混合, 建议使用混合空间."

msgid ""
"Blending can also use filters, i.e. you can control individually which "
"tracks go through the blend function. This is very useful for layering "
"animations on top of each other."
msgstr ""
"混合也可以使用过滤器, 也就是说, 你可以单独控制通过混合功能的轨道. 这对于动画"
"的层叠非常有用."

msgid "OneShot"
msgstr "OneShot"

msgid ""
"This node will execute a sub-animation and return once it finishes. Blend "
"times for fading in and out can be customized, as well as filters."
msgstr ""
"此节点将执行子动画, 并在完成后返回. 可以用于定制淡入淡出时间, 以及过滤器."

msgid ""
"After setting the request and changing the animation playback, the one-shot "
"node automatically clears the request on the next process frame by setting "
"its ``request`` value to ``AnimationNodeOneShot.ONE_SHOT_REQUEST_NONE``."
msgstr ""
"在设置时间和改变动画播放后，播放节点会通过将其 ``request`` 值设置为 "
"``AnimationNodeOneShot.ONE_SHOT_REQUEST_NONE``/ 做到在下一个进程帧自动清除请"
"求。"

msgid "TimeSeek"
msgstr "时间缩放"

msgid ""
"This node can be used to cause a seek command to happen to any sub-children "
"of the animation graph. Use this node type to play an ``Animation`` from the "
"start or a certain playback position inside the ``AnimationNodeBlendTree``."
msgstr ""
"这个节点可以用来使寻找命令发生在动画图像的任何子代上。使用这个节点类型可以从 "
"``AnimationNodeBlendTree`` 中的开始或某个位置播放 ``Animation``\\ 。"

msgid ""
"After setting the time and changing the animation playback, the seek node "
"automatically goes into sleep mode on the next process frame by setting its "
"``seek_request`` value to ``-1.0``."
msgstr ""
"在设置时间和改变动画播放后，寻找节点通过设置其 ``seek_position`` 值为 "
"``-1.0``\\ ，在下一个进程帧自动进入睡眠模式。"

msgid "TimeScale"
msgstr "时间缩放"

msgid ""
"Allows scaling the speed of the animation (or reverse it) connected to the "
"`in` input via the `scale` parameter. Setting the `scale` to 0 will pause "
"the animation."
msgstr ""
"允许通过 `scale` 参数缩放连接到 `in` 输入的动画速度（或使其反转）。 将 "
"`scale` 设置为0会暂停动画。"

msgid "Transition"
msgstr "转换"

msgid ""
"Very simple state machine (when you don't want to cope with a "
"``StateMachine`` node). Animations can be connected to the outputs and "
"transition times can be specified. After setting the request and changing "
"the animation playback, the transition node automatically clears the request "
"on the next process frame by setting its ``transition_request`` value to an "
"empty string (``\"\"``)."
msgstr ""
"非常简单的状态机（当你不想使用 ``StateMachine`` 节点时）。动画可以连接到输"
"出，过渡时间可以指定。在设置请求和更改动画播放后，过渡节点会通过将其 "
"``transition_request`` 值设置为空字符串 (``\"\"``)，在下一个进程帧自动清除请"
"求。"

msgid "BlendSpace2D"
msgstr "二维混合空间"

msgid ""
"``BlendSpace2D`` is a node to do advanced blending in two dimensions. Points "
"are added to a two-dimensional space and then a position can be controlled "
"to determine blending:"
msgstr ""
"``BlendSpace2D`` 是一个在二维空间进行高级混合的节点. 将点添加到一个二维空间, "
"然后可以控制位置来确定混合:"

msgid ""
"The ranges in X and Y can be controlled (and labeled for convenience). By "
"default, points can be placed anywhere (right-click on the coordinate system "
"or use the *add point* button) and triangles will be generated automatically "
"using Delaunay."
msgstr ""
"可以控制X和Y的范围(为方便起见, 还可以标记它们). 默认情况下, 可以在任何位置放"
"置点(只需右键单击坐标系统或使用 *添加点* 按钮)将自动生成德洛内三角形."

msgid ""
"It is also possible to draw the triangles manually by disabling the *auto "
"triangle* option, though this is rarely necessary:"
msgstr ""
"也可以通过禁用 *自动三角形* 选项来手动绘制三角形, 虽然基本上没必要这么做:"

msgid ""
"Finally, it is possible to change the blend mode. By default, blending "
"happens by interpolating points inside the closest triangle. When dealing "
"with 2D animations (frame by frame), you may want to switch to *Discrete* "
"mode. Alternatively, if you want to keep the current play position when "
"switching between discrete animations, there is a *Carry* mode. This mode "
"can be changed in the *Blend* menu:"
msgstr ""
"最后, 可能会更改混合模式. 默认情况下, 混合是通过在最近的三角形内插点来实现"
"的. 当处理二维动画(逐帧)时, 你可能希望切换到 *离散* 模式. 此外, 如果你想在离"
"散动画之间切换时保持当前播放位置, 请使用 *进位* 模式. 此模式可在 *混合* 菜单"
"中更改:"

msgid "BlendSpace1D"
msgstr "一维混合空间"

msgid ""
"This is similar to 2D blend spaces, but in one dimension (so triangles are "
"not needed)."
msgstr "这类似于二维混合空间, 但在一维空间中(所以不需要三角形)."

msgid "StateMachine"
msgstr "状态机"

msgid ""
"This node acts as a state machine with root nodes as states. Root nodes can "
"be created and connected via lines. States are connected via *Transitions*, "
"which are connections with special properties. Transitions are uni-"
"directional, but two can be used to connect in both directions."
msgstr ""
"这个节点是一个状态机，根节点都是状态。根节点可以创建并通过线路连接。状态通过"
"\\ *转换*\\ 连接，它们是具有特殊性质的连接。转换是单向的，但是可以用两个来达"
"到双向连接。"

msgid "There are many types of transition:"
msgstr "有多种类型的转换："

msgid ""
"*Immediate*: Will switch to the next state immediately. The current state "
"will end and blend into the beginning of the new one."
msgstr ""
"*Immediate*\\ （立即）：将立即切换到下一个状态。当前状态将结束，并与新状态的"
"开头相混合。"

msgid ""
"*Sync*: Will switch to the next state immediately, but will seek the new "
"state to the playback position of the old state."
msgstr ""
"*Sync*\\ （同步）：立即切换到下一个状态，但会将新状态快进并到旧状态的播放位"
"置。"

msgid ""
"*At End*: Will wait for the current state playback to end, then switch to "
"the beginning of the next state animation."
msgstr ""
"*At End*\\ （末尾）：将等待当前状态播放结束，然后切换到下一个状态动画的开头。"

msgid ""
"Transitions also have a few properties. Click any transition and it will be "
"displayed in the inspector dock:"
msgstr "过渡也有一些属性。单击任何过渡，它就会显示在“检查器”面板中："

msgid ""
"*Switch Mode* is the transition type (see above), it can be modified after "
"creation here."
msgstr ""
"*Switch Mode*\\ （切换模式）为过渡类型（见上文），可以在此处创建后修改。"

msgid ""
"*Auto Advance* will turn on the transition automatically when this state is "
"reached. This works best with the *At End* switch mode."
msgstr ""
"*Auto Advance*\\ （自动前进）当达到此状态时将自动开启转换。最适合 *At End* 切"
"换模式。"

msgid ""
"*Advance Condition* will turn on auto advance when this condition is set. "
"This is a custom text field that can be filled with a variable name. The "
"variable can be modified from code (more on this later)."
msgstr ""
"*Advance Condition*\\ （前进条件）会在条件成立时打开自动前进。这是一个可以用"
"变量名填充的自定义文本字段。可以从代码中修改变量（稍后将对此进行详细介绍）。"

msgid "*Xfade Time* is the time to cross-fade between this state and the next."
msgstr ""
"*Xfade Time*\\ （叠化时间）是在这个状态和下一个状态之间交叉渐变的时间。"

msgid ""
"*Priority* is used together with the ``travel()`` function from code (more "
"on this later). Lower priority transitions are preferred when travelling "
"through the tree."
msgstr ""
"*Priority*\\ （优先级）与代码中的 ``travel()`` 函数一起使用（后述）。当从一个"
"状态到另一个状态时，会优先使用优先级较低的过渡。"

msgid ""
"*Disabled* toggles disabling this transition (when disabled, it will not be "
"used during travel or auto advance)."
msgstr ""
"*Disabled*\\ （禁用）允许禁用此转换（它不会在行程或自动前进期间使用）。"

msgid "For better blending"
msgstr "为了更好的混合"

msgid ""
"In Godot 4.0+, in order for the blending results to be deterministic "
"(reproducible and always consistent), the blended property values must have "
"a specific initial value. For example, in the case of two animations to be "
"blended, if one animation has a property track and the other does not, the "
"blended animation is calculated as if the latter animation had a property "
"track with the initial value."
msgstr ""
"在 Godot 4.0+ 中，为了使混合结果具有确定性（结果可复现且始终一致），混合属性"
"值必须具有特定的初始值。例如，在要混合两个动画的情况下，如果一个动画具有属性"
"轨道而另一个动画没有，则计算混合动画时，要好像后一个动画（即本来没有属性轨道"
"的那个）具有初始值的属性轨道一样去处理。"

msgid ""
"When using Position/Rotation/Scale 3D tracks for Skeleton3D bones, the "
"initial value is Bone Rest. For other properties, the initial value is ``0`` "
"and if the track is present in the ``RESET`` animation, the value of its "
"first keyframe is used instead."
msgstr ""
"当使用 Skeleton3D 骨骼的 Position/Rotation/Scale 3D 轨道时，初始值为 Bone "
"Rest（骨骼放松姿势）。对于其他属性而言，初始值是 ``0`` ，并且如果轨道出现在 "
"``RESET`` 动画中，那么则使用它第一个关键帧的值。"

msgid ""
"For example, the following AnimationPlayer has two animations, but one of "
"them lacks a Property track for Position."
msgstr ""
"例如，下面的 AnimationPlayer 有两个动画，但其中一个缺少 Position 的属性轨道。"

msgid ""
"This means that the animation lacking that will treat those Positions as "
"``Vector2(0, 0)``."
msgstr ""
"这意味着缺少该 Position 的动画会将这些 Position 视为 ``Vector2(0, 0)`` 。"

msgid ""
"This problem can be solved by adding a Property track for Position as an "
"initial value to the ``RESET`` animation."
msgstr ""
"可以通过将 Position 的 Property 轨道作为初始值添加到 ``RESET`` 动画中来解决这"
"个问题。"

msgid ""
"Be aware that the ``RESET`` animation exists to define the default pose when "
"loading an object originally. It is assumed to have only one frame and is "
"not expected to be played back using the timeline."
msgstr ""
"请注意， ``RESET`` 动画的存在是为了在最初加载对象时定义默认姿势。它被假定只有"
"一帧，并且不应使用时间轴进行播放。"

msgid ""
"Also keep in mind that the Rotation 3D tracks and the Property tracks for 2D "
"rotation with Interpolation Type set to Linear Angle or Cubic Angle will "
"prevent rotation of more than 180 degrees from the initial value as blended "
"animation."
msgstr ""
"另请记住，将“插值类型”设置为“线性角”或“三次角”的“Rotation 3D 轨道”和用于 2D "
"旋转的“属性”轨道，将阻止从初始值旋转超过 180 度的操作作为混合动画。"

msgid ""
"This can be useful for Skeleton3Ds to prevent the bones penetrating the body "
"when blending animations. Therefore, Skeleton3D's Bone Rest values should be "
"as close to the midpoint of the movable range as possible. **This means that "
"for humanoid models, it is preferable to import them in a T-pose**."
msgstr ""
"这种限制对于 Skeleton3D 非常有用，可以防止骨骼在混合动画时穿透身体。因此，"
"Skeleton3D 的 Bone Rest （骨骼放松姿势）值应尽可能接近可移动范围的中点。 **这"
"意味着人形模型最好以 T-pose 导入** 。"

msgid ""
"You can see that the shortest rotation path from Bone Rests is prioritized "
"rather than the shortest rotation path between animations."
msgstr ""
"你可以看到，优先考虑从 Bone Rest 出发的最短旋转路径，而不是动画之间的最短旋转"
"路径。"

msgid ""
"If you need to rotate Skeleton3D itself more than 180 degrees by blend "
"animations for movement, you can use Root Motion."
msgstr ""
"如果需要通过混合动画将 Skeleton3D 本身旋转 180 度以上，则可以使用 Root "
"Motion。"

msgid "Root motion"
msgstr "根骨骼运动"

msgid ""
"When working with 3D animations, a popular technique is for animators to use "
"the root skeleton bone to give motion to the rest of the skeleton. This "
"allows animating characters in a way where steps actually match the floor "
"below. It also allows precise interaction with objects during cinematics."
msgstr ""
"处理 3D 动画时，一种流行的技术是动画师利用根骨骼为其余部分骨骼制作运动动画。"
"这样处于动画角色的脚步就能够与下方的地板相匹配，并且还能够实现过场动画中与物"
"体的精确交互。"

msgid ""
"When playing back the animation in Godot, it is possible to select this bone "
"as the *root motion track*. Doing so will cancel the bone transformation "
"visually (the animation will stay in place)."
msgstr ""
"在 Godot 中回放动画时，可以将这根骨骼选作\\ *根运动轨道*\\ 。这会在视觉上取消"
"这根骨骼的变换（在原地播放动画）。"

msgid ""
"Afterwards, the actual motion can be retrieved via the :ref:`AnimationTree "
"<class_AnimationTree>` API as a transform:"
msgstr ""
"这样做以后，可以通过 :ref:`AnimationTree <class_AnimationTree>` API 获取实际"
"的变换："

msgid ""
"This can be fed to functions such as :ref:`CharacterBody3D.move_and_slide "
"<class_CharacterBody3D_method_move_and_slide>` to control the character "
"movement."
msgstr ""
"可以将这些值提供给 :ref:`CharacterBody3D.move_and_slide "
"<class_CharacterBody3D_method_move_and_slide>` 等函数，用来控制角色的移动。"

msgid ""
"There is also a tool node, ``RootMotionView``, that can be placed in a scene "
"and will act as a custom floor for your character and animations (this node "
"is disabled by default during the game)."
msgstr ""
"还有一个名为 ``RootMotionView`` 的工具节点，可以放置在场景中充当角色和动画的"
"自定义地板（这个节点默认在游戏期间禁用）。"

msgid "Controlling from code"
msgstr "使用代码控制"

msgid ""
"After building the tree and previewing it, the only question remaining is "
"\"How is all this controlled from code?\"."
msgstr "创建树和预览之后，就只剩下一个问题：“这些东西怎么使用代码来控制？”。"

msgid ""
"Keep in mind that the animation nodes are just resources and, as such, they "
"are shared between all instances using them. Setting values in the nodes "
"directly will affect all instances of the scene that uses this "
"``AnimationTree``. This is generally undesirable, but does have some cool "
"use cases, e.g. you can copy and paste parts of your animation tree, or "
"reuse nodes with a complex layout (such as a state machine or blend space) "
"in different animation trees."
msgstr ""
"要注意动画节点就是资源，因此他们会在所有使用他们的实例之间共享。直接修改节点"
"中的值，将会影响到场景中所有使用这个 ``AnimationTree`` 的实例。通常是不希望这"
"样的，不过也有一些不错的用法，比如你可以复制粘贴你的动画树的一部分，或者在不"
"同的动画树中复用具有复杂布局的节点（例如状态机和混合树）。"

msgid ""
"The actual animation data is contained in the ``AnimationTree`` node and is "
"accessed via properties. Check the \"Parameters\" section of the "
"``AnimationTree`` node to see all the parameters that can be modified in "
"real-time:"
msgstr ""
"实际的动画数据包含在 ``AnimationTree`` 节点中, 并通过属性访问. 检查 "
"``AnimationTree`` 节点的 \"参数\" 部分, 查看所有可以实时修改的参数:"

msgid ""
"This is handy because it makes it possible to animate them from an "
"``AnimationPlayer``, or even the ``AnimationTree`` itself, allowing the "
"realization of very complex animation logic."
msgstr ""
"这很方便, 因为它可以通过 ``AnimationPlayer`` 获得动画效果, 甚至是 "
"``AnimationTree`` 本身, 允许实现非常复杂的动画逻辑."

msgid ""
"To modify these values from code, the property path must be obtained. This "
"is done easily by hovering the mouse over any of the parameters:"
msgstr ""
"想要通过代码修改这些值, 必须获得该属性的路径. 这是很容易做到的, 把鼠标悬停在"
"任何参数:"

msgid "Which allows setting them or reading them:"
msgstr "允许设置或读取它们:"

msgid "State machine travel"
msgstr "状态机行程"

msgid ""
"One of the nice features in Godot's ``StateMachine`` implementation is the "
"ability to travel. The graph can be instructed to go from the current state "
"to another one, while visiting all the intermediate ones. This is done via "
"the A\\* algorithm. If there is no path of transitions starting at the "
"current state and finishing at the destination state, the graph teleports to "
"the destination state."
msgstr ""
"Godot 的 ``StateMachine`` 实现提供了很多不错的功能，其中之一就是“行"
"程”（Travel）的能力。可以向图发出指令，让其从当前状态转到另一个状态，所有的中"
"间状态都会被访问到。这是通过 A\\* 算法实现的。如果当前状态和目的状态之间不存"
"在任何可达的过渡路径集，图就会立即传送到目的状态。"

msgid ""
"To use the travel ability, you should first retrieve the :ref:"
"`AnimationNodeStateMachinePlayback "
"<class_AnimationNodeStateMachinePlayback>` object from the ``AnimationTree`` "
"node (it is exported as a property)."
msgstr ""
"要使用行程能力, 你应该首先从 ``AnimationTree`` 节点中检索 :ref:"
"`AnimationNodeStateMachinePlayback "
"<class_AnimationNodeStateMachinePlayback>` 对象(其被导出为一个属性)."

msgid ""
"Once retrieved, it can be used by calling one of the many functions it "
"offers:"
msgstr "一旦检索到, 可以调用它提供的许多函数之一:"

msgid ""
"The state machine must be running before you can travel. Make sure to either "
"call ``start()`` or choose a node to **Autoplay on Load**."
msgstr ""
"状态机必须正在运行才能使用行程能力。确保调用 ``start()`` 或选择一个节点以\\ "
"**在加载时自动播放**\\ 。"

msgid "Translation status"
msgstr "翻译状态"
