# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Playing videos"
msgstr "播放视频"

msgid "Godot supports video playback with the :ref:`class_VideoPlayer` node."
msgstr "Godot 通过 :ref:`class_VideoPlayer` 节点支持视频的播放。"

msgid "Supported playback formats"
msgstr "支持的播放格式"

msgid ""
"The only supported format in core is **Ogg Theora** (not to be confused with "
"Ogg Vorbis audio). It's possible for extensions to bring support for "
"additional formats, but no such extensions exist yet as of July 2022."
msgstr ""
"核心中仅支持 **Ogg Theora** 格式（请勿与 Ogg Vorbis 音频混淆）。扩展可以支持"
"额外的格式，但是截止到 2022 年 7 月，还没有这种扩展存在。"

msgid ""
"H.264 and H.265 cannot be supported in core Godot, as they are both "
"encumbered by software patents. AV1 is royalty-free, but it remains slow to "
"decode on the CPU and hardware decoding support isn't readily available on "
"all GPUs in use yet."
msgstr ""
"Godot 核心无法支持 H.264 和 H.265，因为它们都被软件专利所限。AV1 不需要授权，"
"但 CPU 解码仍然很慢，也不是所有 GPU 都已支持硬件解码。"

msgid ""
"WebM is supported in core in Godot 3.x, but support for it will be removed "
"in 4.0 as it proved to be too buggy and difficult to maintain. Therefore, "
"**using WebM is not recommended**."
msgstr ""
"Godot 3.x 核心中支持 WebM，但是会在 4.0 中移除支持，因为 bug 很多难以维护。因"
"此\\ **不推荐使用 WebM**\\ 。"

msgid ""
"You may find videos with an ``.ogg`` or ``.ogx`` extensions, which are "
"generic extensions for data within an Ogg container."
msgstr ""
"你的视频可能使用的是 ``.ogg`` 或者 ``.ogx`` 扩展名，这是带有数据的 Ogg 容器的"
"通用扩展名。"

msgid ""
"Renaming these file extensions to ``.ogv`` *may* allow the videos to be "
"imported in Godot. However, not all files with ``.ogg`` or ``.ogx`` "
"extensions are videos - some of them may only contain audio."
msgstr ""
"将这些文件扩展名修改为 ``.ogv``\\ *可能*\\ 可以让视频在 Godot 中导入。不过，"
"并不是所有 ``.ogg`` 或 ``.ogx`` 扩展名的文件都是视频——有些可能只包含音频。"

msgid "Setting up VideoPlayer"
msgstr "设置 VideoPlayer"

msgid "Create a VideoPlayer node using the Create New Node dialog."
msgstr "使用“新建 Node”对话框创建 VideoPlayer 节点。"

msgid ""
"Select the VideoPlayer node in the scene tree dock, go to the inspector and "
"load an ``.ogv`` file in the Stream property."
msgstr ""
"在场景树面板上选中 VideoPlayer 节点，到检查器中为 Stream 属性加载 ``.ogv`` 文"
"件。"

msgid ""
"If you don't have your video in Ogg Theora format yet, jump to :ref:"
"`doc_playing_videos_recommended_theora_encoding_settings`."
msgstr ""
"如果你还没有把你的视频转为 Ogg Theora 格式，请跳转到 :ref:"
"`doc_playing_videos_recommended_theora_encoding_settings`。"

msgid ""
"If you want the video to play as soon as the scene is loaded, check "
"**Autoplay** in the inspector. If not, leave **Autoplay** disabled and call "
"``play()`` on the VideoPlayer node in a script to start playback when "
"desired."
msgstr ""
"如果你希望在场景加载时立即播放视频，请在检查器中勾选 **Autoplay**\\ 。否则，"
"请保持 **Autoplay** 关闭，并在需要时在脚本中调用 VideoPlayer 节点的 "
"``play()`` 开始播放。"

msgid "Handling resizing and different aspect ratios"
msgstr "处理大小变化及不同的纵横比"

msgid ""
"By default in Godot 4.0, the VideoPlayer will automatically be resized to "
"match the video's resolution. You can make it follow usual :ref:"
"`class_Control` sizing by enabling **Expand** on the VideoPlayer node."
msgstr ""
"Godot 4.0 中在默认情况下，VideoPlayer 会自动调整到与视频分辨率相匹配的大小。"
"你可以让它遵循普通的 :ref:`class_Control` 大小规则，启用 VideoPlayer 节点的 "
"**Expand** 即可。"

msgid ""
"To adjust how the VideoPlayer node resizes depending on window size, adjust "
"the anchors using the **Layout** menu at the top of the 2D editor viewport. "
"However, this setup may not be powerful enough to handle all use cases, such "
"as playing fullscreen videos without distorting the video (but with empty "
"space on the edges instead). For more control, you can use an :ref:"
"`class_AspectRatioContainer` node, which is designed to handle this kind of "
"use case:"
msgstr ""
"要调整 VideoPlayer 节点的大小随窗口大小改变的方式，请通过 2D 编辑器视口顶部的"
"\\ **布局**\\ 按钮调整锚点。不过，这种设置可能不足以处理所有可能的情况，例如"
"全屏播放视频但不造成形变（需要在边界处留白）。要进行精确的控制，你可以使用专"
"为处理这种情况设计的 :ref:`class_AspectRatioContainer` 节点："

msgid ""
"Add an AspectRatioContainer node. Make sure it is not a child of any other "
"container node. Select the AspectRatioContainer node, then set its "
"**Layout** at the top of the 2D editor to **Full Rect**. Set **Ratio** in "
"the AspectRatioContainer node to match your video's aspect ratio. You can "
"use math formulas in the inspector to help yourself. Remember to make one of "
"the operands a float. Otherwise, the division's result will always be an "
"integer."
msgstr ""
"添加一个 AspectRatioContainer 节点。请确保它不是任何其他容器节点的子节点。选"
"中该 AspectRatioContainer 节点，然后在 2D 编辑器的顶部将\\ **布局**\\ 设置为"
"\\ **整个矩形**\\ 。将 AspectRatioContainer 节点的 **Ratio（比例）**\\ 设置为"
"与你的视频的长宽比匹配的比例。你可以在检查器里直接输入数学公式。请记住要将其"
"中的一个操作数写成浮点形式，否则会得到整数的商。"

msgid ""
"AspectRatioContainer's Ratio property being modified in the editor inspector"
msgstr "在编辑器检查器中修改 AspectRatioContainer 的 Ratio 属性"

msgid "This will evaluate to (approximately) 1.777778"
msgstr "求值会得到（大约）1.777778"

msgid ""
"Once you've configured the AspectRatioContainer, reparent your VideoPlayer "
"node to be a child of the AspectRatioContainer node. Make sure **Expand** is "
"disabled on the VideoPlayer. Your video should now scale automatically to "
"fit the whole screen while avoiding distortion."
msgstr ""
"配置好 AspectRatioContainer 之后，请将你的 VideoPlayer 节点调整为该 "
"AspectRatioContainer 节点的子节点。请确保禁用了该 VideoPlayer 的 "
"**Expand**\\ 。你的视频现在应该就会自动适应到全屏的大小，不产生变形。"

msgid ""
"See :ref:`doc_multiple_resolutions` for more tips on supporting multiple "
"aspect ratios in your project."
msgstr ""
"更多在项目中支持不同的长宽比的技巧，请参阅 :ref:`doc_multiple_resolutions`。"

msgid "Displaying a video on a 3D surface"
msgstr "在 3D 表面上显示视频"

msgid ""
"Using a VideoPlayer node as a child of a :ref:`class_Viewport` node, it's "
"possible to display any 2D node on a 3D surface. For example, this can be "
"used to display animated billboards when frame-by-frame animation would "
"require too much memory."
msgstr ""
"使用 VideoPlayer 节点作为 :ref:`class_Viewport` 节点的子节点，就可以在 3D 表"
"面上显示任何 2D 节点。例如，可以用于显示动态的广告板，帧动画可能花费太多的内"
"存。"

msgid "This can be done with the following steps:"
msgstr "可以使用以下步骤实现："

msgid ""
"Create a :ref:`class_Viewport` node. Set its size to match your video's size "
"in pixels."
msgstr ""
"创建一个 :ref:`class_Viewport` 节点。将其设置为与你的视频大小相匹配的像素大"
"小。"

msgid ""
"Create a VideoPlayer node *as a child of the Viewport node* and specify a "
"video path in it. Make sure **Expand** is disabled, and enable **Autoplay** "
"if needed."
msgstr ""
"创建一个 VideoPlayer 节点\\ *作为该 Viewport 节点的子节点*\\ ，并为其指定一个"
"视频的路径。请确保禁用了 **Expand**\\ ，需要时启用 **Autoplay**\\ 。"

msgid ""
"Create a MeshInstance node with a PlaneMesh or QuadMesh resource in its Mesh "
"property. Resize the mesh to match the video's aspect ratio (otherwise, it "
"will appear distorted)."
msgstr ""
"创建一个 MeshInstance 节点，将其 Mesh 属性设为 PlaneMesh 或 QuadMesh。将该网"
"格的大小调整到与视频的长宽比一致（否则看上去就会变形）。"

msgid ""
"Create a new SpatialMaterial resource in the **Material Override** property "
"in the GeometryInstance section."
msgstr ""
"在 GeometryInstance 部分的 **Material Override** 属性中新建一个 "
"SpatialMaterial 资源。"

msgid ""
"Enable **Local To Scene** in the SpatialMaterial's Resource section (at the "
"bottom). This is *required* before you can use a ViewportTexture in its "
"Albedo Texture property."
msgstr ""
"在该 SpatialMaterial（底部）的 Resource 部分启用 **Local To Scene**\\ 。这是"
"在 Albedo Texture 属性中使用 ViewportTexture 所\\ *必须的*\\ 。"

msgid ""
"In the SpatialMaterial, set the **Albedo > Texture** property to **New "
"ViewportTexture**. Edit the new resource by clicking it, then specify the "
"path to the Viewport node in the **Viewport Path** property."
msgstr ""
"在该 SpatialMaterial 中，将 **Albedo > Texture** 属性设置为\\ **新建 "
"ViewportTexture**\\ 。点击编辑这个新的资源，在 **Viewport Path** 属性中指定指"
"向 Viewport 节点的路径。"

msgid ""
"Enable **Albedo Tex Force sRGB** in the SpatialMaterial to prevent colors "
"from being washed out."
msgstr ""
"在该 SpatialMaterial 中启用 **Albedo Tex Force sRGB**\\ ，防止颜色变化。"

msgid ""
"If the billboard is supposed to emit its own light, enable **Flags > "
"Unshaded** to improve rendering performance."
msgstr "如果广告板应该自发光，请启用 **Flags > Unshaded** 提升渲染性能。"

msgid ""
"See :ref:`doc_viewports` and the `GUI in 3D demo <https://github.com/"
"godotengine/godot-demo-projects/tree/master/viewport/gui_in_3d>`__ for more "
"information on setting this up."
msgstr ""
"更多关于设置的信息，请参阅 :ref:`doc_viewports` 和 `3D GUI 演示 <https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport/"
"gui_in_3d>`__\\ 。"

msgid "Video decoding conditions and recommended resolutions"
msgstr "视频解码条件及推荐分辨率"

msgid ""
"Video decoding is performed on the CPU, as GPUs don't have hardware "
"acceleration for decoding Theora videos. Modern desktop CPUs can decode Ogg "
"Theora videos at 1440p @ 60 FPS or more, but low-end mobile CPUs will likely "
"struggle with high-resolution videos."
msgstr ""
"由于 GPU 在解码 Theora 视频时没有硬件加速，所以视频解码是在 CPU 上执行的。现"
"代的桌面 CPU 可以以 1440p @ 60 FPS 或更高的速度解码 Ogg Theora 格式的视频，但"
"低端移动 CPU 处理高分辨率视频可能会比较吃力。"

msgid "To ensure your videos decode smoothly on varied hardware:"
msgstr "为了确保视频在各种硬件上都能够顺利解码："

msgid ""
"When developing games for desktop platforms, it's recommended to encode in "
"1080p at most (preferably at 30 FPS). Most people are still using 1080p or "
"lower resolution displays, so encoding higher-resolution videos may not be "
"worth the increased file size and CPU requirements."
msgstr ""
"为桌面平台开发游戏时，建议最多编码为 1080p（最好是 30 FPS）。大多数人还在使"
"用 1080p 或者更低分辨率的显示器，所以编码为更高分辨率的视频可能不值那些增大的"
"文件大小和 CPU 需求。"

msgid ""
"When developing games for mobile or web platforms, it's recommended to "
"encode in 720p at most (preferably at 30 FPS or even lower). The visual "
"difference between 720p and 1080p videos on a mobile device is usually not "
"that noticeable."
msgstr ""
"为移动和 Web 平台开发游戏时，建议最多编码为 720p（最好是 30 FPS 或更低）。移"
"动设备上 720p 和 1080p 的视频通常很难看出区别。"

msgid "Playback limitations"
msgstr "播放限制"

msgid ""
"There are several limitations with the current implementation of video "
"playback in Godot:"
msgstr "Godot 中目前的视频播放实现有一些限制："

msgid "Seeking a video to a certain point is not supported."
msgstr "不支持将视频跳跃到特定的时间点。"

msgid ""
"Changing playback speed is not supported. VideoPlayer also won't follow :ref:"
"`Engine.time_scale<class_Engine_property_time_scale>`."
msgstr ""
"不支持修改播放速度。VideoPlayer 也不会遵循 :ref:`Engine."
"time_scale<class_Engine_property_time_scale>`\\ 。"

msgid ""
"Looping is not supported, but you can connect a VideoPlayer's :ref:`finished "
"<class_VideoPlayer_signal_finished>` signal to a function that plays the "
"video again. However, this will cause a black frame to be visible when the "
"video restarts. This can be worked around by adding a fade to black in the "
"video file before the video ends, or by hiding the video for one frame and "
"displaying a TextureRect with a screenshot of the first frame of the video "
"until the video is restarted."
msgstr ""
"不支持循环播放，但你可以将 VideoPlayer 的 :ref:`finished "
"<class_VideoPlayer_signal_finished>` 信号连接到某个函数，在这个函数里重新播放"
"视频。不过，这样会在视频重启时显式一帧黑屏。变通方法是在视频文件的末尾加上淡"
"出到黑屏的效果，或者把视频隐藏一帧，在 TextureRect 上显示视频第一帧的截图，直"
"到视频重启为止。"

msgid "Streaming a video from a URL is not supported."
msgstr "不支持从 URL 播放视频流。"

msgid "Recommended Theora encoding settings"
msgstr "推荐 Theora 编码设置"

msgid ""
"A word of advice is to **avoid relying on built-in Ogg Theora exporters** "
"(most of the time). There are 2 reasons you may want to favor using an "
"external program to encode your video:"
msgstr ""
"建议是（在大多数情况下）\\ **避免依赖内置的 Ogg Theora 导出器**\\ 。你可能想"
"要优先使用外部程序编码视频的原因有 2 个："

msgid ""
"Some programs such as Blender can render to Ogg Theora. However, the default "
"quality presets are usually very low by today's standards. You may be able "
"to increase the quality options in the software you're using, but you may "
"find the output quality to remain less than ideal (given the increased file "
"size). This usually means that the software only supports encoding to "
"constant bit rate (CBR), instead of variable bit rate (VBR). VBR encoding "
"should be preferred in most scenarios as it provides a better quality to "
"file size ratio."
msgstr ""
"Blender 等程序可以渲染 Ogg Theora。然而，默认的质量预设就如今的标准而言通常是"
"非常低的。你可能可以在软件里提高质量选项，但输出的质量可能仍然不理想（提升了"
"文件大小）。这通常意味着那个软件只支持按照固定比特率（CBR）去进行编码，不支持"
"可变比特率（VBR）。大多数场合应该都优先使用 VBR 编码，因为在相同的文件大小下"
"能够提供更好的质量。"

msgid "Some other programs can't render to Ogg Theora at all."
msgstr "有些其他的程序根本无法渲染 Ogg Theora。"

msgid ""
"In this case, you can **render the video to an intermediate high-quality "
"format** (such as a high-bitrate H.264 video) then re-encode it to Ogg "
"Theora. Ideally, you should use a lossless or uncompressed format as an "
"intermediate format to maximize the quality of the output Ogg Theora video, "
"but this can require a lot of disk space."
msgstr ""
"在这种情况下，你可以\\ **将视频使用高质量格式渲染作为中介**\\ （例如高比特率 "
"H.264 视频），然后再重新编码成 Ogg Theora。理想情况下，你应该使用无损或者未压"
"缩格式作为中介格式，最大化输出 Ogg Theora 视频的质量，不过这样做会需要大量的"
"磁盘空间。"

msgid ""
"`HandBrake <https://handbrake.fr/>`__ (GUI) and `FFmpeg <https://ffmpeg.org/"
">`__ (CLI) are popular open source tools for this purpose. FFmpeg has a "
"steeper learning curve, but it's more powerful."
msgstr ""
"`HandBrake <https://handbrake.fr/>`__\\ （GUI）和 `FFmpeg <https://ffmpeg."
"org/>`__\\ （CLI）都是这方面非常流行的开源工具。FFmpeg 的学习曲线相对陡峭，但"
"功能也更强大。"

msgid ""
"Here are example FFmpeg commands to convert a MP4 video to Ogg Theora. Since "
"FFmpeg supports a lot of input formats, you should be able to use the "
"commands below with almost any input video format (AVI, MOV, WebM, …)."
msgstr ""
"这是将 MP4 视频转换为 Ogg Theora 的 FFmpeg 命令示例。因为 FFmpeg 支持很多输入"
"格式，几乎任何输入视频格式（AVI、MOV、WebM……）应该都可以使用下面的命令。"

msgid ""
"Make sure your copy of FFmpeg is compiled with libtheora and libvorbis "
"support. You can check this by running ``ffmpeg`` without any arguments, "
"then looking at the ``configuration:`` line in the command output."
msgstr ""
"请确保你的 FFmpeg 副本是启用 libtheora 和 libvorbis 编译的。检查方法是不带任"
"何参数执行 ``ffmpeg``\\ ，然后查看命令输出中的 ``configuration:`` 一行。"

msgid "Balancing quality and file size"
msgstr "平衡质量与文件大小"

msgid ""
"The **video quality** level (``-q:v``) must be between ``1`` and ``10``. "
"Quality ``6`` is a good compromise between quality and file size. If "
"encoding at a high resolution (such as 1440p or 4K), you will probably want "
"to decrease ``-q:v`` to ``5`` to keep file sizes reasonable. Since pixel "
"density is higher on a 1440p or 4K video, lower quality presets at higher "
"resolutions will look as good or better compared to low-resolution videos."
msgstr ""
"**视频质量**\\ 等级（\\ ``-q:v``\\ ）必须在 ``1`` 和 ``10`` 之间。将质量设为 "
"``6`` 是在质量和文件大小之间的一个不错的妥协。如果要编码较高的分辨率（例如 "
"1440p 或者 4K），你可能想要把 ``-q:v`` 降为 ``5``\\ ，把文件大小控制在合理的"
"范围内。因为 1440p 和 4K 视频的像素密度更高，相较于低分辨率的视频，较低的质量"
"预设看上去的效果是一样甚至更好的。"

msgid ""
"The **audio quality** level (``-q:a``) must be between ``-1`` and ``10``. "
"Quality ``6`` provides a good compromise between quality and file size. In "
"contrast to video quality, increasing audio quality doesn't increase the "
"output file size nearly as much. Therefore, if you want the cleanest audio "
"possible, you can increase this to ``9`` to get *perceptually lossless* "
"audio. This is especially valuable if your input file already uses lossy "
"audio compression. See `this page <https://wiki.hydrogenaud.io/index.php?"
"title=Recommended_Ogg_Vorbis#Recommended_Encoder_Settings>`__ for a table "
"listing Ogg Vorbis audio quality presets and their respective variable "
"bitrates."
msgstr ""
"** 音频质量**\\ 等级（\\ ``-q:a``\\ ）必须在 ``1`` 和 ``10`` 之间。将质量设"
"为 ``6`` 是在质量和文件大小之间的一个不错的妥协。与视频质量不同，提升音频质量"
"并不会显著增加输出文件的大小。因此，如果你想要尽可能清晰的音频，可以将其设为 "
"``9``\\ ，达到\\ *感知上无损*\\ 的音频。在你的输入文件使用的已经是无损音频压"
"缩时尤其有用。Ogg Vorbis 音频质量预设及其对应的可变比特率表见\\ `这个页面 "
"<https://wiki.hydrogenaud.io/index.php?"
"title=Recommended_Ogg_Vorbis#Recommended_Encoder_Settings>`__\\ 。"

msgid "FFmpeg: Convert while preserving original video resolution"
msgstr "FFmpeg：转换时保持原始视频分辨率"

msgid ""
"The following command converts the video while keeping its original "
"resolution. The video and audio's bitrate will be variable to maximize "
"quality while saving space in parts of the video/audio that don't require a "
"high bitrate (such as static scenes)."
msgstr ""
"以下命令会在保持原始分辨率的前提下对视频进行转换。视频和音频的比特率会被设为"
"可变，在最大化质量的同时在不需要高比特率视频/音频的时候节省空间（例如静态场"
"景）。"

msgid "FFmpeg: Resize the video then convert it"
msgstr "FFmpeg：调整视频大小并转换"

msgid ""
"The following command resizes a video to be 720 pixels tall (720p), while "
"preserving its existing aspect ratio. This helps decrease the file size "
"significantly if the source is recorded at a higher resolution than 720p:"
msgstr ""
"以下命令会在保持现有长宽比的前提下将视频调整到 720 像素高（720p）。如果原始文"
"件分辨率是大于 720p 的，就能够显著降低文件大小："

msgid "Translation status"
msgstr "翻译状态"
