# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Playing videos"
msgstr "播放视频"

msgid ""
"Godot supports video playback with the :ref:`class_VideoStreamPlayer` node."
msgstr "Godot 通过 :ref:`class_VideoStreamPlayer` 节点支持视频的播放。"

msgid "Supported playback formats"
msgstr "支持的播放格式"

msgid ""
"The only supported format in core is **Ogg Theora** (not to be confused with "
"Ogg Vorbis audio). It's possible for extensions to bring support for "
"additional formats, but no such extensions exist yet as of July 2022."
msgstr ""
"核心中仅支持 **Ogg Theora** 格式（请勿与 Ogg Vorbis 音频混淆）。扩展可以支持"
"额外的格式，但是截止到 2022 年 7 月，还没有这种扩展存在。"

msgid ""
"H.264 and H.265 cannot be supported in core Godot, as they are both "
"encumbered by software patents. AV1 is royalty-free, but it remains slow to "
"decode on the CPU and hardware decoding support isn't readily available on "
"all GPUs in use yet."
msgstr ""
"Godot 核心无法支持 H.264 和 H.265，因为它们都被软件专利所限。AV1 不需要授权，"
"但 CPU 解码仍然很慢，也不是所有 GPU 都已支持硬件解码。"

msgid ""
"WebM was supported in core in Godot 3.x, but support for it was removed in "
"4.0 as it was too buggy and difficult to maintain."
msgstr ""
"Godot 3.x 核心中支持 WebM，但是会在 4.0 中移除支持，因为 bug 很多且难以维护。"

msgid ""
"You may find videos with an ``.ogg`` or ``.ogx`` extensions, which are "
"generic extensions for data within an Ogg container."
msgstr ""
"你的视频可能使用的是 ``.ogg`` 或者 ``.ogx`` 扩展名，这是带有数据的 Ogg 容器的"
"通用扩展名。"

msgid ""
"Renaming these file extensions to ``.ogv`` *may* allow the videos to be "
"imported in Godot. However, not all files with ``.ogg`` or ``.ogx`` "
"extensions are videos - some of them may only contain audio."
msgstr ""
"将这些文件扩展名修改为 ``.ogv``\\ *可能*\\ 可以让视频在 Godot 中导入。不过，"
"并不是所有 ``.ogg`` 或 ``.ogx`` 扩展名的文件都是视频——有些可能只包含音频。"

msgid "Setting up VideoStreamPlayer"
msgstr "设置 VideoStreamPlayer"

msgid "Create a VideoStreamPlayer node using the Create New Node dialog."
msgstr "使用“新建 Node”对话框创建 VideoStreamPlayer 节点。"

msgid ""
"Select the VideoStreamPlayer node in the scene tree dock, go to the "
"inspector and load an ``.ogv`` file in the Stream property."
msgstr ""
"在场景树面板上选中 VideoStreamPlayer 节点，到检查器中为 Stream 属性加载 ``."
"ogv`` 文件。"

msgid ""
"If you don't have your video in Ogg Theora format yet, jump to :ref:"
"`doc_playing_videos_recommended_theora_encoding_settings`."
msgstr ""
"如果你还没有把你的视频转为 Ogg Theora 格式，请跳转到 :ref:"
"`doc_playing_videos_recommended_theora_encoding_settings`。"

msgid ""
"If you want the video to play as soon as the scene is loaded, check "
"**Autoplay** in the inspector. If not, leave **Autoplay** disabled and call "
"``play()`` on the VideoStreamPlayer node in a script to start playback when "
"desired."
msgstr ""
"如果你希望在场景加载时立即播放视频，请在检查器中勾选 **Autoplay**\\ 。否则，"
"请保持 **Autoplay** 关闭，并在需要时在脚本中调用 VideoStreamPlayer 节点的 "
"``play()`` 开始播放。"

msgid "Handling resizing and different aspect ratios"
msgstr "处理大小变化及不同的纵横比"

msgid ""
"By default in Godot 4.0, the VideoStreamPlayer will automatically be resized "
"to match the video's resolution. You can make it follow usual :ref:"
"`class_Control` sizing by enabling **Expand** on the VideoStreamPlayer node."
msgstr ""
"Godot 4.0 中在默认情况下，VideoStreamPlayer 会自动调整到与视频分辨率相匹配的"
"大小。你可以让它遵循普通的 :ref:`class_Control` 大小规则，启用 "
"VideoStreamPlayer 节点的 **Expand** 即可。"

msgid ""
"To adjust how the VideoStreamPlayer node resizes depending on window size, "
"adjust the anchors using the **Layout** menu at the top of the 2D editor "
"viewport. However, this setup may not be powerful enough to handle all use "
"cases, such as playing fullscreen videos without distorting the video (but "
"with empty space on the edges instead). For more control, you can use an :"
"ref:`class_AspectRatioContainer` node, which is designed to handle this kind "
"of use case:"
msgstr ""
"要调整 VideoStreamPlayer 节点的大小随窗口大小改变的方式，请通过 2D 编辑器视口"
"顶部的\\ **布局**\\ 按钮调整锚点。不过，这种设置可能不足以处理所有可能的情"
"况，例如全屏播放视频但不造成形变（需要在边界处留白）。要进行精确的控制，你可"
"以使用专为处理这种情况设计的 :ref:`class_AspectRatioContainer` 节点："

msgid ""
"Add an AspectRatioContainer node. Make sure it is not a child of any other "
"container node. Select the AspectRatioContainer node, then set its "
"**Layout** at the top of the 2D editor to **Full Rect**. Set **Ratio** in "
"the AspectRatioContainer node to match your video's aspect ratio. You can "
"use math formulas in the inspector to help yourself. Remember to make one of "
"the operands a float. Otherwise, the division's result will always be an "
"integer."
msgstr ""
"添加一个 AspectRatioContainer 节点。请确保它不是任何其他容器节点的子节点。选"
"中该 AspectRatioContainer 节点，然后在 2D 编辑器的顶部将\\ **布局**\\ 设置为"
"\\ **整个矩形**\\ 。将 AspectRatioContainer 节点的 **Ratio（比例）**\\ 设置为"
"与你的视频的长宽比匹配的比例。你可以在检查器里直接输入数学公式。请记住要将其"
"中的一个操作数写成浮点形式，否则会得到整数的商。"

msgid ""
"AspectRatioContainer's Ratio property being modified in the editor inspector"
msgstr "在编辑器检查器中修改 AspectRatioContainer 的 Ratio 属性"

msgid "This will evaluate to (approximately) 1.777778"
msgstr "求值会得到（大约）1.777778"

msgid ""
"Once you've configured the AspectRatioContainer, reparent your "
"VideoStreamPlayer node to be a child of the AspectRatioContainer node. Make "
"sure **Expand** is enabled on the VideoStreamPlayer. Your video should now "
"scale automatically to fit the whole screen while avoiding distortion."
msgstr ""
"配置好 AspectRatioContainer 之后，请将你的 VideoStreamPlayer 节点调整为该 "
"AspectRatioContainer 节点的子节点。请确保禁用了该 VideoPlayer 的 "
"**Expand**\\ 。你的视频现在应该就会自动适应到全屏的大小，不产生变形。"

msgid ""
"See :ref:`doc_multiple_resolutions` for more tips on supporting multiple "
"aspect ratios in your project."
msgstr ""
"更多在项目中支持不同的长宽比的技巧，请参阅 :ref:`doc_multiple_resolutions`。"

msgid "Displaying a video on a 3D surface"
msgstr "在 3D 表面上显示视频"

msgid ""
"Using a VideoStreamPlayer node as a child of a :ref:`class_SubViewport` "
"node, it's possible to display any 2D node on a 3D surface. For example, "
"this can be used to display animated billboards when frame-by-frame "
"animation would require too much memory."
msgstr ""
"使用 VideoStreamPlayer 节点作为 :ref:`class_SubViewport` 节点的子节点，就可以"
"在 3D 表面上显示任何 2D 节点。例如，可以用于显示动态的广告板，帧动画可能花费"
"太多的内存。"

msgid "This can be done with the following steps:"
msgstr "可以使用以下步骤实现："

msgid ""
"Create a :ref:`class_SubViewport` node. Set its size to match your video's "
"size in pixels."
msgstr ""
"创建一个 :ref:`class_SubViewport` 节点。将其设置为与你的视频大小相匹配的像素"
"大小。"

msgid ""
"Create a VideoStreamPlayer node *as a child of the SubViewport node* and "
"specify a video path in it. Make sure **Expand** is disabled, and enable "
"**Autoplay** if needed."
msgstr ""
"创建一个 VideoStreamPlayer 节点\\ *作为该 SubViewport 节点的子节点*\\ ，并为"
"其指定一个视频的路径。请确保禁用了 **Expand**\\ ，需要时启用 "
"**Autoplay**\\ 。"

msgid ""
"Create a MeshInstance3D node with a PlaneMesh or QuadMesh resource in its "
"Mesh property. Resize the mesh to match the video's aspect ratio (otherwise, "
"it will appear distorted)."
msgstr ""
"创建一个 MeshInstance3D 节点，将其 Mesh 属性设为 PlaneMesh 或 QuadMesh。将该"
"网格的大小调整到与视频的长宽比一致（否则看上去就会变形）。"

msgid ""
"Create a new StandardMaterial3D resource in the **Material Override** "
"property in the GeometryInstance3D section."
msgstr ""
"在 GeometryInstance3D 部分的 **Material Override** 属性中新建一个 "
"StandardMaterial3D 资源。"

msgid ""
"Enable **Local To Scene** in the StandardMaterial3D's Resource section (at "
"the bottom). This is *required* before you can use a ViewportTexture in its "
"Albedo Texture property."
msgstr ""
"在该 StandardMaterial3D（底部）的 Resource 部分启用 **Local To Scene**\\ 。这"
"是在 Albedo Texture 属性中使用 ViewportTexture 所\\ *必须的*\\ 。"

msgid ""
"In the StandardMaterial3D, set the **Albedo > Texture** property to **New "
"ViewportTexture**. Edit the new resource by clicking it, then specify the "
"path to the SubViewport node in the **Viewport Path** property."
msgstr ""
"在该 StandardMaterial3D中，将 **Albedo > Texture** 属性设置为\\ **新建 "
"ViewportTexture**\\ 。点击编辑这个新的资源，在 **Viewport Path** 属性中指定指"
"向 SubViewport 节点的路径。"

msgid ""
"Enable **Albedo Texture Force sRGB** in the StandardMaterial3D to prevent "
"colors from being washed out."
msgstr ""
"在该 StandardMaterial3D 中启用 **Albedo Texture Force sRGB**\\ ，防止颜色变"
"化。"

msgid ""
"If the billboard is supposed to emit its own light, set **Shading Mode** to "
"**Unshaded** to improve rendering performance."
msgstr ""
"如果广告板需要自发光，请将 **着色模式** 设置为 **无阴着色** 以提高渲染性能。"

msgid ""
"See :ref:`doc_viewports` and the `GUI in 3D demo <https://github.com/"
"godotengine/godot-demo-projects/tree/master/viewport/gui_in_3d>`__ for more "
"information on setting this up."
msgstr ""
"更多关于设置的信息，请参阅 :ref:`doc_viewports` 和 `3D GUI 演示 <https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport/"
"gui_in_3d>`__\\ 。"

msgid "Looping a video"
msgstr "循环视频"

msgid ""
"For looping a video, the **Loop** property can be enabled. This will "
"seamlessly restart the video when it reaches its end."
msgstr "要循环视频，可以启用 **Loop** 属性。这样视频在抵达末尾时就会无缝重启。"

msgid ""
"Note that setting the project setting **Video Delay Compensation** to a non-"
"zero value might cause your loop to not be seamless, because the "
"synchronization of audio and video takes place at the start of each loop "
"causing occasional missed frames. Set **Video Delay Compensation** in your "
"project settings to **0** to avoid frame drop issues."
msgstr ""
"请注意，将项目设置 **视频延迟补偿** 设置为非零的值可能会导致视频循环不再无"
"缝，因为音频和视频的同步发生在每个循环开始时，会导致偶尔丢失帧。将项目设置中"
"的 **视频延迟补偿** 设置为 **0** 以避免丢帧问题。"

msgid "Video decoding conditions and recommended resolutions"
msgstr "视频解码条件及推荐分辨率"

msgid ""
"Video decoding is performed on the CPU, as GPUs don't have hardware "
"acceleration for decoding Theora videos. Modern desktop CPUs can decode Ogg "
"Theora videos at 1440p @ 60 FPS or more, but low-end mobile CPUs will likely "
"struggle with high-resolution videos."
msgstr ""
"由于 GPU 在解码 Theora 视频时没有硬件加速，所以视频解码是在 CPU 上执行的。现"
"代的桌面 CPU 可以以 1440p @ 60 FPS 或更高的速度解码 Ogg Theora 格式的视频，但"
"低端移动 CPU 处理高分辨率视频可能会比较吃力。"

msgid "To ensure your videos decode smoothly on varied hardware:"
msgstr "为了确保视频在各种硬件上都能够顺利解码："

msgid ""
"When developing games for desktop platforms, it's recommended to encode in "
"1080p at most (preferably at 30 FPS). Most people are still using 1080p or "
"lower resolution displays, so encoding higher-resolution videos may not be "
"worth the increased file size and CPU requirements."
msgstr ""
"为桌面平台开发游戏时，建议最多编码为 1080p（最好是 30 FPS）。大多数人还在使"
"用 1080p 或者更低分辨率的显示器，所以编码为更高分辨率的视频可能不值那些增大的"
"文件大小和 CPU 需求。"

msgid ""
"When developing games for mobile or web platforms, it's recommended to "
"encode in 720p at most (preferably at 30 FPS or even lower). The visual "
"difference between 720p and 1080p videos on a mobile device is usually not "
"that noticeable."
msgstr ""
"为移动和 Web 平台开发游戏时，建议最多编码为 720p（最好是 30 FPS 或更低）。移"
"动设备上 720p 和 1080p 的视频通常很难看出区别。"

msgid "Playback limitations"
msgstr "播放限制"

msgid ""
"There are several limitations with the current implementation of video "
"playback in Godot:"
msgstr "Godot 中目前的视频播放实现有一些限制："

msgid "Seeking a video to a certain point is not supported."
msgstr "不支持将视频跳跃到特定的时间点。"

msgid ""
"Changing playback speed is not supported. VideoStreamPlayer also won't "
"follow :ref:`Engine.time_scale<class_Engine_property_time_scale>`."
msgstr ""
"不支持修改播放速度。VideoStreamPlayer 也不会遵循 :ref:`Engine."
"time_scale<class_Engine_property_time_scale>`\\ 。"

msgid "Streaming a video from a URL is not supported."
msgstr "不支持从 URL 播放视频流。"

msgid "Recommended Theora encoding settings"
msgstr "推荐 Theora 编码设置"

msgid ""
"A word of advice is to **avoid relying on built-in Ogg Theora exporters** "
"(most of the time). There are 2 reasons you may want to favor using an "
"external program to encode your video:"
msgstr ""
"建议是（在大多数情况下）\\ **避免依赖内置的 Ogg Theora 导出器**\\ 。你可能想"
"要优先使用外部程序编码视频的原因有 2 个："

msgid ""
"Some programs such as Blender can render to Ogg Theora. However, the default "
"quality presets are usually very low by today's standards. You may be able "
"to increase the quality options in the software you're using, but you may "
"find the output quality to remain less than ideal (given the increased file "
"size). This usually means that the software only supports encoding to "
"constant bit rate (CBR), instead of variable bit rate (VBR). VBR encoding "
"should be preferred in most scenarios as it provides a better quality to "
"file size ratio."
msgstr ""
"Blender 等程序可以渲染 Ogg Theora。然而，默认的质量预设就如今的标准而言通常是"
"非常低的。你可能可以在软件里提高质量选项，但输出的质量可能仍然不理想（提升了"
"文件大小）。这通常意味着那个软件只支持按照固定比特率（CBR）去进行编码，不支持"
"可变比特率（VBR）。大多数场合应该都优先使用 VBR 编码，因为在相同的文件大小下"
"能够提供更好的质量。"

msgid "Some other programs can't render to Ogg Theora at all."
msgstr "有些其他的程序根本无法渲染 Ogg Theora。"

msgid ""
"In this case, you can **render the video to an intermediate high-quality "
"format** (such as a high-bitrate H.264 video) then re-encode it to Ogg "
"Theora. Ideally, you should use a lossless or uncompressed format as an "
"intermediate format to maximize the quality of the output Ogg Theora video, "
"but this can require a lot of disk space."
msgstr ""
"在这种情况下，你可以\\ **将视频使用高质量格式渲染作为中介**\\ （例如高比特率 "
"H.264 视频），然后再重新编码成 Ogg Theora。理想情况下，你应该使用无损或者未压"
"缩格式作为中介格式，最大化输出 Ogg Theora 视频的质量，不过这样做会需要大量的"
"磁盘空间。"

msgid ""
"`HandBrake <https://handbrake.fr/>`__ (GUI) and `FFmpeg <https://ffmpeg.org/"
">`__ (CLI) are popular open source tools for this purpose. FFmpeg has a "
"steeper learning curve, but it's more powerful."
msgstr ""
"`HandBrake <https://handbrake.fr/>`__\\ （GUI）和 `FFmpeg <https://ffmpeg."
"org/>`__\\ （CLI）都是这方面非常流行的开源工具。FFmpeg 的学习曲线相对陡峭，但"
"功能也更强大。"

msgid ""
"Here are example FFmpeg commands to convert a MP4 video to Ogg Theora. Since "
"FFmpeg supports a lot of input formats, you should be able to use the "
"commands below with almost any input video format (AVI, MOV, WebM, …)."
msgstr ""
"这是将 MP4 视频转换为 Ogg Theora 的 FFmpeg 命令示例。因为 FFmpeg 支持很多输入"
"格式，几乎任何输入视频格式（AVI、MOV、WebM……）应该都可以使用下面的命令。"

msgid ""
"Make sure your copy of FFmpeg is compiled with libtheora and libvorbis "
"support. You can check this by running ``ffmpeg`` without any arguments, "
"then looking at the ``configuration:`` line in the command output."
msgstr ""
"请确保你的 FFmpeg 副本是启用 libtheora 和 libvorbis 编译的。检查方法是不带任"
"何参数执行 ``ffmpeg``\\ ，然后查看命令输出中的 ``configuration:`` 一行。"

msgid "Balancing quality and file size"
msgstr "平衡质量与文件大小"

msgid ""
"The **video quality** level (``-q:v``) must be between ``1`` and ``10``. "
"Quality ``6`` is a good compromise between quality and file size. If "
"encoding at a high resolution (such as 1440p or 4K), you will probably want "
"to decrease ``-q:v`` to ``5`` to keep file sizes reasonable. Since pixel "
"density is higher on a 1440p or 4K video, lower quality presets at higher "
"resolutions will look as good or better compared to low-resolution videos."
msgstr ""
"**视频质量**\\ 等级（\\ ``-q:v``\\ ）必须在 ``1`` 和 ``10`` 之间。将质量设为 "
"``6`` 是在质量和文件大小之间的一个不错的妥协。如果要编码较高的分辨率（例如 "
"1440p 或者 4K），你可能想要把 ``-q:v`` 降为 ``5``\\ ，把文件大小控制在合理的"
"范围内。因为 1440p 和 4K 视频的像素密度更高，相较于低分辨率的视频，较低的质量"
"预设看上去的效果是一样甚至更好的。"

msgid ""
"The **audio quality** level (``-q:a``) must be between ``-1`` and ``10``. "
"Quality ``6`` provides a good compromise between quality and file size. In "
"contrast to video quality, increasing audio quality doesn't increase the "
"output file size nearly as much. Therefore, if you want the cleanest audio "
"possible, you can increase this to ``9`` to get *perceptually lossless* "
"audio. This is especially valuable if your input file already uses lossy "
"audio compression. Higher quality audio does increase the CPU usage of the "
"decoder, so it might lead to audio dropouts in case of high system load. See "
"`this page <https://wiki.hydrogenaud.io/index.php?"
"title=Recommended_Ogg_Vorbis#Recommended_Encoder_Settings>`__ for a table "
"listing Ogg Vorbis audio quality presets and their respective variable "
"bitrates."
msgstr ""
"** 音频质量**\\ 等级（\\ ``-q:a``\\ ）必须在 ``-1`` 和 ``10`` 之间。将质量设"
"为 ``6`` 是在质量和文件大小之间的一个不错的妥协。与视频质量不同，提升音频质量"
"并不会显著增加输出文件的大小。因此，如果你想要尽可能清晰的音频，可以将其设为 "
"``9``\\ ，达到\\ *感知上无损*\\ 的音频。在你的输入文件使用的已经是有损音频压"
"缩时，这个设置尤其有用。更高质量的音频确实会增加解码器的 CPU 使用率，因此在系"
"统负载较高的情况下可能会导致音频丢失。Ogg Vorbis 音频质量预设及其对应的可变比"
"特率表见\\ `这个页面 <https://wiki.hydrogenaud.io/index.php?"
"title=Recommended_Ogg_Vorbis#Recommended_Encoder_Settings>`__\\ 。"

msgid "FFmpeg: Convert while preserving original video resolution"
msgstr "FFmpeg：转换时保持原始视频分辨率"

msgid ""
"The following command converts the video while keeping its original "
"resolution. The video and audio's bitrate will be variable to maximize "
"quality while saving space in parts of the video/audio that don't require a "
"high bitrate (such as static scenes)."
msgstr ""
"以下命令会在保持原始分辨率的前提下对视频进行转换。视频和音频的比特率会被设为"
"可变，在最大化质量的同时在不需要高比特率视频/音频的时候节省空间（例如静态场"
"景）。"

msgid "FFmpeg: Resize the video then convert it"
msgstr "FFmpeg：调整视频大小并转换"

msgid ""
"The following command resizes a video to be 720 pixels tall (720p), while "
"preserving its existing aspect ratio. This helps decrease the file size "
"significantly if the source is recorded at a higher resolution than 720p:"
msgstr ""
"以下命令会在保持现有长宽比的前提下将视频调整到 720 像素高（720p）。如果原始文"
"件分辨率是大于 720p 的，就能够显著降低文件大小："

msgid "Chroma Key Videos"
msgstr "色键视频"

msgid ""
"Chroma key, commonly known as the \"green screen\" or \"blue screen\" "
"effect, allows you to remove a specific color from an image or video and "
"replace it with another background. This effect is widely used in video "
"production to composite different elements together seamlessly."
msgstr ""
"色键（Chroma Key）也就是常说的“绿幕”“蓝幕”效果，能够移除图像或视频中的特定颜"
"色，替换为其他背景。这种效果在视频制作领域广泛使用，可以将不同的元素无缝合成"
"到一起。"

msgid ""
"We will achieve the chroma key effect by writing a custom shader in GDScript "
"and using a `VideoStreamPlayer` node to display the video content."
msgstr ""
"我们将通过在 GDScript 中编写自定义着色器，并使用 `VideoStreamPlayer` 节点来显"
"示视频内容来实现色键效果。"

msgid "Scene Setup"
msgstr "场景设置"

msgid ""
"Ensure that the scene contains a `VideoStreamPlayer` node to play the video "
"and a `Control` node to hold the UI elements for controlling the chroma key "
"effect."
msgstr ""
"确保场景包含用于播放视频的 `VideoStreamPlayer` 节点，和用于保存用于控制色键效"
"果的 UI 元素的 `Control` 节点。"

msgid "Writing the Custom Shader"
msgstr "编写自定义着色器"

msgid "To implement the chroma key effect, follow these steps:"
msgstr "要实现色键效果，请按照下列步骤操作："

msgid ""
"Select the `VideoStreamPlayer` node in the scene and go to its properties. "
"Under `CanvasItem > Material`, create a new shader named \"ChromaKeyShader."
"gdshader.\""
msgstr ""
"选择场景中的 `VideoStreamPlayer` 节点。转到该节点属性栏，在 `CanvasItem > "
"Material` 下，创建一个名为“ChromaKeyShader.gdshader”的新着色器。"

msgid ""
"In the \"ChromaKeyShader.gdshader\" file, write the custom shader code as "
"shown below:"
msgstr "在“ChromaKeyShader.gdshader”文件中，编写自定义着色器代码，如下所示："

msgid ""
"The shader uses the distance calculation to identify pixels close to the "
"chroma key color and discards them, effectively removing the selected color. "
"Pixels that are slightly further away from the chroma key color are faded "
"based on the fade_factor, blending them smoothly with the surrounding "
"colors. This process creates the desired chroma key effect, making it appear "
"as if the background has been replaced with another image or video."
msgstr ""
"着色器使用距离计算来识别接近色键颜色的像素并将其丢弃，从而有效地删除所选颜"
"色。距离色键颜色稍远的像素将根据 fade_factor 进行淡入淡出，从而使它们与周围的"
"颜色平滑地混合。此过程会创建所需的色键效果，使其看起来像是背景已被其他图像或"
"视频替换。"

msgid ""
"The code above represents a simple demonstration of the Chroma Key shader, "
"and users can customize it according to their specific requirements."
msgstr ""
"上面的代码是色键着色器的简单演示，用户可以根据自己的具体要求进行自定义。"

msgid "UI Controls"
msgstr "UI 控件"

msgid ""
"To allow users to manipulate the chroma key effect in real-time, we created "
"sliders in the `Control` node. The `Control` node's script contains the "
"following functions:"
msgstr ""
"为了允许用户实时操纵色键效果，我们在 `Control` 节点中创建了滑动条。 "
"`Control` 节点的脚本包含以下功能："

msgid ""
"also make sure that the range of the sliders are appropriate, our settings "
"are :"
msgstr "还要确保滑动条的范围合适，此处我们的设置是："

msgid "Signal Handling"
msgstr "信号处理"

msgid ""
"Connect the appropriate signal from the UI elements to the `Control` node's "
"script. you created in the `Control` node's script to control the chroma key "
"effect. These signal handlers will update the shader's uniform variables in "
"response to user input."
msgstr ""
"将适当的信号从 UI 元素连接到你创建的 `Control` 节点的脚本上，来控制色键效果。"
"这些信号处理函数会更新着色器的 uniform 变量，响应用户输入。"

msgid ""
"Save and run the scene to see the chroma key effect in action! With the "
"provided UI controls, you can now adjust the chroma key color, pickup range, "
"and fade amount in real-time, achieving the desired chroma key functionality "
"for your video content."
msgstr ""
"保存并运行场景来查看色键效果的实际表现！通过 godot 提供的 UI 控件，现在你可以"
"实时调整色键颜色、拾取范围（pickup range）和淡入度量（fade amount），从而为你"
"的视频内容实现所需的色键功能。"

msgid "Translation status"
msgstr "翻译状态"
