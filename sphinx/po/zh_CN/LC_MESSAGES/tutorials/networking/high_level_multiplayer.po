# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-19 11:09+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:4
msgid "High-level multiplayer"
msgstr "高级多人游戏"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:7
msgid "High-level vs low-level API"
msgstr "高层与低层API"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:9
msgid ""
"The following explains the differences of high- and low-level networking in "
"Godot as well as some fundamentals. If you want to jump in head-first and "
"add networking to your first nodes, skip to `Initializing the network`_ "
"below. But make sure to read the rest later on!"
msgstr ""
"下面解释了Godot高级, 低级网络的区别以及一些基本原理. 如果您等不及了且将网络添"
"加到您的第一个节点中, 请跳到下面的 `初始化网络`_ . 但是请确保稍后阅读其余部"
"分！"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:11
msgid ""
"Godot always supported standard low-level networking via UDP, TCP and some "
"higher level protocols such as SSL and HTTP. These protocols are flexible "
"and can be used for almost anything. However, using them to synchronize game "
"state manually can be a large amount of work. Sometimes that work can't be "
"avoided or is worth it, for example when working with a custom server "
"implementation on the backend. But in most cases, it's worthwhile to "
"consider Godot's high-level networking API, which sacrifices some of the "
"fine-grained control of low-level networking for greater ease of use."
msgstr ""
"Godot始终支持通过UDP, TCP 和一些更高级别的协议(如SSL和HTTP)进行标准的低级网络"
"连接. 这些协议非常灵活, 几乎可以用于任何事情. 然而, 使用它们来手动同步游戏状"
"态可能需要大量的工作. 有时这种工作是无法避免的, 或者是值得的, 例如在后台使用"
"自定义服务器实现时. 但在大多数情况下, 考虑Godot的高级网络API是值得的, 它牺牲"
"了对低级网络的一些细粒度控制, 以获得更大的易用性."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:14
msgid "This is due to the inherent limitations of the low-level protocols:"
msgstr "这是由于低级协议的固有限制:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:16
msgid ""
"TCP ensures packets will always arrive reliably and in order, but latency is "
"generally higher due to error correction. It's also quite a complex protocol "
"because it understands what a \"connection\" is, and optimizes for goals "
"that often don't suit applications like multiplayer games. Packets are "
"buffered to be sent in larger batches, trading less per-packet overhead for "
"higher latency. This can be useful for things like HTTP, but generally not "
"for games. Some of this can be configured and disabled (e.g. by disabling "
"\"Nagle's algorithm\" for the TCP connection)."
msgstr ""
"TCP确保包总是可靠地, 有序地到达, 但是由于错误纠正, 延迟通常更高. 它也是一个相"
"当复杂的协议, 因为它理解什么是 ``连接``, 并针对通常不适合多人游戏等应用程序的"
"目标进行优化. 包被缓冲成更大的批发送, 每包开销更少, 延迟更高. 这对于HTTP之类"
"的东西可能很有用, 但对于游戏通常不太有用. 其中一些可以配置和禁用(例如禁用TCP"
"连接的 \"Nagle's algorithm\" )."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:18
msgid ""
"UDP is a simpler protocol, which only sends packets (and has no concept of a "
"\"connection\"). No error correction makes it pretty quick (low latency), "
"but packets may be lost along the way or received in the wrong order. Added "
"to that, the MTU (maximum packet size) for UDP is generally low (only a few "
"hundred bytes), so transmitting larger packets means splitting them, "
"reorganizing them and retrying if a part fails."
msgstr ""
"UDP 是一个更简单的协议, 它只发送数据包(没有 \"连接\" 的概念). 没有错误纠正使"
"其非常快(低延迟), 但是包可能在过程中丢失或以错误的顺序接收. 此外,UDP 的 MTU "
"(最大数据包大小)通常很低(只有几百字节), 因此传输更大的数据包意味着对它们进行"
"分割, 重新组织它们, 并在部分失败时重试."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:23
msgid ""
"In general, TCP can be thought of as reliable, ordered, and slow; UDP as "
"unreliable, unordered and fast. Because of the large difference in "
"performance, it often makes sense to re-build the parts of TCP wanted for "
"games (optional reliability and packet order), while avoiding the unwanted "
"parts (congestion/traffic control features, Nagle's algorithm, etc). Due to "
"this, most game engines come with such an implementation, and Godot is no "
"exception."
msgstr ""
"一般来说,TCP 可以被认为是可靠的, 有序的和缓慢的; UDP则是不可靠, 无序, 但是速"
"度快. 由于性能上的巨大差异, 在避免不需要的部分(拥塞/流量控制特性, Nagle算法"
"等)的同时, 重新构建游戏所需的TCP部分(可选的可靠性和包顺序)通常是合理的. 正因"
"为如此, 大多数游戏引擎都带有这样的实现,Godot也不例外."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:26
msgid ""
"In summary, you can use the low-level networking API for maximum control and "
"implement everything on top of bare network protocols or use the high-level "
"API based on :ref:`SceneTree <class_SceneTree>` that does most of the heavy "
"lifting behind the scenes in a generally optimized way."
msgstr ""
"综上所述, 您可以使用低级网络API来实现最大限度的控制, 并在完全裸露的网络协议之"
"上实现所有功能, 或者使用基于 :ref:`SceneTree <class_SceneTree>` 的高级API, 后"
"者以通常以一种比较优化的方式在后台完成大部分繁重的工作."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:28
msgid ""
"Most of Godot's supported platforms offer all or most of the mentioned high- "
"and low-level networking features. As networking is always largely hardware "
"and operating system dependent, however, some features may change or not be "
"available on some target platforms. Most notably, the HTML5 platform "
"currently only offers WebSocket support and lacks some of the higher level "
"features as well as raw access to low-level protocols like TCP and UDP."
msgstr ""
"Godot支持的大多数平台都提供所有或大部分上述的高, 低网络功能. 但是, 由于网络在"
"很大程度上依赖于硬件和操作系统, 一些特性可能会改变, 或者在某些目标平台上不可"
"用. 最值得注意的是,HTML5平台目前只提供WebSocket支持, 缺乏一些高级功能, 以及对"
"TCP和UDP等低级协议的原始访问."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:34
msgid ""
"More about TCP/IP, UDP, and networking: https://gafferongames.com/post/"
"udp_vs_tcp/"
msgstr ""
"更多关于TCP/IP, UDP和网络的信息: https://gafferongames.com/post/udp_vs_tcp/"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:37
msgid ""
"Gaffer On Games has a lot of useful articles about networking in Games "
"(`here <https://gafferongames.com/categories/game-networking/>`__), "
"including the comprehensive `introduction to networking models in games "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."
msgstr ""
"Gaffer On Games有很多关于游戏中网络的有用文章( `这里 <https://gafferongames."
"com/categories/game-networking/>`__ ), 包括全面的 `游戏中的网络模型介绍 "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__ ."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:41
msgid ""
"If you want to use your low-level networking library of choice instead of "
"Godot's built-in networking, see here for an example: https://github.com/"
"PerduGames/gdnet3"
msgstr ""
"如果您想使用您选择的底层网络库来代替Godot的内置网络, 请参阅这里的示例 : "
"https://github.com/PerduGames/gdnet3"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:45
msgid ""
"Adding networking to your game comes with some responsibility. It can make "
"your application vulnerable if done wrong and may lead to cheats or "
"exploits. It may even allow an attacker to compromise the machines your "
"application runs on and use your servers to send spam, attack others or "
"steal your users data if they play your game."
msgstr ""
"在您的游戏中加入社交网络需要承担一定的责任. 如果做错了, 它会使您的应用程序很"
"容易受到攻击, 并可能导致欺骗或利用. 它甚至可能允许攻击者破坏您的应用程序运行"
"在的机器, 并使用您的服务器发送垃圾邮件, 攻击其他人或窃取您的用户数据, 如果他"
"们玩您的游戏."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:50
msgid ""
"This is always the case when networking is involved and has nothing to do "
"with Godot. You can of course experiment, but when you release a networked "
"application, always take care of any possible security concerns."
msgstr ""
"当涉及到网络而与Godot无关时, 情况总是如此. 当然, 您可以进行试验, 但是在发布网"
"络应用程序时, 请始终注意任何可能的安全问题."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:55
msgid "Mid level abstraction"
msgstr "中间层的抽象"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:57
msgid ""
"Before going into how we would like to synchronize a game across the "
"network, it can be helpful to understand how the base network API for "
"synchronization works."
msgstr ""
"在讨论我们希望如何跨网络同步游戏之前, 了解用于同步的基本网络API是如何工作的可"
"能会有所帮助."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:59
msgid ""
"Godot uses a mid-level object :ref:`NetworkedMultiplayerPeer "
"<class_NetworkedMultiplayerPeer>`. This object is not meant to be created "
"directly, but is designed so that several C++ implementations can provide it."
msgstr ""
"Godot使用了一个中层对象 :ref:`NetworkedMultiplayerPeer "
"<class_NetworkedMultiplayerPeer>`. 这个对象并不是直接创建的, 但经过设计, 以便"
"多个C++实现可以提供它."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:62
msgid ""
"This object extends from :ref:`PacketPeer <class_PacketPeer>`, so it "
"inherits all the useful methods for serializing, sending and receiving data. "
"On top of that, it adds methods to set a peer, transfer mode, etc. It also "
"includes signals that will let you know when peers connect or disconnect."
msgstr ""
"这个对象扩展自 :ref:`PacketPeer <class_PacketPeer>`, 因此它继承了所有用于序列"
"化, 发送和接收数据的方法. 除此之外, 它还添加了设置节点, 传输模式等的方法. 它"
"同时还包括当节点连接或断开时将通知您的信号."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:64
msgid ""
"This class interface can abstract most types of network layers, topologies "
"and libraries. By default, Godot provides an implementation based on ENet (:"
"ref:`NetworkedMultiplayerEnet <class_NetworkedMultiplayerENet>`), one based "
"on WebRTC (:ref:`WebRTCMultiplayer <class_WebRTCMultiplayer>`), and one "
"based on WebSocket (:ref:`WebSocketMultiplayerPeer "
"<class_WebSocketMultiplayerPeer>`), but this could be used to implement "
"mobile APIs (for ad hoc WiFi, Bluetooth) or custom device/console-specific "
"networking APIs."
msgstr ""
"这个类接口可以抽象出大多数类型的网络层, 拓扑结构和库。默认情况下，Godot提供了"
"一个基于ENet的实现( :ref:`NetworkedMultiplayerEnet "
"<class_NetworkedMultiplayerENet>`), 一个基于WebRTC的实现( :ref:"
"`WebRTCMultiplayer <class_WebRTCMultiplayer>`), 还有一个基于WebSocket的实现"
"( :ref:`WebSocketMultiplayerPeer<class_WebSocketMultiplayerPeer>`)，但这可以"
"用来实现移动API(用于特设的WiFi, 蓝牙)或自定义设备/控制台特定的网络API。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:70
msgid ""
"For most common cases, using this object directly is discouraged, as Godot "
"provides even higher level networking facilities. Yet it is made available "
"in case a game has specific needs for a lower level API."
msgstr ""
"大多数常见情况下, 不鼓励直接使用这个对象, 因为Godot提供了更高级别的网络使用. "
"只有当游戏对较低级别的API有特殊需求的情况下, 才使用它."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:74
msgid "Initializing the network"
msgstr "初始化网络"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:76
msgid ""
"The object that controls networking in Godot is the same one that controls "
"everything tree-related: :ref:`SceneTree <class_SceneTree>`."
msgstr ""
"在Godot中, 控制联网的对象与控制所有与树相关的东西的对象是相同的: :ref:"
"`SceneTree <class_SceneTree>`."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:78
msgid ""
"To initialize high-level networking, the SceneTree must be provided a "
"NetworkedMultiplayerPeer object."
msgstr ""
"为了初始化高级网络, 必须向SceneTree提供一个NetworkedMultiplayerPeer对象."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:80
msgid ""
"To create that object, it first has to be initialized as a server or client."
msgstr "要创建该对象, 首先必须将其初始化为服务器或客户端."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:82
msgid ""
"Initializing as a server, listening on the given port, with a given maximum "
"number of peers:"
msgstr "作为服务器初始化, 监听给定的端口, 指定最大节点的数量:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:90
msgid "Initializing as a client, connecting to a given IP and port:"
msgstr "作为客户端初始化, 连接到给定的IP和端口:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:98
msgid "Get the previously set network peer:"
msgstr "获取之前设置的网络客户端:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:104
msgid "Checking whether the tree is initialized as a server or client:"
msgstr "检查树是否被初始化为服务器或客户端:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:110
msgid "Terminating the networking feature:"
msgstr "停止联网功能:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:116
msgid ""
"(Although it may make sense to send a message first to let the other peers "
"know you're going away instead of letting the connection close or timeout, "
"depending on your game.)"
msgstr ""
"(更加合理的做法是, 首先发送消息让其他节点知道您正在离开, 而不是直接让连接关闭"
"或让连接超时, 但这也取决于您的游戏设计.)"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:120
msgid ""
"When exporting to Android, make sure to enable the [code]INTERNET[/code] "
"permission in the Android export preset before exporting the project or "
"using one-click deploy. Otherwise, network communication of any kind will be "
"blocked by Android."
msgstr ""
"当导出到安卓时，在导出项目或使用一键部署之前，确保在安卓导出预设中启用"
"[code]INTERNET[/code]权限。否则，任何形式的网络通信都会被安卓系统阻止。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:126
msgid "Managing connections"
msgstr "管理连接"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:128
msgid ""
"Some games accept connections at any time, others during the lobby phase. "
"Godot can be requested to no longer accept connections at any point (see "
"``set_refuse_new_network_connections(bool)`` and related methods on :ref:"
"`SceneTree <class_SceneTree>`). To manage who connects, Godot provides the "
"following signals in SceneTree:"
msgstr ""
"有些游戏在任何时候都可以接受连接, 也有游戏只在大厅阶段接受连接. 可以请求Godot"
"在任何时间点不再接受连接(参见 `set_refuse_new_network_connections(bool)` 和 :"
"ref:`SceneTree <class_SceneTree>` 的相关方法). 为了管理连接的节点,Godot在"
"SceneTree中提供了以下信号:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:131
msgid "Server and Clients:"
msgstr "服务器和客户端:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:133
msgid "``network_peer_connected(int id)``"
msgstr "``network_peer_connected(int id)``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:134
msgid "``network_peer_disconnected(int id)``"
msgstr "``network_peer_disconnected(int id)``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:136
msgid ""
"The above signals are called on every peer connected to the server "
"(including on the server) when a new peer connects or disconnects. Clients "
"will connect with a unique ID greater than 1, while network peer ID 1 is "
"always the server. Anything below 1 should be handled as invalid. You can "
"retrieve the ID for the local system via :ref:`SceneTree."
"get_network_unique_id() <class_SceneTree_method_get_network_unique_id>`. "
"These IDs will be useful mostly for lobby management and should generally be "
"stored, as they identify connected peers and thus players. You can also use "
"IDs to send messages only to certain peers."
msgstr ""
"当一个新的对等体连接或断开连接时, 上述信号在每个连接到服务器的对等体上被调"
"用, 包括服务器上. 客户端将以大于1的唯一ID连接, 而网络对等体ID 1始终是服务器. "
"任何低于1的东西都应该被当作无效处理. 你可以通过 :ref:`SceneTree."
"get_network_unique_id() <class_SceneTree_method_get_network_unique_id>` 检索"
"到本地系统的ID. 这些ID主要对大厅管理有用, 一般来说应该被储存起来, 因为它们可"
"以识别连接的同伴, 从而识别玩家. 你也可以使用ID只向某些对等体发送消息."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:142
msgid "Clients:"
msgstr "客户端:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:144
msgid "``connected_to_server``"
msgstr "``connected_to_server``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:145
msgid "``connection_failed``"
msgstr "``connection_failed``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:146
msgid "``server_disconnected``"
msgstr "``server_disconnected``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:148
msgid ""
"Again, all these functions are mainly useful for lobby management or for "
"adding/removing players on the fly. For these tasks, the server clearly has "
"to work as a server and you have to perform tasks manually such as sending a "
"newly connected player information about other already connected players (e."
"g. their names, stats, etc)."
msgstr ""
"同样, 所有这些功能主要用于大厅管理或即时添加/删除玩家. 对于这些任务, 服务器显"
"然必须作为一个服务工作, 你必须手动执行任务, 例如向新连接的玩家发送关于其他已"
"经连接的玩家的信息(例如他们的名字, 统计信息等)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:152
msgid ""
"Lobbies can be implemented any way you want, but the most common way is to "
"use a node with the same name across scenes in all peers. Generally, an "
"autoloaded node/singleton is a great fit for this, to always have access to, "
"e.g. \"/root/lobby\"."
msgstr ""
"您可以用任何您想要的方式实现大厅, 但是最常见的方式是用一个在所有游戏角色的场"
"景中具有相同名字的节点. 通常, 一个自动加载的节点/单例非常适合于此, 这样就可以"
"在任何时候访问它, 例如 ``/root/lobby`` ."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:156
msgid "RPC"
msgstr "RPC"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:158
msgid ""
"To communicate between peers, the easiest way is to use RPCs (remote "
"procedure calls). This is implemented as a set of functions in :ref:`Node "
"<class_Node>`:"
msgstr ""
"为了在节点之间进行通信, 最简单的方法是使用RPC(远程过程调用). 它是靠一组 :ref:"
"`Node <class_Node>` 的函数实现的:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:161
msgid "``rpc(\"function_name\", <optional_args>)``"
msgstr "``rpc(\"function_name\", <optional_args>)``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:162
msgid "``rpc_id(<peer_id>,\"function_name\", <optional_args>)``"
msgstr "``rpc_id(<peer_id>,\"function_name\", <optional_args>)``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:163
msgid "``rpc_unreliable(\"function_name\", <optional_args>)``"
msgstr "``rpc_unreliable(\"function_name\", <optional_args>)``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:164
msgid "``rpc_unreliable_id(<peer_id>, \"function_name\", <optional_args>)``"
msgstr "``rpc_unreliable_id(<peer_id>, \"function_name\", <optional_args>)``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:166
msgid "Synchronizing member variables is also possible:"
msgstr "同步成员变量也是可能的:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:168
msgid "``rset(\"variable\", value)``"
msgstr "``rset(\"variable\", value)``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:169
msgid "``rset_id(<peer_id>, \"variable\", value)``"
msgstr "``rset_id(<peer_id>, \"variable\", value)``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:170
msgid "``rset_unreliable(\"variable\", value)``"
msgstr "``rset_unreliable(\"variable\", value)``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:171
msgid "``rset_unreliable_id(<peer_id>, \"variable\", value)``"
msgstr "``rset_unreliable_id(<peer_id>, \"variable\", value)``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:173
msgid "Functions can be called in two fashions:"
msgstr "可以用两种方式来调用函数:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:175
msgid ""
"Reliable: the function call will arrive no matter what, but may take longer "
"because it will be re-transmitted in case of failure."
msgstr ""
"可靠的: 函数调用无论如何都会到达, 但是可能需要更长的时间, 因为在发生故障时它"
"将被重新发送."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:176
msgid ""
"Unreliable: if the function call does not arrive, it will not be re-"
"transmitted; but if it arrives, it will do it quickly."
msgstr ""
"不可靠: 如果函数调用没有到达, 它将不会被重新传送；但如果它到达了, 将迅速完成."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:178
msgid ""
"In most cases, reliable is desired. Unreliable is mostly useful when "
"synchronizing object positions (sync must happen constantly, and if a packet "
"is lost, it's not that bad because a new one will eventually arrive and it "
"would likely be outdated because the object moved further in the meantime, "
"even if it was resent reliably)."
msgstr ""
"在大多数情况下, 需要可靠的调用. 当同步对象位置时, 不可靠的调用才很有用(因为同"
"步必须持续发生, 如果包丢失, 这并不那么糟糕, 因为新的包最终会到达；同时包很可"
"能会过时, 因为对象在此期间进一步移动了, 即使它被可靠地怨恨)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:181
msgid ""
"There is also the ``get_rpc_sender_id`` function in ``SceneTree``, which can "
"be used to check which peer (or peer ID) sent an RPC."
msgstr ""
"``SceneTree`` 中还有 ``get_rpc_sender_id`` 函数, 可以用来检查哪个对等体(或对"
"等体ID)发送了RPC."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:184
msgid "Back to lobby"
msgstr "回到大厅"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:186
msgid ""
"Let's get back to the lobby. Imagine that each player that connects to the "
"server will tell everyone about it."
msgstr ""
"让我们回到大厅. 想象一下, 连接到服务器的每个游戏角色都会将他的到来告诉其他每"
"一个人."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:232
msgid ""
"You might have already noticed something different, which is the usage of "
"the ``remote`` keyword on the ``register_player`` function:"
msgstr ""
"你可能已经注意到了一些不同的东西, 那就是在 ``register_player`` 函数上使用了 "
"``remote`` 关键字:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:238
msgid ""
"This keyword has two main uses. The first is to let Godot know that this "
"function can be called from RPC. If no keywords are added, Godot will block "
"any attempts to call functions for security. This makes security work a lot "
"easier (so a client can't call a function to delete a file on another "
"client's system)."
msgstr ""
"这个关键字有两个主要用途. 第一是让Godot知道这个函数可以从RPC调用. 如果不加任"
"何关键字,Godot将阻止任何试图调用函数的行为, 以保证安全. 这使安全工作变得更加"
"容易(所以一个客户端不能调用一个函数来删除另一个客户端系统上的文件)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:242
msgid ""
"The second use is to specify how the function will be called via RPC. There "
"are four different keywords:"
msgstr "第二个用途是指定如何通过RPC调用该函数. 这里又有四个不同的关键字:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:244
msgid "``remote``"
msgstr "``remote``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:245
msgid "``remotesync``"
msgstr "``remotesync``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:246
msgid "``master``"
msgstr "``master``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:247
msgid "``puppet``"
msgstr "``puppet``"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:249
msgid ""
"The ``remote`` keyword means that the ``rpc()`` call will go via network and "
"execute remotely."
msgstr "``remote`` 关键字意味着 ``rpc()`` 调用将通过网络并远程执行."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:251
msgid ""
"The ``remotesync`` keyword means that the ``rpc()`` call will go via network "
"and execute remotely, but will also execute locally (do a normal function "
"call)."
msgstr ""
"``remotesync`` 关键字意味着 ``rpc()`` 调用将通过网络并远程执行, 但也会在本地"
"执行, 当做一个正常的函数调用."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:253
msgid ""
"The others will be explained further down. Note that you could also use the "
"``get_rpc_sender_id`` function on ``SceneTree`` to check which peer actually "
"made the RPC call to ``register_player``."
msgstr ""
"其他的将会进一步解释. 请注意, 你也可以使用 ``SceneTree`` 上的 "
"``get_rpc_sender_id`` 函数来检查哪个对等体实际上对 ``register_player`` 进行了"
"RPC调用."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:256
msgid ""
"With this, lobby management should be more or less explained. Once you have "
"your game going, you will most likely want to add some extra security to "
"make sure clients don't do anything funny (just validate the info they send "
"from time to time, or before game start). For the sake of simplicity and "
"because each game will share different information, this is not shown here."
msgstr ""
"有了这个, 大厅管理就应该或多或少的解释一下. 一旦你开始开发游戏, 很可能想增加"
"一些额外的安全性, 以确保客户不做任何有趣的事情(只是不时地验证他们发送的信息, "
"或在游戏开始前验证). 为了简单起见, 并且因为每个游戏将分享不同的信息, 所以就不"
"写这方面了."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:261
msgid "Starting the game"
msgstr "开始游戏"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:263
msgid ""
"Once enough players have gathered in the lobby, the server should probably "
"start the game. This is nothing special in itself, but we'll explain a few "
"nice tricks that can be done at this point to make your life much easier."
msgstr ""
"一旦有足够的游戏角色聚集在大厅时, 服务器应该开始游戏. 这本身没有什么特别的, "
"但是我们将解释一些很好的技巧, 这些技巧可以在这点上让您的生活更容易."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:267
msgid "Player scenes"
msgstr "游戏角色场景"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:269
msgid ""
"In most games, each player will likely have its own scene. Remember that "
"this is a multiplayer game, so in every peer you need to instance **one "
"scene for each player connected to it**. For a 4 player game, each peer "
"needs to instance 4 player nodes."
msgstr ""
"在大多数游戏中, 每个游戏角色都可能有自己的场景. 请记住, 这是一个多人游戏, 所"
"以在每个客户端中, 您需要为连接到它的每个游戏角色实例化 **一个场景** . 对于一"
"个4人游戏, 每个客户端需要4个游戏角色节点实例."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:272
msgid ""
"So, how to name such nodes? In Godot, nodes need to have a unique name. It "
"must also be relatively easy for a player to tell which node represents each "
"player ID."
msgstr ""
"那么, 如何命名这样的节点呢？在Godot中, 节点需要有一个独特的名字. 对于玩家来"
"说, 也必须比较容易分辨出哪个节点代表每个玩家的ID."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:275
msgid ""
"The solution is to simply name the *root nodes of the instanced player "
"scenes as their network ID*. This way, they will be the same in every peer "
"and RPC will work great! Here is an example:"
msgstr ""
"解决方案是简单地将 *实例化后的游戏角色场景的根节点命名为它的网络ID* . 这样, "
"它们在每一个客户端中都是一样的,RPC调用也会很容易！下面是一个示例:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:305
msgid ""
"Depending on when you execute pre_configure_game(), you may need to change "
"any calls to ``add_child()`` to be deferred via ``call_deferred()``, as the "
"SceneTree is locked while the scene is being created (e.g. when ``_ready()`` "
"is being called)."
msgstr ""
"根据执行pre_configure_game()的时间, 您可能需要将对 ``add_child()`` 的任何调用"
"更改为通过 ``call_deferred()`` 进行延迟, 因为SceneTree在创建场景时被锁定(例"
"如, 当 ``_ready()`` 被调用)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:309
msgid "Synchronizing game start"
msgstr "同步游戏开始"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:311
msgid ""
"Setting up players might take different amounts of time for every peer due "
"to lag, different hardware, or other reasons. To make sure the game will "
"actually start when everyone is ready, pausing the game until all players "
"are ready can be useful:"
msgstr ""
"由于延迟, 不同的硬件或其他原因, 设置游戏角色在每个客户端上花费的时间可能不"
"同. 为了确保游戏会在每个人都准备好的时候真正开始, 有必要暂停游戏直到所有的游"
"戏角色都准备好:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:320
msgid ""
"When the server gets the OK from all the peers, it can tell them to start, "
"as for example:"
msgstr "当服务器从所有客户端获得OK时, 它才告诉他们开始游戏, 例如:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:344
msgid "Synchronizing the game"
msgstr "同步游戏"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:346
msgid ""
"In most games, the goal of multiplayer networking is that the game runs "
"synchronized on all the peers playing it. Besides supplying an RPC and "
"remote member variable set implementation, Godot adds the concept of network "
"masters."
msgstr ""
"在大多数游戏中, 多人联网的目标是让游戏在所有对等玩家身上同步运行. 除了提供RPC"
"和远程成员变量集的实现,Godot还增加了网络主机的概念."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:350
msgid "Network master"
msgstr "网络主人"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:352
msgid ""
"The network master of a node is the peer that has the ultimate authority "
"over it."
msgstr "一个节点的网络主人是对该节点具有终极权限的客户端."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:354
msgid ""
"When not explicitly set, the network master is inherited from the parent "
"node, which if not changed, is always going to be the server (ID 1). Thus "
"the server has authority over all nodes by default."
msgstr ""
"当没有明确设置时, 网络主控就会从父节点继承, 如果不改变的话, 父节点总是会成为"
"服务器(ID 1). 因此, 服务器默认拥有对所有节点的权限."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:356
msgid ""
"The network master can be set with the function :ref:`Node."
"set_network_master(id, recursive) <class_Node_method_set_network_master>` "
"(recursive is ``true`` by default and means the network master is "
"recursively set on all child nodes of the node as well)."
msgstr ""
"可以使用函数 :ref:`Node.set_network_master(id, recursive) "
"<class_Node_method_set_network_master>` 来设置网络主人(默认情况下recursive(递"
"归)为 ``true`` , 这意味着在节点的所有子节点上也递归地设置了网络主人)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:359
msgid ""
"Checking that a specific node instance on a peer is the network master for "
"this node for all connected peers is done by calling :ref:`Node."
"is_network_master() <class_Node_method_is_network_master>`. This will return "
"``true`` when executed on the server and ``false`` on all client peers."
msgstr ""
"通过调用 :ref:`Node.is_network_master() "
"<class_Node_method_is_network_master>` 来检查客户端上的特定节点实例是否是该节"
"点用于所有连接的客户端的网络主人. 这在服务器上执行时将返回 ``true`` , 在所有"
"客户端上将返回 ``false`` ."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:361
msgid ""
"If you have paid attention to the previous example, it's possible you "
"noticed that each peer was set to have network master authority for their "
"own player (Node) instead of the server:"
msgstr ""
"如果你有留意前面的例子, 你有可能注意到了每个客户端(peer)都被设置为拥有自己玩"
"家(节点)的网络主权限, 而不是服务器:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:381
msgid ""
"Each time this piece of code is executed on each peer, the peer makes itself "
"master on the node it controls, and all other nodes remain as puppets with "
"the server being their network master."
msgstr ""
"每当在客户端上执行这段代码时, 客户端就使得它控制的节点上成为主人, 同时其他所"
"有节点仍然保持为傀儡(服务器是它们的网络主人)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:383
msgid ""
"To clarify, here is an example of how this looks in the `bomber demo "
"<https://github.com/godotengine/godot-demo-projects/tree/master/networking/"
"multiplayer_bomber>`_:"
msgstr ""
"为了阐明这点, 可以看看这个 `轰炸机演示 <https://github.com/godotengine/godot-"
"demo-projects/tree/master/networking/multiplayer_bomber>`_ :"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:390
msgid "Master and puppet keywords"
msgstr "主人和傀儡关键词"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:394
msgid ""
"The real advantage of this model is when used with the ``master``/``puppet`` "
"keywords in GDScript (or their equivalent in C# and Visual Script). "
"Similarly to the ``remote`` keyword, functions can also be tagged with them:"
msgstr ""
"这种模式的真正优势在于与GDScript中的 ``master``/``puppet`` 关键字(或C#和"
"Visual Script中的相应关键字)一起使用时. 与 ``remote`` 关键字类似, 函数也可以"
"用它们来标记:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:397
msgid "Example bomb code:"
msgstr "炸弹代码的示例:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:405
msgid "Example player code:"
msgstr "游戏角色代码的示例:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:422
msgid ""
"In the above example, a bomb explodes somewhere (likely managed by whoever "
"is the master of this bomb-node, e.g. the host). The bomb knows the bodies "
"(player nodes) in the area, so it checks that they contain an ``exploded`` "
"method before calling it."
msgstr ""
"在上面的例子中, 一个炸弹在某个地方爆炸了(很可能是由这个炸弹节点的管理者管理"
"的, 比如主机). 炸弹知道该地区的机构(玩家节点), 所以它在调用之前会检查它们是否"
"包含一个 ``exploded`` 的方法."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:425
msgid ""
"Recall that each peer has a complete set of instances of player nodes, one "
"instance for each peer (including itself and the host). Each peer has set "
"itself as the master of the instance corresponding to itself, and it has set "
"a different peer as the master for each of the other instances."
msgstr ""
"回顾一下, 每个对等体都有一套完整的玩家节点实例, 每个对等体(包括自己和主机)都"
"有一个实例. 每个对等体都将自己设定为与自己对应的实例的主控, 并将其他每个实例"
"的主控设定为不同的对等体."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:429
msgid ""
"Now, going back to the call to the ``exploded`` method, the bomb on the host "
"has called it remotely on all bodies in the area that have the method. "
"However, this method is in a player node and has a ``master`` keyword."
msgstr ""
"现在, 回到对 ``exploded`` 方法的调用, 主机上的炸弹已经远程调用了该区域内所有"
"拥有该方法的机体. 不过, 这个方法是在玩家节点中的, 而且有一个 ``master`` 关键"
"词."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:432
msgid ""
"The ``master`` keyword on the ``exploded`` method in the player node means "
"two things for how this call is made. Firstly, from the perspective of the "
"calling peer (the host), the calling peer will only attempt to remotely call "
"the method on the peer that it has set as the network master of the player "
"node in question. Secondly, from the perspective of the peer the host is "
"sending the call to, the peer will only accept the call if it set itself as "
"the network master of the player node with the method being called (which "
"has the ``master`` keyword). This works well as long as all peers agree on "
"who is the master of what."
msgstr ""
"玩家节点中的 ``exploded`` 方法上的 ``master`` 关键字对于如何进行这种调用有两"
"个意思. 第一, 从调用对等体(主机)的角度来看, 调用对等体只会尝试远程调用它设定"
"为相关玩家节点网络主控的对等体上的方法. 其次, 从宿主发送调用的对等体的角度来"
"看, 只有当对等体将自己设置为被调用方法的玩家节点的网络主控(该节点有 "
"``master`` 关键字)时, 它才会接受调用. 只要所有的对等体都同意谁是怎样的主控, "
"工作状态将最好."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:439
msgid ""
"The above setup means that only the peer who owns the affected body will be "
"responsible for telling all the other peers that its body was stunned, after "
"being remotely instructed to do so by the host's bomb. The owning peer "
"therefore (still in the ``exploded`` method) tells all the other peers that "
"its player node was stunned. The peer does this by remotely calling the "
"``stun`` method on all instances of that player node (on the other peers). "
"Because the ``stun`` method has the ``puppet`` keyword, only peers who did "
"not set themselves as the network master of the node will call it (in other "
"words, those peers are set as puppets for that node by virtue of not being "
"the network master of it)."
msgstr ""
"上述设置意味着, 只有拥有受影响身体的对等体, 才会负责告诉所有其他对等体它的身"
"体被眩晕了, 因为主机的炸弹远程信号指示它这样做. 即, 拥有的对等体仍采用 "
"``exploded`` 方法告诉所有其他对等体, 它的玩家节点被眩晕了. 对等体通过远程调用"
"该玩家节点的所有实例, 在其他对等体上的 ``stun`` 方法来实现. 因为 ``stun`` 方"
"法有 ``puppet`` 关键字, 所以只有没有将自己设置为节点的网络主控的对等体才会调"
"用它, 换句话说, 这些对等体由于不是该节点的网络主控而被设置为该节点的傀儡."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:446
msgid ""
"The result of this call to ``stun`` is to make the player look stunned on "
"the screen of all the peers, including the current network master peer (due "
"to the local call to ``stun`` after ``rpc(\"stun\")``)."
msgstr ""
"这个调用 ``stun`` 的结果是让玩家在屏幕上看起来眩晕了所有对等体, 包括当前的网"
"络主控(由于在 ``rpc(\"stun\")`` 后本地调用 ``stun`` )."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:449
msgid ""
"The master of the bomb (the host) repeats the above steps for each of the "
"bodies in the area, such that all the instances of any player in the bomb "
"area get stunned on the screens of all the peers."
msgstr ""
"炸弹的主人(主机)对区域内的每一个物体重复上述步骤, 这样, 炸弹区域内任何玩家的"
"所有实例都会在所有对等体的屏幕上被眩晕."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:452
msgid ""
"Note that you could also send the ``stun()`` message only to a specific "
"player by using ``rpc_id(<id>, \"exploded\", bomb_owner)``. This may not "
"make much sense for an area-of-effect case like the bomb, but might in other "
"cases, like single target damage."
msgstr ""
"注意, 你也可以通过使用 ``rpc_id(<id>, \"exploded\", bomb_owner)`` 只向特定的"
"玩家发送 ``stun()`` 消息. 这对于像炸弹这样的区域效果来说可能没有什么意义, 但"
"在其他情况下可能会有意义, 比如单目标伤害."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:460
msgid "Exporting for dedicated servers"
msgstr "导出专用服务"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:462
msgid ""
"Once you've made a multiplayer game, you may want to export it to run it on "
"a dedicated server with no GPU available. See :ref:"
"`doc_exporting_for_dedicated_servers` for more information."
msgstr ""
"一旦你制作了一个多人游戏, 你可能会想导出它到一个没有GPU的专用服务器上运行. 参"
"见 :ref:`doc_exporting_for_dedicated_servers` 获取更多信息."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:468
msgid ""
"The code samples on this page aren't designed to run on a dedicated server. "
"You'll have to modify them so the server isn't considered to be a player. "
"You'll also have to modify the game starting mechanism so that the first "
"player who joins can start the game."
msgstr ""
"这个页面上的代码样本并不是为了在专用服务器上运行而设计的. 必须修改它们, 使服"
"务器不被认为是一个玩家, 还必须修改游戏启动机制, 使第一个加入的玩家可以启动游"
"戏."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:475
msgid ""
"The bomberman example here is largely for illustrational purposes, and does "
"not do anything on the host-side to handle the case where a peer uses a "
"custom client to cheat by for example refusing to stun itself. In the "
"current implementation such cheating is perfectly possible because each "
"client is the network master of its own player, and the network master of a "
"player is the one which decides whether to call the I-was-stunned method "
"(``stun``) on all of the other peers and itself."
msgstr ""
"这里的炸弹人例子主要是以演示为目的，没有在主机端处理任何作弊的情形，比如玩家"
"的自定义客户端可能不会做击晕自己的操作。目前的实现中，这样的作弊行为是可行"
"的，因为每个客户端都是各自玩家的网络主控，而决定是否让其它玩家调用“我被击晕"
"了”方法（ ``stun`` ）的也正是玩家的网络主控。"
