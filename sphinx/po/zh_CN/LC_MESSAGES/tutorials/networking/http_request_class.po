# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-04 09:58+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/networking/http_request_class.rst:4
msgid "Making HTTP requests"
msgstr "制作HTTP请求"

#: ../../docs/tutorials/networking/http_request_class.rst:6
msgid ""
"The :ref:`HTTPRequest <class_HTTPRequest>` node is the easiest way to make "
"HTTP requests in Godot. It is backed by the more low-level :ref:`HTTPClient "
"<class_HTTPClient>`, for which a tutorial is available :ref:`here "
"<doc_http_client_class>`."
msgstr ""
"在Godot中, 用 :ref:`HTTPRequest <class_HTTPRequest>` 节点发出HTTP请求是最简单"
"的方法。 它继承自更低级别的 :ref:`HTTPClient <class_HTTPClient>` ，相关的教程"
"见 :ref:`here <doc_http_client_class>`。"

#: ../../docs/tutorials/networking/http_request_class.rst:9
msgid ""
"For the sake of this example, we will create a simple UI with a button, that "
"when pressed will start the HTTP request to the specified URL."
msgstr ""
"这个示例中，我们将创建一个带有按钮的简单UI，按下该按钮时将发送对指定网址的"
"HTTP请求。"

#: ../../docs/tutorials/networking/http_request_class.rst:12
msgid "Preparing scene"
msgstr "准备场景"

#: ../../docs/tutorials/networking/http_request_class.rst:14
#, fuzzy
msgid ""
"Create a new empty scene, add a CanvasLayer as the root node and add a "
"script to it. Then add two child nodes to it: a Button and an HTTPRequest "
"node. You will need to connect the following signals to the CanvasLayer "
"script:"
msgstr ""
"创建一个新的空场景，添加CanvasLayer作为其根节点并向其添加脚本。 然后向其添加"
"两个子节点:Button和HTTPRequest节点。 您需要将以下信号连接到CanvasLayer节点的"
"脚本:"

#: ../../docs/tutorials/networking/http_request_class.rst:16
msgid "Button.pressed: When the button is pressed, we will start the request."
msgstr "Button.pressed:  按下按钮后，我们将发送请求。"

#: ../../docs/tutorials/networking/http_request_class.rst:17
msgid ""
"HTTPRequest.request_completed: When the request is completed, we will get "
"the requested data as an argument."
msgstr ""
"HTTPRequest.request_completed: 当请求完成后，我们将获取请求的数据作为参数。"

#: ../../docs/tutorials/networking/http_request_class.rst:22
msgid "Scripting"
msgstr "编写脚本"

#: ../../docs/tutorials/networking/http_request_class.rst:24
msgid ""
"Below is all the code we need to make it work. The URL points to an online "
"API mocker; it returns a pre-defined JSON string, which we will then parse "
"to get access to the data."
msgstr ""
"下面是我们使其工作所需的所有代码。 该网址指向一个在线API模拟器; 它将返回一个"
"预先定义好的JSON字符串，然后我们将解析它以获取对数据的访问权限。"

#: ../../docs/tutorials/networking/http_request_class.rst:40
msgid ""
"With this, you should see ``(hello:world)`` printed on the console; hello "
"being a key, and world being a value, both of them strings."
msgstr ""
"有了这个，您应该在控制台上看到 ``(hello:world)`` ; hello是关键字，world是值，"
"两者都是字符串。"

#: ../../docs/tutorials/networking/http_request_class.rst:42
msgid ""
"For more information on parsing JSON, see the class references for :ref:"
"`JSON <class_JSON>` and :ref:`JSONParseResult <class_JSONParseResult>`."
msgstr ""
"有关解析JSON的更多信息，请参阅类型参考 :ref:`JSON <class_JSON>` 和 :ref:"
"`JSONParseResult <class_JSONParseResult>` 。"

#: ../../docs/tutorials/networking/http_request_class.rst:44
msgid ""
"Note that you may want to check whether the ``result`` equals "
"``RESULT_SUCCESS`` and whether a JSON parsing error occurred, see the JSON "
"class reference and :ref:`HTTPRequest <class_HTTPRequest>` for more."
msgstr ""
"请注意，您可能需要检查 ``result`` 是否等于 ``RESULT_SUCCESS`` 以及JSON解析错"
"误是否发生，要了解更多信息, 请参阅JSON类型参考和 :ref:`HTTPRequest "
"<class_HTTPRequest>` 。"

#: ../../docs/tutorials/networking/http_request_class.rst:46
msgid ""
"Of course, you can also set custom HTTP headers. These are given as a string "
"array, with each string containing a header in the format ``\"header: value"
"\"``. For example, to set a custom user agent (the HTTP ``user-agent`` "
"header) you could use the following:"
msgstr ""
"当然，您也可以设置自定义的HTTP头部。 它们以字符串数组的形式给出，每个字符串都"
"包含一个格式为 ``\"header: value\"`` 的头部。 例如，要设置自定义用户代理(HTTP"
"的 ``user-agent`` 头部部分)，您可以像这样使用:"

#: ../../docs/tutorials/networking/http_request_class.rst:53
#, fuzzy
msgid ""
"Please note that, for SSL/TLS encryption and thus HTTPS URLs to work, you "
"may need to take some steps as described :ref:`here <doc_ssl_certificates>`."
msgstr ""
"请注意，为可以用到SSL/TLS加密即HTTPS 格式的网址上，您可能需要额外的操作, 见 :"
"ref:`here <doc_ssl_certificates>` 。"

#: ../../docs/tutorials/networking/http_request_class.rst:55
msgid ""
"Also, when calling APIs using authorization, be aware that someone might "
"analyse and decompile your released application and thus may gain access to "
"any embedded authorization information like tokens, usernames or passwords. "
"That means it is usually not a good idea to embed things such as database "
"access credentials inside your game. Avoid providing information useful to "
"an attacker whenever possible."
msgstr ""
"此外，在使用授权调用API时，请注意有人可能会分析和反编译已发布的应用程序，因此"
"可能会访问到任何嵌入程序的授权信息，如令牌, 用户名或密码等。 这意味着在游戏中"
"嵌入诸如数据库访问凭证之类的东西通常不是一个好主意。 尽可能避免提供对攻击者有"
"用的信息。"

#: ../../docs/tutorials/networking/http_request_class.rst:59
msgid "Sending data to server"
msgstr "将数据发送到服务器"

#: ../../docs/tutorials/networking/http_request_class.rst:61
#, fuzzy
msgid ""
"Until now, we have limited ourselves to requesting data from a server. But "
"what if you need to send data to the server? Here is a common way of doing "
"it:"
msgstr ""
"到目前为止，我们仅限于从服务器请求数据。 但是，如果您需要将数据发送到服务器"
"呢？ 下面是一种常见的做法:"

#: ../../docs/tutorials/networking/http_request_class.rst:72
msgid ""
"Keep in mind that you have to wait for a request to finish before sending "
"another one. Making multiple request at once requires you to have one node "
"per request. A common strategy is to create and delete HTTPRequest nodes at "
"runtime as necessary."
msgstr ""
"请记住，在发送另一个请求之前，您必须等待请求完成。 一次发出多个请求需要每个请"
"求有一个节点。 常见的策略是在运行时根据需要创建和删除HTTPRequest节点。"
