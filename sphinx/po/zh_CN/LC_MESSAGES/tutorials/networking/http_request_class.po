# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Making HTTP requests"
msgstr "进行 HTTP 请求"

msgid ""
"The :ref:`HTTPRequest <class_HTTPRequest>` node is the easiest way to make "
"HTTP requests in Godot. It is backed by the more low-level :ref:`HTTPClient "
"<class_HTTPClient>`, for which a tutorial is available :ref:`here "
"<doc_http_client_class>`."
msgstr ""
"在Godot中, 用 :ref:`HTTPRequest <class_HTTPRequest>` 节点发出HTTP请求是最简单"
"的方法. 它继承自更低级别的 :ref:`HTTPClient <class_HTTPClient>` , 相关的教程"
"见 :ref:`here <doc_http_client_class>`."

msgid ""
"For the sake of this example, we will create a simple UI with a button, that "
"when pressed will start the HTTP request to the specified URL."
msgstr ""
"这个示例中, 我们将创建一个带有按钮的简单UI, 按下该按钮时将发送对指定网址的"
"HTTP请求."

msgid ""
"When exporting to Android, make sure to enable the ``INTERNET`` permission "
"in the Android export preset before exporting the project or using one-click "
"deploy. Otherwise, network communication of any kind will be blocked by "
"Android."
msgstr ""
"当导出到 Android 时，在导出项目或使用一键部署之前，确保在 Android 导出预设中"
"启用 ``INTERNET`` 权限。否则，任何形式的网络通信都会被 Android 系统阻止。"

msgid "Preparing scene"
msgstr "准备场景"

msgid ""
"Create a new empty scene, add a CanvasLayer as the root node and add a "
"script to it. Then add two child nodes to it: a Button and an HTTPRequest "
"node. You will need to connect the following signals to the CanvasLayer "
"script:"
msgstr ""
"创建一个新的空场景, 添加一个CanvasLayer作为根节点, 并为其添加一个脚本. 然后给"
"它添加两个子节点: 一个Button和一个HTTPRequest节点. 然后需要把以下信号连接到"
"CanvasLayer脚本上:"

msgid "Button.pressed: When the button is pressed, we will start the request."
msgstr "Button.pressed: 按下按钮后, 我们将发送请求."

msgid ""
"HTTPRequest.request_completed: When the request is completed, we will get "
"the requested data as an argument."
msgstr ""
"HTTPRequest.request_completed: 当请求完成后, 我们将获取请求的数据作为参数."

msgid "Scripting"
msgstr "编写脚本"

msgid ""
"Below is all the code we need to make it work. The URL points to an online "
"API mocker; it returns a pre-defined JSON string, which we will then parse "
"to get access to the data."
msgstr ""
"下面是我们使其工作所需的所有代码. 该网址指向一个在线API模拟器; 它将返回一个预"
"先定义好的JSON字符串, 然后我们将解析它以获取对数据的访问权限."

msgid ""
"With this, you should see ``(hello:world)`` printed on the console; hello "
"being a key, and world being a value, both of them strings."
msgstr ""
"有了这个, 您应该在控制台上看到 ``(hello:world)`` ; hello是关键字,world是值, "
"两者都是字符串."

msgid ""
"For more information on parsing JSON, see the class references for :ref:"
"`JSON <class_JSON>` and :ref:`JSONParseResult <class_JSONParseResult>`."
msgstr ""
"有关解析JSON的更多信息, 请参阅类型参考 :ref:`JSON <class_JSON>` 和 :ref:"
"`JSONParseResult <class_JSONParseResult>` ."

msgid ""
"Note that you may want to check whether the ``result`` equals "
"``RESULT_SUCCESS`` and whether a JSON parsing error occurred, see the JSON "
"class reference and :ref:`HTTPRequest <class_HTTPRequest>` for more."
msgstr ""
"请注意, 您可能需要检查 ``result`` 是否等于 ``RESULT_SUCCESS`` 以及JSON解析错"
"误是否发生, 要了解更多信息, 请参阅JSON类型参考和 :ref:`HTTPRequest "
"<class_HTTPRequest>` ."

msgid ""
"Of course, you can also set custom HTTP headers. These are given as a string "
"array, with each string containing a header in the format ``\"header: "
"value\"``. For example, to set a custom user agent (the HTTP ``user-agent`` "
"header) you could use the following:"
msgstr ""
"当然, 您也可以设置自定义的HTTP头部. 它们以字符串数组的形式给出, 每个字符串都"
"包含一个格式为 ``\"header: value\"`` 的头部. 例如, 要设置自定义用户代理(HTTP"
"的 ``user-agent`` 头部部分), 您可以像这样使用:"

msgid ""
"Please note that, for SSL/TLS encryption and thus HTTPS URLs to work, you "
"may need to take some steps as described :ref:`here <doc_ssl_certificates>`."
msgstr ""
"请注意, 为了使SSL/TLS加密, 从而使HTTPS URL发挥作用, 你可能需要采取一些额外的"
"操作步骤, 如 :ref:`here <doc_ssl_certificates>` ."

msgid ""
"Also, when calling APIs using authorization, be aware that someone might "
"analyse and decompile your released application and thus may gain access to "
"any embedded authorization information like tokens, usernames or passwords. "
"That means it is usually not a good idea to embed things such as database "
"access credentials inside your game. Avoid providing information useful to "
"an attacker whenever possible."
msgstr ""
"此外, 在使用授权调用API时, 请注意有人可能会分析和反编译已发布的应用程序, 因此"
"可能会访问到任何嵌入程序的授权信息, 如令牌, 用户名或密码等. 这意味着在游戏中"
"嵌入诸如数据库访问凭证之类的东西通常不是一个好主意. 尽可能避免提供对攻击者有"
"用的信息."

msgid "Sending data to server"
msgstr "将数据发送到服务器"

msgid ""
"Until now, we have limited ourselves to requesting data from a server. But "
"what if you need to send data to the server? Here is a common way of doing "
"it:"
msgstr ""
"到目前为止, 我们仅限于从服务器上请求数据. 但如果你需要向服务器发送数据呢？这"
"里有一个常见的方法:"

msgid ""
"Keep in mind that you have to wait for a request to finish before sending "
"another one. Making multiple request at once requires you to have one node "
"per request. A common strategy is to create and delete HTTPRequest nodes at "
"runtime as necessary."
msgstr ""
"请记住, 在发送另一个请求之前, 您必须等待请求完成. 一次发出多个请求需要每个请"
"求有一个节点. 常见的策略是在运行时根据需要创建和删除HTTPRequest节点."

msgid "Translation status"
msgstr "翻译状态"
