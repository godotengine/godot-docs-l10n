# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2022, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-11 15:14+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Matrices and transforms"
msgstr "矩阵与变换"

msgid "Introduction"
msgstr "前言"

msgid ""
"Before reading this tutorial, we recommend that you thoroughly read and "
"understand the :ref:`doc_vector_math` tutorial, as this tutorial requires a "
"knowledge of vectors."
msgstr ""
"在阅读本教程之前，我们推荐你从头到尾阅读并且理解 :ref:`doc_vector_math` 教"
"程，因为本教程需要一点向量的知识。"

msgid ""
"This tutorial is about *transformations* and how we represent them in Godot "
"using matrices. It is not a full in-depth guide to matrices. Transformations "
"are most of the time applied as translation, rotation, and scale, so we will "
"focus on how to represent those with matrices."
msgstr ""
"这个教程介绍的是\\ *变换*\\ 以及我们如何在 Godot 中使用矩阵表示它。这不是完整"
"深入的矩阵指南。变换大多数时候被应用为平移、旋转、缩放，所以我们将会关注如何"
"用矩阵表示这些变换。"

msgid ""
"Most of this guide focuses on 2D, using :ref:`class_Transform2D` and :ref:"
"`class_Vector2`, but the way things work in 3D is very similar."
msgstr ""
"虽然这个指南主要关注于 2D，使用 :ref:`class_Transform2D` 和 :ref:"
"`class_Vector2`\\ ，但是 3D 中的工作方式也十分相似。"

msgid ""
"As mentioned in the previous tutorial, it is important to remember that in "
"Godot, the Y axis points *down* in 2D. This is the opposite of how most "
"schools teach linear algebra, with the Y axis pointing up."
msgstr ""
"正如之前的教程中提到的，要记住在 Godot 中，2D 的 Y 轴是\\ *向下*\\ 的。这与学"
"校里教的线性代数正好相反，在那里 Y 轴是向上的。"

msgid ""
"The convention is that the X axis is red, the Y axis is green, and the Z "
"axis is blue. This tutorial is color-coded to match these conventions, but "
"we will also represent the origin vector with a blue color."
msgstr ""
"这里的惯例是 X 轴用红色、Y 轴用绿色、Z 轴用蓝色。本教程中的颜色都遵循这个惯"
"例，不过我们也在原点向量上使用蓝色。"

msgid "Matrix components and the Identity matrix"
msgstr "矩阵分量和单位矩阵"

msgid ""
"The identity matrix represents a transform with no translation, no rotation, "
"and no scale. Let's start by looking at the identity matrix and how its "
"components relate to how it visually appears."
msgstr ""
"单位矩阵代表一个没有平移、没有旋转、没有缩放的变换。让我们开始看看单位矩阵以"
"及它的分量如何与它的视觉表现相联系吧。"

msgid ""
"Matrices have rows and columns, and a transformation matrix has specific "
"conventions on what each does."
msgstr "矩阵有行和列，变换矩阵对它们有特定的约定。"

msgid ""
"In the image above, we can see that the red X vector is represented by the "
"first column of the matrix, and the green Y vector is likewise represented "
"by the second column. A change to the columns will change these vectors. We "
"will see how they can be manipulated in the next few examples."
msgstr ""
"在上图中，我们可以看到红色的 X 向量由矩阵的第一列表示，绿色的 Y 向量则由第二"
"列表示。改变列就会改变这些向量。我们将在接下来的几个例子中看到如何操作它们。"

msgid ""
"You should not worry about manipulating rows directly, as we usually work "
"with columns. However, you can think of the rows of the matrix as showing "
"which vectors contribute to moving in a given direction."
msgstr ""
"您不必担心直接操作行, 因为我们通常使用列. 然而, 你可以把矩阵的行看作是表示哪"
"些向量有助于在给定的方向上移动."

msgid ""
"When we refer to a value such as `t.x.y`, that's the Y component of the X "
"column vector. In other words, the bottom-left of the matrix. Similarly, `t."
"x.x` is top-left, `t.y.x` is top-right, and `t.y.y` is bottom-right, where "
"`t` is the Transform2D."
msgstr ""
"当我们指定一个值例如 `t.x.y` , 这是X列向量的Y分量. 换句话说, 是这个矩阵的左下"
"角. 类似地, `t.x.x` 是左上角, `t.y.x` 是右上角, 然后 `t.y.y` 是右下角, 在这"
"里 `t` 是一个 Transform2D."

msgid "Scaling the transformation matrix"
msgstr "缩放变换矩阵"

msgid ""
"Applying a scale is one of the easiest operations to understand. Let's start "
"by placing the Godot logo underneath our vectors so that we can visually see "
"the effects on an object:"
msgstr ""
"应用一个缩放是最容易理解的操作之一. 让我们开始吧, 把Godot logo放置于我们的向"
"量之下, 这样我们可以直观得看出应用于这些对象上的效果:"

msgid ""
"Now, to scale the matrix, all we need to do is multiply each component by "
"the scale we want. Let's scale it up by 2. 1 times 2 becomes 2, and 0 times "
"2 becomes 0, so we end up with this:"
msgstr ""
"现在, 为了缩放矩阵, 我们唯一需要做的就是将每个矩阵分量乘以我们想要的缩放比"
"例. 来将它缩放两倍吧,1乘以2变成了2,0乘以2变成了0, 所以我们最后得到了这个:"

msgid "To do this in code, we can simply multiply each of the vectors:"
msgstr "要在代码中做到这件事. 我们可以简单地乘上每个向量:"

msgid ""
"If we wanted to return it to its original scale, we can multiply each "
"component by 0.5. That's pretty much all there is to scaling a "
"transformation matrix."
msgstr ""
"如果我们想要回到它原来的尺度, 我们可以对每个分量乘以0.5. 这几乎就是缩放一个变"
"换矩阵的全部了."

msgid ""
"To calculate the object's scale from an existing transformation matrix, you "
"can use `length()` on each of the column vectors."
msgstr ""
"要从一个已经存在的变换矩阵中计算对象的缩放尺度, 你可以对每个列向量使用 "
"`length()` 方法."

msgid ""
"In actual projects, you can use the `scaled()` method to perform scaling."
msgstr "在实际的项目中, 你可以使用 `scaled()` 方法去执行缩放."

msgid "Rotating the transformation matrix"
msgstr "旋转变换矩阵"

msgid ""
"We'll start the same way as earlier, with the Godot logo underneath the "
"identity matrix:"
msgstr "我们将以与前面相同的方式开始, 在标识矩阵下使用Godot徽标:"

msgid ""
"As an example, let's say we want to rotate our Godot logo clockwise by 90 "
"degrees. Right now the X axis points right and the Y axis points down. If we "
"rotate these in our head, we would logically see that the new X axis should "
"point down and the new Y axis should point left."
msgstr ""
"举个例子，假设我们想顺时针旋转 Godot 标志 90 度。现在，X 轴指向右边，Y 轴向"
"下。如果我们在头脑中旋转这些，我们就会在逻辑上看到，新的 X 轴应该向下，新的 "
"Y 轴应该指向左边。"

msgid ""
"You can imagine that you grab both the Godot logo and its vectors, and then "
"spin it around the center. Wherever you finish spinning, the orientation of "
"the vectors determines what the matrix is."
msgstr ""
"你可以想象, 你抓住了godot的图标和它的向量, 然后旋转它的中心. 无论你在哪里完成"
"旋转, 向量的方向决定了矩阵是什么."

msgid ""
"We need to represent \"down\" and \"left\" in normal coordinates, so means "
"we'll set X to (0, 1) and Y to (-1, 0). These are also the values of "
"`Vector2.DOWN` and `Vector2.LEFT`. When we do this, we get the desired "
"result of rotating the object:"
msgstr ""
"我们需要在法线坐标中表示“下”和“左”，因此我们将 X 设为 (0, 1)，将 Y 设为 (-1, "
"0)。这些也正是 Vector2.DOWN 和 Vector2.LEFT 的值，当我们这样做时，就会得到旋"
"转对象想要的结果："

msgid ""
"If you have trouble understanding the above, try this exercise: Cut a square "
"of paper, draw X and Y vectors on top of it, place it on graph paper, then "
"rotate it and note the endpoints."
msgstr ""
"如果你很难理解上面的内容, 那就试试这个练习: 剪一个正方形的纸, 在上面画X和Y向"
"量, 把它放在图表纸上, 然后旋转它并记下端点."

msgid ""
"To perform rotation in code, we need to be able to calculate the values "
"programmatically. This image shows the formulas needed to calculate the "
"transformation matrix from a rotation angle. Don't worry if this part seems "
"complicated, I promise it's the hardest thing you need to know."
msgstr ""
"要在代码中执行旋转, 我们需要能够以编程方式计算值. 这幅图像显示了从旋转角度计"
"算变换矩阵所需的公式. 如果这部分看起来很复杂, 别担心, 我保证这是你需要知道的"
"最难的事情."

msgid ""
"Godot represents all rotations with radians, not degrees. A full turn is "
"`TAU` or `PI*2` radians, and a quarter turn of 90 degrees is `TAU/4` or "
"`PI/2` radians. Working with `TAU` usually results in more readable code."
msgstr ""
"Godot 用弧度表示所有的旋转，不用角度。完整转一圈是 `TAU` 或 `PI*2` 弧度，90 "
"度的四分之一圈是 `TAU/4` 或 `PI/2` 弧度。使用 `TAU` 通常会让代码更易读。"

msgid ""
"Fun fact: In addition to Y being *down* in Godot, rotation is represented "
"clockwise. This means that all the math and trig functions behave the same "
"as a Y-is-up CCW system, since these differences \"cancel out\". You can "
"think of rotations in both systems being \"from X to Y\"."
msgstr ""
"有趣的事实：在 Godot 中，不仅 Y 是\\ *朝下*\\ 的，旋转也是顺时针的。这意味着"
"所有的数学和三角函数的行为都与 Y 朝上的 CCW 坐标系相同，因为这些差异“相互抵"
"消”了。你可以认为在这两个坐标系中的旋转都是“从 X 到 Y”。"

msgid ""
"In order to perform a rotation of 0.5 radians (about 28.65 degrees), we "
"simply plug in a value of 0.5 to the formula above and evaluate to find what "
"the actual values should be:"
msgstr ""
"为了执行 0.5 弧度的旋转（约 28.65 度），我们只需将 0.5 代入上面的公式中，然后"
"计算出实际值应该是什么："

msgid "Here's how that would be done in code (place the script on a Node2D):"
msgstr "这是在代码中完成的方法（将脚本放在 Node2D 上）："

msgid ""
"To calculate the object's rotation from an existing transformation matrix, "
"you can use `atan2(t.x.y, t.x.x)`, where t is the Transform2D."
msgstr ""
"要从现有的变换矩阵中计算对象的旋转，可以使用 `atan2(t.x.y, t.x.x)`\\ ，其中 "
"t 是 Transform2D。"

msgid ""
"In actual projects, you can use the `rotated()` method to perform rotations."
msgstr "在实际项目中，可以使用 `rotated()` 方法进行旋转。"

msgid "Basis of the transformation matrix"
msgstr "变换矩阵的基"

msgid ""
"So far we have only been working with the `x` and `y`, vectors, which are in "
"charge of representing rotation, scale, and/or shearing (advanced, covered "
"at the end). The X and Y vectors are together called the *basis* of the "
"transformation matrix. The terms \"basis\" and \"basis vectors\" are "
"important to know."
msgstr ""
"到目前为止，我们只使用 `x` 和 `y` 向量，它们负责表示旋转、缩放和/或剪切（高"
"级，会在文末提及）。X 和 Y 向量合称变换矩阵的\\ *基*\\ （Basis）。“基”和“基向"
"量”都是非常重要的术语。"

msgid ""
"You might have noticed that :ref:`class_Transform2D` actually has three :ref:"
"`class_Vector2` values: `x`, `y`, and `origin`. The `origin` value is not "
"part of the basis, but it is part of the transform, and we need it to "
"represent position. From now on we'll keep track of the origin vector in all "
"examples. You can think of origin as another column, but it's often better "
"to think of it as completely separate."
msgstr ""
"你可能已经注意到 :ref:`class_Transform2D` 实际上有三个 :ref:`class_Vector2` "
"值：\\ `x`\\ 、\\ `y`\\ 、\\ `origin`\\ 。其中 `origin` 值不是基的一部分，而"
"是变换的一部分，我们需要用它来表示位置。从现在开始，我们将在所有例子中记录原"
"点向量。您可以将原点看作另一列，但把它认为是完全独立的通常更好。"

msgid ""
"Note that in 3D, Godot has a separate :ref:`class_Basis` structure for "
"holding the three :ref:`class_Vector3` values of the basis, since the code "
"can get complex and it makes sense to separate it from :ref:"
"`class_Transform` (which is composed of one :ref:`class_Basis` and one "
"extra :ref:`class_Vector3` for the origin)."
msgstr ""
"请注意在 3D 中，Godot 有一个单独的 :ref:`class_Basis` 结构，里面包含矩阵基的"
"三个 :ref:`class_Vector3` 的值。因为代码可能变得复杂，因此将它们从 :ref:"
"`class_Transform`\\ （由一个 :ref:`class_Basis` 和一个额外的原点 :ref:"
"`class_Vector3` 组成）中拆分出来是值得的。"

msgid "Translating the transformation matrix"
msgstr "变换矩阵的平移"

msgid ""
"Changing the `origin` vector is called a *translating* the transformation "
"matrix. Translating is basically a technical term for \"moving\" the object, "
"but it explicitly does not involve any rotation."
msgstr ""
"对 `origin` 向量的修改称为对变换矩阵的\\ *平移*\\ 。平移其实上是“移动”对象的"
"一个技术术语，但它不会包含任何旋转。"

msgid ""
"Let's work through an example to help understand this. We will start with "
"the identity transform like last time, except we will keep track of the "
"origin vector this time."
msgstr ""
"让我们通过一个例子来帮助理解这一点。我们将像上次一样从恒等变换开始，但这次我"
"们将记录原点向量。"

msgid ""
"If we want the object to move to a position of (1, 2), we simply need to set "
"its `origin` vector to (1, 2):"
msgstr ""
"如果希望对象移动到 (1, 2) 的位置，只需将其 `origin` 向量设置为 (1, 2)："

msgid ""
"There is also a `translated()` method, which performs a different operation "
"to adding or changing `origin` directly. The `translated()` method will "
"translate the object *relative to its own rotation*. For example, an object "
"rotated 90 degrees clockwise will move to the right when `translated()` with "
"`Vector2.UP`."
msgstr ""
"还有一个 `translated()` 方法，它执行的是与直接增加或更改 `origin` 不同的操"
"作。这个 `translated()` 方法将让该对象相对于它自己的旋转进行平移。例如，顺时"
"针旋转了 90 度的对象如果用 `Vector2.UP` 调用了 `translated()`\\ ，那么它就会"
"向右移动。"

msgid ""
"Godot's 2D uses coordinates based on pixels, so in actual projects you will "
"want to translate by hundreds of units."
msgstr ""
"Godot 的 2D 使用基于像素的坐标，所以在实际项目中，你会想要转换成数百个单位。"

msgid "Putting it all together"
msgstr "融会贯通"

msgid ""
"We're going to apply everything we mentioned so far onto one transform. To "
"follow along, create a simple project with a Sprite node and use the Godot "
"logo for the texture resource."
msgstr ""
"我们将把到目前为止提到的所有内容都应用到一个变换上。接下来，使用 Sprite 节点"
"创建一个简单的项目，并使用 Godot 徽标作为其纹理资源。"

msgid ""
"Let's set the translation to (350, 150), rotate by -0.5 rad, and scale by 3. "
"I've posted a screenshot, and the code to reproduce it, but I encourage you "
"to try and reproduce the screenshot without looking at the code!"
msgstr ""
"让我们将平移设置为 (350, 150)，旋转设为 -0.5 rad，缩放设为 3。我把屏幕截图和"
"重现代码都发出来了，但我鼓励您不看代码来尝试重现屏幕截图！"

msgid "Shearing the transformation matrix (advanced)"
msgstr "剪切变换矩阵（高级）"

msgid ""
"If you are only looking for how to *use* transformation matrices, feel free "
"to skip this section of the tutorial. This section explores an uncommonly "
"used aspect of transformation matrices for the purpose of building an "
"understanding of them."
msgstr ""
"如果您只想了解如何\\ *使用*\\ 变换矩阵，请随意跳过本教程的这一节。本节探讨变"
"换矩阵的一个不常用的方面，目的是为了你建立对它们的理解。"

msgid ""
"You may have noticed that a transform has more degrees of freedom than the "
"combination of the above actions. The basis of a 2D transformation matrix "
"has four total numbers in two :ref:`class_Vector2` values, while a rotation "
"value and a Vector2 for scale only has 3 numbers. The high-level concept for "
"the missing degree of freedom is called *shearing*."
msgstr ""
"您可能已经注意到，变换的自由度比上述操作的组合要多。2D 变换矩阵的基在两个 :"
"ref:`class_Vector2` 值中总共有四个数，而旋转值和缩放的 Vector2 只有三个数字。"
"缺失自由度的高级概念称为\\ *剪切*\\ （Shearing）。"

msgid ""
"Normally, you will always have the basis vectors perpendicular to each "
"other. However, shearing can be useful in some situations, and understanding "
"shearing helps you understand how transforms work."
msgstr ""
"通常，您将始终拥有彼此垂直的基向量。但是，剪切在某些情况下可能很有用，了解剪"
"切可以帮助您理解变换的工作原理。"

msgid ""
"To show you visually how it will look, let's overlay a grid onto the Godot "
"logo:"
msgstr "为了直观地向您展示它的外观, 让我们在Godot徽标上叠加一个网格:"

msgid ""
"Each point on this grid is obtained by adding the basis vectors together. "
"The bottom-right corner is X + Y, while the top-right corner is X - Y. If we "
"change the basis vectors, the entire grid moves with it, as the grid is "
"composed of the basis vectors. All lines on the grid that are currently "
"parallel will remain parallel no matter what changes we make to the basis "
"vectors."
msgstr ""
"此网格上的每个点都是通过将基向量相加而获得的。右下角是 X + Y，而右上角是 X - "
"Y。如果我们更改基向量，整个栅格也会随之移动，因为栅格是由基向量组成的。无论我"
"们对基向量做什么更改，栅格上当前平行的所有直线都将保持平行。"

msgid "As an example, let's set Y to (1, 1):"
msgstr "例如, 让我们将Y设置为(1,1):"

msgid ""
"You can't set the raw values of a Transform2D in the editor, so you *must* "
"use code if you want to shear the object."
msgstr "不能在编辑器中设置Transform2D的原始值, 所以想要剪切对象, 必须使用代码."

msgid ""
"Due to the vectors no longer being perpendicular, the object has been "
"sheared. The bottom-center of the grid, which is (0, 1) relative to itself, "
"is now located at a world position of (1, 1)."
msgstr ""
"由于向量不再垂直, 因此对象已被剪切. 栅格的底部中心(相对于自身为(0,1))现在位于"
"世界位置(1,1)."

msgid ""
"The intra-object coordinates are called UV coordinates in textures, so let's "
"borrow that terminology for here. To find the world position from a relative "
"position, the formula is U * X + V * Y, where U and V are numbers and X and "
"Y are the basis vectors."
msgstr ""
"对象内部坐标在纹理中称为UV坐标, 因此我们借用此处的术语. 要从相对位置找到世界"
"位置, 公式为U*X+V*Y, 其中U和V是数字,X和Y是基向量."

msgid ""
"The bottom-right corner of the grid, which is always at the UV position of "
"(1, 1), is at the world position of (2, 1), which is calculated from X*1 + "
"Y*1, which is (1, 0) + (1, 1), or (1 + 1, 0 + 1), or (2, 1). This matches up "
"with our observation of where the bottom-right corner of the image is."
msgstr ""
"栅格的右下角始终位于UV位置(1,1), 位于世界位置(2,1), 该位置是从X*1+Y*1(即"
"(1,0)+(1,1)或(1+1,0+1)或(2,1)计算得出的. 这与我们观察到的图像右下角的位置相吻"
"合."

msgid ""
"Similarly, the top-right corner of the grid, which is always at the UV "
"position of (1, -1), is at the world position of (0, -1), which is "
"calculated from X*1 + Y*-1, which is (1, 0) - (1, 1), or (1 - 1, 0 - 1), or "
"(0, -1). This matches up with our observation of where the top-right corner "
"of the image is."
msgstr ""
"同样, 栅格的右上角始终位于UV位置(1, -1), 位于世界位置(0, -1), 该位置是从"
"X*1+Y*-1计算得出的,X*1+Y*-1是(1,0)-(1,1)或(1-1,0-1)或(0, -1). 这与我们观察到"
"的图像右上角的位置相吻合."

msgid ""
"Hopefully you now fully understand the how a transformation matrix affects "
"the object, and the relationship between the basis vectors and how the "
"object's \"UV\" or \"intra-coordinates\" have their world position changed."
msgstr ""
"希望您现在完全了解变换矩阵如何影响对象，以及基向量之间的关系以及对象"
"的“UV”或“内部坐标”如何更改其世界位置。"

msgid ""
"In Godot, all transform math is done relative to the parent node. When we "
"refer to \"world position\", that would be relative to the node's parent "
"instead, if the node had a parent."
msgstr ""
"在Godot中, 所有变换数学运算都是相对于父节点完成的. 当我们提到 \"世界位置\" "
"时, 如果节点有父节点, 那么它将相对于节点的父位置."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about linear transformations: https://www.youtube.com/watch?"
"v=kYB8IZa5AuE"
msgstr ""
"如果你想要更多的解释，你可以查看 3Blue1Brown 关于线性变换的精彩视频：\\ "
"https://www.bilibili.com/video/BV1ys411472E?p=4"

msgid "Practical applications of transforms"
msgstr "变换的实际应用"

msgid ""
"In actual projects, you will usually be working with transforms inside "
"transforms by having multiple :ref:`class_Node2D` or :ref:`class_Spatial` "
"nodes parented to each other."
msgstr ""
"在实际项目中，您通常会通过将多个 :ref:`class_Node2D` 或 :ref:`class_Spatial` "
"节点设置为彼此的父级来处理变换中的变换。"

msgid ""
"However, sometimes it's very useful to manually calculate the values we "
"need. We will go over how you could use :ref:`class_Transform2D` or :ref:"
"`class_Transform` to manually calculate transforms of nodes."
msgstr ""
"但是, 有时手动计算我们需要的值非常有用. 我们将介绍如何使用 :ref:"
"`CLASS_Transform2D` 或 :ref:`CLASS_Transform` 手动计算节点转换."

msgid "Converting positions between transforms"
msgstr "在变换之间转换位置"

msgid ""
"There are many cases where you'd want to convert a position in and out of a "
"transform. For example, if you have a position relative to the player and "
"would like to find the world (parent-relative) position, or if you have a "
"world position and want to know where it is relative to the player."
msgstr ""
"在许多情况下, 您可能需要将位置转换为变换中的位置或将其转换为转换外的位置. 例"
"如, 如果您有一个相对于球员的位置并想要查找世界(父级相对)位置, 或者如果您有一"
"个世界位置并想知道它相对于球员的位置."

msgid ""
"We can find what a vector relative to the player would be defined in world "
"space as using the \"xform\" method:"
msgstr ""
"通过“xform”方法，我们可以找到相对于玩家的向量如果定义在世界空间中的话应该是什"
"么："

msgid ""
"And we can use the \"xform_inv\" method to find a what world space position "
"would be if it was instead defined relative to the player:"
msgstr ""
"我们可以使用 \"xform_inv\" 方法来查找世界空间位置(如果它是相对于玩家定义的):"

msgid ""
"If you know in advance that the transform is positioned at (0, 0), you can "
"use the \"basis_xform\" or \"basis_xform_inv\" methods instead, which skip "
"dealing with translation."
msgstr ""
"如果您事先知道变换位于 (0, 0) 处，则可以改"
"用“basis_xform”或“basis_xform_inv”方法，这将跳过处理平移的过程。"

msgid "Moving an object relative to itself"
msgstr "相对于对象本身移动对象"

msgid ""
"A common operation, especially in 3D games, is to move an object relative to "
"itself. For example, in first-person shooter games, you would want the "
"character to move forward (-Z axis) when you press :kbd:`W`."
msgstr ""
"一种常见的操作，尤其是在 3D 游戏中，是相对于自身移动对象。例如，在第一人称射"
"击游戏中，当您按下 :kbd:`W` 键时，您希望角色向前移动（-Z 轴）。"

msgid ""
"Since the basis vectors are the orientation relative to the parent, and the "
"origin vector is the position relative to the parent, we can simply add "
"multiples of the basis vectors to move an object relative to itself."
msgstr ""
"由于基向量是相对于父对象的方向，而原点向量是相对于父对象的位置，因此我们可以"
"简单地将基向量的倍数相加，以相对于对象本身移动对象。"

msgid "This code moves an object 100 units to its own right:"
msgstr "此代码会让对象向它自己的右边移动 100 个单位："

msgid "For moving in 3D, you would need to replace \"x\" with \"basis.x\"."
msgstr "要在 3D 中移动，需要将“x”替换为“basis.x”。"

msgid ""
"In actual projects, you can use `translate_object_local` in 3D or "
"`move_local_x` and `move_local_y` in 2D to do this."
msgstr ""
"在实际工程中，您可以使用 3D 中的 `translate_object_local` 或者 2D 中的 "
"`move_local_x` 和 `move_local_y` 来实现。"

msgid "Applying transforms onto transforms"
msgstr "将变换应用于变换"

msgid ""
"One of the most important things to know about transforms is how you can use "
"several of them together. A parent node's transform affects all of its "
"children. Let's dissect an example."
msgstr ""
"关于转换, 需要了解的最重要的事情之一是如何将几个转换一起使用. 父节点的变换会"
"影响其所有子节点. 让我们来剖析一个例子."

msgid ""
"In this image, the child node has a \"2\" after the component names to "
"distinguish them from the parent node. It might look a bit overwhelming with "
"so many numbers, but remember that each number is displayed twice (next to "
"the arrows and also in the matrices), and that almost half of the numbers "
"are zero."
msgstr ""
"在此图像中, 子节点的组件名称后面有一个 \"2\", 以将其与父节点区分开来. 这么多"
"数字可能看起来有点令人不知所措, 但请记住, 每个数字都会显示两次(在箭头旁边和矩"
"阵中), 而且几乎一半的数字都是零."

msgid ""
"The only transformations going on here are that the parent node has been "
"given a scale of (2, 1), the child has been given a scale of (0.5, 0.5), and "
"both nodes have been given positions."
msgstr ""
"这里进行的唯一转换是父节点的比例为(2,1), 子节点的比例为(0.5,0.5), 两个节点都"
"指定了位置."

msgid ""
"All child transformations are affected by the parent transformations. The "
"child has a scale of (0.5, 0.5), so you would expect it to be a 1:1 ratio "
"square, and it is, but only relative to the parent. The child's X vector "
"ends up being (1, 0) in world space, because it is scaled by the parent's "
"basis vectors. Similarly, the child node's `origin` vector is set to (1, 1), "
"but this actually moves it (2, 1) in world space, due to the parent node's "
"basis vectors."
msgstr ""
"所有子变换都受父变换的影响. 子对象的比例为 (0.5, 0.5), 因此您会认为它是 1:1 "
"的比例正方形, 确实如此, 但仅相对于父对象. 子对象的 X 向量最终在世界空间中为 "
"(1, 0), 因为它是由父对象的基础向量缩放的. 类似地，子节点的 `origin` 向量被设"
"置为(1,1), 但由于父节点的基向量, 这实际上会在世界空间中移动它 (2, 1)."

msgid ""
"To calculate a child transform's world space transform manually, this is the "
"code we would use:"
msgstr "要手动计算子变换的世界空间变换, 我们将使用以下代码:"

msgid ""
"In actual projects, we can find the world transform of the child by applying "
"one transform onto another using the `*` operator:"
msgstr ""
"在实际工程中, 我们可以通过 `*` 运算符将一个变换应用到另一个变换中, 从而找到孩"
"子的世界变换:"

msgid "When multiplying matrices, order matters! Don't mix them up."
msgstr "当矩阵相乘时, 顺序很重要！别把它们弄混了."

msgid "Lastly, applying the identity transform will always do nothing."
msgstr "最后, 应用身份变换始终不起任何作用."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about matrix composition: https://www.youtube.com/watch?"
"v=XkY2DOUCWMU"
msgstr ""
"如果您想了解更多信息，可以查看 3Blue1Brown 关于矩阵组成的精彩视频：\\ "
"https://www.bilibili.com/video/BV1ys411472E?p=5"

msgid "Inverting a transformation matrix"
msgstr "求逆变换矩阵"

msgid ""
"The \"affine_inverse\" function returns a transform that \"undoes\" the "
"previous transform. This can be useful in some situations, but it's easier "
"to just provide a few examples."
msgstr ""
"\"affine_inverse\" 函数返回一个 \"撤销\" 前一个转换的转换. 这在某些情况下可能"
"很有用, 但只提供几个示例会更容易."

msgid ""
"Multiplying an inverse transform by the normal transform undoes all "
"transformations:"
msgstr "将反变换乘以法线变换将撤消所有变换:"

msgid ""
"Transforming a position by a transform and its inverse results in the same "
"position (same for \"xform_inv\"):"
msgstr "通过转换转换位置及其反转会导致相同的位置(与 \"xform_inv\" 相同):"

msgid "How does it all work in 3D?"
msgstr "这一切是如何在 3D 模式下工作的？"

msgid ""
"One of the great things about transformation matrices is that they work very "
"similarly between 2D and 3D transformations. All the code and formulas used "
"above for 2D work the same in 3D, with 3 exceptions: the addition of a third "
"axis, that each axis is of type :ref:`class_Vector3`, and also that Godot "
"stores the :ref:`class_Basis` separately from the :ref:`class_Transform`, "
"since the math can get complex and it makes sense to separate it."
msgstr ""
"变换矩阵的一个伟大之处在于, 它们在2D和3D变换之间的工作方式非常相似. 上面用于"
"2D的所有代码和公式在3D中的工作方式都相同, 只有3个不同之处: 增加了第三个轴, 每"
"个轴的类型为 :ref:`CLASS_Vector3`, 并且Godot将 :ref:`CLASS_Basis` 与 :ref:"
"`CLASS_Transform` 分开存储, 因为数学运算可能会很复杂, 因此将其分开是有意义的."

msgid ""
"All of the concepts for how translation, rotation, scale, and shearing work "
"in 3D are all the same compared to 2D. To scale, we take each component and "
"multiply it; to rotate, we change where each basis vector is pointing; to "
"translate, we manipulate the origin; and to shear, we change the basis "
"vectors to be non-perpendicular."
msgstr ""
"与二维相比, 有关平移, 旋转, 缩放和剪切在三维中的工作方式的所有概念都是相同"
"的. 要缩放, 我们取每个分量并将其相乘；要旋转, 我们更改每个基向量指向的位置；"
"要平移, 我们操纵原点；要剪切, 我们将基向量更改为不垂直."

msgid ""
"If you would like, it's a good idea to play around with transforms to get an "
"understanding of how they work. Godot allows you to edit 3D transform "
"matrices directly from the inspector. You can download this project which "
"has colored lines and cubes to help visualize the :ref:`class_Basis` vectors "
"and the origin in both 2D and 3D: https://github.com/godotengine/godot-demo-"
"projects/tree/master/misc/matrix_transform"
msgstr ""
"如果您愿意, 最好尝试一下转换, 以了解它们是如何工作的. Godot 允许您直接从检查"
"器编辑 3D 变换矩阵. 您可以下载此项目, 其中包含彩色线条和立方体, 以帮助在 2D "
"和 3D 中可视化 :ref:`class_Basis` 向量和原点: https://github.com/godotengine/"
"godot-demo-projects/tree/master/misc/matrix_transform"

msgid ""
"Spatial's \"Matrix\" section in Godot 3.2's inspector displays the matrix as "
"transposed, with the columns horizontal and the rows vertical. This may be "
"changed to be less confusing in a future release of Godot."
msgstr ""
"在 Godot 3.2 的检查器中，Spatial 的“Matrix”部分显示的是转置过的矩阵，横向的是"
"列、纵向的是行。这一点可能会在 Godot 的未来版本中进行更改，使其不那么令人困"
"惑。"

msgid ""
"You cannot edit Node2D's transform matrix directly in Godot 3.2's inspector. "
"This may be changed in a future release of Godot."
msgstr ""
"不能在Godot 3.2的检查器中直接编辑Node2D的变换矩阵. 在Godot的未来版本中, 这一"
"点可能会有所改变."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about 3D linear transformations: https://www.youtube.com/"
"watch?v=rHLEWRxRGiM"
msgstr ""
"如果你想要更多的解释，你可以查看 3Blue1Brown 关于 3D 线性变换的精彩视频：\\ "
"https://www.bilibili.com/video/BV1ys411472E?p=6"

msgid "Representing rotation in 3D (advanced)"
msgstr "表示 3D 中的旋转（高级）"

msgid ""
"The biggest difference between 2D and 3D transformation matrices is how you "
"represent rotation by itself without the basis vectors."
msgstr ""
"2D 和 3D 变换矩阵之间最大的区别在于您如何在没有基向量的情况下自行表示旋转。"

msgid ""
"With 2D, we have an easy way (atan2) to switch between a transformation "
"matrix and an angle. In 3D, we can't simply represent rotation as one "
"number. There is something called Euler angles, which can represent "
"rotations as a set of 3 numbers, however, they are limited and not very "
"useful, except for trivial cases."
msgstr ""
"对于2D, 我们有一个在变换矩阵和角度之间切换的简单方法(Atan2). 在3D中, 我们不能"
"简单地将旋转表示为一个数字. 有一种叫做欧拉角的东西, 它可以将旋转表示为一组3个"
"数字, 但它们是有限的, 除了微不足道的情况外, 它们并不是很有用."

msgid ""
"In 3D we do not typically use angles, we either use a transformation basis "
"(used pretty much everywhere in Godot), or we use quaternions. Godot can "
"represent quaternions using the :ref:`class_Quat` struct. My suggestion to "
"you is to completely ignore how they work under-the-hood, because they are "
"very complicated and unintuitive."
msgstr ""
"在 3D 中，我们通常不使用角度，我们要么使用变换的基（在 Godot 中几乎到处都使"
"用），要么使用四元数。Godot 可以使用 :ref:`class_Quat` 结构表示四元数。我给你"
"的建议是完全忽略它们是如何在幕后工作的，因为它们非常复杂和不直观。"

msgid ""
"However, if you really must know how it works, here are some great "
"resources, which you can follow in order:"
msgstr ""
"然而, 如果你真的想知道它是如何工作的, 这里有一些很棒的参考资料, 你可以按顺序"
"跟随它们:"

msgid "https://www.youtube.com/watch?v=mvmuCPvRoWQ"
msgstr "https://www.bilibili.com/video/BV1fx41187tZ"

msgid "https://www.youtube.com/watch?v=d4EgbgTm0Bg"
msgstr "https://www.bilibili.com/video/BV1SW411y7W1"

msgid "https://eater.net/quaternions"
msgstr "https://eater.net/quaternions"

msgid "Translation status"
msgstr "翻译状态"
