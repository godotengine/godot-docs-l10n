# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Viewports"
msgstr "使用 Viewport"

msgid "Introduction"
msgstr "前言"

msgid ""
"Think of a :ref:`Viewport <class_Viewport>` as a screen onto which the game "
"is projected. In order to see the game, we need to have a surface on which "
"to draw it; that surface is the Root :ref:`Viewport <class_Viewport>`."
msgstr ""
"将 :ref:`Viewports <class_Viewport>` 想成投影游戏的荧幕. 为了看到游戏, 我们需"
"要有一个表面来绘制它, 这个表面是作为根节点的 :ref:`Viewport "
"<class_Viewport>`."

msgid ""
":ref:`Viewports <class_Viewport>` can also be added to the scene so that "
"there are multiple surfaces to draw on. When we are drawing to a :ref:"
"`Viewport <class_Viewport>` that is not the Root, we call it a render "
"target. We can access the contents of a render target by accessing its "
"corresponding :ref:`texture <class_ViewportTexture>`. By using a :ref:"
"`Viewport <class_Viewport>` as a render target, we can either render "
"multiple scenes simultaneously or we can render to a :ref:`texture "
"<class_ViewportTexture>` which is applied to an object in the scene, for "
"example a dynamic skybox."
msgstr ""
":ref:`Viewports <class_Viewport>` 也可以添加到场景中, 以便绘制多个区域. 当我"
"们绘制到一个不是根节点的 :ref:`Viewport <class_Viewport>` 时, 我们将该视口称"
"为渲染目标. 我们可以通过访问它对应的 :ref:`texture <class_ViewportTexture>` "
"属性来访问渲染目标的内容. 将任一 :ref:`Viewport <class_Viewport>` 作为渲染目"
"标时, 我们要么可以同时渲染多个场景, 要么可以渲染到场景中某个对象的 :ref:"
"`texture <class_ViewportTexture>` 上, 例如渲染到动态天空盒的材质上."

msgid ""
":ref:`Viewports <class_Viewport>` have a variety of use cases, including:"
msgstr ":ref:`Viewport <class_Viewport>` 有多种使用情况, 包括:"

msgid "Rendering 3D objects within a 2D game"
msgstr "在2D游戏中渲染3D物体"

msgid "Rendering 2D elements in a 3D game"
msgstr "在3D游戏中渲染2D元素"

msgid "Rendering dynamic textures"
msgstr "渲染动态纹理"

msgid "Generating procedural textures at runtime"
msgstr "在运行时生成程序式纹理"

msgid "Rendering multiple cameras in the same scene"
msgstr "在同一场景中渲染多个摄像机"

msgid ""
"What all these use cases have in common is that you are given the ability to "
"draw objects to a texture as if it were another screen and can then choose "
"what to do with the resulting texture."
msgstr ""
"所有这些用例的共同点是, 你被赋予了在纹理上绘制物体的能力, 就好像它是另一个屏"
"幕一样, 然后可以选择如何处理产生的纹理."

msgid "Input"
msgstr "输入"

msgid ""
":ref:`Viewports <class_Viewport>` are also responsible for delivering "
"properly adjusted and scaled input events to all their children nodes. "
"Typically, input is received by the nearest :ref:`Viewport <class_Viewport>` "
"in the tree, but you can set :ref:`Viewports <class_Viewport>` not to "
"receive input by checking 'Disable Input' to 'on'; this will allow the next "
"nearest :ref:`Viewport <class_Viewport>` in the tree to capture the input."
msgstr ""
":ref:`Viewport <class_Viewport>` 也负责将正确调整和缩放的输入事件传递给他们所"
"有的子节点. 通常, 输入是由树中最近的 :ref:`Viewport <class_Viewport>` 接收"
"的, 但是你可以通过将 'Disable Input' 选为 'on' 来设置 :ref:`Viewport "
"<class_Viewport>` 不接收输入；这将允许树中最近的 :ref:`Viewport "
"<class_Viewport>` 捕捉输入."

msgid ""
"For more information on how Godot handles input, please read the :ref:`Input "
"Event Tutorial<doc_inputevent>`."
msgstr ""
"关于 Godot 如何处理输入的更多信息，请阅读\\ :ref:`输入事件教程 "
"<doc_inputevent>`\\ 。"

msgid "Listener"
msgstr "侦听器"

msgid ""
"Godot supports 3D sound (in both 2D and 3D nodes); more on this can be found "
"in the :ref:`Audio Streams Tutorial<doc_audio_streams>`. For this type of "
"sound to be audible, the :ref:`Viewport <class_Viewport>` needs to be "
"enabled as a listener (for 2D or 3D). If you are using a custom :ref:"
"`Viewport <class_Viewport>` to display your :ref:`World <class_World>`, "
"don't forget to enable this!"
msgstr ""
"Godot 支持 3D 声音（在 2D 和 3D 节点中都支持）；更多信息可以在\\ :ref:`音频流"
"教程 <doc_audio_streams>`\\ 中找到。为了使这种类型的声音能够被听到, :ref:"
"`Viewport <class_Viewport>` 需要被启用为一个监听器(对于2D或3D). 如果你使用一"
"个自定义的 :ref:`Viewport <class_Viewport>` 来显示你的 :ref:`World "
"<class_World>`, 别忘了启用这个功能！"

msgid "Cameras (2D & 3D)"
msgstr "摄像机（2D 和 3D）"

msgid ""
"When using a :ref:`Camera <class_Camera>` / :ref:`Camera2D "
"<class_Camera2D>`, cameras will always display on the closest parent :ref:"
"`Viewport <class_Viewport>` (going towards the root). For example, in the "
"following hierarchy:"
msgstr ""
"当使用 :ref:`Camera <class_Camera>` / :ref:`Camera2D <class_Camera2D>` 时, 摄"
"像机将始终显示在最近的父节点上 :ref:`Viewport <class_Viewport>` (朝向根节"
"点). 例如, 在下面的层次结构中:"

msgid ""
"CameraA will display on the Root :ref:`Viewport <class_Viewport>` and it "
"will draw MeshA. CameraB will be captured by the :ref:`Viewport "
"<class_Viewport>` Node along with MeshB. Even though MeshB is in the scene "
"hierarchy, it will still not be drawn to the Root :ref:`Viewport "
"<class_Viewport>`. Similarly MeshA will not be visible from the :ref:"
"`Viewport <class_Viewport>` node because :ref:`Viewport <class_Viewport>` "
"nodes only capture nodes below them in the hierarchy."
msgstr ""
"CameraA将显示根节点的 :ref:`Viewport <class_Viewport>` , 它将绘制MeshA. "
"CameraB将被 :ref:`Viewport <class_Viewport>` 节点以及MeshB捕获. 即使MeshB在场"
"景层次结构中, 它仍然不会被绘制到根节点的 :ref:`Viewport <class_Viewport>` "
"中. 类似地, 在 :ref:`Viewport <class_Viewport>` 节点中不会看到MeshA, 因为 :"
"ref:`Viewport <class_Viewport>` 节点仅捕获层次结构中它下面的节点."

msgid ""
"There can only be one active camera per :ref:`Viewport <class_Viewport>`, so "
"if there is more than one, make sure that the desired one has the "
"\"current\" property set, or make it the current camera by calling:"
msgstr ""
"每个视口 :ref:`Viewport <class_Viewport>` 只能有一个激活的摄像机, 因此, 如果"
"有多个摄像机时, 请确保您需要的那个摄像机的 \"current\" 属性被设置上, 或者通过"
"调用以下语句来使其成为当前摄像机:"

msgid ""
"By default, cameras will render all objects in their world. In 3D, cameras "
"can use their :ref:`cull_mask <class_Camera_property_cull_mask>` property "
"combined with the :ref:`VisualInstance's <class_VisualInstance>` :ref:`layer "
"<class_VisualInstance_property_layers>` property to restrict which objects "
"are rendered."
msgstr ""
"默认情况下, 相机将渲染其世界中的所有对象. 在3D中, 相机可以使用他们的 :ref:"
"`cull_mask <class_Camera_property_cull_mask>` 属性和 :ref:`VisualInstance's "
"<class_VisualInstance>` :ref:`layer <class_VisualInstance_property_layers>` "
"属性来限制哪些对象被渲染."

msgid "Scale & stretching"
msgstr "缩放和拉伸"

msgid ""
":ref:`Viewports <class_Viewport>` have a \"size\" property, which represents "
"the size of the :ref:`Viewport <class_Viewport>` in pixels. For :ref:"
"`Viewports <class_Viewport>` which are children of :ref:`ViewportContainers "
"<class_viewportcontainer>`, these values are overridden, but for all others, "
"this sets their resolution."
msgstr ""
":ref:`Viewport <class_Viewport>` 有一个“size”属性，表示 :ref:`Viewport "
"<class_Viewport>` 的尺寸，单位为像素。对于 :ref:`ViewportContainers "
"<class_viewportcontainer>` 的子 :ref:`Viewport <class_Viewport>` 节点而言，这"
"些值会被重写，但对于所有其他的节点，这样就设置了它们的分辨率。"

msgid ""
"It is also possible to scale the 2D content and make the :ref:`Viewport "
"<class_Viewport>` resolution different from the one specified in size, by "
"calling:"
msgstr ""
"也可以通过调用 :ref:`Viewport <class_Viewport>` 来缩放2D内容, 并使其分辨率与"
"指定的尺寸不同:"

msgid ""
"The root :ref:`Viewport <class_Viewport>` uses this for the stretch options "
"in the project settings. For more information on scaling and stretching "
"visit the :ref:`Multiple Resolutions Tutorial <doc_multiple_resolutions>`"
msgstr ""
"根节点的 :ref:`Viewport <class_Viewport>` 用到项目设置中的拉伸选项。有关缩放"
"和拉伸的更多信息，请访问\\ :ref:`多分辨率教程 <doc_multiple_resolutions>`"

msgid "Worlds"
msgstr "世界"

msgid ""
"For 3D, a :ref:`Viewport <class_Viewport>` will contain a :ref:`World "
"<class_World>`. This is basically the universe that links physics and "
"rendering together. Spatial-based nodes will register using the :ref:`World "
"<class_World>` of the closest :ref:`Viewport <class_Viewport>`. By default, "
"newly created :ref:`Viewports <class_Viewport>` do not contain a :ref:`World "
"<class_World>` but use the same as their parent :ref:`Viewport "
"<class_Viewport>` (the root :ref:`Viewport <class_Viewport>` always contains "
"a :ref:`World <class_World>`, which is the one objects are rendered to by "
"default). A :ref:`World <class_World>` can be set in a :ref:`Viewport "
"<class_Viewport>` using the \"world\" property, and that will separate all "
"children nodes of that :ref:`Viewport <class_Viewport>` from interacting "
"with the parent :ref:`Viewport's <class_Viewport>` :ref:`World "
"<class_World>`. This is especially useful in scenarios where, for example, "
"you might want to show a separate character in 3D imposed over the game "
"(like in StarCraft)."
msgstr ""
"在 3D 中，\\ :ref:`Viewport <class_Viewport>` 会包含一个 :ref:`World "
"<class_World>`，简单而言就是连接物理和渲染的宇宙。基于 Spatial 的节点会注册到"
"距离最近的 :ref:`Viewport <class_Viewport>` 的 :ref:`World <class_World>` "
"中。新建的 :ref:`Viewports <class_Viewport>` 默认不包含 :ref:`World "
"<class_World>`，会使用和父 :ref:`Viewport <class_Viewport>` 的值（根 :ref:"
"`Viewport <class_Viewport>` 始终包含 :ref:`World <class_World>`，对象默认渲染"
"到此处）。可以通过 :ref:`Viewport <class_Viewport>` 的“world”属性设置 :ref:"
"`World <class_World>`，设置完成后，就会切断该 :ref:`Viewport "
"<class_Viewport>` 所有子节点与父 :ref:`Viewport <class_Viewport>` 中 :ref:"
"`World <class_World>` 的交互。特定情况下这是非常有用的，例如，你可能会想要在"
"游戏之上单独显示一个 3D 角色（类似星际争霸）。"

msgid ""
"As a helper for situations where you want to create :ref:`Viewports "
"<class_Viewport>` that display single objects and don't want to create a :"
"ref:`World <class_World>`, :ref:`Viewport <class_Viewport>` has the option "
"to use its own :ref:`World <class_World>`. This is useful when you want to "
"instance 3D characters or objects in a 2D :ref:`World <class_World2D>`."
msgstr ""
"作为您想要创建的情况的帮助 :ref:`Viewports <class_Viewport>` 显示单个对象而不"
"想创建 :ref:`World <class_World>`, :ref:`Viewport <class_Viewport>` 可以选择"
"使用自己的 :ref:`World <class_World>`. 当您想要在2D :ref:`World "
"<class_World2D>` 中实例化3D角色或对象时, 这非常有用."

msgid ""
"For 2D, each :ref:`Viewport <class_Viewport>` always contains its own :ref:"
"`World2D <class_World2D>`. This suffices in most cases, but in case sharing "
"them may be desired, it is possible to do so by setting the :ref:`Viewport's "
"<class_Viewport>` :ref:`World2D <class_World2D>` manually."
msgstr ""
"对于 2D，每个 :ref:`Viewport <class_Viewport>` 总是包含它自己的 :ref:"
"`World2D <class_World2D>`\\ 。这在大多数情况下都足够了，但是如果需要共享，可"
"以手动设置 :ref:`Viewport <class_Viewport>` 的 :ref:`World2D "
"<class_World2D>`\\ 。"

msgid ""
"For an example of how this works, see the demo projects `3D in 2D <https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ "
"and `2D in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/2d_in_3d>`_ respectively."
msgstr ""
"关于如何工作的例子, 请分别参阅演示项目 `3D in 2D <https://github.com/"
"godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ 和 `2D in "
"3D <https://github.com/godotengine/godot-demo-projects/tree/master/"
"viewport/2d_in_3d>`_ ."

msgid "Capture"
msgstr "Capture（捕获）"

msgid ""
"It is possible to query a capture of the :ref:`Viewport <class_Viewport>` "
"contents. For the root :ref:`Viewport <class_Viewport>`, this is effectively "
"a screen capture. This is done with the following code:"
msgstr ""
"可以查询 :ref:`Viewport <class_Viewport>` 内容的捕获. 对于根 :ref:`Viewport "
"<class_Viewport>` , 这实际上是一个屏幕截图. 这可以通过以下代码完成:"

msgid ""
"But if you use this in ``_ready()`` or from the first frame of the :ref:"
"`Viewport's <class_Viewport>` initialization, you will get an empty texture "
"because there is nothing to get as texture. You can deal with it using (for "
"example):"
msgstr ""
"但是如果你在 ``_ready()`` 中使用, 或者从 :ref:`Viewport 的 <class_Viewport>` "
"初始化的第一帧开始使用, 你会得到一个空的纹理, 因为没有什么可以作为纹理获得. "
"你可以用来处理它, 例如:"

msgid "Viewport Container"
msgstr "视口容器"

msgid ""
"If the :ref:`Viewport <class_Viewport>` is a child of a :ref:"
"`ViewportContainer <class_viewportcontainer>`, it will become active and "
"display anything it has inside. The layout looks like this:"
msgstr ""
"如果 :ref:`Viewport <class_Viewport>` 是 :ref:`ViewportContainer "
"<class_viewportcontainer>` 的子节点, 它将变为活动状态并显示其内部的任何内容. "
"布局看起来像这样:"

msgid ""
"The :ref:`Viewport <class_Viewport>` will cover the area of its parent :ref:"
"`ViewportContainer <class_viewportcontainer>` completely if :ref:"
"`Stretch<class_viewportcontainer_property_stretch>` is set to ``true`` in :"
"ref:`ViewportContainer <class_viewportcontainer>`. Note: The size of the :"
"ref:`ViewportContainer <class_viewportcontainer>` cannot be smaller than the "
"size of the :ref:`Viewport <class_Viewport>`."
msgstr ""
"如果 :ref:`ViewportContainer <class_viewportcontainer>` 的 :ref:"
"`Stretch<class_viewportcontainer_property_stretch>` 为 ``true``\\ ，那么 :"
"ref:`Viewport <class_Viewport>` 就会完全覆盖这个父 :ref:`ViewportContainer "
"<class_viewportcontainer>`。注意：该 :ref:`ViewportContainer "
"<class_viewportcontainer>` 的大小不能小于 :ref:`Viewport <class_Viewport>` 的"
"大小。"

msgid "Rendering"
msgstr "渲染"

msgid ""
"Due to the fact that the :ref:`Viewport <class_Viewport>` is an entryway "
"into another rendering surface, it exposes a few rendering properties that "
"can be different from the project settings. The first is MSAA; you can "
"choose to use a different level of MSAA for each :ref:`Viewport "
"<class_Viewport>`; the default behavior is DISABLED. You can also set the :"
"ref:`Viewport <class_Viewport>` to use HDR, HDR is very useful for when you "
"want to store values in the texture that are outside the range 0.0 - 1.0."
msgstr ""
"由于以下事实 :ref:`Viewport <class_Viewport>` 是进入另一个渲染表面的入口, 它"
"会暴露一些可能与项目设置不同的渲染属性. 第一个是MSAA, 您可以选择为每个使用不"
"同级别的MSAA :ref:`Viewport <class_Viewport>`, 默认行为是DISABLED. 您还可以设"
"置 :ref:`Viewport <class_Viewport>` 以使用HDR, 当您想要在纹理中存储超出0.0 - "
"1.0范围的值时,HDR非常有用."

msgid ""
"If you know how the :ref:`Viewport <class_Viewport>` is going to be used, "
"you can set its Usage to either 3D or 2D. Godot will then restrict how the :"
"ref:`Viewport <class_Viewport>` is drawn to in accordance with your choice; "
"default is 3D. The 2D usage mode is slightly faster and uses less memory "
"compared to the 3D one. It's a good idea to set the :ref:`Viewport "
"<class_Viewport>`'s Usage property to 2D if your viewport doesn't render "
"anything in 3D."
msgstr ""
"如果你知道 :ref:`Viewport <class_Viewport>` 将被如何使用，可以把它的用法设置"
"为 3D 或 2D。这样 Godot 就会根据选择限制 :ref:`Viewport <class_Viewport>` 的"
"绘制方式；默认是 3D。与 3D 使用模式相比，2D使用模式的速度稍快，占用的内存也"
"少。如果视口没有在 3D 中渲染任何东西，将 :ref:`Viewport <class_Viewport>` 的"
"使用属性设置为 2D 是一个好主意。"

msgid ""
"If you need to render 3D shadows in the viewport, make sure to set the "
"viewport's *Shadow Atlas Size* property to a value higher than 0. Otherwise, "
"shadows won't be rendered. For reference, the Project Settings define it to "
"4096 by default."
msgstr ""
"如果需要在视图中渲染3D阴影, 请确保将视图的 *Shadow Atlas Size阴影贴图集大小* "
"属性设置为大于0的值. 否则, 阴影将不会被渲染. 作为参考, 项目设置默认定义为"
"4096."

msgid ""
"Godot also provides a way of customizing how everything is drawn inside :ref:"
"`Viewports <class_Viewport>` using “Debug Draw”. Debug Draw allows you to "
"specify one of four options for how the :ref:`Viewport <class_Viewport>` "
"will display things drawn inside it. Debug Draw is disabled by default."
msgstr ""
"Godot还提供了一种自定义内部绘制方式的方法 :ref:`Viewports <class_Viewport>` "
"使用\"Debug Draw\". Debug Draw允许您指定以下四个选项之一 :ref:`Viewport "
"<class_Viewport>` 将显示在其中绘制的内容. 默认情况下禁用Debug Draw."

msgid "*A scene drawn with Debug Draw disabled*"
msgstr "*禁用Debug Draw绘制的场景*"

msgid ""
"The other three options are Unshaded, Overdraw, and Wireframe. Unshaded "
"draws the scene without using lighting information so all the objects appear "
"flatly colored the color of their albedo."
msgstr ""
"其他三个选项是Unhaded,Overdraw和Wireframe. 无阴影在不使用光照信息的情况下绘制"
"场景, 因此所有对象都显示为其反射颜色的扁平颜色."

msgid "*The same scene with Debug Draw set to Unshaded*"
msgstr "*Debug Draw设置为Unshaded的相同场景*"

msgid ""
"Overdraw draws the meshes semi-transparent with an additive blend so you can "
"see how the meshes overlap."
msgstr "Overdraw 使用加法混合绘制半透明的网格，以便您可以看到网格重叠的方式。"

msgid "*The same scene with Debug Draw set to Overdraw*"
msgstr "*Debug Draw设置为Overdraw的同一场景*"

msgid ""
"Lastly, Wireframe draws the scene using only the edges of triangles in the "
"meshes."
msgstr "最后, 绘制的场景中线框仅使用网格中里边缘的三角形."

msgid ""
"The effects of the Wireframe mode are only visible in the editor, not while "
"the project is running."
msgstr "线框模式的效果只在编辑器中可看见, 在项目运行时不可见."

msgid "Render target"
msgstr "渲染目标"

msgid ""
"When rendering to a :ref:`Viewport <class_Viewport>`, whatever is inside "
"will not be visible in the scene editor. To display the contents, you have "
"to draw the :ref:`Viewport's <class_Viewport>` :ref:`ViewportTexture "
"<class_ViewportTexture>` somewhere. This can be requested via code using "
"(for example):"
msgstr ""
"当渲染到一个 :ref:`Viewport <class_Viewport>` 时, 里面的东西在场景编辑器中是"
"看不到的. 为了显示内容, 你必须在某个地方绘制 :ref:`Viewport's "
"<class_Viewport>` :ref:`ViewportTexture <class_ViewportTexture>`. 这可以通过"
"代码使用, 例如:"

msgid ""
"Or it can be assigned in the editor by selecting \"New ViewportTexture\""
msgstr "或者可以通过选择\"New ViewportTexture\"在编辑器中指定它"

msgid ""
"and then selecting the :ref:`Viewport <class_Viewport>` you want to use."
msgstr "然后选择您想要使用的 :ref:`Viewport <class_Viewport>`."

msgid ""
"Every frame, the :ref:`Viewport <class_Viewport>`'s texture is cleared away "
"with the default clear color (or a transparent color if :ref:`Transparent "
"Bg<class_Viewport_property_transparent_bg>` is set to ``true``). This can be "
"changed by setting :ref:`Clear "
"Mode<class_Viewport_property_render_target_clear_mode>` to Never or Next "
"Frame. As the name implies, Never means the texture will never be cleared, "
"while next frame will clear the texture on the next frame and then set "
"itself to Never."
msgstr ""
"每一帧, :ref:`Viewport <class_Viewport>` 的纹理都会被清除, 并使用默认的透明色"
"(或者如果 :ref:`Transparent Bg<class_Viewport_property_transparent_bg>` 被设"
"置为 ``true`` ). 这可以通过设置 :ref:`Clear "
"Mode<class_Viewport_property_render_target_clear_mode>` 为Never或Next Frame来"
"改变. 顾名思义,Never意味着纹理将永远不会被清除, 而Next Frame将在下一帧清除纹"
"理, 然后将自己设置为Never."

msgid ""
"By default, re-rendering of the :ref:`Viewport <class_Viewport>` happens "
"when the :ref:`Viewport <class_Viewport>`'s :ref:`ViewportTexture "
"<class_ViewportTexture>` has been drawn in a frame. If visible, it will be "
"rendered; otherwise, it will not. This behavior can be changed to manual "
"rendering (once), or always render, no matter if visible or not. This "
"flexibility allows users to render an image once and then use the texture "
"without incurring the cost of rendering every frame."
msgstr ""
"默认情况下，\\ :ref:`Viewport <class_Viewport>` 的重新渲染会发生在 :ref:"
"`Viewport <class_Viewport>` 的 :ref:`ViewportTexture "
"<class_ViewportTexture>` 在一帧中被绘制时。可见是会渲染；不可见时则不会。这个"
"行为可以改为手动渲染（单次）或者无论是否可见总是渲染。这种灵活性使用户可以渲"
"染一次图像，然后使用纹理，而不需要承担每一帧渲染的消耗。"

msgid ""
"Make sure to check the Viewport demos! Viewport folder in the demos archive "
"available to download, or https://github.com/godotengine/godot-demo-projects/"
"tree/master/viewport"
msgstr ""
"一定要查看Viewport演示！ 可以下载演示档案中的Viewport文件夹, 或https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport"

msgid "Translation status"
msgstr "翻译状态"
