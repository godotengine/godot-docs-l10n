# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Optimization using MultiMeshes"
msgstr "使用 MultiMesh 优化"

msgid ""
"For large amount of instances (in the thousands), that need to be constantly "
"processed (and certain amount of control needs to be retained), :ref:`using "
"servers directly <doc_using_servers>` is the recommended optimization."
msgstr ""
"对于大量的实例(成千上万), 需要不断处理(需要保留一定的控制), 建议优化 :ref:`直"
"接使用服务 <doc_using_servers>` ."

msgid ""
"When the amount of objects reach the hundreds of thousands or millions, none "
"of these approaches are efficient anymore. Still, depending on the "
"requirements, there is one more optimization possible."
msgstr ""
"当对象数量达到数十万或数百万时, 这些方法都不再有效. 尽管如此, 根据要求, 还有"
"另一种可能的优化方法."

msgid "MultiMeshes"
msgstr "MultiMesh"

msgid ""
"A :ref:`MultiMesh<class_MultiMesh>` is a single draw primitive that can draw "
"up to millions of objects in one go. It's extremely efficient because it "
"uses the GPU hardware to do this (in OpenGL ES 2.0, it's less efficient "
"because there is no hardware support for it, though)."
msgstr ""
":ref:`MultiMesh<class_MultiMesh>` 是一个单次绘制的图元，可以一次性绘制多达数"
"百万个对象。它的效率非常高，因为它使用 GPU 硬件来做这件事（不过在 OpenGL ES "
"2.0 中，它的效率较低，因为没有硬件支持）。"

msgid ""
"The only drawback is that there is no *screen* or *frustum* culling possible "
"for individual instances. This means, that millions of objects will be "
"*always* or *never* drawn, depending on the visibility of the whole "
"MultiMesh. It is possible to provide a custom visibility rect for them, but "
"it will always be *all-or-none* visibility."
msgstr ""
"唯一的缺点是, 对于单个实例, 不可能进行 *屏幕* 或 *视锥* 剔除. 这意味着, 根据"
"整个MultiMesh的可见性, 数百万个对象将被 *始终* 或 *不会* 绘制. 可以为它们提供"
"一个自定义的可见性矩形, 但它将始终是 *全或无* 的可见性."

msgid ""
"If the objects are simple enough (just a couple of vertices), this is "
"generally not much of a problem as most modern GPUs are optimized for this "
"use case. A workaround is to create several MultiMeshes for different areas "
"of the world."
msgstr ""
"如果对象足够简单(只有几个顶点), 这通常不是什么大问题, 因为大多数现代GPU都为这"
"种用例进行了优化. 一个变通的方法是为世界的不同区域创建多个MultiMeshes."

msgid ""
"It is also possible to execute some logic inside the vertex shader (using "
"the ``INSTANCE_ID`` or ``INSTANCE_CUSTOM`` built-in constants). For an "
"example of animating thousands of objects in a MultiMesh, see the :ref:"
"`Animating thousands of fish <doc_animating_thousands_of_fish>` tutorial. "
"Information to the shader can be provided via textures (there are floating-"
"point :ref:`Image<class_Image>` formats which are ideal for this)."
msgstr ""
"也可以在顶点着色器中执行一些逻辑(使用 ``INSTANCE_ID`` 或 ``INSTANCE_CUSTOM`` "
"内置常量). 关于在MultiMesh中对数千个对象进行动画制作的例子, 请参见 :ref:"
"`Animating thousands of fish <doc_animating_thousands_of_fish>` 教程. 可以通"
"过纹理向着色器提供信息(有浮点 :ref:`Image<class_Image>` 格式是理想的格式)."

#, fuzzy
msgid ""
"Another alternative is to use a GDExtension and C++, which should be "
"extremely efficient (it's possible to set the entire state for all objects "
"using linear memory via the :ref:`RenderingServer.multimesh_set_buffer() "
"<class_RenderingServer_method_multimesh_set_buffer>` function). This way, "
"the array can be created with multiple threads, then set in one call, "
"providing high cache efficiency."
msgstr ""
"另一种选择是使用GDNative和C++, 效率应该非常高(可以通过 :ref:`VisualServer."
"multimesh_set_as_bulk_array() "
"<class_VisualServer_method_multimesh_set_as_bulk_array>` 函数来设置所有对象使"
"用线性内存的全部状态). 这样一来, 可以用多个线程创建数组, 然后在一次调用中设"
"置, 提供了很高的缓存效率."

msgid ""
"Finally, it's not required to have all MultiMesh instances visible. The "
"amount of visible ones can be controlled with the :ref:`MultiMesh."
"visible_instance_count <class_MultiMesh_property_visible_instance_count>` "
"property. The typical workflow is to allocate the maximum amount of "
"instances that will be used, then change the amount visible depending on how "
"many are currently needed."
msgstr ""
"最后, 并不是所有的MultiMesh实例都必须是可见的. 可以通过 :ref:`MultiMesh."
"visible_instance_count <class_MultiMesh_property_visible_instance_count>` 属"
"性来控制可见的数量. 典型的工作流程是先分配最大数量的实例, 然后根据当前需要的"
"数量改变可见的数量."

msgid "Multimesh example"
msgstr "多重网格示例"

msgid ""
"Here is an example of using a MultiMesh from code. Languages other than "
"GDScript may be more efficient for millions of objects, but for a few "
"thousands, GDScript should be fine."
msgstr ""
"这里是一个从代码中使用MultiMesh的例子.GDScript以外的其他语言对于数百万个对象"
"来说可能更有效, 但对于几千个对象来说,GDScript应该是可以的."

msgid "Translation status"
msgstr "翻译状态"
