# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "CPU optimization"
msgstr "CPU 优化"

msgid "Measuring performance"
msgstr "测量性能"

#, fuzzy
msgid ""
"We have to know where the \"bottlenecks\" are to know how to speed up our "
"program. Bottlenecks are the slowest parts of the program that limit the "
"rate that everything can progress. Focusing on bottlenecks allows us to "
"concentrate our efforts on optimizing the areas which will give us the "
"greatest speed improvement, instead of spending a lot of time optimizing "
"functions that will lead to small performance improvements."
msgstr ""
"我们必须知道“瓶颈”在哪里，才能知道如何加快我们的程序。瓶颈是指程序中最慢的部"
"分，限制了所有事情的进展速度。专注于瓶颈，可以让我们集中精力优化能给我们带来"
"最大速度提升的地方，而不是花大量时间去优化那些能带来微小性能提升的功能。"

msgid ""
"For the CPU, the easiest way to identify bottlenecks is to use a profiler."
msgstr "对于 CPU 来说，找出瓶颈的最简单方法就是使用性能剖析器。"

msgid "CPU profilers"
msgstr "CPU 分析器"

msgid ""
"Profilers run alongside your program and take timing measurements to work "
"out what proportion of time is spent in each function."
msgstr ""
"剖析器与你的程序一起运行, 并进行时间测量, 以计算出每个功能所花费的时间比例."

msgid ""
"The Godot IDE conveniently has a built-in profiler. It does not run every "
"time you start your project: it must be manually started and stopped. This "
"is because, like most profilers, recording these timing measurements can "
"slow down your project significantly."
msgstr ""
"Godot集成开发环境有一个方便的内置剖析器. 它不会在每次启动项目时运行: 必须手动"
"启动和停止. 这是因为, 与大多数剖析器一样, 记录这些时序测量会大大减慢你的项目"
"速度."

msgid "After profiling, you can look back at the results for a frame."
msgstr "剖析后, 你可以回看一帧的结果."

msgid "Screenshot of the Godot profiler"
msgstr "Godot 性能分析器的截图"

msgid "Results of a profile of one of the demo projects."
msgstr "其中一个演示项目的简介结果."

msgid ""
"We can see the cost of built-in processes such as physics and audio, as well "
"as seeing the cost of our own scripting functions at the bottom."
msgstr ""
"我们可以看到物理, 音频等内置流程的消耗, 也可以在底部看到自己脚本功能的消耗."

msgid ""
"Time spent waiting for various built-in servers may not be counted in the "
"profilers. This is a known bug."
msgstr "等待各种内置服务器的时间可能不会被计算在剖析器中. 这是一个已知的错误."

msgid ""
"When a project is running slowly, you will often see an obvious function or "
"process taking a lot more time than others. This is your primary bottleneck, "
"and you can usually increase speed by optimizing this area."
msgstr ""
"当一个项目运行缓慢时, 你经常会看到一个明显的功能或流程比其他功能或流程花费更"
"多的时间. 这是你的主要瓶颈, 你通常可以通过优化这个领域来提高速度."

msgid ""
"For more info about using Godot's built-in profiler, see :ref:"
"`doc_debugger_panel`."
msgstr "有关使用Godot内置分析器的更多信息, 请参阅: :ref:`doc_debugger_panel`."

msgid "External profilers"
msgstr "外部分析器"

msgid ""
"Although the Godot IDE profiler is very convenient and useful, sometimes you "
"need more power, and the ability to profile the Godot engine source code "
"itself."
msgstr ""
"虽然Godot IDE剖析器非常方便有用, 但有时你需要更强大的功能, 以及对Godot引擎源"
"代码本身进行剖析的能力."

msgid ""
"You can :ref:`use a number of third-party C++ profilers "
"<doc_using_cpp_profilers>` to do this."
msgstr ""
"你可以 :ref:`使用若干个第三方 C++ 分析器 <doc_using_cpp_profilers>` 来实现。"

msgid "Screenshot of Callgrind"
msgstr "Callgrind 的截图"

msgid "Example results from Callgrind, which is part of Valgrind."
msgstr "例子结果来自Callgrind, 这是Valgrind的一部分."

msgid ""
"From the left, Callgrind is listing the percentage of time within a function "
"and its children (Inclusive), the percentage of time spent within the "
"function itself, excluding child functions (Self), the number of times the "
"function is called, the function name, and the file or module."
msgstr ""
"从左边开始,Callgrind正在列出函数及其子函数内的时间百分比(Inclusive), 函数本身"
"(不包括子函数)内的时间百分比(Self), 函数被调用的次数, 函数名称以及文件或模块."

#, fuzzy
msgid ""
"In this example, we can see nearly all time is spent under the ``Main::"
"iteration()`` function. This is the master function in the Godot source code "
"that is called repeatedly. It causes frames to be drawn, physics ticks to be "
"simulated, and nodes and scripts to be updated. A large proportion of the "
"time is spent in the functions to render a canvas (66%), because this "
"example uses a 2D benchmark. Below this, we see that almost 50% of the time "
"is spent outside Godot code in ``libglapi`` and ``i965_dri`` (the graphics "
"driver). This tells us the a large proportion of CPU time is being spent in "
"the graphics driver."
msgstr ""
"在这个例子中，我们可以看到几乎所有的时间都花在 `Main::iter()` 函数下。这是 "
"Godot 源代码中被反复调用的主函数。它导致帧被绘制、物理周期被模拟、节点和脚本"
"被更新。很大一部分时间是花在渲染画布的函数中（66%），因为这个例子使用的是 2D "
"基准。下面，我们看到几乎 50% 的时间都花在了 Godot 代码之外的 ``libglapi`` 和 "
"``i965_dri``\\ （图形驱动）中。这告诉我们，很大一部分 CPU 时间都花在了图形驱"
"动上。"

msgid ""
"This is actually an excellent example because, in an ideal world, only a "
"very small proportion of time would be spent in the graphics driver. This is "
"an indication that there is a problem with too much communication and work "
"being done in the graphics API. This specific profiling led to the "
"development of 2D batching, which greatly speeds up 2D rendering by reducing "
"bottlenecks in this area."
msgstr ""
"这其实是一个很好的例子, 因为在理想的世界里, 只有很小一部分时间会花在图形驱动"
"上. 这说明存在一个问题, 就是在图形API中进行了太多的交流和工作. 这种特殊的剖析"
"导致了2D批处理的发展, 通过减少这方面的瓶颈, 大大加快了2D渲染的速度."

msgid "Manually timing functions"
msgstr "手动计时函数"

msgid ""
"Another handy technique, especially once you have identified the bottleneck "
"using a profiler, is to manually time the function or area under test. The "
"specifics vary depending on the language, but in GDScript, you would do the "
"following:"
msgstr ""
"另一个方便的技术, 特别是当你使用分析器确定了瓶颈后, 就是手动为功能或被测区域"
"计时. 具体细节因语言而异, 但在GDScript中, 你可以做如下操作:"

msgid ""
"When manually timing functions, it is usually a good idea to run the "
"function many times (1,000 or more times), instead of just once (unless it "
"is a very slow function). The reason for doing this is that timers often "
"have limited accuracy. Moreover, CPUs will schedule processes in a haphazard "
"manner. Therefore, an average over a series of runs is more accurate than a "
"single measurement."
msgstr ""
"当手动为函数计时时, 通常最好是多次(1000次或更多次)运行该函数, 而不是只运行一"
"次(除非是非常慢的函数). 这样做的原因是, 定时器的精度往往有限. 此外,CPU会以一"
"种无序的方式调度进程. 因此, 一系列运行的平均值比单次测量更准确."

msgid ""
"As you attempt to optimize functions, be sure to either repeatedly profile "
"or time them as you go. This will give you crucial feedback as to whether "
"the optimization is working (or not)."
msgstr ""
"当你尝试优化功能时, 一定要反复对它们进行剖析或计时. 这将为你提供关键的反馈, "
"说明优化是否有效(或无效)."

msgid "Caches"
msgstr "缓存"

msgid ""
"CPU caches are something else to be particularly aware of, especially when "
"comparing timing results of two different versions of a function. The "
"results can be highly dependent on whether the data is in the CPU cache or "
"not. CPUs don't load data directly from the system RAM, even though it's "
"huge in comparison to the CPU cache (several gigabytes instead of a few "
"megabytes). This is because system RAM is very slow to access. Instead, CPUs "
"load data from a smaller, faster bank of memory called cache. Loading data "
"from cache is very fast, but every time you try and load a memory address "
"that is not stored in cache, the cache must make a trip to main memory and "
"slowly load in some data. This delay can result in the CPU sitting around "
"idle for a long time, and is referred to as a \"cache miss\"."
msgstr ""
"CPU缓存是另外一个需要特别注意的东西, 特别是在比较一个函数的两个不同版本的时序"
"结果时. 其结果可能高度依赖于数据是否在CPU缓存中.CPU不会直接从系统RAM中加载数"
"据, 尽管它与CPU缓存相比非常巨大(几千兆字节而不是几兆字节). 这是因为系统RAM的"
"访问速度非常慢. 相反,CPU从一个较小, 较快的内存库中加载数据, 称为cache. 从缓存"
"中加载数据的速度非常快, 但每次你试图加载一个没有存储在缓存中的内存地址时, 缓"
"存必须前往主内存并缓慢地加载一些数据. 这种延迟会导致CPU长时间闲置, 被称为 "
"\"cache miss\"."

msgid ""
"This means that the first time you run a function, it may run slowly because "
"the data is not in the CPU cache. The second and later times, it may run "
"much faster because the data is in the cache. Due to this, always use "
"averages when timing, and be aware of the effects of cache."
msgstr ""
"这意味着, 第一次运行一个函数时, 由于数据不在CPU缓存中, 它可能运行得很慢. 第二"
"次和以后的时间, 可能运行得更快, 因为数据在缓存中. 由于这个原因, 在计时时一定"
"要使用平均数, 并且要注意缓存的影响."

msgid ""
"Understanding caching is also crucial to CPU optimization. If you have an "
"algorithm (routine) that loads small bits of data from randomly spread out "
"areas of main memory, this can result in a lot of cache misses, a lot of the "
"time, the CPU will be waiting around for data instead of doing any work. "
"Instead, if you can make your data accesses localised, or even better, "
"access memory in a linear fashion (like a continuous list), then the cache "
"will work optimally and the CPU will be able to work as fast as possible."
msgstr ""
"了解缓存对于CPU优化也是至关重要的. 如果你有一个算法(例程), 从主内存随机分布的"
"区域加载小数据位, 这可能会导致大量的缓存失误, 很多时候,CPU会在附近等待数据, "
"而不是做别的工作. 相反, 如果你能使你的数据访问本地化, 或者更好的是以线性方式"
"访问内存(像一个连续的列表), 那么缓存将以最佳方式工作,CPU将能够尽可能快地工作."

#, fuzzy
msgid ""
"Godot usually takes care of such low-level details for you. For example, the "
"Server APIs make sure data is optimized for caching already for things like "
"rendering and physics. Still, you should be especially aware of caching when "
"writing GDExtensions."
msgstr ""
"Godot通常会为你处理这些低级的细节. 例如, 服务器API确保数据已经为渲染和物理学"
"等方面的缓存进行了优化. 不过, 在使用 :ref:`GDNative <toc-tutorials-"
"gdnative>` 时, 你还是要特别注意缓存问题."

msgid "Languages"
msgstr "语言"

msgid ""
"Godot supports a number of different languages, and it is worth bearing in "
"mind that there are trade-offs involved. Some languages are designed for "
"ease of use at the cost of speed, and others are faster but more difficult "
"to work with."
msgstr ""
"Godot支持多种不同的语言, 值得注意的是, 其中有一些折衷. 有些语言是以速度为代价"
"而设计的, 便于使用, 而另一些语言速度更快, 但更难使用."

msgid ""
"Built-in engine functions run at the same speed regardless of the scripting "
"language you choose. If your project is making a lot of calculations in its "
"own code, consider moving those calculations to a faster language."
msgstr ""
"无论你选择哪种脚本语言, 内置的引擎函数都以同样的速度运行. 如果你的项目在自己"
"的代码中进行了大量的计算, 可以考虑将这些计算转移到更快的语言中."

msgid "GDScript"
msgstr "GDScript"

msgid ""
":ref:`GDScript <toc-learn-scripting-gdscript>` is designed to be easy to use "
"and iterate, and is ideal for making many types of games. However, in this "
"language, ease of use is considered more important than performance. If you "
"need to make heavy calculations, consider moving some of your project to one "
"of the other languages."
msgstr ""
":ref:`GDScript <toc-learn-scripting-gdscript>` 被设计成易于使用和迭代的语言, "
"是制作多种类型游戏的理想选择. 然而, 在这种语言中, 易用性被认为比性能更重要. "
"如果你需要进行繁重的计算, 请考虑将你的一些项目转移到其他语言中."

msgid "C#"
msgstr "C#"

#, fuzzy
msgid ""
":ref:`C# <toc-learn-scripting-C#>` is popular and has first-class support in "
"Godot. It offers a good compromise between speed and ease of use. Beware of "
"possible garbage collection pauses and leaks that can occur during gameplay, "
"though. A common approach to workaround issues with garbage collection is to "
"use *object pooling*, which is outside the scope of this guide."
msgstr ""
":ref:`C # <toc-learn-scripting-C#>` 很受欢迎, 在Godot中得到了一流的支持. 它在"
"速度和易用性之间提供了一个很好的折中. 不过要注意游戏过程中可能出现的垃圾收集"
"暂停和泄漏. 解决垃圾收集问题的一个常见方法是使用 *对象池*, 这不在本指南的范围"
"内."

msgid "Other languages"
msgstr "其他语言"

#, fuzzy
msgid ""
"Third parties provide support for several other languages, including `Rust "
"<https://github.com/godot-rust/gdext>`_."
msgstr ""
"第三方提供对其他几种语言的支持，包括 `Rust <https://github.com/godot-rust/"
"godot-rust>`_ 和 `Javascript <https://github.com/GodotExplorer/"
"ECMAScript>`_\\ 。"

msgid "C++"
msgstr "C++"

msgid ""
"Godot is written in C++. Using C++ will usually result in the fastest code. "
"However, on a practical level, it is the most difficult to deploy to end "
"users' machines on different platforms. Options for using C++ include "
"GDExtensions and :ref:`custom modules <doc_custom_modules_in_cpp>`."
msgstr ""
"Godot 是用 C++ 编写的。使用 C++ 通常会产生最快的代码。然而，在实际层面上，部"
"署到不同平台的最终用户机器上是最困难的。使用 C++ 的选项包括 GDExtensions 和 :"
"ref:`自定义模块 <doc_custom_modules_in_cpp>`。"

msgid "Threads"
msgstr "线程"

msgid ""
"Consider using threads when making a lot of calculations that can run in "
"parallel to each other. Modern CPUs have multiple cores, each one capable of "
"doing a limited amount of work. By spreading work over multiple threads, you "
"can move further towards peak CPU efficiency."
msgstr ""
"在进行大量的计算时, 考虑使用线程, 这些计算可以相互并行运行. 现代CPU有多个核"
"心, 每个核心能做的工作量有限. 通过将工作分散在多个线程上, 你可以进一步向CPU的"
"峰值效率迈进."

#, fuzzy
msgid ""
"The disadvantage of threads is that you have to be incredibly careful. As "
"each CPU core operates independently, they can end up trying to access the "
"same memory at the same time. One thread can be reading to a variable while "
"another is writing: this is called a *race condition*. Before you use "
"threads, make sure you understand the dangers and how to try and prevent "
"these race conditions. Threads can make debugging considerably more "
"difficult."
msgstr ""
"线程的缺点是，你必须非常小心。由于每个 CPU 核心都是独立运行的，它们最终可能会"
"在同一时间试图访问相同的内存。一个线程可以在另一个线程在写的时候读取一个变"
"量：这被称为\\ *竞态条件*\\ 。在你使用线程之前，请确保你了解这些危险以及如何"
"尝试和防止这些竞态条件。"

msgid "For more information on threads, see :ref:`doc_using_multiple_threads`."
msgstr "有关线程的更多信息, 请参见 :ref:`doc_using_multiple_threads`."

msgid "SceneTree"
msgstr "SceneTree"

msgid ""
"Although Nodes are an incredibly powerful and versatile concept, be aware "
"that every node has a cost. Built-in functions such as ``_process()`` and "
"``_physics_process()`` propagate through the tree. This housekeeping can "
"reduce performance when you have a very large numbers of nodes (how many "
"exactly depends on the target platform and can range from thousands to tens "
"of thousands so ensure that you profile performance on all target platforms "
"during development)."
msgstr ""
"虽然节点是一个非常强大、涉及面广泛的概念，但请注意：每个节点都是有代价的。内"
"置函数，如 `_process()` 和 `_physics_process()` 会在节点树上遍历每个节点进行"
"调用。当你有非常多的节点时，这种内务管理就会降低性能。（节点的数量取决于目标"
"平台，可能从数千到数万不等，请确保在开发过程中评测所有目标平台上的性能）。"

msgid ""
"Each node is handled individually in the Godot renderer. Therefore, a "
"smaller number of nodes with more in each can lead to better performance."
msgstr ""
"在 Godot 渲染器中，每个节点都是单独处理的。总的节点数量越少，每个节点中的节点"
"越多，可以获得更好的性能。"

msgid ""
"One quirk of the :ref:`SceneTree <class_SceneTree>` is that you can "
"sometimes get much better performance by removing nodes from the SceneTree, "
"rather than by pausing or hiding them. You don't have to delete a detached "
"node. You can for example, keep a reference to a node, detach it from the "
"scene tree using :ref:`Node.remove_child(node) "
"<class_Node_method_remove_child>`, then reattach it later using :ref:`Node."
"add_child(node) <class_Node_method_add_child>`. This can be very useful for "
"adding and removing areas from a game, for example."
msgstr ""
":ref:`SceneTree <class_SceneTree>` 比较奇怪的一点是：你有时可以通过从 "
"SceneTree 中删除节点，而非暂停或隐藏节点这种方式来获得更好的性能，不一定要删"
"除一个从场景树中分离出来的的节点。例如，你可以保留一个节点的引用，使用 :ref:"
"`Node.remove_child(node) <class_Node_method_remove_child>` 将该节点从场景树中"
"分离出来，然后使用 :ref:`Node.add_child(node) <class_Node_method_add_child>` "
"将其重新加回场景树。对于在游戏中添加和删除区域，这一点十分有用。"

msgid ""
"You can avoid the SceneTree altogether by using Server APIs. For more "
"information, see :ref:`doc_using_servers`."
msgstr ""
"你可以通过使用服务器API来完全避免使用 SceneTree。更多信息请参见 :ref:"
"`doc_using_servers` 。"

msgid "Physics"
msgstr "物理"

msgid ""
"In some situations, physics can end up becoming a bottleneck. This is "
"particularly the case with complex worlds and large numbers of physics "
"objects."
msgstr ""
"在某些情况下，物理终会成为一个瓶颈，尤其是在复杂的世界和大量物理对象的情况下"
"更是如此。"

msgid "Here are some techniques to speed up physics:"
msgstr "以下是一些加速物理的技巧："

msgid ""
"Try using simplified versions of your rendered geometry for collision "
"shapes. Often, this won't be noticeable for end users, but can greatly "
"increase performance."
msgstr ""
"尝试使用渲染简单的几何图形来处理碰撞形状，虽然在通常情况下对终端用户来说这一"
"点并不明显，但可以大大提高性能。"

msgid ""
"Try removing objects from physics when they are out of view / outside the "
"current area, or reusing physics objects (maybe you allow 8 monsters per "
"area, for example, and reuse these)."
msgstr ""
"尝试禁用不在视野中/在当前区域之外的物理物体的物理效果，在视野中/在当前区域之"
"内时则给这些物理对象启用物理效果（例如，你允许每个区域有8个怪物，并允许重新启"
"用这些怪物的物理效果）。"

msgid ""
"Another crucial aspect to physics is the physics tick rate. In some games, "
"you can greatly reduce the tick rate, and instead of for example, updating "
"physics 60 times per second, you may update them only 30 or even 20 times "
"per second. This can greatly reduce the CPU load."
msgstr ""
"物理的另一个关键方面是物理刻速率。在一些游戏中，你可以大大降低物理刻率，比如"
"说，你可以不用每秒更新物理 60 次，而只需每秒更新 30 次甚至 20 次。这样可以大"
"大降低 CPU 的负载。"

msgid ""
"The downside of changing physics tick rate is you can get jerky movement or "
"jitter when the physics update rate does not match the frames per second "
"rendered. Also, decreasing the physics tick rate will increase input lag. "
"It's recommended to stick to the default physics tick rate (60 Hz) in most "
"games that feature real-time player movement."
msgstr ""
"改变物理刻速率的缺点是，当物理更新速率与每秒渲染的帧数不匹配时，可能会出现抖"
"动。另外，降低物理刻速率会增加输入延迟。建议在大多数以玩家实时移动为特色的游"
"戏中，坚持使用默认的物理刻速率（60 Hz）。"

msgid ""
"The solution to jitter is to use *fixed timestep interpolation*, which "
"involves smoothing the rendered positions and rotations over multiple frames "
"to match the physics. You can either implement this yourself or use a `third-"
"party addon <https://github.com/lawnjelly/smoothing-addon>`__. Performance-"
"wise, interpolation is a very cheap operation compared to running a physics "
"tick. It's orders of magnitude faster, so this can be a significant "
"performance win while also reducing jitter."
msgstr ""
"解决抖动的方法是使用\\ *固定时间步长插值*\\ 以匹配物理，该技术涉及到平滑多个"
"帧的渲染位置和旋转等操作。你可以自己实现，或者使用\\ `第三方插件 <https://"
"github.com/lawnjelly/smoothing-addon>`__ \\ 。来实现。从性能上来说，与运行物"
"理刻比，插值是一个非常低成本、高性能提升的操作，速度快了好几个数量级，在减少"
"抖动的同时也带来了部分显著的性能提升。"

msgid "Translation status"
msgstr "翻译状态"
