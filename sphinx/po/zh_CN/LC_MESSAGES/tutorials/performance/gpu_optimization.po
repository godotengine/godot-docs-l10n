# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GPU optimization"
msgstr "GPU 优化"

msgid "Introduction"
msgstr "前言"

msgid ""
"The demand for new graphics features and progress almost guarantees that you "
"will encounter graphics bottlenecks. Some of these can be on the CPU side, "
"for instance in calculations inside the Godot engine to prepare objects for "
"rendering. Bottlenecks can also occur on the CPU in the graphics driver, "
"which sorts instructions to pass to the GPU, and in the transfer of these "
"instructions. And finally, bottlenecks also occur on the GPU itself."
msgstr ""
"对新的图形功能和进步的需求几乎可以保证你必会遇到图形瓶颈. 有些瓶颈可能出现在"
"CPU端, 例如在Godot引擎内部的计算中, 为渲染准备对象. 瓶颈也可能发生在CPU上的图"
"形驱动中, 它将指令分类传递给GPU, 以及这些指令的传输过程. 最后, 瓶颈也会发生在"
"GPU本身."

msgid ""
"Where bottlenecks occur in rendering is highly hardware-specific. Mobile "
"GPUs in particular may struggle with scenes that run easily on desktop."
msgstr ""
"渲染中的瓶颈发生在哪里, 高度依赖于硬件. 特别是移动GPU可能会在桌面上轻松运行的"
"场景中挣扎."

msgid ""
"Understanding and investigating GPU bottlenecks is slightly different to the "
"situation on the CPU. This is because, often, you can only change "
"performance indirectly by changing the instructions you give to the GPU. "
"Also, it may be more difficult to take measurements. In many cases, the only "
"way of measuring performance is by examining changes in the time spent "
"rendering each frame."
msgstr ""
"了解和调查GPU瓶颈与CPU上的情况略有不同. 这是因为, 通常情况下, 你只能通过改变"
"你给GPU的指令来间接改变性能. 另外, 测量起来可能更困难. 在许多情况下, 衡量性能"
"的唯一方法是通过检查每帧渲染时间的变化."

msgid "Draw calls, state changes, and APIs"
msgstr "绘制调用、状态更变、API"

msgid ""
"The following section is not relevant to end-users, but is useful to provide "
"background information that is relevant in later sections."
msgstr "以下部分与最终用户无关, 但对于提供与后面章节相关的背景信息是有用的."

msgid ""
"Godot sends instructions to the GPU via a graphics API (OpenGL, OpenGL ES or "
"Vulkan). The communication and driver activity involved can be quite costly, "
"especially in OpenGL and OpenGL ES. If we can provide these instructions in "
"a way that is preferred by the driver and GPU, we can greatly increase "
"performance."
msgstr ""
"Godot通过图形API(OpenGL, OpenGL ES或Vulkan)向GPU发送指令. 所涉及的通信和驱动"
"活动可能非常昂贵, 尤其是在OpenGL和OpenGL ES中. 如果我们能以驱动和GPU喜欢的方"
"式提供这些指令, 就能大大提高性能."

msgid ""
"Nearly every API command in OpenGL requires a certain amount of validation "
"to make sure the GPU is in the correct state. Even seemingly simple commands "
"can lead to a flurry of behind-the-scenes housekeeping. Therefore, the goal "
"is to reduce these instructions to a bare minimum and group together similar "
"objects as much as possible so they can be rendered together, or with the "
"minimum number of these expensive state changes."
msgstr ""
"OpenGL中几乎每一个API命令都需要一定的验证, 以确保GPU处于正确的状态. 即使是看"
"似简单的命令, 也会导致一连串的幕后工作. 因此, 我们的目标是将这些指令减少到最"
"低限度, 并尽可能地将相似的对象分组, 以便它们可以一起渲染, 或者以最少的数量进"
"行这些昂贵的状态变化."

msgid "2D batching"
msgstr "2D 批处理"

msgid ""
"In 2D, the costs of treating each item individually can be prohibitively "
"high - there can easily be thousands of them on the screen. This is why 2D "
"*batching* is used. Multiple similar items are grouped together and rendered "
"in a batch, via a single draw call, rather than making a separate draw call "
"for each item. In addition, this means state changes, material and texture "
"changes can be kept to a minimum."
msgstr ""
"在2D中, 单独处理每个项目的成本可能会非常高--屏幕上很容易有成千上万的项目. 这"
"就是为什么使用2D *批处理* 的原因. 多个类似的项目被归为一组, 并通过一个单一的"
"绘制调用进行批量渲染, 而不是对每个项目进行单独的绘制调用. 此外, 这意味着状态"
"变化, 材质和纹理变化可以保持在最低限度."

msgid "For more information on 2D batching, see :ref:`doc_batching`."
msgstr "关于2D批处理的更多信息, 参见 :ref:`doc_batching` ."

msgid "3D batching"
msgstr "3D 批处理"

msgid ""
"In 3D, we still aim to minimize draw calls and state changes. However, it "
"can be more difficult to batch together several objects into a single draw "
"call. 3D meshes tend to comprise hundreds or thousands of triangles, and "
"combining large meshes in real-time is prohibitively expensive. The costs of "
"joining them quickly exceeds any benefits as the number of triangles grows "
"per mesh. A much better alternative is to **join meshes ahead of time** "
"(static meshes in relation to each other). This can either be done by "
"artists, or programmatically within Godot."
msgstr ""
"在3D中, 我们的目标仍然是尽量减少绘制调用和状态变化. 然而, 将多个对象批量合并"
"到一个绘图调用中可能比较困难.3D网格往往由数百个或数千个三角形组成, 而实时组合"
"大型网格的成本非常高. 随着每个网格的三角形数量的增加, 加入它们的成本很快就超"
"过了带来的好处. 一个更好的选择是 **提前加入网格** (静态网格之间的关系). 这可"
"以由设计师完成, 或者在Godot中以编程方式完成."

msgid ""
"There is also a cost to batching together objects in 3D. Several objects "
"rendered as one cannot be individually culled. An entire city that is off-"
"screen will still be rendered if it is joined to a single blade of grass "
"that is on screen. Thus, you should always take objects' location and "
"culling into account when attempting to batch 3D objects together. Despite "
"this, the benefits of joining static objects often outweigh other "
"considerations, especially for large numbers of distant or low-poly objects."
msgstr ""
"在3D中把物体批处理在一起也是有成本的. 几个对象渲染成一个, 就不能单独剔除. 如"
"果将屏幕外的整座城市与屏幕上的一片草地连接在一起, 那么它仍然会被渲染. 因此, "
"当试图将3D对象批量连接在一起时, 应该始终考虑到对象的位置和剔除. 尽管如此, 加"
"入静态对象的好处往往大于其他考虑因素, 特别是对于大量的远距离或低多边形物体."

msgid ""
"For more information on 3D specific optimizations, see :ref:"
"`doc_optimizing_3d_performance`."
msgstr ""
"有关特定于3D的优化的更多信息, 请参阅 :ref:`doc_optimizing_3d_performance`."

msgid "Reuse Shaders and Materials"
msgstr "重复使用着色器和材质"

msgid ""
"The Godot renderer is a little different to what is out there. It's designed "
"to minimize GPU state changes as much as possible. :ref:`SpatialMaterial "
"<class_SpatialMaterial>` does a good job at reusing materials that need "
"similar shaders. If custom shaders are used, make sure to reuse them as much "
"as possible. Godot's priorities are:"
msgstr ""
"Godot 渲染器和其它的渲染器不同，是以尽量减少 GPU 状态更改为目标的。 :ref:"
"`SpatialMaterial <class_SpatialMaterial>` 可以在所需着色器相似时很好地复用材"
"质。如果是用自定义着色器，那么请尽量进行复用。Godot 的优先级是："

msgid ""
"**Reusing Materials:** The fewer different materials in the scene, the "
"faster the rendering will be. If a scene has a huge amount of objects (in "
"the hundreds or thousands), try reusing the materials. In the worst case, "
"use atlases to decrease the amount of texture changes."
msgstr ""
"**复用材质：**\\ 场景中不同的材质越少, 渲染的速度就越快. 如果一个场景有大量的"
"物体(数以百计或数以千计), 可以尝试重复使用这些材质. 在最坏的情况下, 使用图集"
"来减少纹理变化的数量."

msgid ""
"**Reusing Shaders:** If materials can't be reused, at least try to re-use "
"shaders. Note: shaders are automatically reused between SpatialMaterials "
"that share the same configuration (features that are enabled or disabled "
"with a check box) even if they have different parameters."
msgstr ""
"**复用着色器：**\\ 如果材质不能被重复使用，至少要尝试重用着色器。注意：在共享"
"相同配置（可用复选框启用或禁用该功能）的SpatialMaterials之间会自动重用着色"
"器，即使它们有不同的参数。"

msgid ""
"If a scene has, for example, ``20,000`` objects with ``20,000`` different "
"materials each, rendering will be slow. If the same scene has ``20,000`` "
"objects, but only uses ``100`` materials, rendering will be much faster."
msgstr ""
"例如, 如果一个场景有 ``20,000`` 个物体, 每个物体有 ``20,000`` 种不同的材质, "
"渲染会很慢. 如果同一个场景有 ``20,000`` 个物体, 但只使用 ``100`` 种材料, 渲染"
"就会快很多."

msgid "Pixel cost versus vertex cost"
msgstr "像素成本与顶点成本"

msgid ""
"You may have heard that the lower the number of polygons in a model, the "
"faster it will be rendered. This is *really* relative and depends on many "
"factors."
msgstr ""
"你可能听说过, 一个模型中的多边形数量越少, 它的渲染速度就越快. 这其实是 *相对"
"的* , 取决于许多因素."

msgid ""
"On a modern PC and console, vertex cost is low. GPUs originally only "
"rendered triangles. This meant that every frame:"
msgstr "在现代PC和控制台, 顶点成本很低.GPU最初只渲染三角形. 这意味着每一帧:"

msgid "All vertices had to be transformed by the CPU (including clipping)."
msgstr "所有顶点都必须由 CPU 进行转换（包括剪裁）。"

msgid "All vertices had to be sent to the GPU memory from the main RAM."
msgstr "所有顶点都必须从主 RAM 发送到 GPU 内存。"

msgid ""
"Nowadays, all this is handled inside the GPU, greatly increasing "
"performance. 3D artists usually have the wrong feeling about polycount "
"performance because 3D DCCs (such as Blender, Max, etc.) need to keep "
"geometry in CPU memory for it to be edited, reducing actual performance. "
"Game engines rely on the GPU more, so they can render many triangles much "
"more efficiently."
msgstr ""
"现在, 所有这些都在GPU内部处理, 大大提高了性能. 三维艺术家通常对多维性能有错误"
"的感觉, 因为三维DCC(如Blender, Max等)需要将几何图形保存在CPU内存中进行编辑, "
"从而降低了实际性能. 游戏引擎更依赖GPU, 所以它们可以更有效地渲染许多三角形."

msgid ""
"On mobile devices, the story is different. PC and console GPUs are brute-"
"force monsters that can pull as much electricity as they need from the power "
"grid. Mobile GPUs are limited to a tiny battery, so they need to be a lot "
"more power efficient."
msgstr ""
"在移动设备上, 情况则不同. 个人电脑和控制台的GPU是粗暴的怪物, 可以从电网中获取"
"所需的电力. 移动GPU被限制在一个很小的电池里, 所以它们需要更高的功率效率."

msgid ""
"To be more efficient, mobile GPUs attempt to avoid *overdraw*. Overdraw "
"occurs when the same pixel on the screen is being rendered more than once. "
"Imagine a town with several buildings. GPUs don't know what is visible and "
"what is hidden until they draw it. For example, a house might be drawn and "
"then another house in front of it (which means rendering happened twice for "
"the same pixel). PC GPUs normally don't care much about this and just throw "
"more pixel processors to the hardware to increase performance (which also "
"increases power consumption)."
msgstr ""
"为了提高工作效率, 移动GPU试图避免 *overdraw* . 当屏幕上的同一个像素被渲染了不"
"止一次时, 就会出现Overdraw. 想象一下, 一个有几座建筑的小镇. 在绘制之前,GPU不"
"知道哪些是可见的, 哪些是隐藏的. 例如, 一栋房子可能被画出来, 然后在它前面又画"
"了一栋房子(这意味着同一像素的渲染发生了两次).PC GPU通常不怎么关心这个问题, 只"
"是把更多的像素处理扔给硬件以提高性能(这也会增加功耗)."

msgid ""
"Using more power is not an option on mobile so mobile devices use a "
"technique called *tile-based rendering* which divides the screen into a "
"grid. Each cell keeps the list of triangles drawn to it and sorts them by "
"depth to minimize *overdraw*. This technique improves performance and "
"reduces power consumption, but takes a toll on vertex performance. As a "
"result, fewer vertices and triangles can be processed for drawing."
msgstr ""
"在移动设备上使用更多的电力是不可能的，所以移动设备使用一种叫做\\ *基于图块的"
"渲染*\\ 的技术，将屏幕划分为一个网格。每个单元格都保存着绘制的三角形列表，并"
"按深度进行排序，以尽量减少\\ *过度绘制*\\ 。这种技术提高了性能，降低了功耗，"
"但对顶点性能造成了影响。因此，可以处理更少的顶点和三角形进行绘制。"

msgid ""
"Additionally, tile-based rendering struggles when there are small objects "
"with a lot of geometry within a small portion of the screen. This forces "
"mobile GPUs to put a lot of strain on a single screen tile, which "
"considerably decreases performance as all the other cells must wait for it "
"to complete before displaying the frame."
msgstr ""
"一般来说, 这并不是那么糟糕, 但在移动设备上有一个必须避免的特殊情况, 即在屏幕"
"的一小部分内具有大量几何形状的小物体. 这迫使移动GPU在单个屏幕单元上用很大的力"
"气, 大大降低了性能(因为所有其他单元必须等待它完成才能显示该帧)."

msgid ""
"To summarize, don't worry about vertex count on mobile, but **avoid "
"concentration of vertices in small parts of the screen**. If a character, "
"NPC, vehicle, etc. is far away (which means it looks tiny), use a smaller "
"level of detail (LOD) model. Even on desktop GPUs, it's preferable to avoid "
"having triangles smaller than the size of a pixel on screen."
msgstr ""
"总而言之, 在移动端不要担心顶点数量, 但 **避免顶点集中在屏幕的一小部分** . 如"
"果一个角色, NPC, 车辆等离得很远(这意味着它看起来很小), 就使用一个较小的细节级"
"别模型(LOD). 即使在桌面GPU上, 最好也不要让三角形小于屏幕上一个像素的大小."

msgid "Pay attention to the additional vertex processing required when using:"
msgstr "使用时要注意额外的顶点处理："

msgid "Skinning (skeletal animation)"
msgstr "蒙皮（骨骼动画）"

msgid "Morphs (shape keys)"
msgstr "变形（形态键）"

msgid "Vertex-lit objects (common on mobile)"
msgstr "顶点照明对象（在移动设备上很常见）"

msgid "Pixel/fragment shaders and fill rate"
msgstr "像素/片段着色器和填充速率"

msgid ""
"In contrast to vertex processing, the costs of fragment (per-pixel) shading "
"have increased dramatically over the years. Screen resolutions have "
"increased (the area of a 4K screen is 8,294,400 pixels, versus 307,200 for "
"an old 640×480 VGA screen, that is 27x the area), but also the complexity of "
"fragment shaders has exploded. Physically-based rendering requires complex "
"calculations for each fragment."
msgstr ""
"与顶点处理相比, 片段着色器(每像素)的成本在这些年里急剧增加. 屏幕分辨率提高了"
"(4K屏幕的面积是829400像素, 而老式640×480 VGA屏幕的面积是307200, 是27倍), 但片"
"段着色器的复杂度也爆炸式增长. 基于物理的渲染需要对每个片段进行复杂的计算."

msgid ""
"You can test whether a project is fill rate-limited quite easily. Turn off V-"
"Sync to prevent capping the frames per second, then compare the frames per "
"second when running with a large window, to running with a very small "
"window. You may also benefit from similarly reducing your shadow map size if "
"using shadows. Usually, you will find the FPS increases quite a bit using a "
"small window, which indicates you are to some extent fill rate-limited. On "
"the other hand, if there is little to no increase in FPS, then your "
"bottleneck lies elsewhere."
msgstr ""
"你可以很容易地测试一个项目是否受到填充率限制. 关闭V-Sync以防止每秒帧数的上"
"限, 然后比较使用大窗口运行时的每秒帧数和使用非常小的窗口运行时的帧数. 如果使"
"用阴影, 你也可以从同样减少阴影贴图大小中获益. 通常, 你会发现使用小窗口的FPS会"
"增加不少, 这说明你在某种程度上受到了填充率的限制. 另一方面, 如果FPS几乎没有增"
"加, 那么你的瓶颈就在其他地方."

msgid ""
"You can increase performance in a fill rate-limited project by reducing the "
"amount of work the GPU has to do. You can do this by simplifying the shader "
"(perhaps turn off expensive options if you are using a :ref:`SpatialMaterial "
"<class_SpatialMaterial>`), or reducing the number and size of textures used."
msgstr ""
"你可以通过减少 GPU 的工作量来提高填充率限制项目的性能。你可以通过简化着色器"
"（如果你使用的是 :ref:`SpatialMaterial <class_SpatialMaterial>`\\ ，也许可以"
"关闭昂贵的选项），或者减少使用的纹理数量和大小来实现。"

msgid ""
"**When targeting mobile devices, consider using the simplest possible "
"shaders you can reasonably afford to use.**"
msgstr "**在针对移动设备时, 考虑使用你能合理负担得起的最简单的着色器.**"

msgid "Reading textures"
msgstr "读取纹理"

msgid ""
"The other factor in fragment shaders is the cost of reading textures. "
"Reading textures is an expensive operation, especially when reading from "
"several textures in a single fragment shader. Also, consider that filtering "
"may slow it down further (trilinear filtering between mipmaps, and "
"averaging). Reading textures is also expensive in terms of power usage, "
"which is a big issue on mobiles."
msgstr ""
"片段着色器的另一个因素是读取纹理的成本。读取纹理是一项昂贵的操作，尤其是在一"
"个片段着色器中从多个纹理中读取时。另外，考虑到过滤可能会进一步减慢它的速度"
"（mipmap 之间的三线性过滤，以及平均）。读取纹理在功耗方面也很昂贵，这在手机上"
"是个大问题。"

msgid ""
"**If you use third-party shaders or write your own shaders, try to use "
"algorithms that require as few texture reads as possible.**"
msgstr ""
"**如果您使用第三方着色器或编写自己的着色器, 请尽量使用需要尽可能少的纹理读取"
"的算法.**"

msgid "Texture compression"
msgstr "纹理压缩"

msgid ""
"By default, Godot compresses textures of 3D models when imported using video "
"RAM (VRAM) compression. Video RAM compression isn't as efficient in size as "
"PNG or JPG when stored, but increases performance enormously when drawing "
"large enough textures."
msgstr ""
"默认情况下,Godot在导入3D模型时使用视频RAM(VRAM)压缩来压缩纹理. 视频RAM压缩在"
"存储时不如PNG或JPG有效, 但在绘制足够大的纹理时, 会极大地提高性能."

msgid ""
"This is because the main goal of texture compression is bandwidth reduction "
"between memory and the GPU."
msgstr "这是因为纹理压缩的主要目标是在内存和GPU之间减少带宽."

msgid ""
"In 3D, the shapes of objects depend more on the geometry than the texture, "
"so compression is generally not noticeable. In 2D, compression depends more "
"on shapes inside the textures, so the artifacts resulting from 2D "
"compression are more noticeable."
msgstr ""
"在3D中, 物体的形状更多地取决于几何体而不是纹理, 所以压缩一般不明显. 在2D中, "
"压缩更多的是取决于纹理内部的形状, 所以2D压缩产生的伪影比较明显."

msgid ""
"As a warning, most Android devices do not support texture compression of "
"textures with transparency (only opaque), so keep this in mind."
msgstr ""
"作为警告, 大多数Android设备不支持具有透明度的纹理的纹理压缩(仅不透明), 因此请"
"记住这一点."

msgid ""
"Even in 3D, \"pixel art\" textures should have VRAM compression disabled as "
"it will negatively affect their appearance, without improving performance "
"significantly due to their low resolution."
msgstr ""
"即使在3D中,\"像素艺术 \"纹理也应该禁用VRAM压缩, 因为这会对其外观产生负面影"
"响, 而不会因为其低分辨率而显著提高性能."

msgid "Post-processing and shadows"
msgstr "后期处理和阴影"

msgid ""
"Post-processing effects and shadows can also be expensive in terms of "
"fragment shading activity. Always test the impact of these on different "
"hardware."
msgstr ""
"就片段着色活动而言, 后期处理效果和阴影也可能很昂贵. 始终测试这些对不同硬件的"
"影响."

msgid ""
"**Reducing the size of shadowmaps can increase performance**, both in terms "
"of writing and reading the shadowmaps. On top of that, the best way to "
"improve performance of shadows is to turn shadows off for as many lights and "
"objects as possible. Smaller or distant OmniLights/SpotLights can often have "
"their shadows disabled with only a small visual impact."
msgstr ""
"**减少阴影图的大小可以提高性能** , 无论是在写还是读取阴影贴图方面. 除此之外, "
"提高阴影性能的最好方法是关闭尽可能多的灯光和物体的阴影. 较小或较远的"
"OmniLights/SpotLights通常可以禁用它们的阴影, 而对视觉影响很小."

msgid "Transparency and blending"
msgstr "透明度和混合"

msgid ""
"Transparent objects present particular problems for rendering efficiency. "
"Opaque objects (especially in 3D) can be essentially rendered in any order "
"and the Z-buffer will ensure that only the front most objects get shaded. "
"Transparent or blended objects are different. In most cases, they cannot "
"rely on the Z-buffer and must be rendered in \"painter's order\" (i.e. from "
"back to front) to look correct."
msgstr ""
"透明物体对渲染效率带来了特殊的问题. 不透明的对象(尤其是在3D中)基本上可以以任"
"意顺序渲染,Z-缓冲区将确保只有最前面的对象得到阴影. 透明或混合对象则不同, 在大"
"多数情况下, 它们不能依赖Z-缓冲区, 必须以 \"画家顺序\"(即从后到前)渲染才能看起"
"来正确."

msgid ""
"Transparent objects are also particularly bad for fill rate, because every "
"item has to be drawn even if other transparent objects will be drawn on top "
"later on."
msgstr ""
"透明对象的填充率也特别差, 因为每一个项目都要绘制, 即使之面会在上面绘制其他透"
"明对象."

msgid ""
"Opaque objects don't have to do this. They can usually take advantage of the "
"Z-buffer by writing to the Z-buffer only first, then only performing the "
"fragment shader on the \"winning\" fragment, the object that is at the front "
"at a particular pixel."
msgstr ""
"不透明的对象不需要这样做. 它们通常可以利用Z-缓冲区, 只先向Z-缓冲区写入数据, "
"然后只在 \"胜利\" 的片段上执行片段着色器, 也就是在某一像素处处于前面的对象."

msgid ""
"Transparency is particularly expensive where multiple transparent objects "
"overlap. It is usually better to use transparent areas as small as possible "
"to minimize these fill rate requirements, especially on mobile, where fill "
"rate is very expensive. Indeed, in many situations, rendering more complex "
"opaque geometry can end up being faster than using transparency to \"cheat\"."
msgstr ""
"在多个透明对象重叠的情况下, 透明度特别昂贵. 通常情况下, 使用透明区域越小越"
"好, 以尽量降低这些填充率要求, 尤其是在移动端. 事实上, 在很多情况下, 渲染更复"
"杂的不透明几何体最终可能比使用透明度来 \"作弊\" 更快."

msgid "Multi-platform advice"
msgstr "多平台建议"

msgid ""
"If you are aiming to release on multiple platforms, test *early* and test "
"*often* on all your platforms, especially mobile. Developing a game on "
"desktop but attempting to port it to mobile at the last minute is a recipe "
"for disaster."
msgstr ""
"如果您的目标是在多个平台上发布, 请在您的所有平台上(尤其是移动平台)上进行 *早"
"期* 并 *经常* 性测试. 在桌面上开发游戏, 但试图在最后一刻将其移植到移动设备, "
"这是灾难的根源."

msgid ""
"In general, you should design your game for the lowest common denominator, "
"then add optional enhancements for more powerful platforms. For example, you "
"may want to use the GLES2 backend for both desktop and mobile platforms "
"where you target both."
msgstr ""
"一般来说, 你应该从最底的共性设计你的游戏, 然后为更强大的平台添加可选的增强功"
"能. 例如, 你可能希望在同时针对桌面和移动平台的情况下, 同时使用GLES2后台."

msgid "Mobile/tiled renderers"
msgstr "移动端和图块渲染"

msgid ""
"As described above, GPUs on mobile devices work in dramatically different "
"ways from GPUs on desktop. Most mobile devices use tile renderers. Tile "
"renderers split up the screen into regular-sized tiles that fit into super "
"fast cache memory, which reduces the number of read/write operations to the "
"main memory."
msgstr ""
"如上所述, 移动设备上的GPU与桌面上的GPU工作方式有很大不同. 大多数移动设备都使"
"用图块渲染器. 图块渲染器将屏幕分割成规则大小的图块, 这些图块可以放入超快的缓"
"存中, 从而减少了对主内存的读和写操作次数."

msgid ""
"There are some downsides though. Tiled rendering can make certain techniques "
"much more complicated and expensive to perform. Tiles that rely on the "
"results of rendering in different tiles or on the results of earlier "
"operations being preserved can be very slow. Be very careful to test the "
"performance of shaders, viewport textures and post processing."
msgstr ""
"不过也有一些缺点. 图块渲染会让某些技术变得更加复杂, 执行起来也更加昂贵. 依赖"
"于不同图块渲染的结果, 或者依赖于早期操作的结果被保存的图块可能会非常慢. 要非"
"常小心地测试着色器, 视图纹理和后期处理的性能."

msgid "Translation status"
msgstr "翻译状态"
