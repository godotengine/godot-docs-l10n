# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "optimization"
msgstr "优化"

msgid "Optimizing 3D performance"
msgstr "优化 3D 性能"

msgid "Culling"
msgstr "剔除"

msgid ""
"Godot will automatically perform view frustum culling in order to prevent "
"rendering objects that are outside the viewport. This works well for games "
"that take place in a small area, however things can quickly become "
"problematic in larger levels."
msgstr ""
"Godot会自动执行视图视锥剔除, 以防止渲染视口外的物体. 这对于发生在小范围内的游"
"戏来说效果很好, 然而在较大的关卡中, 事情很快就会变得很麻烦."

msgid "Occlusion culling"
msgstr "遮挡剔除"

msgid ""
"Walking around a town for example, you may only be able to see a few "
"buildings in the street you are in, as well as the sky and a few birds "
"flying overhead. As far as a naive renderer is concerned however, you can "
"still see the entire town. It won't just render the buildings in front of "
"you, it will render the street behind that, with the people on that street, "
"the buildings behind that. You quickly end up in situations where you are "
"attempting to render 10× or 100× more than what is visible."
msgstr ""
"比如走在一个小镇上, 你可能只能看到你所在的街道上的几栋建筑, 以及天空和几只飞"
"过头顶的鸟. 然而就一个天真的渲染器而言, 你仍然可以看到整个小镇. 它不会只渲染"
"你前面的建筑, 它会渲染那后面的街道, 与那条街上的人, 那后面的建筑. 你很快就会"
"遇到这样的情况: 你试图渲染比可见的东西多10倍或100倍的东西."

msgid ""
"Things aren't quite as bad as they seem, because the Z-buffer usually allows "
"the GPU to only fully shade the objects that are at the front. This is "
"called *depth prepass* and is enabled by default in Godot when using the "
"GLES3 renderer. However, unneeded objects are still reducing performance."
msgstr ""
"事情并没有看上去那么糟糕，因为 Z 缓冲通常只允许 GPU 完全遮挡在前面的物体。这"
"被称为\\ *深度预处理*\\ （depth prepass），在使用 GLES3 渲染器时，Godot 默认"
"启用。然而，不需要的对象仍然在降低性能。"

msgid ""
"One way we can potentially reduce the amount to be rendered is to take "
"advantage of occlusion."
msgstr "一种可能的减少渲染量的方法，就是利用遮挡信息。"

msgid ""
"For instance, in our city street scenario, you may be able to work out in "
"advance that you can only see two other streets, ``B`` and ``C``, from "
"street ``A``. Streets ``D`` to ``Z`` are hidden. In order to take advantage "
"of occlusion, all you have to do is work out when your viewer is in street "
"``A`` (perhaps using Godot Areas), then you can hide the other streets."
msgstr ""
"例如, 在我们的城市街道场景中, 你可能会事先计算出, 从街道 ``A`` 只能看到另外两"
"条街道, ``B`` 和 ``C``. ``D`` 到 ``Z`` 的街道是隐藏的. 为了利用遮挡的优势, 你"
"所要做的就是计算出什么时候你的观察者在街道 ``A`` 中(也许使用Godot区域), 然后"
"你就可以隐藏其他街道."

msgid ""
"This example is a manual version of what is known as a *potentially visible "
"set*. It is a very powerful technique for speeding up rendering. You can "
"also use it to restrict physics or AI to the local area, and speed these up "
"as well as rendering."
msgstr ""
"这个例子就是手动版本的所谓\\ *潜在可见集*\\ 。用这种技术来加速渲染非常有效。"
"你还可以用它来把物理和 AI 限制在局部区域，从而和渲染一并加速。"

msgid "Portal Rendering"
msgstr "Portal 渲染"

msgid ""
"However, there is a much easier way to take advantage of occlusion. Godot "
"features an advanced portal rendering system, which can perform occlusion "
"culling from cameras and lights. See :ref:`doc_rooms_and_portals`."
msgstr ""
"然而，有一种更简单的方法可以实现遮挡。 Godot 具有先进的 Portal 渲染系统，可以"
"从相机和灯光执行遮挡剔除。参阅 :ref:`doc_rooms_and_portals`。"

msgid ""
"This is not a fully automatic system and it requires some manual setup. "
"However, it potentially offers significant performance increases."
msgstr ""
"虽然这个系统并不是全自动的，需要一些手动设置，但是却能带来显著的性能提升。"

#, fuzzy
msgid ""
"In some cases, you can adapt your level design to add more occlusion "
"opportunities. For example, you can add more walls to prevent the player "
"from seeing too far away, which would decrease performance due to the lost "
"opportunities for occlusion culling."
msgstr ""
"在某些情况下，你可以通过调整你的关卡设计来增加更多的遮挡机会。例如，你可以增"
"加更多的墙来防止玩家看得太远，否则就会因为失去了遮挡机会而降低性能。"

msgid "Other occlusion techniques"
msgstr "其他遮挡技术"

msgid ""
"As well as the portal system and manual methods, there are various other "
"occlusion techniques such as raster-based occlusion culling. Some of these "
"may be available through add-ons or may be available in core Godot in the "
"future."
msgstr ""
"除了入口系统和手动操作之外，还有诸如基于光栅的遮挡剔除等剔除技术。其中有一些"
"可以通过插件实现，有一些会在将来的 Godot 核心中实现。"

msgid "Transparent objects"
msgstr "透明物体"

msgid ""
"Godot sorts objects by :ref:`Material <class_Material>` and :ref:`Shader "
"<class_Shader>` to improve performance. This, however, can not be done with "
"transparent objects. Transparent objects are rendered from back to front to "
"make blending with what is behind work. As a result, **try to use as few "
"transparent objects as possible**. If an object has a small section with "
"transparency, try to make that section a separate surface with its own "
"material."
msgstr ""
"Godot通过 :ref:`Material <class_Material>` 和 :ref:`Shader <class_Shader>` 对"
"对象进行排序以提高性能. 然而, 这对透明物体来说是不可能的. 透明物体从后往前渲"
"染, 以便与后面的物体混合. 因此, **尽量少使用透明对象** . 如果一个物体有一小部"
"分是透明的, 尽量让这部分成为一个独立的表面, 有自己的材质."

msgid ""
"For more information, see the :ref:`GPU optimizations "
"<doc_gpu_optimization>` doc."
msgstr "更多信息请参阅 :ref:`GPU 优化 <doc_gpu_optimization>` 文档。"

msgid "Level of detail (LOD)"
msgstr "细节程度（LOD）"

msgid ""
"In some situations, particularly at a distance, it can be a good idea to "
"**replace complex geometry with simpler versions**. The end user will "
"probably not be able to see much difference. Consider looking at a large "
"number of trees in the far distance. There are several strategies for "
"replacing models at varying distance. You could use lower poly models, or "
"use transparency to simulate more complex geometry."
msgstr ""
"在某些情况下, 特别是在远处, 用简单的版本**代替复杂的几何图形可能是个好主意. "
"最终用户可能看不出什么区别. 考虑看看远处的大量树木. 有几种策略可以替换不同距"
"离的模型. 您可以使用较低的多边形模型, 或者使用透明度来模拟更复杂的几何体."

msgid "Billboards and imposters"
msgstr "Billboard 和 imposter"

msgid ""
"The simplest version of using transparency to deal with LOD is billboards. "
"For example, you can use a single transparent quad to represent a tree at "
"distance. This can be very cheap to render, unless of course, there are many "
"trees in front of each other. In which case transparency may start eating "
"into fill rate (for more information on fill rate, see :ref:"
"`doc_gpu_optimization`)."
msgstr ""
"使用透明度来处理LOD的最简单版本是广告牌. 例如, 你可以用一个单一的透明四边形来"
"表示一棵树的距离. 这可以是非常便宜的渲染, 当然, 除非前面有很多树. 在这种情况"
"下, 透明度可能会开始吞噬填充率(关于填充率的更多信息, 请参见 :ref:"
"`doc_gpu_optimization`)."

msgid ""
"An alternative is to render not just one tree, but a number of trees "
"together as a group. This can be especially effective if you can see an area "
"but cannot physically approach it in a game."
msgstr ""
"另一种方法是不只渲染一棵树, 而是将一些树作为一组来渲染. 如果你能看到一个区"
"域, 但在游戏中不能实际接近它, 这可能是特别有效的."

msgid ""
"You can make imposters by pre-rendering views of an object at different "
"angles. Or you can even go one step further, and periodically re-render a "
"view of an object onto a texture to be used as an imposter. At a distance, "
"you need to move the viewer a considerable distance for the angle of view to "
"change significantly. This can be complex to get working, but may be worth "
"it depending on the type of project you are making."
msgstr ""
"你可以通过预先渲染对象的不同角度的视图来制作冒牌货. 或者你甚至可以更进一步, "
"周期性地将一个物体的视图重新渲染到一个纹理上, 作为一个冒牌货使用. 在远处, 你"
"需要将观察者移动相当长的距离, 视角才会发生显著变化. 这可能是复杂的工作, 但可"
"能是值得的, 这取决于你正在制作的项目类型."

msgid "Use instancing (MultiMesh)"
msgstr "使用实例化（MultiMesh）"

msgid ""
"If several identical objects have to be drawn in the same place or nearby, "
"try using :ref:`MultiMesh <class_MultiMesh>` instead. MultiMesh allows the "
"drawing of many thousands of objects at very little performance cost, making "
"it ideal for flocks, grass, particles, and anything else where you have "
"thousands of identical objects."
msgstr ""
"如果必须在同一地点或附近绘制多个相同的对象, 请尝试使用 :ref:`MultiMesh "
"<class_MultiMesh>` 来代替.MultiMesh允许以很小的性能代价来绘制成千上万的对象, "
"这使得它非常适合用于绘制羊群, 草地, 粒子以及其他任何有成千上万相同对象的地方."

msgid "Also see the :ref:`Using MultiMesh <doc_using_multimesh>` doc."
msgstr "另请参阅 :ref:`Using MultiMesh <doc_using_multimesh>` 文档."

msgid "Bake lighting"
msgstr "烘焙照明"

msgid ""
"Lighting objects is one of the most costly rendering operations. Realtime "
"lighting, shadows (especially multiple lights), and GI are especially "
"expensive. They may simply be too much for lower power mobile devices to "
"handle."
msgstr ""
"对物体进行照明是最昂贵的渲染操作之一. 实时光照, 阴影(尤其是很多灯光)和 GI 都"
"特别昂贵. 对于低功率的移动设备来说, 它们可能根本无法处理."

msgid ""
"**Consider using baked lighting**, especially for mobile. This can look "
"fantastic, but has the downside that it will not be dynamic. Sometimes, this "
"is a trade-off worth making."
msgstr ""
"**考虑使用烘焙照明** , 尤其是移动端, 这看起来很棒, 但有一个缺点, 那就是它不是"
"动态的, 有时, 这需要做出的权衡."

msgid ""
"In general, if several lights need to affect a scene, it's best to use :ref:"
"`doc_baked_lightmaps`. Baking can also improve the scene quality by adding "
"indirect light bounces."
msgstr ""
"一般来说, 如果几个灯光需要影响一个场景, 最好使用 :ref:"
"`doc_baked_lightmaps` . 烘焙也可以通过增加间接光的反弹来提高场景的质量."

msgid "Animation and skinning"
msgstr "动画和皮肤"

msgid ""
"Animation and vertex animation such as skinning and morphing can be very "
"expensive on some platforms. You may need to lower the polycount "
"considerably for animated models or limit the number of them on screen at "
"any one time."
msgstr ""
"在某些平台上, 动画和顶点动画(如换肤和变形)可能非常昂贵. 你可能需要大大降低动"
"画模型的多边形数量, 或者任何时候限制屏幕上的模型数量."

msgid "Large worlds"
msgstr "庞大的世界"

msgid ""
"If you are making large worlds, there are different considerations than what "
"you may be familiar with from smaller games."
msgstr "如果您要制作大型游戏, 则与小型游戏可能会有所不同."

msgid ""
"Large worlds may need to be built in tiles that can be loaded on demand as "
"you move around the world. This can prevent memory use from getting out of "
"hand, and also limit the processing needed to the local area."
msgstr ""
"大型的世界可能需要用碎片建立, 可以在你在世界中移动时按需加载, 这可以防止内存"
"使用失控, 也可以将所需的处理限制在局部区域."

msgid ""
"There may also be rendering and physics glitches due to floating point error "
"in large worlds. You may be able to use techniques such as orienting the "
"world around the player (rather than the other way around), or shifting the "
"origin periodically to keep things centred around ``Vector3(0, 0, 0)``."
msgstr ""
"在大型世界中, 由于浮点错误, 也可能会出现渲染和物理故障, 你可能会使用一些技"
"术, 比如将世界围绕着玩家的方向(而不是相反), 或者定期移动原点以保持以 "
"``Vector3(0, 0, 0)`` 为中心."

msgid "Translation status"
msgstr "翻译状态"
