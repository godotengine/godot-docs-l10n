# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Canvas layers"
msgstr "画布层"

msgid "Viewport and Canvas items"
msgstr "Viewport（视口）和 Canvas Item（画布项）"

msgid ""
":ref:`CanvasItem <class_CanvasItem>` is the base for all 2D nodes, be it "
"regular 2D nodes, such as :ref:`Node2D <class_Node2D>`, or :ref:`Control "
"<class_Control>`. Both inherit from :ref:`CanvasItem <class_CanvasItem>`. "
"You can arrange canvas items in trees. Each item will inherit its parent's "
"transform: when the parent moves, its children move too."
msgstr ""
":ref:`CanvasItem <class_CanvasItem>` 是所有 2D 节点的基类，无论是 :ref:"
"`Node2D <class_Node2D>` 等普通 2D 节点，还是 :ref:`Control <class_Control>` "
"控件节点。它们都继承自 :ref:`CanvasItem <class_CanvasItem>`\\ 。你可以把画布"
"项组织成树。每个项目都会继承父节点的变换：父节点移动，子项也会移动。"

msgid ""
"CanvasItem nodes, and nodes inheriting from them, are direct or indirect "
"children of a :ref:`Viewport <class_Viewport>`, that displays them."
msgstr ""
"CanvasItem 节点和继承他们的节点都是 :ref:`Viewport <class_Viewport>` 的直接或"
"间接子节点，并将通过这个视口来显示。"

msgid ""
"The Viewport's property :ref:`Viewport.canvas_transform "
"<class_Viewport_property_canvas_transform>`, allows to apply a custom :ref:"
"`Transform2D <class_Transform2D>` transform to the CanvasItem hierarchy it "
"contains. Nodes such as :ref:`Camera2D <class_Camera2D>` work by changing "
"that transform."
msgstr ""
"Viewport 的 :ref:`Viewport.canvas_transform "
"<class_Viewport_property_canvas_transform>` 属性能够对它所包含的 CanvasItem "
"层级结构施加一个自定义的 :ref:`Transform2D <class_Transform2D>` 变换。\\ :"
"ref:`Camera2D <class_Camera2D>` 等节点的工作原理就是修改这个变换。"

msgid ""
"To achieve effects like scrolling, manipulating the canvas transform "
"property is more efficient than moving the root canvas item and the entire "
"scene with it."
msgstr ""
"像滚动这样的效果最好是通过操纵画布的变换（transform）属性来实现。这种方法比移"
"动根画布项和整个场景更有效。"

msgid ""
"Usually though, we don't want *everything* in the game or app to be subject "
"to the canvas transform. For example:"
msgstr ""
"通常情况下，我们并不希望游戏或应用程序中的\\ *所有东西*\\ 都受到画布变换的约"
"束。比如："

msgid ""
"**Parallax Backgrounds**: Backgrounds that move slower than the rest of the "
"stage."
msgstr "**视差背景**\\ ：比场景其他部分移动得慢的背景。"

msgid ""
"**UI**: Think of a user interface (UI) or head-up display (HUD) superimposed "
"on our view of the game world. We want a life counter, score display and "
"other elements to retain their screen positions even when our view of the "
"game world changes."
msgstr ""
"**UI**\\ ：想想看，用户界面（UI）或平视显示系统（HUD）叠加在我们游戏世界的视"
"图上。我们希望生命计数器、分数显示和其他元素能够保持其屏幕位置，即使我们在游"
"戏世界的视角发生变化。"

msgid ""
"**Transitions**: We may want visual effects used for transitions (fades, "
"blends) to remain at a fixed screen location."
msgstr ""
"**转场**\\ ：我们应该希望用于转场的效果（淡入淡出、混合）也保持在固定的位置。"

msgid "How to solve these problems in a single scene tree?"
msgstr "如何在单个场景树中解决这些问题？"

msgid "CanvasLayers"
msgstr "CanvasLayer"

msgid ""
"The answer is :ref:`CanvasLayer <class_CanvasLayer>`, which is a node that "
"adds a separate 2D rendering layer for all its children and grand-children. "
"Viewport children will draw by default at layer \"0\", while a CanvasLayer "
"will draw at any numeric layer. Layers with a greater number will be drawn "
"above those with a smaller number. CanvasLayers also have their own "
"transform and do not depend on the transform of other layers. This allows "
"the UI to be fixed in screen-space while our view on the game world changes."
msgstr ""
"答案是画布层 :ref:`CanvasLayer <class_CanvasLayer>`\\ ，它是一个节点，可以为"
"所有子代和孙代添加一个单独的 2D 渲染层。Viewport 的子节点默认在图层“0”处绘"
"制，而 CanvasLayer 将在任何数字层处绘制。数字较大的图层将绘制在数字较小的图层"
"之上。CanvasLayer 也有自己的变换，不受其他层的影响。这使得当我们对游戏世界的"
"观察发生变化时，UI 可以固定在屏幕空间中。"

msgid ""
"An example of this is creating a parallax background. This can be done with "
"a CanvasLayer at layer \"-1\". The screen with the points, life counter and "
"pause button can also be created at layer \"1\"."
msgstr ""
"一个例子是创建视差背景（Parallax Background）。这可以通过层为“-1”的 "
"CanvasLayer 完成。带有分数、生命计数器和暂停按钮的屏幕也可以创建在编号为“1”的"
"层中。"

msgid "Here's a diagram of how it looks:"
msgstr "下面是它的图示："

msgid ""
"CanvasLayers are independent of tree order, and they only depend on their "
"layer number, so they can be instantiated when needed."
msgstr ""
"CanvasLayer 独立于树顺序, 它们仅依赖于它们的层数, 因此可以只在需要时让它们实"
"例化."

msgid ""
"CanvasLayers aren't necessary to control the drawing order of nodes. The "
"standard way to ensuring that a node is correctly drawn 'in front' or "
"'behind' others is to manipulate the order of the nodes in the scene panel. "
"Perhaps counterintuitively, the topmost nodes in the scene panel are drawn "
"on *behind* lower ones in the viewport. 2D nodes also have the :ref:"
"`CanvasItem.z_index <class_CanvasItem_property_z_index>` property for "
"controlling their drawing order."
msgstr ""
"控制节点的绘制顺序并不一定要用 CanvasLayer。确保节点被正确绘制在“前面”或“后"
"面”的标准方法是调整场景面板中节点的顺序。也许违反直觉，但在视口中，场景面板中"
"较上面的节点会被画在较下面的节点的\\ *后面*\\ 。2D 节点的 :ref:`CanvasItem."
"z_index <class_CanvasItem_property_z_index>` 属性也能够控制绘图顺序。"

msgid "Translation status"
msgstr "翻译状态"
