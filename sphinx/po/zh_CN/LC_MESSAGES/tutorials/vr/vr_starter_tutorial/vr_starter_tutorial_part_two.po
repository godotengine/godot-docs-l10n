# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-16 15:51+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "VR starter tutorial part 2"
msgstr "VR 入门教程第 2 部分"

msgid "Introduction"
msgstr "前言"

msgid ""
"In this part of the VR starter tutorial series, we will be adding a number "
"of special :ref:`RigidBody <class_RigidBody>`-based nodes that can be used "
"in VR."
msgstr ""
"在这部分VR入门系列教程中, 我们将增加一些特殊的, 基于 :ref:`RigidBody "
"<class_RigidBody>` 的节点来用于VR中."

msgid ""
"This continues from where we left on in the last tutorial part, where we "
"just finished getting the VR controllers working and defined a custom class "
"called ``VR_Interactable_Rigidbody``."
msgstr ""
"这将继续我们在上一个教程部分的内容, 我们刚刚完成了VR控制器的工作, 并定义了一"
"个名为 ``VR_Interactable_Rigidbody`` 的自定义类."

#, fuzzy
msgid ""
"You can find the finished project on the `OpenVR GitHub repository <https://"
"github.com/GodotVR/godot_openvr_fps>`__."
msgstr ""
"你可以在 `OpenVR的GitHub 仓库 <https://github.com/GodotVR/"
"godot_openvr_fps>`_ 上找到这个完成的项目."

msgid "Adding destroyable targets"
msgstr "添加可销毁的目标"

msgid ""
"Before we make any of the special :ref:`RigidBody <class_RigidBody>`-based "
"nodes, we need something for them to do. Let's make a simple sphere target "
"that will break into a bunch of pieces when destroyed."
msgstr ""
"在我们制作任何一个特殊的以 :ref:`RigidBody <class_RigidBody>` 为基础的节点之"
"前, 我们需要一些东西来让它们去执行. 让我们做一个简单的球体目标, 当它被摧毁"
"时, 会破裂成一堆碎片."

msgid ""
"Open up ``Sphere_Target.tscn``, which is in the ``Scenes`` folder. The scene "
"is fairly simple, with just a :ref:`StaticBody <class_StaticBody>` with a "
"sphere shaped :ref:`CollisionShape <class_CollisionShape>`, a :ref:"
"`MeshInstance <class_MeshInstance>` node displaying a sphere mesh, and an :"
"ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node."
msgstr ""
"打开 ``Sphere_Target.tscn`` , 它在 ``Scenes`` 文件夹中. 这个场景相当简单, 只"
"有一个 :ref:`StaticBody <class_StaticBody>` 和一个球体形状的 :ref:"
"`CollisionShape <class_CollisionShape>` , 一个显示球体网格的 :ref:"
"`MeshInstance <class_MeshInstance>` 节点, 以及一个 :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` 节点."

msgid ""
"The special :ref:`RigidBody <class_RigidBody>` nodes will handle damaging "
"the sphere, which is why we are using a :ref:`StaticBody <class_StaticBody>` "
"node instead of something like an :ref:`Area <class_Area>` or :ref:"
"`RigidBody <class_RigidBody>` node. Outside of that, there isn't really a "
"lot to talk about, so let's move straight into writing the code."
msgstr ""
"特殊的 :ref:`RigidBody <class_RigidBody>` 节点将处理对球体的损坏, 这就是为什"
"么我们使用 :ref:`StaticBody <class_StaticBody>` 节点, 而不是诸如 :ref:`Area "
"<class_Area>` 或 :ref:`RigidBody <class_RigidBody>` 一类的节点. 除此以外, 就"
"没什么好说的了, 所以让我们直接进入写代码的阶段."

msgid ""
"Select the ``Sphere_Target_Root`` node and make a new script called "
"``Sphere_Target.gd``. Add the following code:"
msgstr ""
"选择 ``Sphere_Target_Root`` 节点, 制作一个名为 ``Sphere_Target.gd`` 的新脚"
"本. 添加以下代码:"

msgid "Let's go over how this script works."
msgstr "让我们来看看这个脚本是如何工作的."

msgid "Explaining the Sphere Target code"
msgstr "解释Sphere Target代码"

msgid "First, let's go through all the class variables in the script:"
msgstr "首先, 让我们浏览一下脚本中所有的类变量:"

msgid ""
"``destroyed``: A variable to track whether the sphere target has been "
"destroyed."
msgstr "``destroyed``: 一个变量, 用于跟踪球体目标是否已被销毁."

msgid ""
"``destroyed_timer``: A variable to track how long the sphere target has been "
"destroyed."
msgstr "``destroyed_timer``: 一个变量, 用于跟踪球体目标被摧毁的时间."

msgid ""
"``DESTROY_WAIT_TIME``: A constant to define the length of time the target "
"can be destroyed for before it frees/deletes itself."
msgstr ""
"``DESTROY_WAIT_TIME``: 一个常数, 用于定义目标在释放/删除自己之前可以被销毁的"
"时间长度."

msgid ""
"``health``: A variable to store the amount of health the sphere target has."
msgstr "``health``: 目标所具有的健康量."

msgid ""
"``RIGID_BODY_TARGET``: A constant to hold the scene of the destroyed sphere "
"target."
msgstr "``RIGID_BODY_TARGET`` : 一个常数, 用于储存被摧毁的球体目标的场景."

msgid ""
"Feel free to check out the ``RIGID_BODY_TARGET`` scene. It is just a bunch "
"of :ref:`RigidBody <class_RigidBody>` nodes and a broken sphere model."
msgstr ""
"你可以随意查看 ``RIGID_BODY_TARGET`` 场景. 它只是一堆 :ref:`RigidBody "
"<class_RigidBody>` 节点和一个破碎的球体模型."

msgid ""
"We'll be instancing this scene so when the target is destroyed, it looks "
"like it broke into a bunch of pieces."
msgstr "我们将实例化这个场景, 所以当目标被摧毁时, 它看起来就像碎成了一堆碎片."

msgid "``_ready`` function step-by-step explanation"
msgstr "``_ready`` 函数的逐步说明"

msgid ""
"All the ``_ready`` function does is that it stops the ``_physics_process`` "
"from being called by calling ``set_physics_process`` and passing ``false``. "
"The reason we do this is because all the code in ``_physics_process`` is for "
"destroying this node when enough time has passed, which we only want to do "
"when the target has been destroyed."
msgstr ""
"``_ready`` 函数所做的就是通过调用 ``set_physics_process`` 并传递 ``false`` 来"
"阻止 ``_physics_process`` 被调用. 我们这样做的原因是, ``_physics_process`` 中"
"的所有代码都是为了在足够长的时间内销毁这个节点, 而我们只想在目标被销毁时进行"
"销毁."

msgid "``_physics_process`` function step-by-step explanation"
msgstr "``_physics_process`` 函数分步说明"

msgid ""
"First this function adds time, ``delta``, to the ``destroyed_timer`` "
"variable. It then checks to see if ``destroyed_timer`` is greater than or "
"equal to ``DESTROY_WAIT_TIME``. If ``destroyed_timer`` is greater than or "
"equal to ``DESTROY_WAIT_TIME``, then the sphere target frees/deletes itself "
"by calling the ``queue_free`` function."
msgstr ""
"首先, 这个函数将时间 ``delta`` 添加到 ``destroyed_timer`` 变量中. 然后检查 "
"``destroyed_timer`` 是否大于或等于 ``DESTROY_WAIT_TIME`` . 如果 "
"``destroyed_timer`` 大于或等于 ``DESTROY_WAIT_TIME`` , 那么球体目标将通过调"
"用 ``queue_free`` 函数来释放/删除自己."

msgid "``damage`` function step-by-step explanation"
msgstr "``damage`` 函数的分步说明"

msgid ""
"The ``damage`` function will be called by the special :ref:`RigidBody "
"<class_RigidBody>` nodes, which will pass the amount of damage done to the "
"target, which is a function argument variable called ``damage``. The "
"``damage`` variable will hold the amount of damage the special :ref:"
"`RigidBody <class_RigidBody>` node did to the sphere target."
msgstr ""
"``damage`` 函数将被特殊的 :ref:`RigidBody <class_RigidBody>` 节点调用, 它将传"
"递对目标造成的伤害量, 这是一个名为 ``damage`` 的函数参数变量. ``damage`` 变量"
"将保存特殊的 :ref:`RigidBody <class_RigidBody>` 节点对球体目标造成的伤害量."

msgid ""
"First this function checks to make sure the target is not already destroyed "
"by checking if the ``destroyed`` variable is equal to ``true``. If "
"``destroyed`` is equal to ``true``, then the function calls ``return`` so "
"none of the other code is called. This is just a safety check so that if two "
"things damage the target at exactly the same time, the target cannot be "
"destroyed twice."
msgstr ""
"首先, 这个函数通过检查 ``destroyed`` 变量是否等于 ``true`` 来检查目标是否已经"
"被销毁. 如果 ``destroyed`` 等于 ``true`` , 那么这个函数就会调用 ``return`` , "
"所以其他代码都不会被调用. 这只是一个安全检查, 如果两个东西同时损坏目标, 则目"
"标不能被破坏两次."

msgid ""
"Next the function removes the amount of damage taken, ``damage``, from the "
"target's health, ``health``. If then checks to see if ``health`` is equal to "
"zero or less, meaning that the target has just been destroyed."
msgstr ""
"接下来, 该函数从目标的健康状况 ``health`` 中删除受到的伤害量 ``damage`` . 然"
"后检查 ``health`` 是否等于零或更少, 这意味着目标刚刚已被摧毁."

msgid ""
"If the target has just been destroyed, then we disable the :ref:"
"`CollisionShape <class_CollisionShape>` by setting it's ``disabled`` "
"property to ``true``. We then make the ``Sphere_Target`` :ref:`MeshInstance "
"<class_MeshInstance>` invisible by setting the ``visible`` property to "
"``false``. We do this so the target can no longer effect the physics world "
"and so the non-broken target mesh is not visible."
msgstr ""
"如果目标刚刚被摧毁，那么我们通过将 ``disabled`` 属性设置为 ``true`` 来禁用"
"该 :ref:`CollisionShape <class_CollisionShape>`。然后将 ``Sphere_Target`` :"
"ref:`MeshInstance <class_MeshInstance>` 的 ``visible`` 属性设置为 ``false``"
"\\ ，使其不可见。这样做是为了让目标不能再影响物理世界，所以不可破碎的目标网格"
"是不可见的。"

msgid ""
"After this the function then instances the ``RIGID_BODY_TARGET`` scene and "
"adds it as a child of the target. It then sets the ``global_transform`` of "
"the newly instanced scene, called ``clone``, to the ``global_transform`` of "
"the non-broken target. This makes it where the broken target starts at the "
"same position as the non-broken target with the same rotation and scale."
msgstr ""
"之后, 函数将实例化 ``RIGID_BODY_TARGET`` 场景, 并将其添加为目标的子场景. 然"
"后, 它将新实例化的场景的 ``global_transform``(称为 ``clone``)设置为未被破坏的"
"目标的 ``global_transform``. 这使得被破坏的目标与未被破坏的目标在相同的位置开"
"始, 并具有相同的旋转和比例."

msgid ""
"Then the function sets the ``destroyed`` variable to ``true`` so the target "
"knows it has been destroyed and calls the ``set_physics_process`` function "
"and passes ``true``. This will start executing the code in "
"``_physics_process`` so that after ``DESTROY_WAIT_TIME`` seconds have "
"passed, the sphere target will free/destroy itself."
msgstr ""
"然后该函数将 ``destroyed`` 变量设置为 ``true``, 这样目标就知道它已经被破坏"
"了, 并调用 ``set_physics_process`` 函数并传递 ``true``. 这将开始执行 "
"``_physics_process`` 中的代码, 这样在 ``DESTROY_WAIT_TIME`` 秒过后, 球体目标"
"将释放/销毁自己."

msgid ""
"The function then gets the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node and calls the ``play`` function so it "
"plays its sound."
msgstr ""
"然后这个函数获得 :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` 节点"
"并调用 ``play`` 函数, 这样就可以播放它的声音."

msgid ""
"Finally, the ``remove_sphere`` function is called in ``Game.gd``. To get "
"``Game.gd``, the code uses the scene tree and works its way from the root of "
"the scene tree to the root of the ``Game.tscn`` scene."
msgstr ""
"最后, 在 ``Game.gd`` 中调用 ``remove_sphere`` 函数. 为了得到 ``Game.gd``, 代"
"码使用场景树, 从场景树的根部到 ``Game.tscn`` 场景的根部."

msgid "Adding the ``remove_sphere`` function to ``Game.gd``"
msgstr "将 ``remove_sphere`` 函数添加到 ``Game.gd``"

msgid ""
"You may have noticed we are calling a function in ``Game.gd``, called "
"``remove_sphere``, that we have not defined yet. Open up ``Game.gd`` and add "
"the following additional class variables:"
msgstr ""
"你可能已经注意到我们在 ``Game.gd`` 中调用了一个函数, 叫做 "
"``remove_sphere`` , 而我们还没有定义. 打开 ``Game.gd`` , 添加以下其他的类变"
"量:"

msgid ""
"``spheres_left``: The amount of sphere targets left in the world. In the "
"provided ``Game`` scene, there are ``10`` spheres, so that is the initial "
"value."
msgstr ""
"``spheres_left``. 游戏世界里剩余的球体目标数量. 在提供的 ``游戏`` 场景中, 有 "
"``10`` 个球体, 所以这是初始值."

msgid ""
"``sphere_ui``: A reference to the sphere UI. We will use this later in the "
"tutorial to display the amount of spheres left in the world."
msgstr ""
"``sphere_ui``: 对球体UI的引用. 我们之后会在教程中用到这个, 来显示世界中剩余球"
"体的数量."

msgid ""
"With these variables defined, we can now add the ``remove_sphere`` function. "
"Add the following code to ``Game.gd``:"
msgstr ""
"有了这些变量的定义, 我们现在可以添加 ``remove_sphere`` 函数. 在 ``Game.gd`` "
"中添加以下代码:"

msgid "Let's go through what this function does real quick:"
msgstr "让我们快速浏览一下这个函数的作用:"

msgid ""
"First, it removes one from the ``spheres_left`` variable. It then checks to "
"see if the ``sphere_ui`` variable is not equal to ``null``, and if it is not "
"equal to ``null`` it calls the ``update_ui`` function on ``sphere_ui``, "
"passing in the number of spheres as an argument to the function."
msgstr ""
"首先, 它从 ``spheres_left`` 变量中删除一个. 然后检查 ``sphere_ui`` 变量是否不"
"等于 ``null`` , 如果不等于 ``null`` , 则调用 ``sphere_ui`` 的 ``update_ui`` "
"函数, 将球体的数量作为参数传给该函数."

msgid "We will add the code for ``sphere_ui`` later in this tutorial!"
msgstr "我们将在后面的教程中添加 ``sphere_ui`` 的代码!"

msgid ""
"Now the ``Sphere_Target`` is ready to be used, but we don't have any way to "
"destroy it. Let's fix that by adding some special :ref:`RigidBody "
"<class_RigidBody>`-based nodes that can damage the targets."
msgstr ""
"现在 ``Sphere_Target`` 已经可以使用了, 但是我们没有办法破坏它. 让我们通过添加"
"一些特殊的基于 :ref:`RigidBody <class_RigidBody>` 的节点来解决这个问题, 这些"
"节点可以破坏目标."

msgid "Adding a pistol"
msgstr "加一把手枪"

msgid ""
"Let's add a pistol as the first interactable :ref:`RigidBody "
"<class_RigidBody>` node. Open up ``Pistol.tscn``, which you can find in the "
"``Scenes`` folder."
msgstr ""
"让我们添加一把手枪作为第一个可交互的 :ref:`RigidBody <class_RigidBody>` 节"
"点. 在 ``Scenes`` 文件夹中找到并打开 ``Pistol.tscn`` ."

msgid ""
"Let's quickly go over a few things of note in ``Pistol.tscn`` real quick "
"before we add the code."
msgstr "在添加代码之前, 我们先来快速了解一下 ``Pistol.tscn`` 中的一些注意事项."

msgid ""
"All of the nodes in ``Pistol.tscn`` expect the root node are rotated. This "
"is so the pistol is in the correct rotation relative to the VR controller "
"when it is picked up. The root node is a :ref:`RigidBody <class_RigidBody>` "
"node, which we need because we're going to use the "
"``VR_Interactable_Rigidbody`` class we created in the last part of this "
"tutorial series."
msgstr ""
"``Pistol.tscn`` 中的所有节点(除了根节点)都是旋转的. 这是为了让手枪在拿起时相"
"对于VR控制器处于正确的旋转状态. 根节点是一个 :ref:`RigidBody "
"<class_RigidBody>` 节点, 我们需要这个节点, 因为我们将使用我们在本系列教程最后"
"一部分创建的 ``VR_Interactable_Rigidbody`` 类."

msgid ""
"There is a :ref:`MeshInstance <class_MeshInstance>` node called "
"``Pistol_Flash``, which is a simple mesh that we will be using to simulate "
"the muzzle flash on the end of the pistol's barrel. A :ref:`MeshInstance "
"<class_MeshInstance>` node called ``LaserSight`` is used to as a guide for "
"aiming the pistol, and it follows the direction of the :ref:`Raycast "
"<class_Raycast>` node, called ``Raycast``, that the pistol uses to detect if "
"its 'bullet' hit something. Finally, there is an :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node at the end of the pistol that we will use "
"to play the sound of the pistol firing."
msgstr ""
"有一个 :ref:`MeshInstance <class_MeshInstance>` 节点叫做 ``Pistol_Flash``, 这"
"是一个简单的网格, 我们将用它来模拟手枪枪管末端的枪口闪光. 一个名为 "
"``LaserSight`` 的 :ref:`MeshInstance <class_MeshInstance>` 节点用来作为手枪瞄"
"准的指南, 它遵循 :ref:`Raycast <class_Raycast>` 节点的方向, 名为 "
"``Raycast``, 手枪用来检测它的 '子弹' 是否击中了什么东西. 最后, 在手枪的尾部有"
"一个 :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` 节点, 我们将用它"
"来播放手枪射击的声音."

msgid ""
"Feel free to look at the other parts of the scene if you want. Most of the "
"scene is fairly straightforward, with the major changes mentioned above. "
"Select the :ref:`RigidBody <class_RigidBody>` node called ``Pistol`` and "
"make a new script called ``Pistol.gd``. Add the following code:"
msgstr ""
"如果你想的话, 可以随意看看场景的其他部分. 场景的大部分是相当简单的, 只有上面"
"提到的主要变化. 选择 :ref:`RigidBody <class_RigidBody>` 节点, 称为 "
"``Pistol`` , 并制作一个新的脚本, 称为 ``Pistol.gd`` . 添加以下代码:"

msgid "Explaining the pistol code"
msgstr "解释手枪代码"

msgid ""
"First, notice how instead of ``extends RigidBody``, we instead have "
"``extends VR_Interactable_Rigidbody``. This makes it where the pistol script "
"extends the ``VR_Interactable_Rigidbody`` class so the VR controllers know "
"this object can be interacted with and that the functions defined in "
"``VR_Interactable_Rigidbody`` can be called when this object is held by a VR "
"controller."
msgstr ""
"首先, 请注意, 我们有 ``extends RigidBody``, 而不是 ``extends "
"VR_Interactable_Rigidbody``. 这使得手枪脚本在哪里扩展了 "
"``VR_Interactable_Rigidbody`` 类, 这样VR控制器就知道这个对象可以被交互, 当这"
"个对象被VR控制器持有时, ``VR_Interactable_Rigidbody`` 中定义的函数可以被调用."

msgid "Next, let's look at the class variables:"
msgstr "接下来, 我们来看看类变量:"

msgid ""
"``flash_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that is used to simulate muzzle flash on the "
"pistol."
msgstr ""
"``node_flash_one``: 一个用于保存第一个枪口闪光的变量 :ref:`MeshInstance "
"<class_MeshInstance>`."

msgid ""
"``FLASH_TIME``: A constant to define how long the muzzle flash will be "
"visible. This will also define how fast the pistol can fire."
msgstr ""
"``FLASH_TIME`` : 一个常数, 用于定义枪口闪光的可见时间. 这也将定义手枪的射击速"
"度."

msgid ""
"``flash_timer``: A variable to hold the amount of time the muzzle flash has "
"been visible for."
msgstr "``flash_timer``: 一个变量, 用于保存枪口闪光的可见时间."

msgid ""
"``laser_sight_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that acts as the pistol's 'laser sight'."
msgstr ""
"``node_flash_one``: 一个用于保存第一个枪口闪光的变量 :ref:`MeshInstance "
"<class_MeshInstance>`."

msgid ""
"``pistol_fire_sound``: A variable to hold the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node used for the pistol's firing sound."
msgstr ""
"``pistol_fire_sound``: 一个变量, 用来保存用于手枪射击声音的 :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` 节点."

msgid ""
"``raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` node that "
"is used for calculating the bullet's position and normal when the pistol is "
"fired."
msgstr ""
"``raycast``: 一个变量, 用来保存 :ref:`Raycast <class_Raycast>` 节点, 用于计算"
"手枪发射时子弹的坐标和法线."

msgid ""
"``BULLET_DAMAGE``: A constant to define the amount of damage a single bullet "
"from the pistol does."
msgstr "``BULLET_DAMAGE``: 一个常数, 用来定义手枪的一颗子弹的伤害量."

msgid ""
"``COLLISION_FORCE``: A constant that defines the amount of force that is "
"applied to :ref:`RigidBody <class_RigidBody>` nodes when the pistol's bullet "
"collides."
msgstr ""
"``COLLISION_FORCE`` : 一个常数, 用于定义手枪子弹碰撞时对 :ref:`RigidBody "
"<class_RigidBody>` 节点施加的力."

msgid ""
"This function gets the nodes and assigns them to their proper variables. For "
"the ``flash_mesh`` and ``laser_sight_mesh`` nodes, both have their "
"``visible`` property set to ``false`` so they are not visible initially."
msgstr ""
"该函数获取节点并将其分配给适当的变量. 对于 ``flash_mesh`` 和 "
"``laser_sight_mesh`` 节点, 它们的 ``visible`` 属性都设置为 ``false`` , 所以它"
"们最初是不可见的."

msgid ""
"The ``_physics_process`` function first checks to see if the pistol's muzzle "
"flash is visible by checking if ``flash_timer`` is more than zero. If "
"``flash_timer`` is more than zero, then we remove time, ``delta`` from it. "
"Next we check if the ``flash_timer`` variable is zero or less now that we "
"removed ``delta`` from it. If it is, then the pistol muzzle flash timer just "
"finished and so we need to make ``flash_mesh`` invisible by setting it's "
"``visible`` property to ``false``."
msgstr ""
"``_physics_process`` 函数首先检查手枪的枪口闪光是否可见——检查 "
"``flash_timer`` 是否大于零. 如果 ``flash_timer`` 大于零, 那么我们就从中去掉时"
"间 ``delta`` . 接下来, 我们检查 ``flash_timer`` 变量是否为零或更小, 因为我们"
"已经从中减去了 ``delta`` . 如果是的话, 那么这说明手枪枪口闪光计时器刚刚结束, "
"所以我们需要将 ``flash_mesh`` 的 ``visible`` 属性设置为 ``false`` , 使 "
"``flash_mesh`` 不可见."

msgid "``interact`` function step-by-step explanation"
msgstr "``interact`` 函数的分步说明"

msgid ""
"The interact function first checks to see if the pistol's muzzle flash is "
"invisible by checking to see if ``flash_timer`` is less than or equal to "
"zero. We do this so we can limit the rate of fire of the pistol to the "
"length of time the muzzle flash is visible, which is a simple solution for "
"limiting how fast the player can fire."
msgstr ""
"interact函数首先通过检查 ``flash_timer`` 是否小于或等于0来检查手枪的枪口闪光"
"是否隐形. 我们这样做是为了将手枪的射击速度限制在枪口闪光可见的时间长度内, 这"
"是限制玩家射击速度的一个简单解决方案."

msgid ""
"If ``flash_timer`` is zero or less, we then set ``flash_timer`` to "
"``FLASH_TIME`` so there is a delay before the pistol can fire again. After "
"that we set ``flash_mesh.visible`` to ``true`` so the muzzle flash at the "
"end of the pistol is visible while ``flash_timer`` is more than zero."
msgstr ""
"如果 ``flash_timer`` 为0或更少, 我们就把 ``flash_timer`` 设置为 "
"``FLASH_TIME`` , 这样在手枪再次射击之前就会有一个延迟. 之后我们将 "
"``flash_mesh.visible`` 设置为 ``true`` , 这样在 ``flash_timer`` 大于零的时"
"候, 就可以确保手枪尾部的枪口闪光是可见的."

msgid ""
"Next we call the ``force_raycast_update`` function on the :ref:`Raycast "
"<class_Raycast>` node in ``raycast`` so that it gets the latest collision "
"info from the physics world. We then check if the ``raycast`` hit something "
"by checking if the ``is_colliding`` function is equal to ``true``."
msgstr ""
"接下来, 我们在 ``raycast`` 中的 :ref:`Raycast <class_Raycast>` 节点上调用 "
"``force_raycast_update`` 函数, 这样它就能从物理世界获得最新的碰撞信息. 然后我"
"们通过检查 ``is_colliding`` 函数是否等于 ``true`` 来检查 ``raycast`` 是否撞到"
"了什么东西."

msgid ""
"If the ``raycast`` hit something, then we get the :ref:`PhysicsBody "
"<class_PhysicsBody>` it collided with through the ``get_collider`` function. "
"We assign the hit :ref:`PhysicsBody <class_PhysicsBody>` to a variable "
"called ``body``."
msgstr ""
"如果 ``raycast`` 撞到了什么东西, 那么我们通过 ``get_collider`` 函数得到与它碰"
"撞的 :ref:`PhysicsBody <class_PhysicsBody>` . 我们把撞到的 :ref:`PhysicsBody "
"<class_PhysicsBody>` 分配给一个叫 ``body`` 的变量."

msgid ""
"We then get the direction of the :ref:`Raycast <class_Raycast>` by getting "
"it's positive ``Z`` directional axis from the :ref:`Basis <class_Basis>` on "
"the ``raycast`` node's ``global_transform``. This will give us the direction "
"the raycast is pointing on the Z axis, which is the same direction as the "
"blue arrow on the :ref:`Spatial <class_Spatial>` gizmo when ``Local space "
"mode`` is enabled in the Godot editor. We store this direction in a variable "
"called ``direction_vector``."
msgstr ""
"然后我们通过 ``raycast`` 节点 ``global_transform`` 上 :ref:`Basis "
"<class_Basis>` 的 ``Z`` 轴正方向得到该 :ref:`Raycast <class_Raycast>` 的方"
"向。这将为我们提供射线 Z 轴的指向，这与在 Godot 编辑器中启用\\ ``局部空间模式"
"``\\ 时 :ref:`Spatial<class_Spatial>` 小工具上的蓝色箭头的方向相同。我们将这"
"个方向存储在一个名为 ``direction_vector`` 的变量中。"

msgid ""
"Next we get the distance from the :ref:`Raycast <class_Raycast>` origin to "
"the :ref:`Raycast <class_Raycast>` collision point by getting the distance "
"from the global position, ``global_transform.origin`` of the ``raycast`` "
"node to the collision point of the :ref:`Raycast <class_Raycast>`, ``raycast."
"get_collision_point``, using the ``distance_to`` function. This will give us "
"the distance the :ref:`Raycast <class_Raycast>` traveled before it collided, "
"which we store in a variable called ``raycast_distance``."
msgstr ""
"接下来我们要获取从 :ref:`Raycast <class_Raycast>` 原点到 :ref:`Raycast "
"<class_Raycast>` 碰撞点的距离。使用 ``distance_to`` 函数计算 ``raycast`` 节点"
"的全局位置 ``global_transform.origin`` 到 :ref:`Raycast <class_Raycast>` 的碰"
"撞点 ``raycast.get_collision_point`` 的距离。这样得到的是 :ref:`Raycast "
"<class_Raycast>` 在发生碰撞前所经过的距离，我们把它存储在一个名叫 "
"``raycast_distance`` 的变量里。"

msgid ""
"Then the code checks if the :ref:`PhysicsBody <class_PhysicsBody>`, "
"``body``, has a function/method called ``damage`` using the ``has_method`` "
"function. If the :ref:`PhysicsBody <class_PhysicsBody>` has a function/"
"method called ``damage``, then we call the ``damage`` function and pass "
"``BULLET_DAMAGE`` so it takes damage from the bullet colliding into it."
msgstr ""
"然后代码检查 :ref:`PhysicsBody <class_PhysicsBody>` , ``body`` , 是否有一个叫"
"做 ``damage`` 的函数/方法, 使用 ``has_method`` 函数. 如果 :ref:`PhysicsBody "
"<class_PhysicsBody>` 有一个叫做 ``damage`` 的函数/方法, 那么我们就调用 "
"``damage`` 函数, 并传递 ``BULLET_DAMAGE`` , 这样它就会受到子弹碰撞到它的伤害."

msgid ""
"Regardless of whether the :ref:`PhysicsBody <class_PhysicsBody>` has a "
"``damage`` function, we then check to see if ``body`` is a :ref:`RigidBody "
"<class_RigidBody>`-based node. If ``body`` is a :ref:`RigidBody "
"<class_RigidBody>`-based node, then we want to push it when the bullet "
"collides."
msgstr ""
"不管 :ref:`PhysicsBody <class_PhysicsBody>` 是否有 ``damage`` 函数, 我们都要"
"检查 ``body`` 是否是基于 :ref:`RigidBody <class_RigidBody>` 的节点. 如果 "
"``body`` 是一个以 :ref:`RigidBody <class_RigidBody>` 为基础的节点, 那么我们要"
"在子弹碰撞时推它."

msgid ""
"To calculate the amount of force applied, we simply take ``COLLISION_FORCE`` "
"and divide it by ``raycast_distance``, then we multiply the whole thing by "
"``body.mass``. We store this calculation in a variable called "
"``collision_force``. This will make collisions over a shorter distance apply "
"move force than those over longer distances, giving a *slightly* more "
"realistic collision response."
msgstr ""
"为了计算所施加的力的大小, 我们只需用 ``COLLISION_FORCE`` 除以 "
"``raycast_distance``, 然后再乘以 ``body.mass``. 我们把这个计算结果存储在一个"
"叫做 ``collision_force`` 的变量中. 这将使短距离的碰撞比长距离的碰撞更容易受"
"力, 从而使碰撞的反应 *更* 真实."

msgid ""
"We then push the :ref:`RigidBody <class_RigidBody>` using the "
"``apply_impulse`` function, where the position is a zero Vector3 so the "
"force is applied from the center, and the collision force is the "
"``collision_force`` variable we calculated."
msgstr ""
"然后我们用 ``apply_impulse`` 函数推送 :ref:`RigidBody <class_RigidBody>`, 其"
"中位置是一个零向量的三维数组, 所以力是从中心开始施加的, 碰撞力是我们计算出来"
"的 ``collision_force`` 变量."

msgid ""
"Regardless of whether the ``raycast`` variable hit something or not, we then "
"play the pistol shot sound by calling the ``play`` function on the "
"``pistol_fire_sound`` variable."
msgstr ""
"不管 ``raycast`` 变量是否击中了什么东西, 我们都要通过调用 "
"``pistol_fire_sound`` 变量上的 ``play`` 函数来播放手枪的射击声."

msgid ""
"Finally, we check to see if the pistol is being held by a VR controller by "
"checking to see if the ``controller`` variable is not equal to ``null``. If "
"it is not equal to ``null``, we then set the ``rumble`` property of the VR "
"controller to ``0.25``, so there is a slight rumble when the pistol fires."
msgstr ""
"最后, 我们通过检查 ``controller`` 变量是否不等于 ``null`` 来检查手枪是否被VR"
"控制器所持有. 如果不等于 ``null`` , 我们就把VR控制器的 ``rumble`` 属性设置为 "
"``0.25`` , 这样手枪射击时就会有轻微的响声."

msgid "``picked_up`` function step-by-step explanation"
msgstr "``picked_up`` 函数的分步说明"

msgid ""
"This function simply makes the ``laser_sight_mesh`` :ref:`MeshInstance "
"<class_MeshInstance>` visible by setting the ``visible`` property to "
"``true``."
msgstr ""
"这个函数只是通过设置 ``visible`` 属性为 ``true`` , 使 ``laser_sight_mesh`` :"
"ref:`MeshInstance <class_MeshInstance>` 可见."

msgid "``dropped`` function step-by-step explanation"
msgstr "``dropped`` 函数的逐步说明"

msgid ""
"This function simply makes the ``laser_sight_mesh`` :ref:`MeshInstance "
"<class_MeshInstance>` invisible by setting the ``visible`` property to "
"``false``."
msgstr ""
"这个函数只是通过设置 ``visible`` 属性为 ``false`` , 使 ``laser_sight_mesh`` :"
"ref:`MeshInstance <class_MeshInstance>` 不可见."

msgid "Pistol finished"
msgstr "手枪完毕"

msgid ""
"That is all we need to do to have working pistols in the project! Go ahead "
"and run the project. If you climb up the stairs and grab the pistols, you "
"can fire them at the sphere targets in the scene using the trigger button on "
"the VR controller! If you fire at the targets long enough, they will break "
"into pieces."
msgstr ""
"这就是我们需要做的所有工作 手枪在项目中！继续运行项目吧. 如果你爬上楼梯, 拿起"
"手枪, 你就可以用VR控制器上的扳机按钮向场景中的球体目标射击!如果你向目标射击的"
"时间足够长, 它们就会碎裂成碎片."

msgid "Adding a shotgun"
msgstr "添加霰弹枪"

msgid "Next let's add a shotgun to the VR project."
msgstr "接下来让我们往VR项目中添加一杆霰弹枪."

msgid ""
"Adding a special shotgun :ref:`RigidBody <class_RigidBody>` should be fairly "
"straightforward, as almost everything with the shotgun is the same as the "
"pistol."
msgstr ""
"添加一个特殊的猎枪 :ref:`RigidBody <class_RigidBody>` 应该是相当简单, 因为猎"
"枪的一切几乎都和手枪一样."

msgid ""
"Open up ``Shotgun.tscn``, which you can find in the ``Scenes`` folder and "
"take a look at the scene. Almost everything is the same as in ``Pistol."
"tscn``. The only thing that is different, beyond name changes, is that "
"instead of a single :ref:`Raycast <class_Raycast>`, there are five :ref:"
"`Raycast <class_Raycast>` nodes. This is because a shotgun generally fires "
"in a cone shape, so we are going to emulate that effect by having several :"
"ref:`Raycast <class_Raycast>` nodes that will rotate randomly in a cone "
"shape when the shotgun fires."
msgstr ""
"在 ``Scenes`` 文件夹中找到并打开 ``Shotgun.tscn`` , 查看这个场景. 几乎所有的"
"东西都和 ``Pistol.tscn`` 一样. 除了名称上的变化, 唯一不同的是, 没有一个 :ref:"
"`Raycast <class_Raycast>` , 而是有五个 :ref:`Raycast <class_Raycast>` 节点. "
"这是因为霰弹枪一般是以锥形发射的, 所以我们要通过几个 :ref:`Raycast "
"<class_Raycast>` 节点来模仿这种效果, 当霰弹枪发射时, 这些节点会以锥形随机旋"
"转."

msgid ""
"Outside of that, everything is more or less the same as ``Pistol.tscn``."
msgstr "除此之外, 一切都和 ``Pistol.tscn`` 差不多."

msgid ""
"Let's write the code for the shotgun. Select the :ref:`RigidBody "
"<class_RigidBody>` node called ``Shotgun`` and make a new script called "
"``Shotgun.gd``. Add the following code:"
msgstr ""
"让我们来编写霰弹枪的代码. 选择 :ref:`RigidBody <class_RigidBody>` 节点, 名为 "
"``Shotgun`` , 并创建一个名为 ``Shotgun.gd`` 的新脚本. 添加以下代码:"

msgid ""
"The majority of this code is exactly the same as the code for the pistol "
"with just a few *minor* changes that are primarily just different names. Due "
"to how similar these scripts are, let's just focus on the changes."
msgstr ""
"这段代码的大部分内容与手枪的代码完全相同, 只有一些 *小* 的改动, 主要是名称不"
"同而已. 由于这些脚本的相似度很高, 我们只关注一下这些变化."

msgid "Explaining the shotgun code"
msgstr "解释猎枪代码"

msgid ""
"Like with the pistol, the shotgun extends ``VR_Interactable_Rigidbody`` so "
"the VR controllers know that this object can be interacted with and what "
"functions are available."
msgstr ""
"和手枪一样, 霰弹枪也扩展了 ``VR_Interactable_Rigidbody`` , 所以VR控制器知道这"
"个对象可以与之交互, 以及有哪些功能."

msgid "There is only one new class variable:"
msgstr "只有一个新的类变量:"

msgid ""
"``raycasts``: A variable to hold the node that has all of the :ref:`Raycast "
"<class_Raycast>` nodes as its children."
msgstr ""
"``raycasts``: 一个变量, 用来保存拥有所有 :ref:`Raycast <class_Raycast>` 子节"
"点的节点."

msgid ""
"The new class variable replaces the ``raycast`` variable from ``Pistol.gd``, "
"because with the shotgun we need to process multiple :ref:`Raycast "
"<class_Raycast>` nodes instead of just one. All of the other class variables "
"are the same as ``Pistol.gd`` and function the same way, some just are "
"renamed to be non-pistol specific."
msgstr ""
"新的类变量取代了 ``Pistol.gd`` 中的 ``raycast`` 变量, 因为对于霰弹枪, 我们需"
"要处理多个 :ref:`Raycast <class_Raycast>` 节点, 而不是只有一个. 所有其他类变"
"量与 ``Pistol.gd`` 相同, 功能也相同, 只是有些变量被重新命名为非手枪专用变量."

msgid ""
"The interact function first checks to see if the shotgun's muzzle flash is "
"invisible by checking to see if ``flash_timer`` is less than or equal to "
"zero. We do this so we can limit the rate of fire of the shotgun to the "
"length of time the muzzle flash is visible, which is a simple solution for "
"limiting how fast the player can fire."
msgstr ""
"interact函数首先通过检查 ``flash_timer`` 是否小于或等于0来检查霰弹枪的枪口闪"
"光是否隐形. 我们这样做是为了将霰弹枪的射击速度限制在枪口闪光可见的时间长度"
"内, 这是限制玩家射击速度的一个简单解决方案."

msgid ""
"If ``flash_timer`` is zero or less, we then set ``flash_timer`` to "
"``FLASH_TIME`` so there is a delay before the shotgun can fire again. After "
"that we set ``flash_mesh.visible`` to ``true`` so the muzzle flash at the "
"end of the shotgun is visible while ``flash_timer`` is more than zero."
msgstr ""
"如果 ``flash_timer`` 为0或更少, 我们再将 ``flash_timer`` 设置为 "
"``FLASH_TIME`` , 这样在霰弹枪再次开火之前就会有一个延迟. 之后我们将 "
"``flash_mesh.visible`` 设置为 ``true`` , 这样在 ``flash_timer`` 大于零的时"
"候, 霰弹枪尾部的枪口闪光将是可见的."

msgid ""
"Next we go through each of the child nodes of the ``raycasts`` variable "
"using a for loop. This way the code will go through each of the :ref:"
"`Raycast <class_Raycast>` nodes that are children of the ``raycasts`` "
"variable."
msgstr ""
"接下来我们使用for循环来检查 ``raycasts`` 变量的每个子节点. 这样代码就会遍历 :"
"ref:`Raycast <class_Raycast>` 的每一个节点, 这些节点都是 ``raycasts`` 变量的"
"子节点."

msgid ""
"For each node, we check to see if ``raycast`` is *not* a :ref:`Raycast "
"<class_Raycast>` node. If the node is not a :ref:`Raycast <class_Raycast>` "
"node, we simply use ``continue`` to skip it."
msgstr ""
"对于每个节点, 我们检查 ``raycast`` 是否 *不是一个* :ref:`Raycast "
"<class_Raycast>` 节点. 如果这个节点不是 :ref:`Raycast <class_Raycast>` 节点, "
"我们就简单地使用 ``continue`` 跳过它."

msgid ""
"Next we rotate the ``raycast`` node randomly around a small ``10`` degrees "
"cone by settings the ``rotation_degrees`` variable of the ``raycast`` to a "
"Vector3 where the X and Z axis are a random number from ``-10`` to ``10``. "
"This random number is selected using the ``rand_range`` function."
msgstr ""
"接下来, 我们通过设置 ``raycast`` 的 ``rotation_degrees`` 变量为Vector3, 其中X"
"轴和Z轴为 ``-10`` 至 ``10`` 的随机数, 将 ``raycast`` 节点围绕一个小于 ``10`` "
"度锥体随机旋转. 这个随机数是用 ``rand_range`` 函数选择的."

msgid ""
"Then we call the ``force_raycast_update`` function on the :ref:`Raycast "
"<class_Raycast>` node in ``raycast`` so that it gets the latest collision "
"info from the physics world. We then check if the ``raycast`` hit something "
"by checking if the ``is_colliding`` function is equal to ``true``."
msgstr ""
"然后我们在 ``raycast`` 中的 :ref:`Raycast <class_Raycast>` 节点上调用 "
"``force_raycast_update`` 函数, 这样它就能从物理世界获得最新的碰撞信息. 然后我"
"们通过检查 ``is_colliding`` 函数是否等于 ``true`` 来检查 ``raycast`` 是否撞到"
"了什么东西."

msgid ""
"The rest of the code is exactly the same, but this process is repeated for "
"each :ref:`Raycast <class_Raycast>` node that is a child of the ``raycasts`` "
"variable."
msgstr ""
"其余的代码完全相同, 但这个过程对每个 :ref:`raycast <class_Raycast>` 节点进行"
"重复, 该节点是 ``raycasts`` 变量的一个子节点."

msgid ""
"We then get the direction of the raycast by getting it's positive ``Z`` "
"directional axis from the :ref:`Basis <class_Basis>` on the ``raycast`` "
"node's ``global_transform``. This will give us the direction the raycast is "
"pointing on the Z axis, which is the same direction as the blue arrow on "
"the :ref:`Spatial <class_Spatial>` gizmo when ``Local space mode`` is "
"enabled in the Godot editor. We store this direction in a variable called "
"``direction_vector``."
msgstr ""
"然后, 我们从 ``raycast`` 节点的 ``global_transform`` 上的 :ref:`Basis "
"<class_Basis>` 得到射线广播的正 ``Z`` 方向轴, 这提供raycast在Z轴上的指向, 与"
"在Godot编辑器中启用 ``Local space mode`` [局部空间模式] 时 :ref:`Spatial "
"<class_Spatial>` 小工具上的蓝色箭头的方向相同. 我们将这个方向存储在一个名为 "
"``direction_vector`` 的变量中."

msgid ""
"Next we get the distance from the raycast origin to the raycast collision "
"point by getting the distance from the global position, ``global_transform."
"origin`` of the ``raycast`` node to the collision point of the raycast, "
"``raycast.get_collision_point``, using the ``distance_to`` function. This "
"will give us the distance the :ref:`Raycast <class_Raycast>` traveled before "
"it collided, which we store in a variable called ``raycast_distance``."
msgstr ""
"接下来, 我们通过使用 ``distance_to`` 函数获取 ``raycast`` 节点的全局位置 "
"``global_transform.origin`` 到raycast的碰撞点 ``raycast."
"get_collision_point`` 的距离, 得到从raycast原点到raycast碰撞点的距离. 这提供"
"了 :ref:`Raycast <class_Raycast>` 在碰撞前走过的距离, 将其存储在一个名为 "
"``raycast_distance`` 的变量中."

msgid ""
"Once all of the :ref:`Raycast <class_Raycast>`\\s in the ``raycast`` "
"variable have been iterated over, we then play the shotgun shot sound by "
"calling the ``play`` function on the ``shotgun_fire_sound`` variable."
msgstr ""
"一旦所有的 :ref:`Raycast <class_Raycast>` 中的 ``raycast`` 变量被迭代过后, 通"
"过调用 ``play`` 中 ``shotgun_fire_sound`` 变量来播放枪声."

msgid ""
"Finally, we check to see if the shotgun is being held by a VR controller by "
"checking to see if the ``controller`` variable is not equal to ``null``. If "
"it is not equal to ``null``, we then set the ``rumble`` property of the VR "
"controller to ``0.25``, so there is a slight rumble when the shotgun fires."
msgstr ""
"最后, 我们通过检查 ``controller`` 变量是否不等于 ``null`` 来检查霰弹枪是否由"
"VR控制器持有. 如果不等于 ``null`` , 我们就把VR控制器的 ``rumble`` 属性设置为 "
"``0.25`` , 这样猎枪射击时就会有轻微的轰鸣声."

msgid "Shotgun finished"
msgstr "霰弹枪完毕"

msgid ""
"Everything else is exactly the same as the pistol, with at most just some "
"simple name changes."
msgstr "其他的一切都和手枪完全一样, 最多只是一些简单的名称变化."

msgid ""
"Now the shotgun is finished! You can find the shotgun in the sample scene by "
"looking around the back of one of the walls (not in the building though!)."
msgstr ""
"现在, 猎枪已经完成了!你可以在样本场景中找到霰弹枪, 在其中一面墙的后面寻找, 不"
"是在建筑物里面！."

msgid "Adding a bomb"
msgstr "添加炸弹"

msgid ""
"Okay, let's add a different special :ref:`RigidBody <class_RigidBody>`. "
"Instead of adding something that shoots, let's add something we can throw - "
"a bomb!"
msgstr ""
"好吧, 让我们添加一个不同的特殊 :ref:`RigidBody <class_RigidBody>` . 与其添加"
"一些会射击的东西, 不如添加一些我们可以投掷的东西--炸弹!"

msgid "Open up ``Bomb.tscn``, which is in the ``Scenes`` folder."
msgstr "打开 ``Bomb.tscn`` , 它位于 ``Scenes`` 文件夹中."

msgid ""
"The root node is a :ref:`RigidBody <class_RigidBody>` node that we'll be "
"extending to use ``VR_Interactable_Rigidbody``, which has a :ref:"
"`CollisionShape <class_CollisionShape>` like the other special :ref:"
"`RigidBody <class_RigidBody>` nodes we've made so far. Likewise, there is a :"
"ref:`MeshInstance <class_MeshInstance>` called ``Bomb`` that is used to "
"display the mesh for the bomb."
msgstr ""
"根节点是一个 :ref:`RigidBody <class_RigidBody>` 节点, 我们将扩展使用 "
"``VR_Interactable_Rigidbody`` , 它有一个 :ref:`CollisionShape "
"<class_CollisionShape>`, 就像我们到目前为止所做的其他特殊 :ref:`RigidBody "
"<class_RigidBody>` 节点一样. 同样, 有一个 :ref:`MeshInstance "
"<class_MeshInstance>` 叫做 ``Bomb`` , 用来显示炸弹的网格."

msgid ""
"Then we have an :ref:`Area <class_Area>` node simply called ``Area`` that "
"has a large :ref:`CollisionShape <class_CollisionShape>` as its child. We'll "
"use this :ref:`Area <class_Area>` node to effect anything within it when the "
"bomb explodes. Essentially, this :ref:`Area <class_Area>` node will be the "
"blast radius for the bomb."
msgstr ""
"然后我们有一个 :ref:`Area <class_Area>` 节点, 简单地称为 ``Area``, 它有一个大"
"的 :ref:`CollisionShape <class_CollisionShape>` 作为它的子节点. 当炸弹爆炸"
"时, 将使用这个 :ref:`Area <class_Area>` 节点来影响其中的任何东西. 基本上, 这"
"个 :ref:`Area <class_Area>` 节点将是炸弹的爆炸半径."

msgid ""
"There is also a couple :ref:`Particles <class_Particles>` nodes. One of the :"
"ref:`Particles <class_Particles>` nodes are for the smoke coming out of the "
"bomb's fuse, while another is for the explosion. You can take a look at the :"
"ref:`ParticlesMaterial <class_ParticlesMaterial>` resources, which define "
"how the particles work, if you want. We will not be covering how the "
"particles work in this tutorial due to it being outside of the scope of this "
"tutorial."
msgstr ""
"还有几个 :ref:`Particles <class_Particles>` 节点, 其中一个 :ref:`Particles "
"<class_Particles>` 节点是炸弹引信中冒出的烟雾, 而另一个是爆炸. 如果你想看的"
"话, 可以看一下 :ref:`ParticlesMaterial <class_ParticlesMaterial>` 资源, 它定"
"义了粒子工作方式. 不会在本教程中介绍粒子如何工作, 因为它不在本教程的范围内."

msgid ""
"There is one thing with the :ref:`Particles <class_Particles>` nodes that we "
"need to make note of. If you select the ``Explosion_Particles`` node, you'll "
"find that its ``lifetime`` property is set to ``0.75`` and that the ``one "
"shot`` checkbox is enabled. This means that the particles will only play "
"once, and the particles will last for ``0.75`` seconds. We'll need to know "
"this so we can time the removal of the bomb with the end of the explosion :"
"ref:`Particles <class_Particles>`."
msgstr ""
"对于 :ref:`Particles <class_Particles>` 节点, 有一件事我们需要注意. 如果你选"
"择了 ``Explosion_Particles`` 节点, 你会发现它的 ``lifetime`` 属性被设置为 "
"``0.75`` , 而且 ``one shot`` 复选框被启用. 这意味着粒子将只播放一次, 并且粒子"
"将持续 ``0.75`` 秒. 我们需要知道这一点, 这样我们就可以在爆炸结束时移除炸弹 :"
"ref:`Particles <class_Particles>`."

msgid ""
"Let's write the code for the bomb. Select the ``Bomb`` :ref:`RigidBody "
"<class_RigidBody>` node and make a new script called ``Bomb.gd``. Add the "
"following code:"
msgstr ""
"让我们来编写炸弹的代码. 选择 ``Bomb`` :ref:`RigidBody <class_RigidBody>` 节"
"点, 制作一个新的脚本, 名为 ``Bomb.gd`` , 添加以下代码:"

msgid "Explaining the bomb code"
msgstr "解释炸弹代码"

msgid ""
"Like with the other special :ref:`RigidBody <class_RigidBody>` nodes, the "
"bomb extends ``VR_Interactable_Rigidbody`` so the VR controllers know this "
"object can be interacted with and that the functions defined defined in "
"``VR_Interactable_Rigidbody`` can be called when this object is held by a VR "
"controller."
msgstr ""
"和其他特殊的 :ref:`RigidBody <class_RigidBody>` 节点一样, 炸弹也扩展了 "
"``VR_Interactable_Rigidbody`` , 这样VR控制器就知道这个对象可以被交互, 当这个"
"对象被VR控制器持有时, ``VR_Interactable_Rigidbody`` 中定义的函数可以被调用."

msgid ""
"``bomb_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that is used for the non-exploded bomb."
msgstr ""
"``bomb_mesh``: 一个变量, 用来保存 :ref:`MeshInstance <class_MeshInstance>` 节"
"点, 用于不爆炸的炸弹."

msgid ""
"``FUSE_TIME``: A constant to define how long the fuse will 'burn' before the "
"bomb explodes"
msgstr "``FUSE_TIME`` : 一个常数, 用于定义炸弹爆炸前引信将 '燃烧' 多长时间"

msgid ""
"``fuse_timer``: A variable to hold the length of time that has passed since "
"the bomb's fuse has started to burn."
msgstr "``fuse_timer``: 一个变量, 用于保存炸弹的引信开始燃烧后的时间长度."

msgid ""
"``explosion_area``: A variable to hold the :ref:`Area <class_Area>` node "
"used to detect objects within the bomb's explosion."
msgstr ""
"``explosion_area``: 一个变量, 用来保存 :ref:`Area <class_Area>` 节点, 用于检"
"测炸弹爆炸范围内的物体."

msgid ""
"``EXPLOSION_DAMAGE``: A constant to define how much damage is applied with "
"the bomb explodes."
msgstr "``EXPLOSION_DAMAGE`` . 一个常数, 用于定义炸弹爆炸时的伤害程度."

msgid ""
"``EXPLOSION_TIME``: A constant to define how long the bomb will last in the "
"scene after it explodes. This value should be the same as the ``lifetime`` "
"property of the explosion :ref:`Particles <class_Particles>` node."
msgstr ""
"``EXPLOSION_TIME``: 一个常数, 用于定义炸弹爆炸后在场景中持续时长, 该值应与爆"
"炸的 ``lifetime`` 属性相同 :ref:`Particles <class_Particles>` 节点."

msgid ""
"``explosion_timer`` A variable to hold the length of time that has passed "
"since the bomb exploded."
msgstr "``explosion_timer`` 一个变量, 用于保存炸弹爆炸后的时间长度."

msgid "``exploded``: A variable to hold whether the bomb has exploded or not."
msgstr "``exploded`` . 一个变量, 用于保存炸弹是否爆炸."

msgid ""
"``COLLISION_FORCE``: A constant that defines the amount of force that is "
"applied to :ref:`RigidBody <class_RigidBody>` nodes when the bomb explodes."
msgstr ""
"``COLLISION_FORCE``: 一个常数, 定义炸弹爆炸时施加在 :ref:`RigidBody "
"<class_RigidBody>` 节点上的力的大小."

msgid ""
"``fuse_particles``: A variable to hold a reference to the :ref:`Particles "
"<class_Particles>` node used for the bomb's fuse."
msgstr ""
"``fuse_particles``: 一个变量, 用于保存炸弹引信的 :ref:`Particles "
"<class_Particles>` 节点的引用."

msgid ""
"``explosion_particles``: A variable to hold a reference to the :ref:"
"`Particles <class_Particles>` node used for the bomb's explosion."
msgstr ""
"``explosion_particles``: 一个变量, 用于保存对炸弹爆炸所用的 :ref:`Particles "
"<class_Particles>` 节点的引用."

msgid ""
"``explosion_sound``: A variable to hold a reference to the :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node used for the "
"explosion sound."
msgstr ""
"``explosion_sound``: 一个变量, 用来保存对用于爆炸声的 :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` 节点的引用."

msgid ""
"The ``_ready`` function first gets all of the nodes from the bomb scene and "
"assigns them to their respective class variables for later use."
msgstr ""
"``_ready`` 函数首先从炸弹场景中获取所有的节点, 并将它们分配给各自的类变量, 以"
"便以后使用."

msgid ""
"Then we call ``set_physics_process`` and pass ``false`` so "
"``_physics_process`` is not executed. We do this because the code in "
"``_physics_process`` will start burning the fuse and exploding the bomb, "
"which we only want to do when the user interacts with the bomb. If we did "
"not disable ``_physics_process``, the bomb's fuse would start before the "
"user has a chance to get to the bomb."
msgstr ""
"然后我们调用 ``set_physics_process`` 并传递 ``false`` , 这样 "
"``_physics_process`` 就不会被执行. 这样做是因为 ``_physics_process`` 中的代码"
"会开始燃烧导火索并爆炸炸弹, 而我们只想在用户与炸弹交互时这样做. 如果我们不禁"
"用 ``_physics_process`` , 炸弹的引信会在用户有机会接近炸弹之前就开始燃烧."

msgid ""
"The ``_physics_process`` function first checks to see if ``fuse_timer`` is "
"less than ``FUSE_TIME``. If it is, then the bomb's fuse is still burning."
msgstr ""
"``_physics_process`` 函数首先检查 ``fuse_timer`` 是否小于 ``FUSE_TIME`` . 如"
"果是, 则说明炸弹的引信仍在燃烧."

msgid ""
"If the bomb's fuse is still burning, we then add time, ``delta``, to the "
"``fuse_timer`` variable. We then check to see if ``fuse_timer`` is more than "
"or equal to ``FUSE_TIME`` now that we have added ``delta`` to it. If "
"``fuse_timer`` is more than or equal to ``FUSE_TIME``, then the fuse has "
"just finished and we need to explode the bomb."
msgstr ""
"如果炸弹的引信仍在燃烧, 我们就在 ``fuse_timer`` 变量中加入时间 ``delta`` , 然"
"后检查 ``fuse_timer`` 是否大于或等于 ``FUSE_TIME`` . 如果 ``fuse_timer`` 大于"
"或等于 ``FUSE_TIME`` , 那么引信刚刚完成, 我们需要引爆炸弹."

msgid ""
"To explode the bomb, we first stop emitting particles for the fuse by "
"setting ``emitting`` to ``false`` on ``fuse_particles``. We then tell the "
"explosion :ref:`Particles <class_Particles>` node, ``explosion_particles``, "
"to emit all of its particle in a single shot by setting ``one_shot`` to "
"``true``. After that, we set ``emitting`` to ``true`` on "
"``explosion_particles`` so it looks like the bomb has exploded. To help make "
"it look like the bomb exploded, we hide the bomb :ref:`MeshInstance "
"<class_MeshInstance>` node by setting ``bomb_mesh.visible`` to ``false``."
msgstr ""
"为了使炸弹爆炸, 我们首先在 ``fuse_particles`` 上将 ``emitting`` 设置为 "
"``false`` , 停止为引信发射粒子. 然后告诉爆炸 :ref:`Particles "
"<class_Particles>` 节点 ``explosion_particles`` , 通过设置 ``one_shot`` 为 "
"``true`` , 让它一次发射所有的粒子. 之后, 在 ``explosion_particles`` 上设置 "
"``emitting`` 为 ``true`` , 这样看起来就像炸弹已经爆炸. 为了让炸弹看起来像爆"
"炸, 通过设置 ``bomb_mesh.visible`` 为 ``false`` 来隐藏炸弹 :ref:"
"`MeshInstance <class_MeshInstance>` 节点."

msgid ""
"To keep the bomb from colliding with other objects in the physics world, we "
"set the ``collision_layer`` and ``collision_mask`` properties of the bomb to "
"``0``. We also change the :ref:`RigidBody <class_RigidBody>` mode to "
"``MODE_STATIC`` so the bomb :ref:`RigidBody <class_RigidBody>` does not move."
msgstr ""
"为了防止炸弹与物理世界中的其他物体发生碰撞, 将炸弹的 ``collision_layer`` 和 "
"``collision_mask`` 属性设置为 ``0`` . 将 :ref:`RigidBody <class_RigidBody>` "
"模式改为 ``MODE_STATIC`` , 这样炸弹 :ref:`RigidBody <class_RigidBody>` 就不会"
"移动."

msgid ""
"Then we need to get all of the :ref:`PhysicsBody <class_PhysicsBody>` nodes "
"within the ``explosion_area`` node. To do this, we use the "
"``get_overlapping_bodies`` in a for loop. The ``get_overlapping_bodies`` "
"function will return an array of :ref:`PhysicsBody <class_PhysicsBody>` "
"nodes within the :ref:`Area <class_Area>` node, which is exactly what we are "
"looking for."
msgstr ""
"然后我们需要获取 ``explosion_area`` 节点内的所有 :ref:`PhysicsBody "
"<class_PhysicsBody>` 节点。要做到这一点，在 for 循环中使用 "
"``get_overlapping_bodies``\\ 。\\ ``get_overlapping_bodies`` 函数将返回 :ref:"
"`Area <class_Area>` 节点内 :ref:`PhysicsBody <class_PhysicsBody>` 节点的数"
"组，这正是我们要的。"

msgid ""
"For each :ref:`PhysicsBody <class_PhysicsBody>` node, which we store in a "
"variable called ``body``, we check to see if it is equal to ``self``. We do "
"this so the bomb does not accidentally explode itself, as the "
"``explosion_area`` could potentially detect the ``Bomb`` :ref:`RigidBody "
"<class_RigidBody>` as a PhysicsBody within the explosion area."
msgstr ""
"对于每个 :ref:`PhysicsBody <class_PhysicsBody>` 节点(我们将其存储在一个名为 "
"``body`` 的变量中), 我们检查它是否等于 ``self`` . 这样做是为了使炸弹不会意外"
"地自己爆炸, 因为 ``explosion_area`` [爆炸区]可能会检测到 ``Bomb`` [炸弹] :"
"ref:`RigidBody <class_RigidBody>` 是爆炸区的一个物理体."

msgid ""
"If the :ref:`PhysicsBody <class_PhysicsBody>` node, ``body``, is not the "
"bomb, then we first check to see if the :ref:`PhysicsBody "
"<class_PhysicsBody>` node has a function called ``damage``. If the :ref:"
"`PhysicsBody <class_PhysicsBody>` node has a function called ``damage``, we "
"call it and pass ``EXPLOSION_DAMAGE`` to it so it takes damage from the "
"explosion."
msgstr ""
"如果 :ref:`PhysicsBody <class_PhysicsBody>` 节点 ``body`` 不是炸弹, 那么首先"
"检查 :ref:`PhysicsBody <class_PhysicsBody>` 节点是否有一个叫做 ``damage`` 的"
"函数. 如果 :ref:`PhysicsBody <class_PhysicsBody>` 节点有一个叫做 ``damage`` "
"的函数, 就调用它, 并把 ``EXPLOSION_DAMAGE`` 传给它, 使它受到爆炸的伤害."

msgid ""
"Next we check to see if the :ref:`PhysicsBody <class_PhysicsBody>` node is "
"a :ref:`RigidBody <class_RigidBody>`. If ``body`` is a :ref:`RigidBody "
"<class_RigidBody>`, we want to move it when the bomb explodes."
msgstr ""
"接下来我们检查一下 :ref:`PhysicsBody <class_PhysicsBody>` 节点是否是 :ref:"
"`RigidBody <class_RigidBody>` . 如果 ``body`` 是一个 :ref:`RigidBody "
"<class_RigidBody>`, 要在炸弹爆炸时移动它."

msgid ""
"To move the :ref:`RigidBody <class_RigidBody>` node when the bomb explodes, "
"we first need to calculate the direction from the bomb to the :ref:"
"`RigidBody <class_RigidBody>` node. To do this we subtract the global "
"position of the bomb, ``global_transform.origin`` from the global position "
"of the :ref:`RigidBody <class_RigidBody>`. This will give us a :ref:`Vector3 "
"<class_Vector3>` that points from the bomb to the :ref:`RigidBody "
"<class_RigidBody>` node. We store this :ref:`Vector3 <class_Vector3>` in a "
"variable called ``direction_vector``."
msgstr ""
"要在炸弹爆炸时移动 :ref:`RigidBody <class_RigidBody>` 节点, 首先需要计算从炸"
"弹到 :ref:`RigidBody <class_RigidBody>` 节点的方向. 为此, 从 :ref:`RigidBody "
"<class_RigidBody>` 的全局位置中减去炸弹的全局位置 ``global_transform."
"origin`` . 这将给出一个 :ref:`Vector3 <class_Vector3>`, 从炸弹指向 :ref:"
"`RigidBody <class_RigidBody>` 节点. 将这个 :ref:`Vector3 <class_Vector3>` 存"
"储在一个名为 ``direction_vector`` 的变量中."

msgid ""
"We then calculate the distance the :ref:`RigidBody <class_RigidBody>` is "
"from the bomb by using the ``length`` function on ``direction_vector``. We "
"store the distance in a variable called ``bomb_distance``."
msgstr ""
"然后, 使用 ``rediction_vector`` 上的 ``length`` 函数计算 :ref:`RigidBody "
"<class_RigidBody>` 离炸弹的距离. 将距离存储在一个名为 ``bomb_distance`` 的变"
"量中."

msgid ""
"We then calculate the amount of force the bomb will be applied to the :ref:"
"`RigidBody <class_RigidBody>` node when the bomb explodes by dividing "
"``COLLISION_FORCE`` by ``bomb_distance``, and multiplying that by "
"``collision_force``. This will make it so if the :ref:`RigidBody "
"<class_RigidBody>` node is closer to the bomb, it will be pushed farther."
msgstr ""
"然后, 计算炸弹爆炸时炸弹对 :ref:`RigidBody <class_RigidBody>` 节点的作用力, "
"方法是将 ``COLLISION_FORCE`` 除以 ``bomb_distance`` , 再乘以 "
"``collision_force`` . 这样, 如果 :ref:`RigidBody <class_RigidBody>` 节点离炸"
"弹更近, 它就会被推得更远."

msgid ""
"Finally, we push the :ref:`RigidBody <class_RigidBody>` node using the "
"``apply_impulse`` function, with a :ref:`Vector3 <class_Vector3>` position "
"of zero and ``collision_force`` multiplied by ``direction_vector."
"normalized`` as the force. This will send the :ref:`RigidBody "
"<class_RigidBody>` node flying when the bomb explodes."
msgstr ""
"最后, 用 ``apply_impulse`` 函数推动 :ref:`RigidBody <class_RigidBody>` 节"
"点, :ref:`Vector3 <class_Vector3>` 位置为零, ``collision_force`` 乘以 "
"``direction_vector.normalized`` 作为力. 这样, 当炸弹爆炸时, 就会把 :ref:"
"`RigidBody <class_RigidBody>` 节点炸飞."

msgid ""
"After we have looped through all of the :ref:`PhysicsBody "
"<class_PhysicsBody>` nodes within the ``explosion_area``, we set the "
"``exploded`` variable to ``true`` so the code knows the bomb exploded and "
"call ``play`` on ``explosion_sound`` so the sound of an explosion is played."
msgstr ""
"当循环浏览了 ``explosion_area`` 内的所有 :ref:`PhysicsBody "
"<class_PhysicsBody>` 节点后, 将 ``exploded`` 变量设置为 ``true`` , 这样代码就"
"知道炸弹爆炸了, 并调用 ``explosion_sound`` 上的 ``play`` , 播放爆炸声."

msgid ""
"Alright, the next section of code starts by first checking if ``exploded`` "
"is equal to ``true``."
msgstr "好了, 下一部分代码开始, 首先检查 ``exploded`` 是否等于 ``true`` ."

msgid ""
"If ``exploded`` is equal to ``true``, then that means the bomb is waiting "
"for the explosion particles to finish before it frees/destroys itself. We "
"add time, ``delta``, to ``explosion_timer`` so we can track how long it has "
"been since the bomb has exploded."
msgstr ""
"如果 ``exploded`` 等于 ``true`` , 那么这意味着炸弹在释放或销毁自己之前, 正在"
"等待爆炸粒子完成. 在 ``explosion_timer`` 中加入时间 ``delta`` , 这样就可以跟"
"踪炸弹爆炸后的时间."

msgid ""
"If ``explosion_timer`` is greater than or equal to ``EXPLOSION_TIME`` after "
"we added ``delta``, then the explosion timer just finished."
msgstr ""
"如果 ``explosion_timer`` 在与 ``delta`` 相加后, 大于或等于 "
"``EXPLOSION_TIME`` , 则爆炸定时器刚刚完成."

msgid ""
"If the explosion timer just finished, we set ``explosion_area.monitoring`` "
"to ``false``. The reason we do this is because there was a bug that would "
"print an error when you freed/deleted an :ref:`Area <class_Area>` node when "
"the ``monitoring`` property was true. To make sure this doesn't happen, we "
"simply set ``monitoring`` to false on ``explosion_area``."
msgstr ""
"如果爆炸计时器刚刚结束, 将 ``explosion_area.monitoring`` 设置为 ``false`` . "
"这样做的原因是有一个bug, 当 ``monitoring`` 属性为真时, 当你释放或删除一个 :"
"ref:`Area <class_Area>` 节点时, 会打印一个错误. 为了确保这种情况不会发生, 只"
"需在 ``explosion_area`` 上将 ``monitoring`` 设置为false."

msgid ""
"Next we check to see if the bomb is being held by a VR controller by "
"checking to see if the ``controller`` variable is not equal to ``null``. If "
"the bomb is being held by a VR controller, we set the ``held_object`` "
"property of the VR controller, ``controller``, to ``null``. Because the VR "
"controller is no longer holding anything, we make the VR controller's hand "
"mesh visible by setting ``controller.hand_mesh.visible`` to ``true``. Then "
"we check to see if the VR controller grab mode is ``RAYCAST``, and if it is "
"we set ``controller.grab_raycast.visible`` to ``true`` so the 'laser sight' "
"for the grab raycast is visible."
msgstr ""
"接下来检查炸弹是否被VR控制器持有, 检查 ``controller`` 变量是否不等于 "
"``null`` . 如果炸弹被VR控制器持有, 就把VR控制器的 ``controller`` 属性 "
"``held_object`` 设置为 ``null`` . 因为VR控制器不再持有任何东西, 所以将 "
"``controller.hand_mesh.visible`` 设置为 ``true``, 使VR控制器的手部网格可见. "
"然后检查VR控制器的抓取模式是否是 ``RAYCAST`` , 如果是, 将 ``controller."
"grab_raycast.visible`` 设置为 ``true`` , 这样抓取raycast的 '激光瞄准器' 就可"
"见了."

msgid ""
"Finally, regardless if the bomb is being held by a VR controller or not, we "
"call ``queue_free`` so the bomb scene is freed/removed from the scene."
msgstr ""
"最后, 不管炸弹是否被VR控制器持有, 调用 ``queue_free`` , 这样炸弹场景就会被释"
"放或从场景中移除."

msgid ""
"First the ``interact`` function calls ``set_physics_process`` and passes "
"``true`` so the code in ``_physics_process`` starts executing. This will "
"start the bomb's fuse and eventually lead to the bomb exploding."
msgstr ""
"首先, ``interact`` 函数调用 ``set_physics_process`` 并传递 ``true`` , 这样 "
"``_physics_process`` 中的代码就开始执行. 这将启动炸弹的引信, 最终导致炸弹爆"
"炸."

msgid ""
"Finally, we start the fuse particles by setting ``fuse_particles.visible`` "
"to ``true``."
msgstr ""
"最后, 通过将 ``fuse_particles.visible`` 设置为 ``true`` 来启动引信粒子."

msgid "Bomb finished"
msgstr "炸弹完毕"

msgid ""
"Now the bomb is ready to go! You can find the bombs in the orange building."
msgstr "现在炸弹已经准备好了!你可以在橙色建筑中找到炸弹."

msgid ""
"Because of how we are calculating the VR controller's velocity, it is "
"easiest to throw the bombs using a thrusting-like motion instead of a more "
"natural throwing-like motion. The smooth curve of a throwing-like motion is "
"harder to track with the code we are using for calculating the velocity of "
"the VR controllers, so it does not always work correctly and can lead "
"inaccurately calculated velocities."
msgstr ""
"由于我们在计算VR控制器的速度时, 最容易使用类似推力的动作来投掷炸弹, 而不是更"
"自然的类似投掷的动作. 抛掷式运动的平滑曲线很难被我们用来计算VR控制器的速度的"
"代码所追踪, 所以它并不总是正确的, 并可能导致不准确的计算速度."

msgid "Adding a sword"
msgstr "加一把剑"

msgid ""
"Let's add one last special :ref:`RigidBody <class_RigidBody>`-based node "
"that can destroy targets. Let's add a sword so we can slice through the "
"targets!"
msgstr ""
"让我们添加最后一个特殊的 :ref:`RigidBody <class_RigidBody>` —— 能够破坏目标的"
"基础节点. 让我们添加一把剑来砍穿目标！"

msgid "Open up ``Sword.tscn``, which you can find in the ``Scenes`` folder."
msgstr "打开 ``Sword.tscn`` , 你可以在 ``Scenes`` 文件夹中找到它."

msgid ""
"There is not a whole lot going on here. All of the child nodes of the root "
"``Sword`` :ref:`RigidBody <class_RigidBody>` node are rotated to they are "
"positioned correctly when the VR controller picks them up, there is a :ref:"
"`MeshInstance <class_MeshInstance>` node for displaying the sword, and there "
"is an :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node that holds "
"a sound for the sword colliding with something."
msgstr ""
"这里并没有发生很多事情. 所有根 ``Sword`` 的子节点 :ref:`RigidBody "
"<class_RigidBody>` 节点都被旋转, 当VR控制器拾取它们时, 位置是正确的, 有一个 :"
"ref:`MeshInstance <class_MeshInstance>` 节点用于显示剑, 还有一个 :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` 节点用于保存剑与某物碰撞时"
"的声音."

msgid ""
"There is one thing that is slightly different though. There is a :ref:"
"`KinematicBody <class_KinematicBody>` node called ``Damage_Body``. If you "
"take a look at it, you'll find that it is not on any collision layers, and "
"is instead only on a single collision mask. This is so the :ref:"
"`KinematicBody <class_KinematicBody>` will not effect other :ref:"
"`PhysicsBody <class_PhysicsBody>` nodes in the scene, but it will still be "
"effected by :ref:`PhysicsBody <class_PhysicsBody>` nodes."
msgstr ""
"但有一点略有不同. 有一个 :ref:`KinematicBody <class_KinematicBody>` 节点叫做 "
"``Damage_Body`` . 如果你看看它, 你会发现它不在任何碰撞层上, 而只在一个碰撞掩"
"码上. 这是为了让 :ref:`KinematicBody <class_KinematicBody>` 不会影响场景中的"
"其他 :ref:`PhysicsBody <class_PhysicsBody>` 节点, 但它仍然会被 :ref:"
"`PhysicsBody <class_PhysicsBody>` 节点影响."

msgid ""
"We are going to use the ``Damage_Body`` :ref:`KinematicBody "
"<class_KinematicBody>` node to detect the collision point and normal when "
"the sword collides with something in the scene."
msgstr ""
"使用 ``Damage_Body`` :ref:`KinematicBody <class_KinematicBody>` 节点来检测剑"
"与场景中的东西碰撞时的碰撞点和法线."

msgid ""
"While this is perhaps not the best way of getting the collision information "
"from a performance point of view, it does give us a lot of information we "
"can use for post-processing! Using a :ref:`KinematicBody "
"<class_KinematicBody>` this way means we can detect exactly where the sword "
"collided with other :ref:`PhysicsBody <class_PhysicsBody>` nodes."
msgstr ""
"虽然从性能的角度来看, 这可能不是获得碰撞信息的最佳方式, 但它确实给了我们很多"
"信息, 可以用来进行后期处理!使用 :ref:`KinematicBody <class_KinematicBody>` 这"
"种方式意味着我们可以准确检测到剑与其他 :ref:`PhysicsBody "
"<class_PhysicsBody>` 节点碰撞的位置."

msgid ""
"That is really the only thing note worthy about the sword scene. Select the "
"``Sword`` :ref:`RigidBody <class_RigidBody>` node and make a new script "
"called ``Sword.gd``. Add the following code:"
msgstr ""
"这确实是剑的场景中唯一值得注意的地方. 选择 `Sword` :ref:`RigidBody "
"<class_RigidBody>` 节点, 并制作一个名为 ``Sword.gd`` 的新脚本. 添加以下代码:"

msgid "Let's go over how this script works!"
msgstr "让我们回顾一下这个脚本是如何运作的！"

msgid "Explaining the sword code"
msgstr "解释剑代码"

msgid ""
"Like with the other special :ref:`RigidBody <class_RigidBody>` nodes, the "
"sword extends ``VR_Interactable_Rigidbody`` so the VR controllers know this "
"object can be interacted with and that the functions defined defined in "
"``VR_Interactable_Rigidbody`` can be called when this object is held by a VR "
"controller."
msgstr ""
"和其他特殊的 :ref:`RigidBody <class_RigidBody>` 节点一样, 剑扩展了 "
"``VR_Interactable_Rigidbody`` , 这样VR控制器就知道这个对象可以被交互, 当这个"
"对象被VR控制器持有时, ``VR_Interactable_Rigidbody`` 中定义的函数可以被调用."

msgid ""
"``SWORD_DAMAGE``: A constant to define the amount of damage the sword does. "
"This damage is applied to every object in the sword on every "
"``_physics_process`` call"
msgstr ""
"``SWORD_DAMAGE`` ：定义剑的伤害量的常数。每次 ``_physics_process`` 调用中，被"
"剑碰到的对象就都会受到对应的伤害"

msgid ""
"``COLLISION_FORCE``: A constant that defines the amount of force applied to :"
"ref:`RigidBody <class_RigidBody>` nodes when the sword collides with a :ref:"
"`PhysicsBody <class_PhysicsBody>`."
msgstr ""
"``COLLISION_FORCE`` : 一个常数, 定义当剑与 :ref:`RigidBody "
"<class_RigidBody>` 节点相撞时, 施加在 :ref:`PhysicsBody <class_PhysicsBody>` "
"节点上的力的大小."

msgid ""
"``damage_body``: A variable to hold the :ref:`KinematicBody "
"<class_KinematicBody>` node used to detect whether the sword is stabbing a :"
"ref:`PhysicsBody <class_PhysicsBody>` node or not."
msgstr ""
"``damage_body`` : 一个变量, 用于存放 :ref:`KinematicBody "
"<class_KinematicBody>` 节点, 用于检测剑是否刺中了 :ref:`PhysicsBody "
"<class_PhysicsBody>` 节点."

msgid ""
"``sword_noise``: A variable to hold the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node used to play a sound when the sword "
"collides with something."
msgstr ""
"``sword_noise`` : 一个变量, 用来存放 :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` 节点, 当剑与某物碰撞时, 用来播放声音."

msgid ""
"All we are doing in the ``_ready`` function is getting the ``Damage_Body`` :"
"ref:`KinematicBody <class_KinematicBody>` node and assigning it to "
"``damage_body``. Because we do not want the sword to detect a collision with "
"the root :ref:`RigidBody <class_RigidBody>` node of the sword, we call "
"``add_collision_exception_with`` on ``damage_body`` and pass ``self`` so the "
"sword will not be detected."
msgstr ""
"我们在 ``_ready`` 函数中所做的就是获取 ``Damage_Body`` :ref:`KinematicBody "
"<class_KinematicBody>` 节点, 并将其分配给 ``damage_body`` . 因为我们不想让剑"
"检测到与剑的根部 :ref:`RigidBody <class_RigidBody>` 节点的碰撞, 所以我们在 "
"``damage_body`` 上调用 ``add_collision_exception_with`` , 并传递 ``self`` , "
"这样剑的根部就不会被检测到."

msgid ""
"Finally, we get the :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` "
"node for the sword collision sound and apply it to the ``sword_noise`` "
"variable."
msgstr ""
"最后, 我们获得 :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` 节点的"
"剑碰撞声, 并将其应用于 ``sword_noise`` 变量."

msgid ""
"First we need to determine whether the sword is colliding with something or "
"not. To do this, we use the ``move_and_collide`` function of the "
"``damage_body`` node. Unlike how ``move_and_collide`` is normally used, we "
"are not passing a velocity and instead are passing an empty :ref:`Vector3 "
"<class_Vector3>`. Because we do not want the ``damage_body`` node to move, "
"we set the ``test_only`` argument (the fourth argument) as ``true`` so the :"
"ref:`KinematicBody <class_KinematicBody>` generates collision info without "
"actually causing any collisions within the collision world."
msgstr ""
"首先, 我们需要确定剑是否与某物相撞. 为此, 使用 ``damage_body`` 节点的 "
"``move_and_collide`` 函数. 与通常使用 ``move_and_collide`` 不同的是, 没有传递"
"速度, 而是传递一个空的 :ref:`Vector3 <class_Vector3>`. 因为不想让 "
"``damage_body`` 节点移动, 所以将 ``test_only`` 参数(第四个参数)设置为 "
"``true`` , 这样 :ref:`KinematicBody <class_KinematicBody>` 就会生成碰撞信息, "
"而不会在碰撞世界中造成任何碰撞."

msgid ""
"The ``move_and_collide`` function will return a :ref:`KinematicCollision "
"<class_KinematicCollision>` class that has all of the information we need "
"for detecting collisions on the sword. We assign the return value of "
"``move_and_collide`` to a variable called ``collision_results``."
msgstr ""
"``move_and_collide`` 函数将返回一个 :ref:`KinematicCollision "
"<class_KinematicCollision>` 类, 它有我们检测剑上碰撞所需的所有信息. 我们将 "
"``move_and_collide`` 的返回值分配给一个叫做 ``collision_results`` 的变量."

msgid ""
"Next we check to see if ``collision_results`` is not equal to ``null``. If "
"``collision_results`` is not equal to ``null``, then we know that the sword "
"has collided with something."
msgstr ""
"接下来我们检查 ``collision_results`` 是否不等于 ``null`` . 如果 "
"``collision_results`` 不等于 ``null`` , 那么我们就知道这把剑与某物相撞了."

msgid ""
"We then check to see if the :ref:`PhysicsBody <class_PhysicsBody>` the sword "
"collided with has a function/method called ``damage`` using the "
"``has_method`` function. If the :ref:`PhysicsBody <class_PhysicsBody>` has a "
"function called ``damage_body``, we call it and pass the amount of damage "
"the sword does, ``SWORD_DAMAGE``, to it."
msgstr ""
"然后, 使用 ``has_method`` 函数检查与剑相撞的 :ref:`PhysicsBody "
"<class_PhysicsBody>` 是否有一个叫做 ``damage`` 的函数或方法. 如果 :ref:"
"`PhysicsBody <class_PhysicsBody>` 有一个叫做 ``damage_body`` 的函数, 就调用"
"它, 并把剑的伤害量 ``SWORD_DAMAGE`` 传递给它."

msgid ""
"Next we check to see if the :ref:`PhysicsBody <class_PhysicsBody>` the sword "
"collided with is a :ref:`RigidBody <class_RigidBody>`. If what the sword "
"collided with is a :ref:`RigidBody <class_RigidBody>` node, we then check to "
"see if the sword is being held by a VR controller or not by checking to see "
"if ``controller`` is equal to ``null``."
msgstr ""
"接下来检查剑碰撞的 :ref:`PhysicsBody <class_PhysicsBody>` 是否是一个 :ref:"
"`RigidBody <class_RigidBody>`. 如果剑碰撞的是一个 :ref:`RigidBody "
"<class_RigidBody>` 节点, 再通过检查 ``controller`` 是否等于 ``null`` 来查看剑"
"是否被VR控制器所持有."

msgid ""
"If the sword is not being held by a VR controller, ``controller`` is equal "
"to ``null``, then we move the :ref:`RigidBody <class_RigidBody>` node the "
"sword collided with using the ``apply_impulse`` function. For the "
"``position`` of the ``apply_impulse`` function, we use "
"``collision_position`` variable stored within the :ref:`KinematicCollision "
"<class_KinematicCollision>` class in ``collision_results``. For the "
"``velocity`` of the ``apply_impulse`` function, we use the "
"``collision_normal`` multiplied by the ``linear_velocity`` of the sword's :"
"ref:`RigidBody <class_RigidBody>` node multiplied by ``COLLISION_FORCE``."
msgstr ""
"如果VR控制器没有握住剑, ``controller`` 等于 ``null`` , 那么就使用 "
"``apply_impulse`` 函数移动剑碰撞的 :ref:`RigidBody <class_RigidBody>` 节点. "
"对于 ``apply_impulse`` 函数中的 ``position`` , 使用 ``collision_results`` "
"中 :ref:`KinematicCollision <class_KinematicCollision>` 类中存储的 "
"``collision_position`` 变量. 对于 ``apply_impulse`` 函数中的 ``velocity`` , "
"使用 ``collision_normal`` 乘以剑的 :ref:`RigidBody <class_RigidBody>` 节点的 "
"``linear_velocity`` 乘以 ``COLLISION_FORCE`` ."

msgid ""
"If the sword is being held by a VR controller, ``controller`` is not equal "
"to ``null``, then we move the :ref:`RigidBody <class_RigidBody>` node the "
"sword collided with using the ``apply_impulse`` function. For the "
"``position`` of the ``apply_impulse`` function, we use "
"``collision_position`` variable stored within the :ref:`KinematicCollision "
"<class_KinematicCollision>` class in ``collision_results``. For the "
"``velocity`` of the ``apply_impulse`` function, we use the "
"``collision_normal`` multiplied by the VR controller's velocity multiplied "
"by ``COLLISION_FORCE``."
msgstr ""
"如果剑被VR控制器握着, ``controller`` 不等于 ``null`` , 那么就使用 "
"``apply_impulse`` 函数移动剑碰撞的 :ref:`RigidBody <class_RigidBody>` 节点. "
"对于 ``apply_impulse`` 函数中的 ``position`` , 使用 ``collision_results`` "
"中 :ref:`KinematicCollision <class_KinematicCollision>` 类中存储的 "
"``collision_position`` 变量. 对于 ``apply_impulse`` 函数的 ``velocity`` , 使"
"用 ``collision_normal`` 乘以VR控制器的速度乘以 ``COLLISION_FORCE`` ."

msgid ""
"Finally, regardless of whether the :ref:`PhysicsBody <class_PhysicsBody>` is "
"a :ref:`RigidBody <class_RigidBody>` or not, we play the sound of the sword "
"colliding with something by calling ``play`` on ``sword_noise``."
msgstr ""
"最后, 不管 :ref:`PhysicsBody <class_PhysicsBody>` 是不是 :ref:`RigidBody "
"<class_RigidBody>`, 通过调用 ``sword_noise`` 上的 ``play`` 来播放剑与物品碰撞"
"的声音."

msgid "Sword finished"
msgstr "剑完毕"

msgid ""
"With that done, you can now slice through the targets! You can find the "
"sword in the corner in between the shotgun and the pistol."
msgstr "完成后, 您现在可以切入目标了！ 您可以在霰弹枪和手枪之间的角落找到剑."

msgid "Updating the target UI"
msgstr "更新目标UI"

msgid "Let's update the UI as the sphere targets are destroyed."
msgstr "让我们在球体目标被摧毁时更新用户界面."

msgid ""
"Open up ``Main_VR_GUI.tscn``, which you can find in the ``Scenes`` folder. "
"Feel free to look at how the scene is setup if you want, but in an effort to "
"keep this tutorial from becoming too long, we will not be covering the scene "
"setup in this tutorial."
msgstr ""
"打开 ``Main_VR_GUI.tscn`` , 可以在 ``Scenes`` 文件夹中找到它. 如果想了解场景"
"是如何设置的, 但为了不让本教程变得太长, 不在本教程中介绍."

msgid ""
"Expand the ``GUI`` :ref:`Viewport <class_Viewport>` node and then select the "
"``Base_Control`` node. Add a new script called ``Base_Control.gd``, and add "
"the following:"
msgstr ""
"展开 ``GUI`` :ref:`Viewport <class_Viewport>` 节点, 然后选择 "
"``Base_Control`` 节点. 添加一个新的脚本, 名为 ``Base_Control.gd`` , 并添加以"
"下内容:"

msgid "Let's go over how this script works real quick."
msgstr "我们来看看这个脚本是如何快速工作的."

msgid ""
"First, in ``_ready``, we get the :ref:`Label <class_Label>` that shows how "
"many spheres are left and assign it to the ``sphere_count_label`` class "
"variable. Next, we get ``Game.gd`` by using ``get_tree().root`` and assign "
"``sphere_ui`` to this script."
msgstr ""
"首先, 在 ``_ready`` 中, 我们获得 :ref:`Label <class_Label>` , 显示还剩下多少"
"个球体, 并将其分配给 ``sphere_count_label`` 类变量. 接下来, 我们通过使用 "
"``get_tree().root`` 获得 ``Game.gd`` 并将 ``sphere_ui`` 分配给这个脚本."

msgid ""
"In ``update_ui``, we change the sphere :ref:`Label <class_Label>`'s text. If "
"there is at least one sphere remaining, we change the text to show how many "
"spheres are still left in the world. If there are no more spheres remaining, "
"we change the text and congratulate the player."
msgstr ""
"在 ``update_ui`` 中, 我们改变球体 :ref:`Label <class_Label>` 的文本. 如果至少"
"还有一个球体, 我们改变文本以显示世界上还剩下多少球体. 如果没有剩余的球体了, "
"我们改变文本并祝贺玩家."

msgid "Adding the final special RigidBody"
msgstr "添加最终的特殊RigidBody"

msgid ""
"Finally, before we finish this tutorial, let's add a way to reset the game "
"while in VR."
msgstr "最后, 在我们完成本教程之前, 让我们添加一种在VR中重置游戏的方法."

msgid ""
"Open up ``Reset_Box.tscn``, which you will find in ``Scenes``. Select the "
"``Reset_Box`` :ref:`RigidBody <class_RigidBody>` node and make a new script "
"called ``Reset_Box.gd``. Add the following code:"
msgstr ""
"在 ``Scenes`` 中找到并打开 ``Reset_Box.tscn`` . 选择 ``Reset_Box`` :ref:"
"`RigidBody <class_RigidBody>` 节点, 并创建一个名为 ``Reset_Box.gd`` 的新脚"
"本. 添加以下代码:"

msgid "Let's quickly go over how this script works."
msgstr "让我们快速浏览一下这个脚本的工作原理."

msgid "Explaining the reset box code"
msgstr "解释重置盒子代码"

msgid ""
"Like with the other special :ref:`RigidBody <class_RigidBody>`-based objects "
"we've created, the reset box extends ``VR_Interactable_Rigidbody``."
msgstr ""
"就像我们创建的其他特殊的 :ref:`RigidBody <class_RigidBody>` 的对象一样, 重置"
"框扩展了 ``VR_Interactable_Rigidbody`` ."

msgid ""
"The ``start_transform`` class variable will store the global transform of "
"the reset box when the game starts, the ``reset_timer`` class variable will "
"hold the length of time that has passed since the reset box's position has "
"moved, the ``RESET_TIME`` constant defines the length of time the reset box "
"has to wait before being reset, and the ``RESET_MIN_DISTANCE`` constant "
"defines how far the reset box has to be away from it's initial position "
"before the reset timer starts."
msgstr ""
"``start_transform`` 类变量将存储游戏开始时重置框的全局变换, ``reset_timer`` "
"类变量保存重置框位置移动后的时长, ``RESET_TIME`` 常量定义了重置框在被重置前需"
"要等待的时长, ``RESET_MIN_DISTANCE`` 常量定义了重置框在重置计时器启动前需要离"
"开初始位置多远."

msgid ""
"In the ``_ready`` function all we are doing is storing the "
"``global_transform`` of the reset position when the scene starts. This is so "
"we can reset the position, rotation, and scale of the reset box object to "
"this initial transform when enough time has passed."
msgstr ""
"在 ``_ready`` 函数中, 我们所做的只是在场景开始时存储重置位置的 "
"``global_transform`` . 这样就可以在时间足够长时, 将重置框对象的位置, 旋转和比"
"例重置为这个初始变换."

msgid ""
"In the ``_physics_process`` function, the code checks to see if the reset "
"box's initial position to the reset box's current position is farther than "
"``RESET_MIN_DISTANCE``. If it is farther, then it starts adding time, "
"``delta``, to ``reset_timer``. Once ``reset_timer`` is more than or equal to "
"``RESET_TIME``, we reset the ``global_transform`` to the ``start_transform`` "
"so the reset box is back in its initial position. We then set "
"``reset_timer`` to ``0``."
msgstr ""
"在 ``_physics_process`` 函数中, 代码检查重置框的初始位置到重置框的当前位置是"
"否比 ``RESET_MIN_DISTANCE`` 远. 如果远, 那么它就开始增加 ``reset_timer`` 时"
"间 ``delta`` . 一旦 ``reset_timer`` 大于或等于 ``reset_TIME`` , 就把 "
"``global_transform`` 重置为 ``start_transform`` , 这样复位框就回到了初始位"
"置. 然后将 ``reset_timer`` 设置为 ``0`` ."

msgid ""
"The ``interact`` function simply reloads the ``Game.tscn`` scene using "
"``get_tree().change_scene``. This will reload the game scene, resetting "
"everything."
msgstr ""
"``interact`` 函数只是使用 ``get_tree().change_scene`` 重新加载 ``Game.tscn`` "
"场景, 这将重新加载游戏场景, 重置所有."

msgid ""
"Finally, the ``dropped`` function resets the ``global_transform`` to the "
"initial transform in ``start_transform`` so the reset box has its initial "
"position/rotation. Then ``reset_timer`` is set to ``0`` so the timer is "
"reset."
msgstr ""
"最后, ``dropped`` 函数将 ``global_transform`` 重设为 ``start_transform`` 中的"
"初始变换, 这样复位框就有了初始位置旋转. 然后将 ``reset_timer`` 设置为 "
"``0`` , 这样就复位了计时器."

msgid "Reset box finished"
msgstr "重置盒子完成"

msgid ""
"With that done, when you grab and interact with the reset box, the entire "
"scene will reset/restart and you can destroy all the targets again!"
msgstr ""
"完成这些后, 当你抓起复位盒并与之互动时, 整个场景将重置/重启, 你可以再次摧毁所"
"有的目标!"

msgid ""
"Resetting the scene abruptly without any sort of transition can lead to "
"discomfort in VR."
msgstr "在没有任何形式过渡的情况下, 突然重置场景会导致VR中的不适感."

msgid "Final notes"
msgstr "最后的笔记"

msgid "Whew! That was a lot of work."
msgstr "呼！ 工作量还不小."

msgid ""
"Now you have a fully working VR project with multiple different types of "
"special :ref:`RigidBody <class_RigidBody>`-based nodes that can be used and "
"extended. Hopefully this will help serve as an introduction to making fully-"
"featured VR games in Godot! The code and concepts detailed in this tutorial "
"can be expanded on to make puzzle games, action games, story-based games, "
"and more!"
msgstr ""
"现在你有一个完全可以工作的VR项目, 有多种不同类型的特殊 :ref:`RigidBody "
"<class_RigidBody>` 的节点可供使用和扩展. 希望这将有助于作为在Godot中制作功能"
"齐全的VR游戏, 本教程介绍中详述的代码和概念可以扩展到制作益智游戏, 动作游戏, "
"基于故事的游戏等!"

#, fuzzy
msgid ""
"You can download the finished project for this tutorial series on the "
"`OpenVR GitHub repository <https://github.com/GodotVR/godot_openvr_fps>`__, "
"under the releases tab!"
msgstr ""
"你可以在 `OpenVR GitHub 仓库 <https://github.com/GodotVR/"
"godot_openvr_fps>`_ , 所发布标签中下载本系列教程的成品项目!"
