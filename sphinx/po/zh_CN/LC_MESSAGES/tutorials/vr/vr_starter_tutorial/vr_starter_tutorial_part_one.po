# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-21 17:14+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "VR starter tutorial part 1"
msgstr "VR 入门教程第 1 部分"

msgid "Introduction"
msgstr "前言"

msgid ""
"This tutorial will show you how to make a beginner VR game project in Godot."
msgstr "本教程将告诉你如何在Godot中制作一个初级的VR游戏项目."

msgid ""
"Keep in mind, **one of the most important things when making VR content is "
"getting the scale of your assets correct**! It can take lots of practice and "
"iterations to get this right, but there are a few things you can do to make "
"it easier:"
msgstr ""
"请记住, **制作VR内容时最重要的事情之一是保证您的资源大小合适** ！ 这可以通过"
"大量练习和反复调整来实现这一目标, 但是您可以采取一些措施来简化这个过程:"

msgid ""
"In VR, 1 unit is typically considered 1 meter. If you design your assets "
"around that standard, you can save yourself a lot of headache."
msgstr ""
"在VR中,1个单位通常被认为是1米. 如果你围绕这个标准设计你的资产, 你可以为自己省"
"去很多麻烦."

msgid ""
"In your 3D modeling program, see if there is a way to measure and use real "
"world distances. In Blender, you can use the MeasureIt add-on; in Maya, you "
"can use the Measure Tool."
msgstr ""
"在你的三维建模程序中, 看看是否有办法测量和使用现实世界的距离. 在Blender中, 你"
"可以使用MeasureIt插件；在Maya中, 你可以使用测量工具."

#, fuzzy
msgid ""
"You can make rough models using a tool like `Google Blocks <https://vr."
"google.com/blocks/>`__, and then refine in another 3D modelling program."
msgstr ""
"您可以使用诸如 `Google Blocks <https://vr.google.com/blocks/>`_ 之类的工具制"
"作粗略模型, 然后在另一个3D建模程序中进行优化."

msgid ""
"Test often, as the assets can look dramatically different in VR than on a "
"flat screen!"
msgstr "经常测试, 因为VR中的资源看起来与平面屏幕上的显着不同！"

msgid "Throughout the course of this tutorial, we will cover:"
msgstr "在本教程的整个过程中, 我们将介绍:"

msgid "How to tell Godot to run in VR."
msgstr "如何让Godot以VR模式运行."

msgid ""
"How to make a teleportation locomotion system that uses the VR controllers."
msgstr "如何制作一个使用VR控制器的传送运动系统."

msgid ""
"How to make a artificial movement locomotion system that uses the VR "
"controllers."
msgstr "如何制作一个使用VR控制器的人工运动的运动系统."

msgid ""
"How to create a :ref:`RigidBody <class_RigidBody>`-based system that allows "
"for picking up, dropping, and throwing RigidBody nodes using the VR "
"controllers."
msgstr ""
"如何创建一个 :ref:`RigidBody <class_RigidBody>` 的系统, 允许使用VR控制器拿"
"起, 放下和投掷RigidBody节点."

msgid "How to create simple destroyable target."
msgstr "如何添加可销毁的目标."

msgid ""
"How to create some special :ref:`RigidBody <class_RigidBody>`-based objects "
"that can destroy the targets."
msgstr ""
"如何创建一些特殊的 :ref:`RigidBody <class_RigidBody>` 的对象, 可以摧毁目标."

#, fuzzy
msgid ""
"While this tutorial can be completed by beginners, it is highly advised to "
"complete :ref:`doc_your_first_2d_game`, if you are new to Godot and/or game "
"development."
msgstr ""
"虽然本教程可以由初学者完成, 但如果你是Godot和/或游戏开发的新手, 强烈建议你完"
"成 :ref:`doc_your_first_game` ."

msgid ""
"**Some experience with making 3D games is required** before going through "
"this tutorial series. This tutorial assumes you have experience with the "
"Godot editor, GDScript, and basic 3D game development. A OpenVR-ready "
"headset and two OpenVR-ready controllers are required."
msgstr ""
"**在通过本系列教程之前, 需要** 有一定的3D游戏制作经验. 本教程假设你有Godot编"
"辑器, GDScript和基本3D游戏开发的经验. 需要连接一个OpenVR耳机和两个OpenVR控制"
"器."

msgid ""
"This tutorial was written and tested using a Windows Mixed Reality headset "
"and controllers. This project has also been tested on the HTC Vive. Code "
"adjustments may be required for other VR Headsets, such as the Oculus Rift."
msgstr ""
"本教程是使用Windows混合现实头盔和控制器编写和测试的. 这个项目也在HTC Vive上进"
"行了测试. 对于其他VR头盔, 如Oculus Rift, 可能需要调整代码."

#, fuzzy
msgid ""
"The Godot project for this tutorial is found on the `OpenVR GitHub "
"repository <https://github.com/GodotVR/godot_openvr_fps>`__. The starter "
"assets for this tutorial can be found in the releases section on the GitHub "
"repository. The starter assets contain some 3D models, sounds, scripts, and "
"scenes that are configured for this tutorial."
msgstr ""
"本教程的Godot项目可以在 `OpenVR GitHub 仓库 <https://github.com/GodotVR/"
"godot_openvr_fps>`_ 找到. 本教程的启动素材可以在GitHub仓库的发布部分找到. 初"
"始素材包含一些3D模型, 声音, 脚本和为本教程配置的场景."

msgid "**Credits for the assets provided**:"
msgstr "**所提供资产的制作组** :"

#, fuzzy
msgid ""
"The sky panorama was created by `CGTuts <https://cgi.tutsplus.com/articles/"
"freebie-8-awesome-ocean-hdris--cg-5684>`__."
msgstr ""
"天空全景图是由 `CGTuts <https://cgi.tutsplus.com/articles/freebie-8-awesome-"
"ocean-hdris--cg-5684>`_ 创建的."

msgid "The font used is Titillium-Regular"
msgstr "使用的字体是Titillium-Regular"

msgid "The font is licensed under the SIL Open Font License, Version 1.1"
msgstr ""
"使用的字体是Titillium-Regular, 并根据SIL Open Font License 1.1版获得许可"

#, fuzzy
msgid ""
"The audio used are from several different sources, all downloaded from the "
"Sonniss #GameAudioGDC Bundle (`License PDF <https://sonniss.com/gdc-bundle-"
"license/>`__)"
msgstr ""
"使用的音频来自几个不同的来源, 都是从Sonniss #GameAudioGDC Bundle下载的"
"(`License PDF <https://sonniss.com/gdc-bundle-license/>`_)"

msgid ""
"The folders where the audio files are stored have the same name as folders "
"in the Sonniss audio bundle."
msgstr "存储音频文件的文件夹与Sonniss音频包中的文件夹名称相同."

#, fuzzy
msgid ""
"The OpenVR addon was created by `Bastiaan Olij <https://github.com/"
"BastiaanOlij>`__ and is released under the MIT license. It can be found both "
"on the `Godot Asset Library <https://godotengine.org/asset-library/"
"asset/150>`__ and on `GitHub <https://github.com/GodotVR/godot-openvr-"
"asset>`__. *3rd party code and libraries used in the OpenVR addon may be "
"under a different license.*"
msgstr ""
"OpenVR插件由 `Bastiaan Olij <https://github.com/BastiaanOlij>`_ 创建, 并在MIT"
"许可下发布. 可以在 `Godot 素材库 <https://godotengine.org/asset-library/"
"asset/150>`_ 和 `GitHub <https://github.com/GodotVR/godot-openvr-asset>`_ 上"
"找到. * OpenVR插件中使用的第三方代码和库可能具有不同的许可.*"

#, fuzzy
msgid ""
"The initial project, 3D models, and scripts were created by `TwistedTwigleg "
"<https://github.com/TwistedTwigleg>`__ and is released under the MIT license."
msgstr ""
"最初的项目, 3D模型和脚本由 `TwistedTwigleg <https://github.com/"
"TwistedTwigleg>`_ 创建, 并在MIT许可下发布."

#, fuzzy
msgid ""
"You can find the finished project on the `OpenVR GitHub repository <https://"
"github.com/GodotVR/godot_openvr_fps>`__."
msgstr ""
"你可以在 `OpenVR的GitHub 仓库 <https://github.com/GodotVR/"
"godot_openvr_fps>`_ 上找到这个完成的项目."

msgid "Getting everything ready"
msgstr "做好准备"

#, fuzzy
msgid ""
"If you have not already, go to the `OpenVR GitHub repository <https://github."
"com/GodotVR/godot_openvr_fps/releases/>`__ and download the \"Starter Assets"
"\" file from the releases. Once you have the starter assets downloaded, open "
"up the project in Godot."
msgstr ""
"如果你还没有下载, 请到 `OpenVR GitHub 仓库 <https://github.com/GodotVR/"
"godot_openvr_fps>`_ , 并从发布的版本中下载 \"Starter Assets \" 文件. 一旦你下"
"载了入门资产, 在Godot中打开项目."

msgid ""
"The starter assets are not required to use the scripts provided in this "
"tutorial. The starter assets include several premade scenes and scripts that "
"will be used throughout the tutorial."
msgstr ""
"使用本教程中提供的脚本不需要启动器资产. 初始资产包括几个预制场景和脚本, 将在"
"本教程中使用."

msgid ""
"When the project is first loaded, the Game.tscn scene will be opened. This "
"will be the main scene used for the tutorial. It includes several nodes and "
"scenes already placed throughout the scene, some background music, and "
"several GUI-related :ref:`MeshInstance <class_MeshInstance>` nodes."
msgstr ""
"当项目第一次加载时,Game.tscn场景将被打开. 这将是本教程使用的主要场景. 它包括"
"已经放置在整个场景中的几个节点和场景, 一些背景音乐, 以及几个与GUI相关的 :ref:"
"`MeshInstance <class_MeshInstance>` 节点."

msgid ""
"The GUI-related :ref:`MeshInstance <class_MeshInstance>` nodes already have "
"scripts attached to them. These scripts will set the texture of a :ref:"
"`Viewport <class_Viewport>` node to the albedo texture of the material of "
"the :ref:`MeshInstance <class_MeshInstance>` node. This is used to display "
"text within the VR project. Feel free to take a look at the script, ``GUI."
"gd``, if you want. We will not be going over how to to use :ref:`Viewport "
"<class_Viewport>` nodes for displaying UI on :ref:`MeshInstance "
"<class_MeshInstance>` nodes in this tutorial ."
msgstr ""
"与GUI相关的 :ref:`MeshInstance <class_MeshInstance>` 节点已经有脚本附加在它们"
"身上. 这些脚本将把 :ref:`Viewport <class_Viewport>` 节点的纹理设置为 :ref:"
"`MeshInstance <class_MeshInstance>` 节点的材质的反射纹理. 这被用来在VR项目中"
"显示文本. 如果你想的话, 可以看一下这个脚本, ``GUI.gd`` . 在本教程中, 我们不会"
"讨论如何使用 :ref:`Viewport <class_Viewport>` 节点在 :ref:`MeshInstance "
"<class_MeshInstance>` 节点上显示用户界面."

msgid ""
"If you are interested in how to use :ref:`Viewport <class_Viewport>` nodes "
"for displaying UI on :ref:`MeshInstance <class_MeshInstance>` nodes, see "
"the :ref:`doc_viewport_as_texture` tutorial. It covers how to use a :ref:"
"`Viewport <class_Viewport>` as a render texture, along with how to apply "
"that texture onto a :ref:`MeshInstance <class_MeshInstance>` node."
msgstr ""
"如果您对如何使用 :ref:`Viewport <class_Viewport>` 节点在 :ref:`MeshInstance "
"<class_MeshInstance>` 节点上显示 UI 感兴趣, 请参阅 :ref:"
"`doc_viewport_as_texture` 教程. 它涵盖了如何使用 :ref:`Viewport "
"<class_Viewport>` 作为渲染纹理, 以及如何将该纹理应用到 :ref:`MeshInstance "
"<class_MeshInstance>` 节点上."

msgid ""
"Before we jump into the tutorial, let's take a moment to talk about how the "
"nodes used for VR work."
msgstr "在我们进入教程之前, 让我们花点时间谈谈用于VR的节点如何工作."

msgid ""
"The :ref:`ARVROrigin <class_ARVROrigin>` node is the center point of the VR "
"tracking system. The position of the :ref:`ARVROrigin <class_ARVROrigin>` is "
"the position the VR system considers the 'center' point on the floor. The :"
"ref:`ARVROrigin <class_ARVROrigin>` has a `world scale` property that "
"effects the size of the user within the VR scene. For this tutorial, it is "
"set to `1.4`, as the world was originally just a tad to big. As mentioned "
"earlier, keeping the scale relatively consistent is important in VR."
msgstr ""
":ref:`ARVROrigin <class_ARVROrigin>` 节点是VR跟踪系统的中心点. :ref:"
"`ARVROrigin <class_ARVROrigin>` 的位置是VR系统认为的 \"中心\" 点在地面上的位"
"置. :ref:`ARVROrigin <class_ARVROrigin>` 有一个 `世界缩放` 属性, 影响用户在VR"
"场景中的大小. 在本教程中, 它被设置为 `1.4` , 因为世界本来就有点大. 如前所述, "
"在VR中保持比例相对一致是很重要的."

msgid ""
"The :ref:`ARVRCamera <class_ARVRCamera>` is the player's headset and view "
"into the scene. The :ref:`ARVRCamera <class_ARVRCamera>` is offset on the Y "
"axis by the VR user's height, which will be important later when we add "
"teleportation locomotoin. If the VR system supports room tracking, then the :"
"ref:`ARVRCamera <class_ARVRCamera>` will move as the player moves. This "
"means that the :ref:`ARVRCamera <class_ARVRCamera>` is not guaranteed to be "
"in the same position as the :ref:`ARVROrigin <class_ARVROrigin>` node."
msgstr ""
":ref:`ARVRCamera <class_ARVRCamera>` 是玩家的头显和进入场景的视角. :ref:"
"`ARVRCamera <class_ARVRCamera>` 在Y轴上的偏移量为VR用户的身高, 这在后面我们添"
"加传送定位时很重要. 如果VR系统支持房间追踪, 那么 :ref:`ARVRCamera "
"<class_ARVRCamera>` 将随着玩家的移动而移动. 这意味着 :ref:`ARVRCamera "
"<class_ARVRCamera>` 并不能保证与 :ref:`ARVROrigin <class_ARVROrigin>` 节点处"
"于同一位置."

msgid ""
"The :ref:`ARVRController <class_ARVRController>` node represents a VR "
"controller. The :ref:`ARVRController <class_ARVRController>` will follow the "
"position and rotation of the VR controller relative to the :ref:`ARVROrigin "
"<class_ARVROrigin>` node. All of the input for the VR controllers happens "
"through the :ref:`ARVRController <class_ARVRController>` node. An :ref:"
"`ARVRController <class_ARVRController>` node with an ``ID`` of ``1`` "
"represents the left VR controller, while an :ref:`ARVRController "
"<class_ARVRController>` controller with an ``ID`` of ``2`` represents the "
"right VR controller."
msgstr ""
":ref:`ARVRController <class_ARVRController>` 节点代表一个VR控制器. :ref:"
"`ARVRController <class_ARVRController>` 将跟随VR控制器相对于 :ref:"
"`ARVROrigin <class_ARVROrigin>` 节点的位置和旋转. 所有的VR控制器的输入都是通"
"过 :ref:`ARVRController <class_ARVRController>` 节点进行的. 一个 :ref:"
"`ARVRController <class_ARVRController>` 节点的 ``ID`` 为 ``1`` , 代表左边的VR"
"控制器, 而一个 :ref:`ARVRController <class_ARVRController>` 控制器的 ``ID`` "
"为 ``2`` , 代表右边的VR控制器."

msgid "To summarize:"
msgstr "总而言之:"

msgid ""
"The :ref:`ARVROrigin <class_ARVROrigin>` node is the center of the VR "
"tracking system and is positioned on the floor."
msgstr ""
":ref:`ARVROrigin <class_ARVROrigin>` -节点是VR跟踪系统的中心, 位于地面上."

msgid ""
"The :ref:`ARVRCamera <class_ARVRCamera>` is the player's VR headset and view "
"into the scene."
msgstr ""
":ref:`ARVRCamera <class_ARVRCamera>` -是玩家的VR头戴式设备, 同时提供了场景的"
"视图."

msgid ""
"The :ref:`ARVRCamera <class_ARVRCamera>` node is offset on the Y axis by the "
"user's height."
msgstr ":ref:`ARVRCamera <class_ARVRCamera>` 节点在Y轴上的偏移量为用户的高度."

msgid ""
"If the VR system supports room tracking, then the :ref:`ARVRCamera "
"<class_ARVRCamera>` node may be offset on the X and Z axes as the player "
"moves."
msgstr ""
"如果VR系统支持房间跟踪, 那么 :ref:`ARVRCamera <class_ARVRCamera>` 节点可能会"
"在玩家移动时在X轴和Z轴上偏移."

msgid ""
"The :ref:`ARVRController <class_ARVRController>` nodes represent the VR "
"controllers and handle all of the input from the VR controllers."
msgstr ""
":ref:`ARVRController <class_ARVRController>` - 节点代表VR控制器并处理来自VR控"
"制器的所有输入."

msgid "Starting VR"
msgstr "启动 VR"

msgid ""
"Now that we have gone over the VR nodes, let's start working on the project. "
"While in ``Game.tscn``, select the ``Game`` node and make a new script "
"called ``Game.gd``. In the ``Game.gd`` file, add the following code:"
msgstr ""
"现在我们已经看过了VR节点, 让我们开始在项目中工作. 在 ``Game.tscn`` 中, 选择 "
"``Game`` 节点, 制作一个新的脚本, 名为 ``Game.gd`` . 在 ``Game.gd`` 文件中, 添"
"加以下代码:"

msgid "Let's go over what this code does."
msgstr "让我们回顾一下这段代码的作用."

msgid ""
"In the ``_ready`` function, we first get the OpenVR VR interface using the "
"``find_interface`` function in the :ref:`ARVRServer <class_ARVRServer>` and "
"assign it to a variable called `VR`. If the :ref:`ARVRServer "
"<class_ARVRServer>` finds an interface with the name OpenVR, it will return "
"it, otherwise it will return ``null``."
msgstr ""
"在 ``_ready`` 函数中, 我们首先使用 :ref:`ARVRServer <class_ARVRServer>` 中的 "
"``find_interface`` 函数获取OpenVR VR接口, 并将其分配给一个名为 `VR` 的变量. "
"如果 :ref:`ARVRServer <class_ARVRServer>` 找到一个名称为OpenVR的接口, 就会返"
"回, 否则就会返回 ``null``."

#, fuzzy
msgid ""
"The OpenVR VR interface is not included with Godot by default. You will need "
"to download the OpenVR asset from the `Asset Library <https://godotengine."
"org/asset-library/asset/150>`__ or `GitHub <https://github.com/GodotVR/godot-"
"openvr-asset>`__."
msgstr ""
"OpenVR的VR界面默认不包括在Godot中. 你需要从 `Asset Library <https://"
"godotengine.org/asset-library/asset/150>`_ 或 `GitHub <https://github.com/"
"GodotVR/godot-openvr-asset>`_ 下载OpenVR资产."

msgid ""
"The code then combines two conditionals, one to check if the `VR` variable "
"is NOT null (``if VR``) and another calls the initialize function, which "
"returns a boolean based on whether the OpenVR interface was able to "
"initialize or not. If both of these conditionals return true, then we can "
"turn the main Godot :ref:`Viewport <class_Viewport>` into an ARVR viewport."
msgstr ""
"然后, 这段代码结合了两个条件, 一个是检查 `VR` 变量是否为NOT空(``if VR``), 另"
"一个是调用initialize函数, 根据OpenVR接口是否能够初始化, 返回一个布尔值. 如果"
"这两个条件都返回true, 那么我们就可以把主Godot :ref:`Viewport "
"<class_Viewport>` 变成一个ARVR Viewport视图."

msgid ""
"If the VR interface initialized successfully, we then get the root :ref:"
"`Viewport <class_Viewport>` and set the `arvr` property to ``true``. This "
"will tell Godot to use the initialized ARVR interface to drive the :ref:"
"`Viewport <class_Viewport>` display."
msgstr ""
"如果VR接口初始化成功, 我们就得到根 :ref:`Viewport <class_Viewport>` , 并将 "
"`arvr` 属性设置为 ``true`` . 这将告诉Godot使用初始化的ARVR接口来驱动 :ref:"
"`Viewport <class_Viewport>` 的显示."

msgid ""
"Finally, we disable VSync so the Frames Per Second (FPS) is not capped by "
"the computer monitor. After this we tell Godot to render at ``90`` frames "
"per second, which is the standard for most VR headsets. Without disabling "
"VSync, the normal computer monitor may limit the frame rate of the VR "
"headset to the frame rate of the computer monitor."
msgstr ""
"最后, 我们禁用VSync, 这样每秒帧数(FPS)就不会被电脑显示器限制. 之后我们告诉"
"Godot以每秒 ``90`` 帧的速度渲染, 这是大多数VR头显的标准. 如果不禁用VSync, 普"
"通电脑显示器可能会将VR头显的帧率限制在电脑显示器的帧率上."

msgid ""
"In the project settings, under the ``Physics->Common`` tab, the physics FPS "
"has been set to ``90``. This makes the physics engine run at the same frame "
"rate as the VR display, which makes physics reactions look smoother when in "
"VR."
msgstr ""
"在项目设置中, 在 ``Physics->Common`` 标签下, 物理FPS已经被设置为 ``90`` . 这"
"使得物理引擎以与VR显示器相同的帧率运行, 使得物理反应在VR中看起来更加平滑."

msgid ""
"That is all we need to do for Godot to launch OpenVR within the project! Go "
"ahead and give it a try if you want. Assuming everything works, you will be "
"able to look around the world. If you have a VR headset with room tracking, "
"then you will be able to move around the scene within the limits of the room "
"tracking."
msgstr ""
"这就是我们需要为Godot在项目中启动OpenVR所做的全部工作, 如果你想的话, 就去试一"
"试吧. 假设一切正常, 你将能够环视这个世界. 如果你有一个带有房间追踪功能的VR头"
"盔, 那么你将能够在房间追踪范围内在场景中移动."

msgid "Creating the controllers"
msgstr "创建控制器"

msgid ""
"Right now all that the VR user can do is stand around, which isn't really "
"what we are going for unless we are working on a VR film. Lets write the "
"code for the VR controllers. We are going to write all the code for the VR "
"controllers in one go, so the code is rather long. That said, once we are "
"finished you will be able to teleport around the scene, artificially move "
"using the touchpad/joystick on the VR controller, and be able to pick up, "
"drop, and throw :ref:`RigidBody <class_RigidBody>`-based nodes."
msgstr ""
"现在,VR用户能做的就是站在周围, 这并不是真正要做的, 除非正在制作一部VR电影. 来"
"编写VR控制器的代码. 要一次性写完所有VR控制器的代码, 所以代码比较长. 也就是"
"说, 一旦我们完成了, 你将能够在场景中进行传送, 使用VR控制器上的触摸板/操纵杆进"
"行人工移动, 并且能够拾取, 丢弃和抛出 :ref:`RigidBody <class_RigidBody>` 类型"
"节点."

msgid ""
"First we need to open the scene used for the VR controllers. "
"``Left_Controller.tscn`` or ``Right_Controller.tscn``. Let's briefly go over "
"how the scene is setup."
msgstr ""
"首先需要打开VR控制器使用的场景, ``Left_Controller.tscn`` 或者 "
"``Right_Controller.tscn``. 简单介绍一下场景是如何设置的."

msgid "How the VR controller scene is setup"
msgstr "如何设置VR控制器的场景"

msgid ""
"In both scenes the root node is a ARVRController node. The only difference "
"is that the ``Left_Controller`` scene has the ``Controller Id`` property set "
"to ``1`` while the ``Right_Controller`` has the ``Controller Id`` property "
"set to ``2``."
msgstr ""
"在这两个场景中, 根节点都是ARVRController节点, 唯一不同的是, "
"``Left_Controller`` 场景的 ``Controller Id`` 属性设置为 ``1``, 而 "
"``Right_Controller`` 的 ``Controller Id`` 属性设置为 ``2``."

msgid ""
"The :ref:`ARVRServer <class_ARVRServer>` attempts to use these two IDs for "
"the left and right VR controllers. For VR systems that support more than 2 "
"controllers/tracked-objects, these IDs may need adjusting."
msgstr ""
":ref:`ARVRServer <class_ARVRServer>` 试图将这两个ID用于左, 右VR控制器. 对于支"
"持2个以上控制器/跟踪对象的VR系统, 这些ID可能需要调整."

msgid ""
"Next is the ``Hand`` :ref:`MeshInstance <class_MeshInstance>` node. This "
"node is used to display the hand mesh that will be used when the VR "
"controller is not holding onto a :ref:`RigidBody <class_RigidBody>` node. "
"The hand in the ``Left_Controller`` scene is a left hand, while the hand on "
"the ``Right_Controller`` scene is a right hand."
msgstr ""
"接下来是 ``Hand`` :ref:`MeshInstance <class_MeshInstance>` 节点. 这个节点是用"
"来显示手部网格的, 当VR控制器没有握住一个 :ref:`RigidBody <class_RigidBody>` "
"节点时, 将使用这个节点. ``Left_Controller`` 场景中的手是左手, 而 "
"``Right_Controller`` 场景中的手是右手."

msgid ""
"The node named ``Raycast`` is a :ref:`Raycast <class_Raycast>` node that is "
"used for aiming where to teleport to when the VR controller is teleporting. "
"The length of the :ref:`Raycast <class_Raycast>` is set to ``-16`` on the Y "
"axis and is rotated so that it points out of the pointer finger of the hand. "
"The ``Raycast`` node has a single child node, ``Mesh``, that is a :ref:"
"`MeshInstance <class_MeshInstance>`. This is used for visually showing where "
"the teleportation :ref:`Raycast <class_Raycast>` is aiming."
msgstr ""
"名为 ``Raycast`` 的节点是一个 :ref:`Raycast <class_Raycast>` 节点, 用于VR控制"
"器传送时瞄准传送到哪里. :ref:`Raycast <class_Raycast>` 的长度在Y轴上设置为 "
"``-16``, 并旋转使其指向手的指针外. ``Raycast`` 节点有一个子节点, ``Mesh``, 是"
"一个 :ref:`MeshInstance <class_MeshInstance>`. 它用于直观地显示传送 :ref:"
"`Raycast <class_Raycast>` 的目标位置."

msgid ""
"The node named ``Area`` is a :ref:`Area <class_Area>` node will be used for "
"grabbing :ref:`RigidBody <class_RigidBody>`-based nodes when the VR "
"controller grab mode is set to ``AREA``. The ``Area`` node has a single "
"child node, ``CollisionShape``, that defines a sphere :ref:`CollisionShape "
"<class_CollisionShape>`. When the VR controller is not holding any objects "
"and the grab button is pressed, the first :ref:`RigidBody <class_RigidBody>`-"
"based node within the ``Area`` node will be picked up."
msgstr ""
"名为 ``Area`` 的节点是一个 :ref:`Area <class_Area>` 节点, 将用于在VR控制器抓"
"取模式设置为 ``AREA`` 时, 抓取基于 :ref:`RigidBody <class_RigidBody>` 的节"
"点. ``Area`` 节点有一个子节点 ``CollisionShape``, 定义了一个球体 :ref:"
"`CollisionShape <class_CollisionShape>`. 当VR控制器没有握住任何物体, 按下抓取"
"按钮时, 在 ``Area`` 节点内的第一个 :ref:`RigidBody <class_RigidBody>` 类型的"
"节点将被拾取."

msgid ""
"Next is a :ref:`Position3D <class_Position3D>` node called ``Grab_Pos``. "
"This is used to define the position that grabbed :ref:`RigidBody "
"<class_RigidBody>` nodes will follow then they are held by the VR controller."
msgstr ""
"接下来是一个名为 ``Grab_Pos`` 的 :ref:`Position3D <class_Position3D>` 节点. "
"这是用来定义抓取的 :ref:`RigidBody <class_RigidBody>` 节点跟随的位置, 它们被"
"VR控制器持有."

msgid ""
"A large :ref:`Area <class_Area>` node called ``Sleep_Area`` is used to "
"disable sleeping for any RigidBody nodes within its :ref:`CollisionShape "
"<class_CollisionShape>`, simple called ``CollisionShape``. This is needed "
"because if a :ref:`RigidBody <class_RigidBody>` node falls asleep, then the "
"VR controller will be unable to grab it. By using ``Sleep_Area``, we can "
"write code that makes any :ref:`RigidBody <class_RigidBody>` node within it "
"not able to sleep, therefore allowing the VR controller to grab it."
msgstr ""
"一个大的 :ref:`Area <class_Area>` 节点称为 ``Sleep_Area``, 用于禁止其 :ref:"
"`CollisionShape <class_CollisionShape>` 内的任何RigidBody节点休眠, 简称为 "
"``CollisionShape``. 之所以需要这样做, 是因为如果一个 :ref:`RigidBody "
"<class_RigidBody>` 节点陷入休眠, 那么VR控制器将无法抓住它. 通过使用 "
"``Sleep_Area``, 我们可以编写代码, 使其中的任何 :ref:`RigidBody "
"<class_RigidBody>` 节点无法进入休眠状态, 以允许VR控制器抓取它."

msgid ""
"An :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node called "
"``AudioStreamPlayer3D`` has a sound loaded that we will use when an object "
"has been picked up, dropped or thrown by the VR controller. While this is "
"not necessary for the functionality of the VR controller, it makes grabbing "
"and dropping objects feel more natural."
msgstr ""
"一个名为 \"AudioStreamPlayer3D <class_AudioStreamPlayer3D>\"的 :ref:"
"`AudioStreamPlayer3D<class_AudioStreamPlayer3D>` 节点加载了一个声音, 当一个物"
"体被VR控制器抓起, 掉落或抛出时, 我们将使用这个声音. 虽然这对于VR控制器的功能"
"来说并不是必须的, 但它让抓取和丢弃物体的感觉更加自然."

msgid ""
"Finally, the last nodes are the ``Grab_Cast`` node and it's only child node, "
"``Mesh``. The ``Grab_Cast`` node will be used for grabbing :ref:`RigidBody "
"<class_RigidBody>`-based nodes when the VR controller grab mode is set to "
"``RAYCAST``. This will allow the VR controller to grab objects that are just "
"slightly out of reach using a Raycast. The ``Mesh`` node is used for "
"visually showing where the teleportation :ref:`Raycast <class_Raycast>` is "
"aiming."
msgstr ""
"最后一个节点是 ``Grab_Cast`` 节点和它唯一的子节点 ``Mesh`` . 当VR控制器抓取模"
"式设置为 ``RAYCAST`` 时, ``Grab_Cast`` 节点将用于抓取 :ref:`RigidBody "
"<class_RigidBody>` 类型节点. 这将允许VR控制器使用Raycast来抓取那些稍微够不到"
"的物体. ``Mesh`` 节点用于直观地显示传送 :ref:`Raycast <class_Raycast>` 的目标"
"位置."

msgid ""
"That is a quick overview of how the VR controller scenes are setup, and how "
"we will be using the nodes to provide the functionality for them. Now that "
"we have looked at the VR controller scene, let's write the code that will "
"drive them."
msgstr ""
"这是对VR控制器场景如何设置的快速概述, 以及将如何使用节点为它们提供功能. 我们"
"已经看了VR控制器场景, 来编写驱动它们的代码."

msgid "The code for the VR controllers"
msgstr "VR控制器的代码"

msgid ""
"Select the root node of the scene, either ``Right_Controller`` or "
"``Left_Controller``, and make a new script called ``VR_Controller.gd``. Both "
"scenes will be using the same script, so it doesn't matter which you use "
"first. With ``VR_Controller.gd`` opened, add the following code:"
msgstr ""
"选择场景的根节点, ``Right_Controller`` 或 ``Left_Controller`` , 然后制作一个"
"新的脚本, 叫做 ``VR_Controller.gd`` . 两个场景将使用同一个脚本, 所以你先用哪"
"个并不重要. 打开 ``VR_Controller.gd`` , 添加以下代码:"

msgid ""
"You can copy and paste the code from this page directly into the script "
"editor."
msgstr "你可以直接将本页的代码复制并粘贴到脚本编辑器中."

msgid ""
"If you do this, all the code copied will be using spaces instead of tabs."
msgstr "如果这么做, 所有复制的代码将使用空格而不是制表符."

msgid ""
"To convert the spaces to tabs in the script editor, click the ``Edit`` menu "
"and select ``Convert Indent To Tabs``. This will convert all the spaces into "
"tabs. You can select ``Convert Indent To Spaces`` to convert tabs back into "
"spaces."
msgstr ""
"要在脚本编辑器中把空格转换成制表符, 请点击 ``Edit`` 菜单, 选择 ``Convert "
"Indent To Tabs`` 把缩进转换成制表符. 这将把所有的空格转换为制表符. 你可以选"
"择 ``Convert Indent To Spaces`` 来将制表符转换为空格."

msgid ""
"This is quite a bit of code to go through. Let's go through what the code "
"does step-by-step."
msgstr "这段代码挺多的, 让我们一步步来看看这段代码的作用."

msgid "Explaining the VR controller code"
msgstr "解释VR控制器的代码"

msgid "First, let's go through all the class variables in the script:"
msgstr "首先, 让我们浏览一下脚本中所有的类变量:"

msgid ""
"``controller_velocity``: A variable to hold a rough approximation of the VR "
"controller's velocity."
msgstr "``controller_velocity``: 一个变量, 用于保存VR控制器速度的近似值."

msgid ""
"``prior_controller_position``: A variable to hold the VR controller's last "
"position in 3D space."
msgstr ""
"``prior_controller_position``: 一个变量, 用于保存VR控制器在3D空间中的最后位"
"置."

msgid ""
"``prior_controller_velocities``: An Array to hold the last 30 calculated VR "
"controller velocities. This is used to smooth the velocity calculations over "
"time."
msgstr ""
"``prior_controller_velocities``: 一个数组, 用于保存最近30次计算的VR控制器的速"
"度. 这是用来平滑速度计算的时间."

msgid ""
"``held_object``: A variable to hold a reference to the object the VR "
"controller is holding. If the VR controller is not holding any objects, this "
"variable will be ``null``."
msgstr ""
"``held_object``: 一个变量, 用于保存VR控制器所持有的对象的引用, 如果VR控制器没"
"有持有任何对象, 这个变量将是 ``null``."

msgid ""
"``held_object_data``: A dictionary to hold data for the :ref:`RigidBody "
"<class_RigidBody>` node being held by the VR controller. This is used to "
"reset the :ref:`RigidBody <class_RigidBody>`'s data when it is no longer "
"held."
msgstr ""
"``held_object_data``: 一个字典, 用于保存VR控制器持有的 :ref:`RigidBody "
"<class_RigidBody>` 节点的数据. 当 :ref:`RigidBody <class_RigidBody>` 节点不再"
"被持有时, 用于重置该节点的数据."

msgid ""
"``grab_area``: A variable to hold the :ref:`Area <class_Area>` node used to "
"grab objects with the VR controller."
msgstr ""
"``grab_area``: 一个变量用来保存 :ref:`Area <class_Area>` 节点, 用于VR控制器抓"
"取物体."

msgid ""
"``grab_raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` node "
"used to grab objects with the VR controller."
msgstr ""
"``grab_raycast``: 一个变量用来保存 :ref:`Raycast <class_Raycast>` 节点, 用于"
"VR控制器抓取物体."

msgid ""
"``grab_mode``: A variable to define the grab mode the VR controller is "
"using. There are only two modes for grabbing objects in this tutorial, "
"``AREA`` and ``RAYCAST``."
msgstr ""
"``grab_mode``: 用于定义VR控制器使用的抓取模式的变量. 本教程中只有两种抓取对象"
"的模式, ``AREA`` 和 ``RAYCAST``."

msgid ""
"``grab_pos_node``: A variable to hold the node that will be used to update "
"the position and rotation of held objects."
msgstr ""
"``grab_pos_node``. 一个变量, 用于保存用于更新所持物体的位置和旋转的节点."

msgid ""
"``hand_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that contains the hand mesh for the VR "
"controller. This mesh will be shown when the VR controller is not holding "
"anything."
msgstr ""
"``hand_mesh``. 一个变量, 用于保存 :ref:`MeshInstance <class_MeshInstance>` 节"
"点, 其中包含VR控制器的手部网格. 当VR控制器没有拿着任何东西时, 这个网格将被显"
"示出来."

msgid ""
"``hand_pickup_drop_sound``: A variable to hold the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node that contains the pickup/drop sound."
msgstr ""
"``hand_pickup_drop_sound``: 一个变量, 用来保存包含拾取/放下声音的 :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` 节点."

msgid ""
"``teleport_pos``: A variable to hold the position the player will be "
"teleported to when the VR controller teleports the player."
msgstr ""
"``teleport_pos``: 一个变量, 用于在VR控制器传送玩家时保存玩家被传送到的位置."

msgid ""
"``teleport_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node used to show where the player is teleporting to."
msgstr ""
"``teleport_mesh``: 一个变量, 用来保存 :ref:`MeshInstance "
"<class_MeshInstance>` 节点, 用于显示玩家的传送位置."

msgid ""
"``teleport_button_down``: A variable used to track whether the controller's "
"teleport button is held down. This will be used to detect if this VR "
"controller is trying to teleport the player."
msgstr ""
"``teleport_button_down``: 一个变量, 用于跟踪控制器的传送按钮是否被按下. 这将"
"被用来检测这个VR控制器是否在试图传送玩家."

msgid ""
"``teleport_raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` "
"node used to calculate the teleport position. This node also has a :ref:"
"`MeshInstance <class_MeshInstance>` that acts as a 'laser sight' for aiming."
msgstr ""
"``teleport_raycast``: 一个变量, 用来保存 :ref:`Raycast <class_Raycast>` 节"
"点, 用来计算传送的位置. 这个节点也有一个 :ref:`MeshInstance "
"<class_MeshInstance>`, 作为瞄准的 \"激光瞄准器\"."

msgid ""
"``CONTROLLER_DEADZONE``: A constant to define the deadzone for both the "
"trackpad and the joystick on the VR controller. See the note below for more "
"information."
msgstr ""
"``CONTROLLER_DEADZONE``: 一个常数, 用于定义VR控制器上的触控板和操纵杆的死区. "
"更多信息请参见下面的说明."

msgid ""
"``MOVEMENT_SPEED``: A constant to define the speed the player moves at when "
"using the trackpad/joystick to move artificially."
msgstr ""
"``MOVEMENT_SPEED``: 一个常数, 用于定义玩家在使用触控板/操纵杆进行人工移动时的"
"移动速度."

msgid ""
"``CONTROLLER_RUMBLE_FADE_SPEED``: A constant to define how fast the VR "
"controller rumble fades."
msgstr ""
"``CONTROLLER_RUMBLE_FADE_SPEED``: 一个常数, 用于定义VR控制器隆隆声衰减的速度."

msgid ""
"``directional_movement``: A variable to hold whether this VR controller is "
"moving the player using the touchpad/joystick."
msgstr ""
"``directional_movement`` : 一个变量, 用于保持该VR控制器是否使用触摸板/操纵杆"
"移动玩家."

msgid ""
"You can find a great article explaining all about how to handle touchpad/"
"joystick dead zones `here <https://web.archive.org/web/20191208161810/http://"
"www.third-helix.com/2013/04/12/doing-thumbstick-dead-zones-right.html>`__."
msgstr ""
"您可以在这里找到一篇很棒的文章解释如何处理游戏手柄/控制器死区 `这里 <https://"
"web.archive.org/web/20191208161810/http://www.third-helix.com/2013/04/12/"
"doing-thumbstick-dead-zones-right.html>`__."

msgid ""
"We are using a translated version of the scaled radial dead zone code "
"provided in that article for the VR controller's joystick/touchpad. The "
"article is a great read, and I highly suggest giving it a look!"
msgstr ""
"我们正在使用该文章中所提供的缩放比例的径向盲区代码的翻译版本, 用于VR控制器的"
"操纵杆/触摸板. 这篇文章读起来很棒, 我强烈建议您看一下！"

msgid ""
"That is quite a few class variables. Most of them are used to hold "
"references to nodes we will need throughout the code. Next let's start "
"looking at the functions, starting with the ``_ready`` function."
msgstr ""
"这是相当多的类变量. 它们中的大部分都是用来保存在整个代码中需要的节点的引用. "
"接下来我们开始查看函数, 从 ``_ready`` 函数开始."

msgid "``_ready`` function step-by-step explanation"
msgstr "``_ready`` 函数的逐步说明"

msgid ""
"First we tell Godot to silence the warnings about not using the values "
"returned by the ``connect`` function. We will not need the returned values "
"for this tutorial."
msgstr ""
"首先, 我们告诉Godot关闭关于不使用 ``connect`` 函数返回值的警告, 在本教程中, "
"将不需要返回值."

msgid ""
"Next we get the :ref:`Raycast <class_Raycast>` node we are going to use for "
"determining the position for teleporting and assign it to the "
"``teleport_raycast`` variable. We then get the :ref:`MeshInstance "
"<class_MeshInstance>` node that we will use to show where the player will be "
"teleporting to. The node we are using for teleporting is a child of the "
"``Game`` scene. We do this so the teleport mesh node is not effected by "
"changes in the VR controller, and so the teleport mesh can be used by both "
"VR controllers."
msgstr ""
"接下来我们获得 :ref:`Raycast <class_Raycast>` 节点, 将使用它来确定传送的位"
"置, 并将其分配给 ``teleport_raycast`` 变量. 然后我们获得 :ref:`MeshInstance "
"<class_MeshInstance>` 节点, 用其显示玩家被传送到哪里. 我们用来传送的节点是 "
"``Game`` 场景的一个子节点, 这样做是为了让传送网格节点不受VR控制器变化的影响, "
"传送网格可以被两个VR控制器使用."

msgid ""
"Then the ``teleport_button_down`` variable is set to false, ``teleport_mesh."
"visible`` is set to ``false``, and ``teleport_raycast.visible`` is set to "
"``false``. This sets up the variables for teleporting the player into their "
"initial, not teleporting the player, state."
msgstr ""
"然后将 ``teleport_button_down`` 变量设置为false, ``teleport_mesh.visible`` 设"
"置为 ``false`` , ``teleport_raycast.visible`` 设置为 ``false`` , 这样就设置了"
"传送玩家进入初始状态, 而不是传送玩家的变量."

msgid ""
"The code then gets the ``grab_area`` node, the ``grab_raycast`` node, and "
"the ``grab_pos_node`` node and assigns them all to their respective "
"variables for use later."
msgstr ""
"然后, 代码获取 ``grab_area`` 节点, ``grab_raycast`` 节点和 ``grab_pos_node`` "
"节点, 并将它们全部分配给各自的变量, 以供以后使用."

msgid ""
"Next the ``grab_mode`` is set to ``AREA`` so the VR controller will attempt "
"to grab objects using the :ref:`Area <class_Area>` node defined in "
"``grab_area`` when the VR controller's grab/grip button is pressed. We also "
"set the ``grab_raycast`` node's ``visible`` property to ``false`` so the "
"'laser sight' child node of ``grab_raycast`` is not visible."
msgstr ""
"接下来将 ``grab_mode`` 设置为 ``AREA`` , 这样VR 控制器将尝试在按下 VR 控制器"
"的抓取/握持按钮时使用 ``grab_area`` 中定义的 :ref:`区域(Area) <class_Area>` "
"节点抓取对象. 我们还将 ``grab_raycast`` 节点的 ``visible`` 属性设置为 "
"``false`` , 这样 ``grab_raycast`` 的 ‘激光瞄准器(laser sight)’子节点就不可见"
"了."

msgid ""
"After that we connect the ``body_entered`` and ``body_exited`` signals from "
"the ``Sleep_Area`` node in the VR controller to the ``sleep_area_entered`` "
"and ``sleep_area_exited`` functions. The ``sleep_area_entered`` and "
"``sleep_area_exited`` functions will be used to make :ref:`RigidBody "
"<class_RigidBody>` nodes unable to sleep when nearby the VR controller."
msgstr ""
"之后我们将VR控制器中的 ``Sleep_Area`` 节点的 ``body_entered`` 和 "
"``body_exited`` 信号连接到 ``sleep_area_entered`` 和 ``sleep_area_exited`` 函"
"数中. ``sleep_area_entered`` 和 ``sleep_area_exited`` 函数将用于使 :ref:"
"`RigidBody <class_RigidBody>` 节点在 VR 控制器附近时无法休眠."

msgid ""
"Then the ``hand_mesh`` and ``hand_pickup_drop_sound`` nodes are gotten and "
"assigned them to their respective variables for use later."
msgstr ""
"然后得到 ``hand_mesh`` 和 ``hand_pickup_drop_sound`` 节点, 并将它们分配给各自"
"的变量, 以便以后使用."

msgid ""
"Finally, the ``button_pressed`` and ``button_release`` signals in the :ref:"
"`ARVRController <class_ARVRController>` node, which the VR controller "
"extends, are connected to the ``button_pressed`` and ``button_released`` "
"functions respectively. This means that when a button on the VR controller "
"is pressed or released, the ``button_pressed`` or ``button_released`` "
"functions defined in this script will be called."
msgstr ""
"最后,VR控制器扩展的 :ref:`ARVRController <class_ARVRController>` 节点中的 "
"``button_pressed`` 和 ``button_release`` 信号分别与 ``button_pressed`` 和 "
"``button_released`` 函数相连. 这意味着当VR控制器上的某个按钮被按下或释放时, "
"本脚本中定义的 \"button_pressed\" 或 \"button_released\" 函数将被调用."

msgid "``_physics_process`` function step-by-step explanation"
msgstr "``_physics_process`` 函数分步说明"

msgid ""
"First we check to see if the ``rumble`` variable is more than zero. If the "
"``rumble`` variable, which is a property of the :ref:`ARVRController "
"<class_ARVRController>` node, is more than zero then the VR controller "
"rumbles."
msgstr ""
"首先我们检查 ``rumble`` 变量是否大于零. 如果 ``rumble`` 变量, 也就是 :ref:"
"`ARVRController <class_ARVRController>` 节点的一个属性, 大于零, 那么VR控制器"
"就会发出隆隆声."

msgid ""
"If the ``rumble`` variable is more than zero, then we reduce the rumble by "
"``CONTROLLER_RUMBLE_FADE_SPEED`` every second by subtracting "
"``CONTROLLER_RUMBLE_FADE_SPEED`` multiplied by delta. There is then a ``if`` "
"condition to check if ``rumble`` is less than zero, which sets ``rumble`` to "
"zero if its value is less than zero."
msgstr ""
"如果 ``rumble`` 变量大于零, 那么我们每隔一秒用 "
"``CONTROLLER_RUMBLE_FADE_SPEED`` 减去 ``CONTROLLER_RUMBLE_FADE_SPEED`` 乘以"
"delta, 就可以减少 ``rumble`` . 然后有一个 ``if`` 条件来检查 ``rumble`` 是否小"
"于零, 如果其值小于零, 则将 ``rumble`` 设置为零."

msgid ""
"This small section of code is all we need for reducing the VR controller's "
"rumble. Now when we set ``rumble`` to a value, this code will automatically "
"make it fade over time."
msgstr ""
"这一小段代码是我们减少VR控制器的隆隆声所需要的全部内容. 现在, 当我们将 "
"``rumble`` 设置为一个值时, 这段代码将自动使其随着时间的推移而逐渐消失."

msgid ""
"The first section of code checks to see if the ``teleport_button_down`` "
"variable is equal to ``true``, which means this VR controller is trying to "
"teleport."
msgstr ""
"第一段代码检查 ``teleport_button_down`` 变量是否等于 ``true``, 这意味着这个VR"
"控制器正在尝试传送."

msgid ""
"If ``teleport_button_down`` is equal to ``true``, we force the "
"``teleport_raycast`` :ref:`Raycast <class_Raycast>` node to update using the "
"``force_raycast_update`` function. The ``force_raycast_update`` function "
"will update the properties within the :ref:`Raycast <class_Raycast>` node "
"with the latest version of the physics world."
msgstr ""
"如果 ``teleport_button_down`` 等于 ``true`` , 我们将使用 "
"``force_raycast_update`` 函数强制更新 ``teleport_raycast`` :ref:`Raycast "
"<class_Raycast>` 节点. ``force_raycast_update`` 函数将用物理世界的最新版本更"
"新 :ref:`Raycast <class_Raycast>` 节点内的属性."

msgid ""
"The code then checks to see if the ``teleport_raycast`` collided with "
"anything by checking of the ``is_colliding`` function in "
"``teleport_raycast`` is true. If the :ref:`Raycast <class_Raycast>` collided "
"with something, we then check to see if the :ref:`PhysicsBody "
"<class_PhysicsBody>` the raycast collided with is a :ref:`StaticBody "
"<class_StaticBody>` or not. We then check to see if the collision normal "
"vector returned by the raycast is greater than or equal to ``0.85`` on the Y "
"axis."
msgstr ""
"这段代码通过检查 ``teleport_raycast`` 中的 ``is_colliding`` 函数是否为真，来"
"检查 ``teleport_raycast`` 是否与任何东西相撞。如果该 :ref:`Raycast "
"<class_Raycast>` 与某物相撞，我们就检查与 Raycast 相撞的 :ref:`PhysicsBody "
"<class_PhysicsBody>` 是否为 :ref:`StaticBody <class_StaticBody>`。然后我们检"
"查射线返回的碰撞法向量在 Y 轴上是否大于等于 ``0.85``\\ 。"

msgid ""
"We do this because we do not want the user to be able to teleport onto "
"RigidBody nodes and we only want the player to be able to teleport on floor-"
"like surfaces."
msgstr ""
"我们这样做是因为我们不希望用户能够传送到RigidBody节点上, 我们只希望玩家能够在"
"类似地板的表面进行传送."

msgid ""
"If all these conditions are met, then we assign the ``teleport_pos`` "
"variable to the ``get_collision_point`` function in ``teleport_raycast``. "
"This will assign ``teleport_pos`` to the position the raycast collided at in "
"world space. We then move the ``teleport_mesh`` to the world position stored "
"in ``teleport_pos``."
msgstr ""
"如果所有这些条件都得到满足, 那么我们就将 ``teleport_pos`` 变量分配给 "
"``teleport_raycast`` 中的 ``get_collision_point`` 函数. 这将把 "
"``teleport_pos`` 分配给射线广播在世界空间中碰撞的位置. 然后我们将 "
"``teleport_mesh`` 移动到 ``teleport_pos`` 中存储的世界位置."

msgid ""
"This section of code will get the position the player is aiming at with the "
"teleportation raycast and update the teleportation mesh, giving a visual "
"update on where the user will be teleporting to when the release the "
"teleport button."
msgstr ""
"这段代码将通过传送射线广播获得玩家瞄准的位置, 并更新传送网, 在释放传送按钮"
"时, 直观地更新用户将传送到哪里."

msgid ""
"The next section of code first checks to see if the VR controller is active "
"through the ``get_is_active`` function, which is defined by :ref:"
"`ARVRController <class_ARVRController>`. If the VR controller is active, "
"then it calls the ``_physics_process_update_controller_velocity`` function."
msgstr ""
"下一节代码首先通过 ``get_is_active`` 函数检查VR控制器是否处于活动状态, 该函数"
"由 :ref:`ARVRController <class_ARVRController>` 定义. 如果VR控制器是活动的, "
"那么它就会调用 ``_physics_process_update_controller_velocity`` 函数."

msgid ""
"The ``_physics_process_update_controller_velocity`` function will calculate "
"the VR controller's velocity through changes in position. It is not perfect, "
"but this process gets a rough idea of the velocity of the VR controller, "
"which is fine for the purposes of this tutorial."
msgstr ""
"``_physics_process_update_controller_velocity`` 函数将通过位置的变化来计算VR"
"控制器的速度. 它并不完美, 但这个过程可以得到VR控制器的速度的一个大致概念, 对"
"于本教程的目的来说, 这是很好的."

msgid ""
"The next section of code checks to see if the VR controller is holding an "
"object by checking to see if the ``held_object`` variable is not equal to "
"``null``."
msgstr ""
"下一段代码通过检查 ``held_object`` 变量是否不等于 ``null`` 来检查VR控制器是否"
"持有一个对象."

msgid ""
"If the VR controller is holding an object, we first store it's scale in a "
"temporary variable called ``held_scale``. We then set the "
"``global_transform`` of the held object to the ``global_transform`` of the "
"``held_object`` node. This will make the held object have the same position, "
"rotation, and scale of the ``grab_pos_node`` node in world space."
msgstr ""
"如果VR控制器持有一个对象, 我们首先将它的比例存储在一个名为 ``held_scale`` 的"
"临时变量中. 然后我们将持有对象的 ``global_transform`` 设置为 ``held_object`` "
"节点的 ``global_transform``. 这将使持有的对象在世界空间中具有与 "
"``grab_pos_node`` 节点相同的位置, 旋转和比例."

msgid ""
"However, because we do not want the held object to change in scale when it "
"is grabbed, we need to set the ``scale`` property of the ``held_object`` "
"node back to ``held_scale``."
msgstr ""
"但是, 由于我们不希望被抓取的对象在被抓取时的比例发生变化, 我们需要将 "
"``held_object`` 节点的 ``scale`` 属性设置为 ``held_scale``."

msgid ""
"This section of code will keep the held object in the same position and "
"rotation as the VR controller, keeping it synced with the VR controller."
msgstr ""
"这段代码将使持有的物体与VR控制器保持相同的位置和旋转, 使其与VR控制器保持同步."

msgid ""
"Finally, the last section of code simply calls the "
"``_physics_process_directional_movement`` function. This function contains "
"all the code for moving the player when the touchpad/joystick on the VR "
"controller moves."
msgstr ""
"最后, 最后一段代码只是简单地调用 ``_physics_process_directional_movement`` 函"
"数. 这个函数包含了当VR控制器上的触摸板/操纵杆移动时移动玩家的所有代码."

msgid ""
"``_physics_process_update_controller_velocity`` function step-by-step "
"explanation"
msgstr "``_physics_process_update_controller_velocity`` 函数步骤解释"

msgid ""
"First this function resets the ``controller_velocity`` variable to zero :ref:"
"`Vector3 <class_Vector3>`."
msgstr ""
"首先, 这个函数将 ``controller_velocity`` 变量重置为零 :ref:`Vector3 "
"<class_Vector3>` ."

msgid ""
"Then we check to see if there are any stored/cached VR controller velocities "
"saved in the ``prior_controller_velocities`` array. We do this by checking "
"to see if the ``size()`` function returns a value greater than ``0``. If "
"there are cached velocities within ``prior_controller_velocities``, then we "
"iterate through each of the stored velocities using a ``for`` loop."
msgstr ""
"然后我们检查是否有任何存储/缓存的VR控制器速度保存在 "
"``prior_controller_velocities`` 数组中. 我们通过检查 ``size()`` 函数是否返回"
"一个大于 ``0`` 的值. 如果在 ``prior_controller_velocities`` 中存在缓存的速"
"度, 那么我们就使用 ``for`` 循环对每个存储的速度进行迭代."

msgid ""
"For each of the cached velocities, we simply add its value to "
"``controller_velocity``. Once the code has gone through all of the cached "
"velocities in ``prior_controller_velocities``, we divide "
"``controller_velocity`` by the size of the ``prior_controller_velocities`` "
"array, which will give us the combined velocity value. This helps take the "
"previous velocities into account, making the direction of the controller's "
"velocity more accurate."
msgstr ""
"对于每一个缓存的速度, 我们只需将其值添加到 ``controller_velocity`` 中. 一旦代"
"码通过了 ``prior_controller_velocities`` 中的所有缓存速度, 我们将 "
"``controller_velocity`` 除以 ``prior_controller_velocities`` 数组的大小, 就会"
"得到综合速度值. 这有助于将之前的速度考虑在内, 使控制器的速度方向更加准确."

msgid ""
"Next we calculate the change in position the VR controller has taken since "
"the last ``_physics_process`` function call. We do this by subtracting "
"``prior_controller_position`` from the global position of the VR controller, "
"``global_transform.origin``. This will give us a :ref:`Vector3 "
"<class_Vector3>` that points from the position in "
"``prior_controller_position`` to the current position of the VR controller, "
"which we store in a variable called ``relative_controller_position``."
msgstr ""
"接下来我们计算VR控制器自上次 ``_physics_process`` 函数调用后的位置变化. 我们"
"通过从VR控制器的全局位置 ``global_transform.origin`` 中减去 "
"``prior_controller_position`` 来计算. 这将给我们一个 :ref:`Vector3 "
"<class_Vector3>` 从 ``prior_controller_position`` 中的位置指向VR控制器的当前"
"位置, 我们将其存储在一个名为 ``relative_controller_position`` 的变量中."

msgid ""
"Next we add the change in position to ``controller_velocity`` so the latest "
"change in position is taken into account in the velocity calculation. We "
"then add ``relative_controller_position`` to ``prior_controller_velocities`` "
"so it can be taken into account on the next calculation of the VR "
"controller's velocity."
msgstr ""
"接下来我们将位置的变化添加到 ``controller_velocity`` 中, 这样在计算速度时就会"
"考虑到最新的位置变化. 然后我们将 ``relative_controller_position`` 添加到 "
"``prior_controller_velocities`` 中, 这样在下一次计算VR控制器的速度时就可以将"
"其考虑进去."

msgid ""
"Then ``prior_controller_position`` is updated with the global position of "
"the VR controller, ``global_transform.origin``. We then divide "
"``controller_velocity`` by ``delta`` so the velocity is higher, giving "
"results like those we expect, while still being relative to the amount of "
"time that has passed. It is not a perfect solution, but the results look "
"decent most of the time and for the purposes of this tutorial, it is good "
"enough."
msgstr ""
"然后 ``prior_controller_position`` 用VR控制器的全局位置 ``global_transform."
"origin`` 更新. 然后我们将 ``controller_velocity`` 除以 ``delta``, 这样速度就"
"会更高, 得到的结果就像我们期望的那样, 同时还是相对于已经过去的时间量. 这不是"
"一个完美的解决方案, 但大多数时候结果看起来还不错, 就本教程而言, 这已经足够了."

msgid ""
"Finally, the function checks to see if the ``prior_controller_velocities`` "
"has more than ``30`` velocities cached by checking if the ``size()`` "
"function returns a value greater than ``30``. If there are more than ``30`` "
"cached velocities stored in ``prior_controller_velocities``, then we simply "
"remove the oldest cached velocity by calling the ``remove`` function and "
"passing in a index position of ``0``."
msgstr ""
"后, 函数检查 ``prior_controller_velocities`` 是否有超过 ``30`` 的速度缓存, 检"
"查 ``size()`` 函数是否返回一个大于 ``30`` 的值. 如果在 "
"``prior_controller_velocities`` 中存储了超过 ``30`` 的缓存速度, 那么我们只需"
"通过调用 ``remove`` 函数并传递一个 ``0`` 的索引位置来删除最老的缓存速度."

msgid ""
"What this function ultimately does is that it gets a rough idea of the VR "
"controller's velocity by calculating the VR controller's relative changes in "
"position over the last thirty ``_physics_process`` calls. While this is not "
"perfect, it gives a decent idea of how fast the VR controller is moving in "
"3D space."
msgstr ""
"这个函数最终要做的是通过计算VR控制器在过去三十次 ``_physics_process`` 的相对"
"位置变化, 得到VR控制器速度的一个大概. 虽然这并不完美, 但它可以很好地了解VR控"
"制器在3D空间中的移动速度."

msgid ""
"``_physics_process_directional_movement`` function step-by-step explanation"
msgstr "``_physics_process_directional_movement`` 函数分步解释"

msgid ""
"First this function gets the axes for the trackpad and the joystick and "
"assigns them to :ref:`Vector2 <class_Vector2>` variables called "
"``trackpad_vector`` and ``joystick_vector`` respectively."
msgstr ""
"首先, 这个函数获取触控板和操纵杆的轴, 并将它们分配给 :ref:`Vector2 "
"<class_Vector2>` 变量, 分别称为 ``trackpad_vector`` 和 ``joystick_vector``."

msgid ""
"You may need to remap the joystick and/or touchpad index values depending on "
"your VR headset and controller. The inputs in this tutorial are the index "
"values of a Windows Mixed Reality headset."
msgstr ""
"您可能需要根据您的VR头显和控制器重新映射操纵杆和/或触摸板的索引值. 本教程中的"
"输入是Windows混合现实耳机的索引值."

msgid ""
"Then ``trackpad_vector`` and ``joystick_vector`` have their deadzones "
"account for. The code for this is detailed in the article below, with slight "
"changes as the code is converted from C# to GDScript."
msgstr ""
"然后 ``trackpad_vector`` 和 ``joystick_vector`` 具有它们的盲区。这方面的代码"
"在下面的文章中详细介绍了，随着代码从 C# 转换到 GDScript，略有变化。"

msgid ""
"Once the ``trackpad_vector`` and ``joystick_vector`` variables have had "
"their deadzones account for, the code then gets the forward and right "
"direction vectors relative to the global transform of the :ref:`ARVRCamera "
"<class_ARVRCamera>`. What this does is that it gives us vectors that point "
"forward and right relative to the rotation of the user camera, the :ref:"
"`ARVRCamera <class_ARVRCamera>`, in world space. These vectors point in the "
"same direction of the blue and red arrows when you select an object in the "
"Godot editor with the ``local space mode`` button enabled. The forward "
"direction vector is stored in a variable called ``forward_direction``, while "
"the right direction vector is stored in a variable called "
"``right_direction``."
msgstr ""
"一旦 \"trackpad_vector\" 和 \"joystick_vector\" 变量的盲区被计算在内, 代码就"
"会得到相对于 :ref:`ARVRCamera <class_ARVRCamera>` 的全局变换的前进和右转方向"
"的向量. 这样做的目的是给我们提供相对于用户相机的旋转, 即 :ref:`ARVRCamera "
"<class_ARVRCamera>`, 在世界空间中向前和向右指向的向量. 当您在Godot编辑器中选"
"择一个对象并启用 \"局部空间模式\" 按钮时, 这些向量与蓝色和红色箭头的方向相"
"同. 前进方向向量存储在一个名为 \"forward_direction\" 的变量中, 而右侧方向向量"
"存储在一个名为 \"right_direction\" 的变量中."

msgid ""
"Next the code adds the ``trackpad_vector`` and ``joystick_vector`` variables "
"together and normalizes the results using the ``normalized`` function. This "
"gives us the combined movement direction of both input devices, so we can "
"use a single :ref:`Vector2 <class_Vector2>` for moving the user. We assign "
"the combined direction to a variable called ``movement_vector``."
msgstr ""
"接下来, 代码将 ``trackpad_vector`` 和 ``joystick_vector`` 变量加在一起, 并使"
"用 ``normalized`` 函数对结果进行标准化. 这样我们就得到了两个输入设备的组合移"
"动方向, 所以我们可以使用一个 :ref:`Vector2 <class_Vector2>` 来移动用户. 我们"
"将组合方向分配给一个名为 ``movement_vector`` 的变量."

msgid ""
"Then we calculate the distance the user will move forward, relative to the "
"forward direction stored in ``forward_direction``. To calculate this, we "
"multiply ``forward_direction`` by ``movement_vector.x``, ``delta``, and "
"``MOVEMENT_SPEED``. This will give us the distance the user will move "
"forward when the trackpad/joystick is pushed forward or backwards. We assign "
"this to a variable called ``movement_forward``."
msgstr ""
"然后我们计算用户将朝 ``forward_direction`` 方向前进的距离大小. 为了计算它, 我"
"们将 ``forward_direction`` 乘以 ``movement_vector.x`` , ``delta`` 和 "
"``MOVEMENT_SPEED`` . 这将给我们提供当触控板/操纵杆被向前或向后推时用户将向前"
"移动的距离. 我们将其分配给名为 ``movement_forward`` 的变量."

msgid ""
"We do a similar calculation for the distance the user will move right, "
"relative to the right direction stored in ``right_direction``. To calculate "
"the distance the user will move right, we multiply ``right_direction`` by "
"``movement_vector.y``, ``delta``, and ``MOVEMENT_SPEED``. This will give us "
"the distance the user will move right when the trackpad/joystick is pushed "
"right or left. We assign this to a variable called ``movement_right``."
msgstr ""
"我们对用户向右移动的距离进行类似的计算, 相对于存储在 ``right_direction`` 中的"
"正确方向. 为了计算用户向右移动的距离, 我们将 ``right_direction`` 乘以 "
"``movement_vector.y``, ``delta`` 和 ``MOVEMENT_SPEED``. 这将给我们提供当触控"
"板/操纵杆被向右或向左推时, 用户将向右移动的距离. 我们将其分配给一个名为 "
"``movement_right`` 的变量."

msgid ""
"Next we remove any movement on the ``Y`` axis of ``movement_forward`` and "
"``movement_right`` by assigning their ``Y`` values to ``0``. We do this so "
"the user cannot fly/fall simply by moving the trackpad or joystick. Without "
"doing this, the player could fly in the direction they are facing."
msgstr ""
"接下来, 我们将 \"向前移动\" 和 \"向右移动\" 的 \"Y\" 轴上的任何移动, 将它们"
"的 \"Y\" 值赋值为 \"0\". 我们这样做是为了让用户不能仅仅通过移动触控板或操纵杆"
"来飞行/下降. 如果不这样做, 玩家可能会朝着他们所面对的方向飞行."

msgid ""
"Finally, we check to see if the ``length`` function on ``movement_right`` or "
"``movement_forward`` is greater than ``0``. If it is, then we need to move "
"the user. To move the user, we perform a global translation to the :ref:"
"`ARVROrigin <class_ARVROrigin>` node using ``get_parent().global_translate`` "
"and pass in the ``movement_right`` variable with the ``movement_forward`` "
"variable added to it. This will move the player in the direction the "
"trackpad/joystick is pointing, relative to the rotation of the VR headset. "
"We also set the ``directional_movement`` variable to ``true`` so the code "
"knows this VR controller is moving the player."
msgstr ""
"最后, 我们检查 ``movement_right`` 或 ``movement_forward`` 上的 ``length`` 函"
"数是否大于 ``0``. 如果是, 那么我们需要移动用户. 要移动用户, 我们使用 "
"``get_parent().global_translate`` 对 :ref:`ARVROrigin <class_ARVROrigin>` 节"
"点进行全局翻译, 并将 ``movement_right`` 变量与 ``movement_forward`` 变量一起"
"传递给它. 这将使玩家沿着触控板/操纵杆指向的方向移动, 相对于VR头显的旋转. 我们"
"还将 ``directional_movement`` 变量设置为 ``true`` , 这样代码就知道这个VR控制"
"器在移动玩家."

msgid ""
"If the ``length`` function on ``movement_right`` or ``movement_forward`` is "
"less than or equal to ``0``, then we simply set the ``directional_movement`` "
"variable to ``false`` so the code knows this VR controller is not moving the "
"player."
msgstr ""
"如果 ``movement_right`` 或 ``movement_forward`` 上的 ``length`` 函数小于或等"
"于 ``0``, 那么我们只需将 ``directional_movement`` 变量设置为 ``false``, 这样"
"代码就知道这个VR控制器没有移动玩家."

msgid ""
"What this function ultimately does is takes the input from the VR "
"controller's trackpad and joystick and moves the player in the direction the "
"player is pushing them. Movement is relative to the rotation of the VR "
"headset, so if the player pushes forward and turns their head to the left, "
"they will move to the left."
msgstr ""
"这个功能最终要做的是接受VR控制器的触控板和操纵杆的输入, 并按照玩家推动它们的"
"方向移动. 移动是相对于VR头显的旋转而言的, 所以如果玩家向前推并向左转头, 它们"
"就会向左移动."

msgid "``button_pressed`` function step-by-step explanation"
msgstr "``button_pressed`` 函数分步说明"

msgid ""
"This function checks to see if the VR button that was just pressed is equal "
"to one of the VR buttons used in this project. The ``button_index`` variable "
"is passed in by the ``button_pressed`` signal in :ref:`ARVRController "
"<class_ARVRController>`, which we connected in the ``_ready`` function."
msgstr ""
"这个函数检查刚刚按下的VR按钮是否等于本项目中使用的一个VR按钮. "
"``button_index`` 变量是由 :ref:`ARVRController <class_ARVRController>` 中的 "
"``button_pressed`` 信号传递进来的, 我们在 ``_ready`` 函数中连接了这个信号."

msgid ""
"There are only three buttons we are looking for in this project: the trigger "
"button, the grab/grip button, and the menu button."
msgstr ""
"在这个项目中, 我们要找的按钮只有三个: 触发按钮, 抓取/握持按钮和菜单按钮."

msgid ""
"You may need to remap these button index values depending on your VR headset "
"and controller. The inputs in this tutorial are the index values of a "
"Windows Mixed Reality headset."
msgstr ""
"您可能需要根据您的VR头显和控制器重新映射这些按钮索引值. 本教程中的输入是"
"Windows混合现实头盔的索引值."

msgid ""
"First we check if the ``button_index`` is equal to ``15``, which should map "
"to the trigger button on the VR controller. If the button pressed is the "
"trigger button, then the ``_on_button_pressed_trigger`` function is called."
msgstr ""
"首先我们检查 ``button_index`` 是否等于 ``15``, 这应该映射到VR控制器的触发按"
"钮. 如果按下的按钮是触发按钮, 那么就会调用 ``_on_button_pressed_trigger`` 函"
"数."

msgid ""
"If the ``button_index`` is equal to ``2``, then the grab button was just "
"pressed. If the button pressed is the grab button, the "
"``_on_button_pressed_grab`` function is called."
msgstr ""
"如果 ``button_index`` 等于 ``2``, 那么抓取按钮刚刚被按下. 如果按下的是抓取按"
"钮, 则调用 ``_on_button_pressed_grab`` 函数."

msgid ""
"Finally, if the ``button_index`` is equal to ``1``, then the menu button was "
"just pressed. If the button pressed is the menu button, the "
"``_on_button_pressed_menu`` function is called."
msgstr ""
"最后, 如果 ``button_index`` 等于 ``1``, 则表示刚刚按下了菜单键, 如果按下的是"
"菜单键, 则调用 ``_on_button_pressed_menu`` 函数. 如果按下的按钮是菜单按钮, 则"
"调用 ``_on_button_pressed_menu`` 函数."

msgid "``_on_button_pressed_trigger`` function step-by-step explanation"
msgstr "``_on_button_pressed_trigger`` 函数的逐步说明"

msgid ""
"First this function checks to see if the VR controller is not holding by "
"checking if ``held_object`` is equal to ``null``. If the VR controller is "
"not holding anything, then we assume that the trigger press on the VR "
"controller was for teleporting. We then make sure that ``teleport_mesh."
"visible`` is equal to ``false``. We use this to tell if the other VR "
"controller is trying to teleport or not, as ``teleport_mesh`` will be "
"visible if the other VR controller is teleporting."
msgstr ""
"首先这个函数通过检查 ``held_object`` 是否等于 ``null`` 来检查VR控制器是否没有"
"拿着. 如果VR控制器没有持有任何东西, 那么我们假设VR控制器上的触发按压是为了传"
"送. 然后我们确保 ``teleport_mesh.visible`` 等于 ``false``. 我们用这个来判断另"
"一个VR控制器是否在尝试传送, 因为如果另一个VR控制器在传送, 那么 "
"``teleport_mesh`` 将是可见的."

msgid ""
"If ``teleport_mesh.visible`` is equal to ``false``, then we can teleport "
"with this VR controller. We set the ``teleport_button_down`` variable to "
"``true``, set ``teleport_mesh.visible`` to true, and set ``teleport_raycast."
"visible`` to ``true``. This will tell the code in ``_physics_process`` that "
"this VR controller is going to teleport, it will make the ``teleport_mesh`` "
"visible so the user knows where the are teleporting to, and will make "
"``teleport_raycast`` visible to the player has a 'laser sight' they can use "
"to aim the teleportation pos."
msgstr ""
"如果 ``teleport_mesh.visible`` 等于 ``false`` , 那么就可以用这个VR控制器进行"
"远程传输. 将 ``teleport_button_down`` 变量设置为 ``true`` , ``teleport_mesh."
"visible`` 设置为true, ``teleport_raycast.visible`` 设置为 ``true`` , 将告诉 "
"``_physics_process`` 中的代码, 这个VR控制器将进行传送, 使 ``teleport_mesh`` "
"可见, 这样用户就知道传送到哪里, 并使 ``teleport_raycast`` 可见, 这样玩家就可"
"以用激光瞄准器来瞄准传送位置."

msgid ""
"If ``held_object`` is not equal to ``null``, then the VR controller is "
"holding something. We then check to see if the object that is being held, "
"``held_object``, extends a class called ``VR_Interactable_Rigidbody``. We "
"have not made ``VR_Interactable_Rigidbody`` yet, but "
"``VR_Interactable_Rigidbody`` will be a custom class we will use on all of "
"the special/custom :ref:`RigidBody <class_RigidBody>`-based nodes in the "
"project."
msgstr ""
"如果 ``held_object`` 非 ``null`` ，那么 VR 控制器就正在握着什么东西，我们就去"
"检查被握对象 ``held_object`` 是否扩展自 ``VR_Interactable_Rigidbody`` 类。虽"
"然我们还没有创建 ``VR_Interactable_Rigidbody`` 类，但是接下来会把 "
"``VR_Interactable_Rigidbody`` 用于项目中所有特殊（自定义）的基于 :ref:"
"`RigidBody <class_RigidBody>` 的节点。"

msgid ""
"Don't worry, we will cover ``VR_Interactable_Rigidbody`` after this section!"
msgstr "别担心, 我们将在本节之后介绍 ``VR_Interactable_Rigidbody`` !"

msgid ""
"If the ``held_object`` extends ``VR_Interactable_Rigidbody``, then we call "
"the ``interact`` function, so the held object can do whatever it is supposed "
"to do when the trigger is pressed and the object is held by the VR "
"controller."
msgstr ""
"如果 ``held_object`` 扩展自 ``VR_Interactable_Rigidbody``, 那么我们就调用 "
"``interact`` 函数, 这样, 当触发器被按下, 对象被VR控制器握住时, 被握住的对象就"
"可以做任何它应做的事情."

msgid "``_on_button_pressed_grab`` function step-by-step explanation"
msgstr "``_on_button_pressed_grab`` 函数分步说明"

msgid ""
"First this function checks to see if ``teleport_button_down`` is equal to "
"``true``. If it is, then it calls ``return``. We do this because we do not "
"want the user to be able to pick up objects while teleporting."
msgstr ""
"首先, 这个函数检查 ``teleport_button_down`` 是否等于 ``true``, 如果是, 则调"
"用 ``return``, 这样做是因为我们不希望用户在传送时能够拾取对象."

msgid ""
"Then we check to see if the VR controller is currently not holding anything "
"by checking if ``held_object`` is equal to ``null``. If the VR controller is "
"not holding anything, then the ``_pickup_rigidbody`` function is called. If "
"the VR controller is holding something, ``held_object`` is not equal to "
"``null``, then the ``_throw_rigidbody`` function is called."
msgstr ""
"然后我们通过检查 ``held_object`` 是否等于 ``null`` 来检查VR控制器当前是否没有"
"持有任何东西. 如果VR控制器没有持有任何东西, 则调用 ``_pickup_rigidbody`` 函"
"数. 如果VR控制器有拿着东西, ``held_object`` 不等于 ``null`` , 则调用 "
"``_throw_rigidbody`` 函数."

msgid ""
"Finally, the pick-up/drop sound is played by calling the ``play`` function "
"on ``hand_pickup_drop_sound``."
msgstr ""
"最后, 通过调用 ``hand_pickup_drop_sound`` 的 ``play`` 函数来播放拾取/放下的声"
"音."

msgid "``_pickup_rigidbody`` function step-by-step explanation"
msgstr "``_pickup_rigidbody`` 函数的分步说明"

msgid ""
"First the function makes a variable called ``rigid_body``, which we'll be "
"using to store the :ref:`RigidBody <class_RigidBody>` that the VR controller "
"is going to pick up, assuming there is a RigidBody to pick up."
msgstr ""
"首先函数定义了一个名为 ``rigid_body`` 的变量, 我们要用它来存储VR控制器要拾取"
"的 :ref:`RigidBody <class_RigidBody>`, 假设要拾取一个RigidBody."

msgid ""
"Then the function checks to see if the ``grab_mode`` variable is equal to "
"``AREA``. If it is, then it gets all of the :ref:`PhysicsBody "
"<class_PhysicsBody>` nodes within the ``grab_area`` using the "
"``get_overlapping_bodies`` functions. This function will return an array of :"
"ref:`PhysicsBody <class_PhysicsBody>` nodes. We assign the array of :ref:"
"`PhysicsBody <class_PhysicsBody>` to a new variable called ``bodies``."
msgstr ""
"然后函数检查 ``grab_mode`` 变量是否等于 ``AREA``, 如果等于, 则使用 "
"``get_overlapping_bodies`` 函数获取 ``grab_area`` 内的所有 :ref:`PhysicsBody "
"<class_PhysicsBody>` 节点. 该函数将返回一个 :ref:`PhysicsBody "
"<class_PhysicsBody>` 节点的数组. 我们将 :ref:`PhysicsBody "
"<class_PhysicsBody>` 的数组分配给一个新的变量 ``bodies``."

msgid ""
"We then check to see if the length of the ``bodies`` variable is more than "
"``0``. If it is, we go through each of the :ref:`PhysicsBody "
"<class_PhysicsBody>` nodes in ``bodies`` using a for loop."
msgstr ""
"然后我们检查 ``bodies`` 变量的长度是否大于 ``0``, 如果是, 我们使用for循环来检"
"查 ``bodies`` 中的 :ref:`PhysicsBody <class_PhysicsBody>` 节点."

msgid ""
"For each :ref:`PhysicsBody <class_PhysicsBody>` node, we check if it is, or "
"extends, a :ref:`RigidBody <class_RigidBody>` node using ``if body is "
"RigidBody``, which will return ``true`` if the :ref:`PhysicsBody "
"<class_PhysicsBody>` node is or extends the :ref:`RigidBody "
"<class_RigidBody>` node. If the object is a :ref:`RigidBody "
"<class_RigidBody>`, then we check to make sure there is not a variable/"
"constant called ``NO_PICKUP`` defined in the body. We do this because if you "
"want to have :ref:`RigidBody <class_RigidBody>` nodes that cannot be picked "
"up, all you have to do is define a constant/variable called ``NO_PICKUP`` "
"and the VR controller will be unable to pick it up. If the :ref:`RigidBody "
"<class_RigidBody>` node does not have a variable/constant defined with the "
"name ``NO_PICKUP``, then we assign the ``rigid_body`` variable to the :ref:"
"`RigidBody <class_RigidBody>` node and break the for loop."
msgstr ""
"对于每个 :ref:`PhysicsBody <class_PhysicsBody>` 节点, 我们使用``if body is "
"RigidBody``检查它是否是 :ref:`RigidBody <class_RigidBody>` 节点, 如果 :ref:"
"`PhysicsBody <class_PhysicsBody>` 节点是 :ref:`RigidBody <class_RigidBody>` "
"节点或其扩展, 将返回 ``true``. 如果对象是 :ref:`RigidBody "
"<class_RigidBody>`, 那么我们检查在body中有没有定义一个名为 ``NO_PICKUP`` 的变"
"量或常量. 之所以这样做, 是因为如果你想让 :ref:`RigidBody <class_RigidBody>` "
"节点无法被拾取, 只需要定义一个名为 ``NO_PICKUP`` 的常量或变量,VR控制器就会无"
"法拾取它. 如果 :ref:`RigidBody <class_RigidBody>` 节点没有定义一个名称为 "
"``NO_PICKUP`` 的变量或常量, 那么将 ``rigid_body`` 变量赋值给 :ref:`RigidBody "
"<class_RigidBody>` 节点, 并中断for循环."

msgid ""
"What this section of code does is goes through all of the physics bodies "
"within the ``grab_area`` and grabs the first :ref:`RigidBody "
"<class_RigidBody>` node that does not have a variable/constant named "
"``NO_PICKUP`` and assigns it to the ``rigid_body`` variable so we can do "
"some additional post processing later in this function."
msgstr ""
"这部分代码要做的是遍历 ``grab_area`` 内的所有物理实体, 并获取第一个没有变量或"
"常量 ``NO_PICKUP`` 的 :ref:`RigidBody <class_RigidBody>` 节点, 并且将其分配"
"给 ``rigid_body`` 变量, 以便我们稍后可以在此函数中进行一些额外的后期处理."

msgid ""
"If the ``grab_mode`` variable is not equal to ``AREA``, we then check to see "
"if it is equal to ``RAYCAST`` instead. If it is equal to ``RAYCAST``, we "
"force the ``grab_raycast`` node to update using the ``force_raycast_update`` "
"function. The ``force_raycast_update`` function will update the :ref:"
"`Raycast <class_Raycast>` with the latest changes in the physics world. We "
"then check to see if the ``grab_raycast`` node collided with something using "
"the ``is_colliding`` function, which will return true if the :ref:`Raycast "
"<class_Raycast>` hit something."
msgstr ""
"如果 ``grab_mode`` 变量不等于 ``AREA`` 我们就检查它是否等于 ``RAYCAST`` . 如"
"果它等于 ``RAYCAST`` , 我们就使用 ``force_raycast_update`` 函数强制更新 "
"``grab_raycast`` 节点. ``force_raycast_update`` 函数将用物理世界的最新变化更"
"新 :ref:`Raycast <class_Raycast>` . 然后我们使用 ``is_colliding`` 函数检查 "
"``grab_raycast`` 节点是否与某物相撞, 如果 :ref:`Raycast <class_Raycast>` 撞到"
"了某物, 则返回true."

msgid ""
"If the ``grab_raycast`` hit something, we get the :ref:`PhysicsBody "
"<class_PhysicsBody>` node hit using the ``get_collider`` function. The code "
"then checks to see if the node hit is a :ref:`RigidBody <class_RigidBody>` "
"node using ``if body is RigidBody``, which will return ``true`` if the :ref:"
"`PhysicsBody <class_PhysicsBody>` node is or extends the :ref:`RigidBody "
"<class_RigidBody>` node. Then the code checks to see if the :ref:`RigidBody "
"<class_RigidBody>` node does not have a variable named ``NO_PICKUP``, and if "
"it does not, then it assigns the :ref:`RigidBody <class_RigidBody>` node to "
"the ``rigid_body`` variable."
msgstr ""
"如果 ``grab_raycast`` 命中了什么东西，我们就会使用 ``get_collider`` 函数得到"
"命中的 :ref:`PhysicsBody <class_PhysicsBody>` 节点。然后，代码使用 ``if body "
"is RigidBody`` 检查命中的节点是否是 :ref:`RigidBody <class_RigidBody>` 节点，"
"如果该 :ref:`PhysicsBody <class_PhysicsBody>` 节点是 :ref:`RigidBody "
"<class_RigidBody>` 或其派生节点，代码将返回 ``true``\\ 。然后代码会检查该 :"
"ref:`RigidBody<class_RigidBody>` 节点是否没有名为 ``NO_PICKUP`` 的变量，如果"
"没有，则将该 :ref:`RigidBody<class_RigidBody>` 节点赋值给 ``rigid_body`` 变"
"量。"

msgid ""
"What this section of code does is sends the ``grab_raycast`` :ref:`Raycast "
"<class_Raycast>` node out and checks if it collided with a :ref:`RigidBody "
"<class_RigidBody>` node that does not have a variable/constant named "
"``NO_PICKUP``. If it collided with a RigidBody without ``NO_PICKUP``, it "
"assigns the node to the ``rigid_body`` variable so we can do some additional "
"post processing later in this function."
msgstr ""
"这段代码的作用是将 ``grab_raycast`` :ref:`Raycast <class_Raycast>` 节点发送出"
"去，并检查它是否与一个没有 ``NO_PICKUP`` 变量/常量的 :ref:`RigidBody "
"<class_RigidBody>` 节点碰撞。如果它与一个没有 ``NO_PICKUP`` 的 RigidBody 碰"
"撞，它将该节点分配给 ``rigid_body`` 变量，这样我们就可以在这个函数的后面做一"
"些额外的后期处理。"

msgid ""
"The final section of code first checks to see if ``rigid_body`` is not equal "
"to ``null``. If ``rigid_body`` is not equal to ``null``, then the VR "
"controller found a :ref:`RigidBody <class_RigidBody>`-based node that can be "
"picked up."
msgstr ""
"最后一段代码首先检查 ``rigid_body`` 是否不等于 ``null`` . 如果 "
"``rigid_body`` 不等于 ``null`` , 那么VR控制器找到了一个可以拾取的 :ref:"
"`RigidBody <class_RigidBody>` 类型节点."

msgid ""
"If there is a VR controller to pickup, we assign ``held_object`` to the :ref:"
"`RigidBody <class_RigidBody>` node stored in ``rigid_body``. We then store "
"the :ref:`RigidBody <class_RigidBody>` node's ``mode``, ``collision_layer``, "
"and ``collision_mask`` in ``held_object_data`` using ``mode``, ``layer``, "
"and ``mask`` as keys for the respective values. This is so we can reapply "
"them later when the object is dropped by the VR controller."
msgstr ""
"如果有一个VR控制器要拾取, 我们将 ``held_object`` 分配给存储在 ``rigid_body`` "
"中的 :ref:`RigidBody <class_RigidBody>` 节点. 然后将 :ref:`RigidBody "
"<class_RigidBody>` 节点的 ``mode`` , ``collision_layer`` 和 "
"``collision_mask`` 以 ``mode`` , ``layer`` 和 ``mask`` 作为各自值的键存储在 "
"``held_object_data`` 中. 这是为了以后当对象被VR控制器丢弃时, 可以重新应用它"
"们."

msgid ""
"We then set the :ref:`RigidBody <class_RigidBody>`'s mode to "
"``MODE_STATIC``, it's ``collision_layer`` to zero, and it's "
"``collision_mask`` to zero. This will make it where the held :ref:`RigidBody "
"<class_RigidBody>` cannot interact with other objects in the physics world "
"when held by the VR controller."
msgstr ""
"然后我们将 :ref:`RigidBody <class_RigidBody>` 的模式设置为 ``MODE_STATIC`` , "
"它的 ``collision_layer`` 和 ``collision_mask`` 为零. 这将使被持有的 :ref:"
"`RigidBody <class_RigidBody>` 在被VR控制器持有时不能与物理世界中的其他物体互"
"动."

msgid ""
"Next the ``hand_mesh`` :ref:`MeshInstance <class_MeshInstance>` is made "
"invisible by setting the ``visible`` property to ``false``. This is so the "
"hand does not get in the way of the held object. Likewise, the "
"``grab_raycast`` 'laser sight' is made invisible by setting the ``visible`` "
"property to ``false``."
msgstr ""
"接下来将 ``hand_mesh`` :ref:`MeshInstance <class_MeshInstance>` 通过设置 "
"``visible`` 属性为 ``false`` 而使 ``hand_mesh`` 变得不可见. 这样, 手就不会挡"
"住所持对象的去路. 同样 ``grab_raycast`` '激光瞄准器' 也是通过设置 "
"``visible`` 属性为 ``false`` 而变得不可见的."

msgid ""
"Then the code checks to see if the held object extends a class called "
"``VR_Interactable_Rigidbody``. If it does, then sets a variable called "
"``controller`` on ``held_object`` to ``self``, and calls the ``picked_up`` "
"function on ``held_object``. While we haven't made "
"``VR_Interactable_Rigidbody`` just yet, what this will do is set tell the "
"``VR_Interactable_Rigidbody`` class that it is being held by a VR "
"controller, where the a reference to the controller is stored in the "
"``controller`` variable, through calling the ``picked_up`` function."
msgstr ""
"然后, 代码检查持有的对象是否扩展了一个叫做 ``VR_Interactable_Rigidbody`` 的"
"类. 如果是, 那么就在 ``held_object`` 上设置 ``controller`` 的变量为 "
"``self`` , 然后在 ``held_object`` 上调用 ``picked_up`` 函数. 虽然我们还没有"
"做 ``VR_Interactable_Rigidbody`` , 但这样做的作用是通过调用 ``picked_up`` 函"
"数, 设置告诉 ``VR_Interactable_Rigidbody`` 类, 它被一个VR控制器持有, 控制器的"
"引用存储在 ``controller`` 变量中."

msgid ""
"The code should make more sense after completing part 2 of this tutorial "
"series, where we will actually be using ``VR_Interactable_Rigidbody``."
msgstr ""
"在完成本系列教程的第二部分后, 代码应该会更有意义, 在那里我们将实际使用 "
"``VR_Interactable_Rigidbody``."

msgid ""
"What this section of code does is that if a :ref:`RigidBody "
"<class_RigidBody>` was found using the grab :ref:`Area <class_Area>` or :ref:"
"`Raycast <class_Raycast>`, it sets it up so that it can be carried by the VR "
"controller."
msgstr ""
"这段代码的作用是, 如果使用抓取 :ref:`Area <class_RigidBody>` 或 :ref:"
"`Raycast <class_Raycast>` 找到了 :ref:`RigidBody <class_RigidBody>`, 它就会将"
"其设置为可以被VR控制器携带."

msgid "``_throw_rigidbody`` function step-by-step explanation"
msgstr "``_throw_rigidbody`` 函数的分步说明"

msgid ""
"First the function checks to see if the VR controller is not holding any "
"object by checking if the ``held_object`` variable is equal to ``null``. If "
"it is, then it simply calls ``return`` so nothing happens. While this "
"shouldn't be possible, the ``_throw_rigidbody`` function should only be "
"called if an object is held, this check helps ensure that if something "
"strange happens, this function will react as expected."
msgstr ""
"首先, 该函数通过检查 ``held_object`` 变量是否等于 ``null`` 来检查VR控制器是否"
"没有持有任何对象. 如果是, 那么它只是调用 ``return``, 所以什么都不会发生. 虽然"
"这应该是不可能的, 但 ``_throw_rigidbody`` 函数应该只在对象被持有的情况下被调"
"用, 这种检查有助于确保如果发生了一些奇怪的事情, 这个函数将按照预期的方式做出"
"反应."

msgid ""
"After checking if the VR controller is holding an object, we assume it is "
"and set the stored :ref:`RigidBody <class_RigidBody>` data back to the held "
"object. We take the ``mode``, ``layer`` and ``mask`` data stored in the "
"``held_object_data`` dictionary and reapply it to the object in "
"``held_object``. This will set the :ref:`RigidBody <class_RigidBody>` back "
"to the state it was prior to being picked up."
msgstr ""
"在检查VR控制器是否持有对象后, 我们假设它是, 并将存储的 :ref:`RigidBody "
"<class_RigidBody>` 数据设置回持有对象. 我们将存储在 ``held_object_data`` 字典"
"中的 ``mode``, ``layer`` 和 ``mask`` 数据重新应用到 ``held_object`` 中的对"
"象. 这将把 :ref:`RigidBody <class_RigidBody>` 设置回被拾取之前的状态."

msgid ""
"Then we call ``apply_impulse`` on the ``held_object`` so that the :ref:"
"`RigidBody <class_RigidBody>` is thrown in the direction of the VR "
"controller's velocity, ``controller_velocity``."
msgstr ""
"然后我们在 ``held_object`` 上调用 ``apply_impulse``, 这样 :ref:`RigidBody "
"<class_RigidBody>` 就会被抛向VR控制器的速度方向, ``controller_velocity``."

msgid ""
"We then check to see if the object held extends a class called "
"``VR_Interactable_Rigidbody``. If it does, then we call a function called "
"``dropped`` in ``held_object`` and set ``held_object.controller`` to "
"``null``. While we have not made ``VR_Interactable_Rigidbody`` yet, but what "
"this will do is call the ``droppped`` function so the :ref:`RigidBody "
"<class_RigidBody>` can do whatever it needs to do when dropped, and we set "
"the ``controller`` variable to ``null`` so that the :ref:`RigidBody "
"<class_RigidBody>` knows that it is not being held."
msgstr ""
"然后, 我们检查持有的对象是否扩展了一个叫做 ``VR_Interactable_Rigidbody`` 的"
"类. 如果是, 那么我们在 ``held_object`` 中调用一个叫做 ``dropped`` 的函数, 并"
"将 ``held_object.controller`` 设置为 ``null`` . 虽然我们还没有做 "
"``VR_Interactable_Rigidbody`` , 但是这样做的目的是调用 ``droppped`` 函数, 这"
"样 :ref:`RigidBody <class_RigidBody>` 就可以在drop时做任何需要做的事情, 我们"
"将 ``controller`` 变量设置为 ``null`` , 这样 :ref:`RigidBody "
"<class_RigidBody>` 就知道它没有被持有."

msgid ""
"Regardless of whether ``held_object`` extends ``VR_Interactable_Rigidbody`` "
"or not, we then set ``held_object`` to ``null`` so the VR controller knows "
"it is no longer holding anything. Because the VR controller is no longer "
"holding anything, we make the ``hand_mesh`` visible by setting ``hand_mesh."
"visible`` to true."
msgstr ""
"无论 ``held_object`` 是否扩展了 ``VR_Interactable_Rigidbody``, 我们都要将 "
"``held_object`` 设置为 ``null``, 这样VR控制器就知道它不再拿着任何东西了. 因为"
"VR控制器不再持有任何东西, 所以我们将 ``hand_mesh.visible`` 设置为true, 使 "
"``hand_mesh`` 可见."

msgid ""
"Finally, if the ``grab_mode`` variable is set to ``RAYCAST``, we set "
"``grab_raycast.visible`` to ``true`` so the 'laser sight' for the :ref:"
"`Raycast <class_Raycast>` in ``grab_raycast`` is visible."
msgstr ""
"最后, 如果 ``grab_mode`` 变量设置为 ``RAYCAST`` , 我们将 ``grab_raycast."
"visible`` 设置为 ``true`` , 这样 ``grab_raycast`` 中的 :ref:`Raycast "
"<class_Raycast>` 的 ``激光视线`` 是可见的."

msgid "``_on_button_pressed_menu`` function step-by-step explanation"
msgstr "``_on_button_pressed_menu`` 函数的分步说明"

msgid ""
"First this function checks to see if the ``grab_mode`` variable is equal to "
"``AREA``. If it is, then it sets ``grab_mode`` to ``RAYCAST``. It then "
"checks to see if the VR controller is not holding anything by checking to "
"see if ``held_object`` is equal to ``null``. If the VR controller is not "
"holding anything, then ``grab_raycast.visible`` is set to ``true`` so the "
"'laser sight' on the grab raycast is visible."
msgstr ""
"首先这个函数检查是否 ``grab_mode`` 变量等于 ``AREA``. 如果是, 则将\" "
"grab_mode\"设置为\" RAYCAST\". 然后, 它会检查该 VR控制器是否未持有任何东西, "
"如果 ``held_object`` 等于 ``null``, 则为未持有. 如果该 VR控制器未持有任何东"
"西, 那么 ``grab_raycast.visible`` 的值被设置为 ``True``, 则 \"激光瞄准器\" 的"
"抓取光线投射可见."

msgid ""
"If the ``grab_mode`` variable is not equal to ``AREA``, then it checks to "
"see if it is equal to ``RAYCAST``. If it is, then it sets the ``grab_mode`` "
"to ``AREA`` and sets ``grab_raycast.visible`` to ``false`` so the 'laser "
"sight' on the grab raycast is not visible."
msgstr ""
"如果 ``grab_mode`` 变量不等于 ``AREA``, 将会检查它是否等于 ``RAYCAST``. 如果"
"是的话, 这将把 ``grab_mode`` 设置为 ``AREA`` 并且将 ``grab_raycast.visible`` "
"设置为 ``false`` , 因此grab raycast上的 \"激光瞄准器\" 将会不可见."

msgid ""
"This section of code simply changes how the VR controller will grab :ref:"
"`RigidBody <class_RigidBody>`-based nodes when the grab/grip button is "
"pressed. If ``grab_mode`` is set to ``AREA``, then the :ref:`Area "
"<class_Area>` node in ``grab_area`` will be used for detecting :ref:"
"`RigidBody <class_RigidBody>` nodes, while if ``grab_mode`` is set to "
"``RAYCAST`` the :ref:`Raycast <class_Raycast>` node in ``grab_raycast`` will "
"be used for detecting :ref:`RigidBody <class_RigidBody>` nodes."
msgstr ""
"这一段代码简单地改变了VR控制器在按下 grab/grip 抓取按钮时如何抓取 :ref:"
"`RigidBody <class_RigidBody>` 的节点. 如果 ``grab_mode`` 设置为 ``AREA``, 那"
"么 ``grab_area`` 中的 :ref:`Area <class_Area>` 节点将被用于检测 :ref:"
"`RigidBody <class_RigidBody>` 节点, 如果 ``grab_mode`` 设置为 ``RAYCAST`` 那"
"么 ``grab_raycast`` 中的 :ref:`Raycast <class_Raycast>` 节点将被用于检测 :"
"ref:`RigidBody <class_RigidBody>` 节点."

msgid "``button_released`` function step-by-step explanation"
msgstr "``button_released`` 函数的分步说明"

msgid ""
"The only section of code in this function checks to see if the index of the "
"button that was just released, ``button_index``, is equal to ``15``, which "
"should map to the trigger button on the VR controller. The ``button_index`` "
"variable is passed in by the ``button_release`` signal in :ref:"
"`ARVRController <class_ARVRController>`, which we connected in the "
"``_ready`` function."
msgstr ""
"这个函数中唯一的一段代码是检查刚刚释放的按钮的索引 ``button_index`` 是否等于 "
"``15`` , 它应该映射到VR控制器上的触发按钮. ``button_index`` 变量是由 :ref:"
"`ARVRController <class_ARVRController>` 中的 ``button_release`` 信号传递进来"
"的, 我们之前在 ``_ready`` 函数中连接了这个信号."

msgid ""
"If the trigger button was just released, then the "
"``_on_button_released_trigger`` function is called."
msgstr ""
"如果触发器按钮被松开, 那么 ``_on_button_released_trigger`` 函数将会被调用."

msgid "``_on_button_released_trigger`` function step-by-step explanation"
msgstr "``_on_button_released_trigger`` 函数的分步说明"

msgid ""
"The only section of code in this function first checks to see if the VR "
"controller is trying to teleport by checking if the ``teleport_button_down`` "
"variable is equal to ``true``."
msgstr ""
"该函数中唯一的一段代码首先通过检查 ``teleport_button_down`` 变量是否等于 "
"``true`` 来检查VR控制器是否在尝试传送."

msgid ""
"If the ``teleport_button_down`` variable is equal to ``true``, the code then "
"checks if there is a teleport position set and whether the teleport mesh is "
"visible. It does this by checking to see if ``teleport_pos`` is not equal to "
"``null`` and if ``teleport_mesh.visible`` is equal to ``true``."
msgstr ""
"如果 ``teleport_button_down`` 变量等于 ``true`` , 代码就会检查是否设置了传送"
"位置, 以及传送网格是否可见. 这是通过检查 ``teleport_pos`` 是否不等于 "
"``null`` 和 ``teleport_mesh.visible`` 是否等于 ``true`` 来实现的."

msgid ""
"If there is a teleport position set and the teleport mesh is visible, the "
"code then calculates the offset from the camera to the :ref:`ARVROrigin "
"<class_ARVROrigin>` node, which is assumed to be the parent node of the VR "
"controller. To calculate the offset, the global position (``global_transform."
"origin``) of the ``Player_Camera`` node has the global position of the :ref:"
"`ARVROrigin <class_ARVROrigin>` subtracted from it. This will result in a "
"vector that points from the :ref:`ARVROrigin <class_ARVROrigin>` to the :ref:"
"`ARVRCamera <class_ARVRCamera>`, which we store in a variable called "
"``camera_offset``."
msgstr ""
"如果有一个传送位置设置, 并且传送网格是可见的, 那么代码就会计算从摄像机到 :"
"ref:`ARVROrigin <class_ARVROrigin>` 节点的偏移量, 该节点被假定为VR控制器的父"
"节点. 为了计算偏移量, ``Player_Camera`` 节点的全局位置(``global_transform."
"origin``)将会减去 :ref:`ARVROrigin <class_ARVROrigin>` 节点的全局位置. 这将产"
"生一个从 :ref:`ARVROrigin <class_ARVROrigin>` 指向 :ref:`ARVRCamera "
"<class_ARVRCamera>` 的向量, 我们将其存储在一个名为 ``camera_offset`` 的变量"
"中."

msgid ""
"The reason we need to know the offset is because some VR headsets use room "
"tracking, where the player's camera can be offset from the :ref:`ARVROrigin "
"<class_ARVROrigin>` node. Because of this, when we teleport we want to keep "
"the offset created by room tracking so that when the player teleports, the "
"offset created by the room tracking is not applied. Without this, if you "
"moved in a room and then teleported, instead of appearing at the position "
"you wanted to teleport at, your position would be offset by the amount of "
"distance you have from the :ref:`ARVROrigin <class_ARVROrigin>` node."
msgstr ""
"我们之所以需要知道偏移量, 是因为一些VR头显使用了房间追踪, 玩家的摄像头可以"
"从 :ref:`ARVROrigin <class_ARVROrigin>` 节点上进行偏移. 正因为如此, 当我们传"
"送时, 我们希望保留房间追踪产生的偏移, 这样当玩家传送时, 房间追踪产生的偏移就"
"不会被应用. 如果没有这个功能, 如果你在一个房间里移动, 然后传送, 你的位置就不"
"会出现在你想传送的位置, 而是会被你与 :ref:`ARVROrigin <class_ARVROrigin>` 节"
"点的距离所抵消."

msgid ""
"Now that we know the offset from the VR camera to the VR origin, we need to "
"remove the difference on the ``Y`` axis. We do this because we do not want "
"to offset based on the user's height. If we did not do this, when "
"teleporting the player's head would be level with the ground."
msgstr ""
"现在我们知道了从VR摄像机到VR原点的偏移量, 我们需要去除 ``Y`` 轴上的差异. 我们"
"之所以这样做, 是因为我们不希望根据用户的身高进行偏移. 如果不这样做的话, 当传"
"送时, 玩家的头部将与地面持平."

msgid ""
"Then we can 'teleport' the player by setting the global position "
"(``global_transform.origin``) of the ARVROrigin node to the position stored "
"in ``teleport_pos`` with ``camera_offset`` subtracted from it. This will "
"teleport the player and remove the room tracking offset, so the user appears "
"exactly where they want when teleporting."
msgstr ""
"然后, 我们便可以通过将ARVROrigin节点的全局位置(``global_transform.origin``)设"
"置为 ``teleport_pos`` 中存储的位置, 并从中减去 ``camera_offset`` 来传送玩家. "
"这将会在传送玩家的同时, 移除房间跟踪的偏移. 因此保证用户在传送时, 将会出现在"
"他们想要的地方."

msgid ""
"Finally, regardless of whether the VR controller teleported the user or not, "
"we reset the teleport related variables. ``teleport_button_down`` is set to "
"``false``, ``teleport_mesh.visible`` is set to ``false`` so the mesh is "
"invisible, ``teleport_raycast.visible`` is set to ``false``, and "
"``teleport_pos`` is set to ``null``."
msgstr ""
"最后, 不管VR控制器是否对用户进行了传送, 我们都要重置传送相关的变量. 我们把 "
"``teleport_button_down`` 设置为 ``false``, ``teleport_mesh.visible`` 设置为 "
"``false`` 以便让传送网格不可见, ``teleport_raycast.visible`` 设置为 "
"``false`` , 然后把 ``teleport_pos`` 设置为 ``null`` ."

msgid "``sleep_area_entered`` function step-by-step explanation"
msgstr "``sleep_area_entered`` 函数的分步说明"

msgid ""
"The only section of code in this function checks to see if the :ref:"
"`PhysicsBody <class_PhysicsBody>` node that entered the ``Sleep_Area`` node "
"has a variable called ``can_sleep``. If it does, then it sets the "
"``can_sleep`` variable to ``false`` and sets the ``sleeping`` variable to "
"``false``."
msgstr ""
"这个函数中唯一的一段代码是检查进入 ``Sleep_Area`` 节点的 :ref:`PhysicsBody "
"<class_PhysicsBody>` 节点是否有一个叫 ``can_sleep`` 的变量. 如果有, 则将 "
"``can_sleep`` 变量设为 ``false``, 并将 ``sleeping`` 变量设为 ``false``."

msgid ""
"Without doing this, sleeping :ref:`PhysicsBody <class_PhysicsBody>` nodes "
"would not be able to be picked up by the VR controller, even if the VR "
"controller is at the same position as the :ref:`PhysicsBody "
"<class_PhysicsBody>` node. To work around this, we simply 'wake up' :ref:"
"`PhysicsBody <class_PhysicsBody>` nodes that are close to the VR controller."
msgstr ""
"如果不这样做, 睡眠状态的 :ref:`PhysicsBody <class_PhysicsBody>` 节点将无法被 "
"VR 控制器拿起, 即使 VR 控制器与 :ref:`PhysicsBody <class_PhysicsBody>` 节点处"
"于同一位置. 为了解决这个问题, 我们只需 \"唤醒\" 靠近VR控制器的 :ref:"
"`PhysicsBody <class_PhysicsBody>` 节点即可."

msgid "``sleep_area_exited`` function step-by-step explanation"
msgstr "``sleep_area_exited`` 函数的分步说明"

msgid ""
"The only section of code in this function checks to see if the :ref:"
"`PhysicsBody <class_PhysicsBody>` node that entered the ``Sleep_Area`` node "
"has a variable called ``can_sleep``. If it does, then it sets the "
"``can_sleep`` variable to ``true``."
msgstr ""
"这个函数中唯一的一段代码是检查进入 ``Sleep_Area`` 节点的 :ref:`PhysicsBody "
"<class_PhysicsBody>` 节点是否有一个叫 ``can_sleep`` 的变量. 如果有, 则将 "
"``can_sleep`` 变量设置为 ``true``."

msgid ""
"This allows :ref:`RigidBody <class_RigidBody>` nodes that leave the "
"``Sleep_Area`` to sleep again, saving performance."
msgstr ""
"这将允许离开 ``Sleep_Area`` 的 :ref:`RigidBody <class_RigidBody>` 节点再次睡"
"眠, 以便节省性能."

msgid ""
"Okay, whew! That was a lot of code! Add the same script, ``VR_Controller."
"gd`` to the other VR controller scene so both VR controllers have the same "
"script."
msgstr ""
"好吧, 哇！那是很多代码！将相同的脚本 ``VR_Controller.gd`` 添加到其他VR控制器"
"场景中, 以便两个VR控制器具有相同的脚本."

msgid ""
"Now we just need to do one thing before testing the project! Right now we "
"are referencing a class called ``VR_Interactable_Rigidbody``, but we have "
"not defined it yet. While we will not be using ``VR_Interactable_Rigidbody`` "
"in this tutorial, let's create it real quick so the project can be run."
msgstr ""
"现在, 我们只需要在测试项目之前再做一件事！现在我们引用了一个叫做 "
"``VR_Interactable_Rigidbody`` 的类, 但是我们还没有定义它. 虽然我们在本教程中"
"不会使用 ``VR_Interactable_Rigidbody``, 但我们还是要快速创建它, 以便项目能够"
"运行."

msgid "Creating a base class for interactable VR objects"
msgstr "为可交互的 VR 对象创建基类"

msgid ""
"With the ``Script`` tab still open, create a new GDScript called "
"``VR_Interactable_Rigidbody.gd``."
msgstr ""
"在 ``Script`` 选项卡仍然打开的情况下，创建一个新的 GDScript，名为 "
"``VR_Interactable_Rigidbody.gd``\\ 。"

msgid ""
"You can create GDScripts in the ``Script`` tab by pressing ``File -> New "
"Script...``."
msgstr ""
"你可以在 ``Script`` 选项卡中通过点击 ``File -> New Script...`` 来新建一个"
"GDScripts脚本."

msgid ""
"Once you have ``VR_Interactable_Rigidbody.gd`` open, add the following code:"
msgstr "打开 ``VR_Interactable_Rigidbody.gd`` 后, 添加以下代码:"

msgid "Let's quickly go through what this script."
msgstr "让我们快速浏览一下这个脚本."

msgid ""
"First we start the script with ``class_name VR_Interactable_Rigidbody``. "
"What this does is that it tells Godot that this GDScript is a new class that "
"called ``VR_Interactable_Rigidbody``. This allows us to compare nodes "
"against the ``VR_Interactable_Rigidbody`` class in other script files "
"without having to load the script directly or do anything special. We can "
"compare the class just like all of the built-in Godot classes."
msgstr ""
"首先, 我们用 ``class_name VR_Interactable_Rigidbody`` 作为脚本的开头. 这样做"
"的目的是告诉Godot这个GDScript是一个新的类, 叫做 "
"``VR_Interactable_Rigidbody`` . 这使我们可以将节点与其他脚本文件中的 "
"``VR_Interactable_Rigidbody`` 类进行比较, 而不必直接加载脚本或做任何特殊的事"
"情. 我们可以像所有内置的Godot类一样对该类进行比较."

msgid ""
"Next is a class variable called ``controller``. ``controller`` will be used "
"to hold a reference to the VR controller that is currently holding the "
"object. If a VR controller is not holding the object, then the "
"``controller`` variable will be ``null``. The reason we need to have a "
"reference to the VR controller is so held objects can access VR controller "
"specific data, like ``controller_velocity``."
msgstr ""
"接下来是一个名为 ``controller`` 的类变量. ``controller`` 将被用来保存对当前持"
"有物品的VR控制器的引用. 如果一个VR控制器没有持有物品, 那么 ``controller`` 变"
"量的值将为 ``null`` . 我们需要对VR控制器有一个引用的原因, 是为了让被持有的物"
"品能够访问VR控制器的特定数据, 比如 ``controller_velocity`` ."

msgid ""
"Finally, we have four functions. The ``_ready`` function is defined by Godot "
"and all we do is simply have ``pass`` as there is nothing we need to do when "
"the object is added to the scene in ``VR_Interactable_Rigidbody``."
msgstr ""
"最后, 我们有四个函数. ``_ready`` 函数是由Godot定义的, 我们要做的只是将其 "
"``pass`` . 因为在 ``VR_Interactable_Rigidbody`` 中, 当对象被添加到场景中时, "
"我们并不需要做什么."

msgid ""
"The ``interact`` function is a stub function that will be called when the "
"interact button on the VR controller, the trigger in this case, is pressed "
"while the object is held."
msgstr ""
"``interact`` 功能是一个桩函数, 当按住VR控制器上的交互按钮(在这种情况下为触发"
"器)时将调用该函数."

msgid ""
"A stub function is a function that is defined but does not have any code. "
"Stub functions are generally designed to be overwritten or extended. In this "
"project, we are using the stub functions so there is a consistent interface "
"across all interactable :ref:`RigidBody <class_RigidBody>` objects."
msgstr ""
"存根函数指的是一个定义了, 但其中没有任何代码的函数. 存根函数一般被设计成可以"
"被覆盖或扩展. 在这个项目中, 我们使用了存根函数, 因此在所有可交互的 :ref:"
"`RigidBody <class_RigidBody>` 对象中都将有一个一致的接口."

msgid ""
"The ``picked_up`` and ``dropped`` functions are stub functions that will be "
"called when the object is picked up and dropped by the VR controller."
msgstr ""
"``picked_up`` 和 ``dropped`` 函数是存根函数, 当VR控制器拾取和放置对象时将调用"
"它们."

msgid ""
"That is all we need to do for now! In the next part of this tutorial series, "
"we'll start making special interactable :ref:`RigidBody <class_RigidBody>` "
"objects."
msgstr ""
"这就是我们现在需要做的所有事情！在本系列教程的下一部分, 我们将开始制作特殊的"
"可交互的 :ref:`RigidBody <class_RigidBody>` 对象."

msgid ""
"Now that the base class is defined, the code in the VR controller should "
"work. Go ahead and try the game again, and you should find you can teleport "
"around by pressing the touch pad, and can grab and throw objects using the "
"grab/grip buttons."
msgstr ""
"现在已经定义了基类,VR控制器中的代码应该可以工作了. 继续尝试游戏, 您会发现您可"
"以通过按触摸板进行四处移动, 并可以使用 \"抓/握\" 按钮抓取和扔出物体."

msgid ""
"Now, you may want to try moving using the trackpads and/or joysticks, but "
"**it may make you motion sick!**"
msgstr ""
"现在, 您可能想尝试使用触控板和/或操纵杆移动, 但 **它可能会让您运动生病！**"

msgid ""
"One of the main reasons this can make you feel motion sick is because your "
"vision tells you that you are moving, while your body is not moving. This "
"conflict of signals can make the body feel sick. Let's add a vignette shader "
"to help reduce motion sickness while moving in VR!"
msgstr ""
"这可能使你感到晕车的主要原因之一, 你的视觉告诉你正在移动, 而你的身体却没有移"
"动. 这种信号的冲突会使身体感到不适. 让我们添加一个晕影着色器来帮助减少在VR中"
"移动时的晕动症吧!"

msgid "Reducing motion sickness"
msgstr "减少晕动病"

#, fuzzy
msgid ""
"There are plenty of ways to reduce motion sickness in VR, and there is no "
"one perfect way to reduce motion sickness. See `this page on the Oculus "
"Developer Center <https://developer.oculus.com/design/latest/concepts/bp-"
"locomotion/>`__ for more information on how to implement locomotion and "
"reducing motion sickness."
msgstr ""
"有很多方法可以减少VR中的晕动病, 并且没有一种方法可以减少晕动病. 有关如何实施"
"运动和减少晕动病的更多信息, 请参阅Oculus开发人员中心的 `这个页面 <https://"
"developer.oculus.com/design/latest/concepts/bp-locomotion/>`_ ."

msgid ""
"To help reduce motion sickness while moving, we are going to add a vignette "
"effect that will only be visible while the player moves."
msgstr ""
"为了帮助减少移动时的晕车, 我们将添加一个只有在游戏角色移动时才能看到的晕影效"
"果."

msgid ""
"First, quickly switch back to ``Game.tscn```. Under the :ref:`ARVROrigin "
"<class_ARVROrigin>` node there is a child node called ``Movement_Vignette``. "
"This node is going to apply a simple vignette to the VR headset when the "
"player is moving using the VR controllers. This should help reduce motion "
"sickness."
msgstr ""
"首先, 让我们迅速切换回 ``Game.tscn`` . 在 :ref:`ARVROrigin "
"<class_ARVROrigin>` 节点下有一个子节点叫 ``Movement_Vignette`` . 当玩家使用VR"
"控制器移动时, 这个节点将在VR头显上应用一个简单的晕影. 这应该有助于减少晕动症."

#, fuzzy
msgid ""
"Open up ``Movement_Vignette.tscn``, which you can find in the ``Scenes`` "
"folder. The scene is just a :ref:`ColorRect <class_ColorRect>` node with a "
"custom shader. Feel free to look at the custom shader if you want, it is "
"just a slightly modified version of the vignette shader you can find in the "
"`Godot demo repository <https://github.com/godotengine/godot-demo-"
"projects>`__."
msgstr ""
"打开 ``Movement_Vignette.tscn`` , 你可以在 ``Scenes`` 文件夹中找到它. 这个场"
"景只是一个 :ref:`ColorRect <class_ColorRect>` 节点和一个自定义着色器. 如果你"
"想的话, 可以随意看看这个自定义着色器, 它只是Vignette着色器的一个略微修改的版"
"本, 你可以在 `Godot 演示资源库 <https://github.com/godotengine/godot-demo-"
"projects>`_ 找到."

msgid ""
"Let's write the code that will make the vignette shader visible when the "
"player is moving. Select the ``Movement_Vignette`` node and create a new "
"script called ``Movement_Vignette.gd``. Add the following code:"
msgstr ""
"让我们来编写代码, 使玩家在移动时可以看到光影效果. 选择 \"Movement_Vignette\" "
"节点并创建一个名为 \"Movement_Vignette.gd\" 的新脚本. 添加以下代码:"

msgid ""
"Because this script is fairly brief, let's quickly go over what it does."
msgstr "因为这个脚本相当简短, 让我们快速浏览一下它的作用."

msgid "Explaining the vignette code"
msgstr "解释小插图代码"

msgid ""
"There are two class variables, ``controller_one`` and ``controller_two``. "
"These variables will hold references to the left and right VR controllers."
msgstr ""
"这里有两个类变量, ``controller_one`` 和 ``controller_two`` . 这两个变量将分别"
"保存对左, 右VR控制器的引用."

msgid ""
"In the ``_ready`` function first waits for four frames using ``yield``. The "
"reason we are waiting four frames is because we want to ensure the VR "
"interface is ready and accessible."
msgstr ""
"在 ``_ready`` 函数中首先使用 ``yield`` 等待四帧. 我们之所以要等待四帧, 是因为"
"要确保VR界面已经准备好并可以访问."

msgid ""
"After waiting the primary VR interface is retrieved using ``ARVRServer."
"primary_interface``, which is assigned to a variable called ``interface``. "
"The code then checks to see if ``interface`` is equal to ``null``. If "
"``interface`` is equal to ``null``, then ``_process`` is disabled using "
"``set_process`` with a value of ``false``."
msgstr ""
"等待之后, 使用 ``ARVRServer.primary_interface`` 检索主VR接口, 该接口被分配给"
"一个名为 ``interface`` 的变量. 然后代码会检查 ``interface`` 是否等于 "
"``null`` , 如果 ``interface`` 等于 ``null`` , 则使用 ``set_process`` 禁用 "
"``_process`` , 值为 ``false`` ."

msgid ""
"If ``interface`` is not ``null``, then we set the ``rect_size`` of the "
"vignette shader to the render size of the VR viewport so it takes up the "
"entire screen. We need to do this because different VR headsets have "
"different resolutions and aspect ratios, so we need to resize the node "
"accordingly. We also set the ``rect_position`` of the vignette shader to "
"zero so it is in the correct position relative to the screen."
msgstr ""
"如果 ``interface`` 不是 ``null`` , 那么我们将vignette shader的 ``rect_size`` "
"设置为VR视窗的渲染大小, 这样它就会占据整个屏幕. 我们需要这样做, 因为不同的VR"
"头显有不同的分辨率和纵横比, 所以需要相应地调整节点的大小, 还要将vignette "
"shader的 ``rect_position`` 设置为0, 这样相对于屏幕的位置处于正确."

msgid ""
"The left and right VR controllers are then retrieved and assigned to "
"``controller_one`` and ``controller_two`` respectively. Finally, the "
"vignette shader is made invisible by default by setting it's ``visible`` "
"property to ``false``."
msgstr ""
"然后检索左和右VR控制器, 并分别分配给 ``controller_one`` 和 "
"``controller_two`` 变量. 最后, 通过将vignette shader的 ``visible`` 属性设置"
"为 ``false`` , 使其默认为不可见."

msgid ""
"In ``_process`` the code first checks if either ``controller_one`` or "
"``controller_two`` are equal to ``null``. If either node is equal to "
"``null``, then ``return`` is called so nothing happens."
msgstr ""
"在 ``_process`` 中, 代码首先检查 ``controller_one`` 或 ``controller_two`` 是"
"否等于 ``null`` . 如果其中一个节点等于 ``null`` , 则调用 ``return`` 来退出函"
"数, 这样就不会发生任何事情."

msgid ""
"Then the code checks to see if either of the VR controllers are moving the "
"player using the touchpad/joystick by checking if ``directional_movement`` "
"is equal to ``true`` in ``controller_one`` or ``controller_two``. If either "
"of the VR controllers are moving the player, then the vignette shader makes "
"itself visible by setting it's ``visible`` property to ``true``. If neither "
"VR controller is moving the player, so ``directional_movement`` is ``false`` "
"in both VR controllers, than the vignette shader makes itself invisible by "
"setting it's ``visible`` property to ``false``."
msgstr ""
"然后代码会通过检查 ``controller_one`` 或 ``controller_two`` 中的 "
"``directional_movement`` 是否等于 ``true`` 来检查VR控制器中的任何一个是否在使"
"用触摸板/摇杆移动玩家. 如果VR控制器中的任何一个在移动玩家, 那么vignette "
"shader将通过设置它的 ``visible`` 属性为 ``true`` 来使自己可见."

msgid ""
"That is the whole script! Now that we have written the code, go ahead and "
"try moving around with the trackpad and/or joystick. You should find that it "
"is less motion sickness-inducing then before!"
msgstr ""
"这就是整个脚本!现在我们已经写好了代码, 去试试用触控板和/或操纵杆移动吧. 你应"
"该发现, 这时的运动不适感比以前少了很多!"

#, fuzzy
msgid ""
"As previously mentioned, there are plenty of ways to reduce motion sickness "
"in VR. Check out `this page on the Oculus Developer Center <https://"
"developer.oculus.com/design/latest/concepts/bp-locomotion/>`__ for more "
"information on how to implement locomotion and reducing motion sickness."
msgstr ""
"如前所述, 有很多方法可以减少VR中的晕动症. 请查看Oculus开发者中心的 `这个页面 "
"<https://developer.oculus.com/design/latest/concepts/bp-locomotion/>`_ , 了解"
"更多关于如何实现运动和减少晕动病的信息."

msgid "Final notes"
msgstr "最后的说明"

msgid ""
"Now you have fully working VR controllers that can move around the "
"environment and interact with :ref:`RigidBody <class_RigidBody>`-based "
"objects. In the next part of this tutorial series, we will be creating some "
"special :ref:`RigidBody <class_RigidBody>`-based objects for the player to "
"use!"
msgstr ""
"现在你已经拥有了完全可以工作的VR控制器, 可以在环境中移动, 并与基于 :ref:"
"`RigidBody <class_RigidBody>` 的对象进行交互. 在本系列教程的下一部分, 我们将"
"创建一些特殊的, 基于 :ref:`RigidBody <class_RigidBody>` 的对象供玩家使用!"

msgid ""
"You can download the finished project for this tutorial series on the Godot "
"OpenVR GitHub repository, under the releases tab!"
msgstr ""
"你可以在Godot OpenVR GitHub仓库的Release标签中下载本系列教程的成品项目！"
