# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Hand tracking"
msgstr "手势跟踪"

msgid "Only available in versions **1.1.0 and later** of the OpenXR plugin."
msgstr "仅在 OpenXR 插件的 **1.1.0 及后续版本**\\ 中可用。"

msgid ""
"The hand tracking API was originally added to OpenXR by Microsoft to make "
"the tracking information for the users hands and fingers available to the XR "
"client. The API provides pose data for all the bones in the players hands "
"but leaves some room for interpretation in how the API is implemented by the "
"XR runtime."
msgstr ""
"手势跟踪 API 最初是由微软加入 OpenXR 的，目的是让 XR 客户的能够使用用户的手掌"
"和手指的跟踪信息。API 会提供玩家双手所有骨骼的姿势数据，同时也为 XR 运行时环"
"境对此的实现方式预留了一些解释空间。"

msgid ""
"In SteamVR support was added based on Valves existing hand tracking system "
"that also provides fully rigged bone data extrapolated from controller "
"inputs and proximity sensors if hand tracking is not supported natively on "
"the system used."
msgstr ""
"在 SteamVR 中，对此的支持是基于 Valves 已有的手势跟踪系统添加的，同样会根据控"
"制器的输入推算并提供所有相连的骨骼数据，如果系统没有提供对手势跟踪的原生支"
"持，数据就会从距离传感器推算。"

msgid ""
"Meta added support for this API to their mobile OpenXR runtime tied into "
"their existing hand tracking functionality on the Quest. Note that you do "
"need to enable hand tracking in the export settings for this to be active. "
"The hand tracking API is only used for pure hand tracking, no pose data is "
"presented when controllers are used."
msgstr ""
"Meta 在为移动端 OpenXR 运行时加入对此 API 的支持时，基于的是他们在 Quest 上已"
"有的手势跟踪功能。请注意，手势跟踪需要在导出设置中启用才能激活。手势跟踪 API "
"只用于纯手部的跟踪，使用控制器时不会提供姿势数据。"

msgid ""
"When using the hand tracking API it is thus important that the capabilities "
"of the target platform are taken into account. This may improve in time as "
"feedback is provided to the OpenXR working group."
msgstr ""
"综上所述，使用手势跟踪 API 时应考虑目标平台的能力。已经向 OpenXR 工作组反馈了"
"相关情况，所以日后可能有所改善。"

msgid ""
"The hand tracking API defines the bone structure that all XR runtimes must "
"abide to however it doesn't dictate the orientation of the bones in rest or "
"any size requirements."
msgstr ""
"手势跟踪 API 定义了骨骼结构，这是所有 XR 运行时环境都需要遵守的。不过它对于放"
"松姿势下骨骼的朝向以及大小并没有要求。"

msgid "Image courtesy of Khronos OpenXR specification."
msgstr "图片来自 Khronos OpenXR 规范。"

msgid ""
"The hand tracking API is independent of the action system and doesn't make "
"use of it's poses. Hand tracking data is provided internally in global space "
"(relative to the tracking volumes origin point) and the hand tracking nodes "
"should thus have the :ref:`ARVROrigin <class_ARVROrigin>` node as their "
"parent, not a :ref:`ARVRController <class_ARVRController>` node."
msgstr ""
"手势跟踪 API 与动作系统是相互独立的，不会用到其中的姿势。手势跟踪数据在内部是"
"以全局空间提供的（相对于跟踪体积的原点），因此手势跟踪节点的父节点应该是 :"
"ref:`ARVROrigin <class_ARVROrigin>` 而不是 :ref:`ARVRController "
"<class_ARVRController>`\\ 。"

msgid ""
"The plugin exposes the hand tracking API as two seperate systems. One that "
"updates positions of a tree of nodes and one that updates bones of a :ref:"
"`Skeleton <class_Skeleton>` so mesh deformation can be used."
msgstr ""
"插件所暴露的手势跟踪 API 分为两个系统。一个用于更新树中节点的位置，一个用于更"
"新 :ref:`Skeleton <class_Skeleton>` 中的骨骼，让网格能够产生形变。"

msgid "Node based hand tracking"
msgstr "基于节点的手势跟踪"

msgid ""
"This implementation is the most versatile as it doesn't require any "
"knowledge of the hand model in rest pose. Note that the plugin comes with "
"two example scenes called `left_hand_nodes.tscn` and `right_hand_nodes.tscn` "
"that you can instance as child nodes of the `ARVROrigin` node. These scenes "
"contain logic to automatically resize the used meshes to fit the size of the "
"provided bone data."
msgstr ""
"这个实现的用途是最通用的，因为不需要任何放松姿势下手部模型的信息。请注意，这"
"个插件附带了两个示例场景，分别叫作 `left_hand_nodes.tscn`\\ （左手节点）和 "
"`right_hand_nodes.tscn`\\ （右手节点），可以实例化为 `ARVROrigin` 的子节点。"
"这些场景中包含了自适应的逻辑，会根据提供的骨骼数据大小自动调整所用网格的大"
"小。"

msgid ""
"At the root of this scene is a :ref:`Spatial <class_Spatial>` node that has "
"`config/OpenXRHand.gdns` assigned as its script. This class from the plugin "
"will position the spatial node at the base of the hand (see Palm in our "
"image up above) and will update the position and orientation of its children."
msgstr ""
"这个场景的根是一个 :ref:`Spatial <class_Spatial>` 节点，附加了 `config/"
"OpenXRHand.gdns` 脚本。这个类是插件提供的，会将这个空间节点放置到手的基准位置"
"（见上图中的 Palm）并更新其子节点的位置和朝向。"

msgid "There are two properties here:"
msgstr "这里有两个属性："

msgid ""
"`Hand` identifies whether we are tracking the position of the left or right "
"hand."
msgstr "`Hand` 表示我们跟踪的是左手还是右手的位置。"

msgid ""
"`Motion Range` is only available on SteamVR and limits how far the hand can "
"close, this is only used in conjunction with infered hand tracking based on "
"controller input."
msgstr ""
"`Motion Range` 只在 SteamVR 上可用，会限制手的最大闭拢距离，只会在使用由控制"
"器输入推算而来的手势跟踪时用到。"

msgid ""
"Our spatial node needs a number of child nodes with hardcoded names that "
"will be updated by our hand tracking system. The type of nodes is not "
"important, our example script uses :ref:`MeshInstance <class_MeshInstance>` "
"nodes to also visualise the bones."
msgstr ""
"我们的空间节点需要有一些名称写死的子节点，这样我们的手势跟踪系统就能够对它们"
"进行更新。这些节点的类型不重要，我们的示例脚本使用的是 :ref:`MeshInstance "
"<class_MeshInstance>` 节点，这样我们就可以实际看到骨骼。"

msgid ""
"First we find the child node `Wrist`, underneath here there are nodes for "
"each finger. Each node starts with the name of the finger followed by the "
"name of the bone. The finger names are `Thumb`, `Index`, `Middle`, `Ring` "
"and `Little`. The bone names are `Metacarpal`, `Proximal`, `Intermediate`, "
"`Distal` and `Tip`. Ergo IndexDistal is the distal bone of the index finger."
msgstr ""
"首先我们找到 `Wrist`\\ （手腕）子节点，它下面的就是各个手指的节点了。节点的名"
"字都以手指的名称开始，后面跟着的是骨骼的名称。手指的名称有 `Thumb`\\ （拇"
"指）、\\ `Index`\\ （食指）、\\ `Middle`\\ （中指）、\\ `Ring`\\ （无名"
"指）、\\ `Little`\\ （小指）。骨骼的名称有 `Metacarpal`\\ （掌骨）、\\ "
"`Proximal`\\ （近端）、\\ `Intermediate`\\ （中部）、\\ `Distal`\\ （远"
"端）、\\ `Tip`\\ （尖端）。因此，IndexDistal 指的是食指的远端骨骼。"

msgid "The thumb is the only finger that does not have a intermediate bone!"
msgstr "食指是唯一没有中部骨骼的手指！"

msgid ""
"The parent-child relationships of these nodes are important and the hand "
"will only look correct if this structure if followed exactly. Note that "
"adding extra nodes isn't a problem, the example scenes add a number of extra "
"bone meshes in to complete the look of the hand. Note also that the example "
"scenes have scripts attached to the wrist node that update the size and "
"positions of these extra nodes."
msgstr ""
"这些节点的父子关系很重要，只有严格遵循这个结构，手才会看起来正常。请注意，加"
"入额外的节点不会有问题，示例场景中就加入了一些额外的骨骼网格，让手看起来更完"
"备。另外也请注意，示例场景中为手腕节点添加了脚本，会更新这些额外节点的大小和"
"位置。"

msgid "Skeleton based hand tracking"
msgstr "基于骨架的手势跟踪"

msgid ""
"The second method supported by the OpenXR plugin is exposing the bone data "
"as a :ref:`Skeleton <class_Skeleton>` node. In this case the solution is "
"divided in two classes, one for placing the hand in space and the second to "
"animate the aforementioned skeleton by updating the bone poses of the "
"skeleton."
msgstr ""
"OpenXR 插件支持的第二种方法是将骨骼数据暴露为 :ref:`Skeleton "
"<class_Skeleton>` 节点。此时，解决方案分为两个类，一个用于放置手的位置，一个"
"用于更新之前提到的骨架中的骨骼，从而进行动画。"

msgid ""
"This approach allows deforming a mesh which is a visually more pleasing "
"solution however differences in implementation between the platforms does "
"pose some problems."
msgstr ""
"这种方法可以用来让网格发生形变，看上去会更舒服，但不同平台实现上的区别也会带"
"来一些问题。"

msgid ""
"Microsoft has added another API to OpenXR that allows for retrieving a "
"properly skinned hand mesh however as they are currently the only platform "
"supporting this API it has not yet been added to the plugin."
msgstr ""
"微软为 OpenXR 加入了一个 API，可以获取一个正确蒙皮后的手部网格。但因为目前只"
"有他们这个平台支持这个 API，所以本插件还未加入支持。"

msgid ""
"At this point in time the plugin only exposes the data as it is provided by "
"the OpenXR runtime. The plugin has an example implementation based on meshes "
"that Valve has made publicly available however these work most reliable when "
"used in conjunction with SteamVR. These scenes are `scenes/left_hand_mesh."
"tscn` and `scenes/right_hand_mesh.tscn` and can be childed to the :ref:"
"`ARVROrigin <class_ARVROrigin>` node."
msgstr ""
"目前，插件所暴露的是 OpenXR 运行时所提供的数据。插件有一个示例实现，其中的网"
"格是 Valve 提供给公众使用的，不过只有在和 SteamVR 一起使用时才能达到最稳定的"
"效果。这些场景是 `scenes/left_hand_mesh.tscn`\\ （左手网格）和 `scenes/"
"right_hand_mesh.tscn`\\ （右手网格），可以作为 :ref:`ARVROrigin "
"<class_ARVROrigin>` 的子节点使用。"

msgid "Below is an overview of the steps needed to implement your own version."
msgstr "自行实现的大致步骤如下。"

msgid ""
"The best way to implement this logic is to ask an artist to model a hand in "
"3D software using real hands dimensions and create an armature for the hand "
"that follows the bone structure exactly as the OpenXR specification dictates "
"in the image at the top of this article. When skinning special care needs to "
"be taken keeping in mind that if full hand tracking is available, the "
"distance between joints will be determined by the actual size of the players "
"hand and may thus be different to the 3D model. After importing the model "
"into Godot you can add the required scripts to make everything work."
msgstr ""
"实现这种逻辑的最佳方式，是让美术在 3D 软件中使用真实手部尺寸建模并为其创建骨"
"架，骨架必须遵循前文给出的 OpenXR 规范图中的骨骼结构。蒙皮时需要额外注意，如"
"果完整的手势跟踪可用，那么关节之间的距离是由实际玩家的手部尺寸决定的，可能会"
"与 3D 模型中的不同。将模型导入 Godot 后，你就可以加入所需的脚本，让一切正常工"
"作了。"

msgid ""
"To place the hand mesh in space a node needs to be added as a child to the :"
"ref:`ARVROrigin <class_ARVROrigin>` node, this node needs to have the "
"`config/OpenXRPose.gdns` script attached. When importing a 3D file you can "
"add this script to the root node of the imported model."
msgstr ""
"要把这个手部网格放进游戏空间中，你需要为 :ref:`ARVROrigin "
"<class_ARVROrigin>` 节点添加一个子节点，这个节点需要附加有 `config/"
"OpenXRPose.gdns` 脚本。导入 3D 文件时，你可以将这个脚本添加到导入后的模型的根"
"节点。"

msgid ""
"The `OpenXRPose` script isn't just used by the hand logic but also exposes "
"other pose locations configured in the action map."
msgstr ""
"并不是只有手部逻辑才需要使用 `OpenXRPose` 脚本，它还暴露了动作映射中配置的其"
"他姿势位置。"

msgid "The following properties can be set on this node:"
msgstr "这个节点有如下属性可供设置："

msgid ""
"`Invisible If Inactive` enables logic that will automatically make this node "
"invisible if the hand is not being tracked."
msgstr "`Invisible If Inactive` 在未跟踪手势时自动隐藏该节点。"

msgid ""
"`Action` specifies which action in the actionmap is being tracked, this "
"needs to be set to the special type `SkeletonBase`."
msgstr ""
"`Action` 指定跟踪的是动作映射中的哪个动作，需要设为特殊的 `SkeletonBase` 类"
"型。"

msgid ""
"`Path` specified the OpenXR input path, this is `/user/hand/left` for the "
"left hand and `/user/hand/right` for the right hand."
msgstr ""
"`Path` 指定 OpenXR 输入路径，左手为 `/user/hand/left` 而右手为 `/user/hand/"
"right`\\ 。"

msgid ""
"The next step is adding the script `config/OpenXRSkeleton.gdns` to the "
"skeleton node of the 3D model. This script has the same two properties as "
"the `OpenXRHand` script namely `Hand` and `Motion Range` and they have the "
"same use."
msgstr ""
"下一步是将 `config/OpenXRSkeleton.gdns` 脚本添加到 3D 模型的骨架节点上。这个"
"脚本也有 `OpenXRHand` 脚本的两个属性，即 `Hand` 和 `Motion Range`\\ ，使用方"
"法也一样。"

msgid ""
"Note that the bone names are standardised, the list of bone names is "
"presented below and need to be suffixed with either `_L` or `_R` depending "
"on whether the bone is for respectively the left hand or the right hand:"
msgstr ""
"请注意，骨骼的名称已经标准化，下面是骨骼的名称列表，需要根据该骨骼属于左手还"
"是右手加上对应的 `_L` 或 `_R` 后缀："

msgid "Palm"
msgstr "Palm"

msgid "Wrist"
msgstr "Wrist"

msgid "Thumb_Metacarpal"
msgstr "Thumb_Metacarpal"

msgid "Thumb_Proximal"
msgstr "Thumb_Proximal"

msgid "Thumb_Distal"
msgstr "Thumb_Distal"

msgid "Thumb_Tip"
msgstr "Thumb_Tip"

msgid "Index_Metacarpal"
msgstr "Index_Metacarpal"

msgid "Index_Proximal"
msgstr "Index_Proximal"

msgid "Index_Intermediate"
msgstr "Index_Intermediate"

msgid "Index_Distal"
msgstr "Index_Distal"

msgid "Index_Tip"
msgstr "Index_Tip"

msgid "Middle_Metacarpal"
msgstr "Middle_Metacarpal"

msgid "Middle_Proximal"
msgstr "Middle_Proximal"

msgid "Middle_Intermediate"
msgstr "Middle_Intermediate"

msgid "Middle_Distal"
msgstr "Middle_Distal"

msgid "Middle_Tip"
msgstr "Middle_Tip"

msgid "Ring_Metacarpal"
msgstr "Ring_Metacarpal"

msgid "Ring_Proximal"
msgstr "Ring_Proximal"

msgid "Ring_Intermediate"
msgstr "Ring_Intermediate"

msgid "Ring_Distal"
msgstr "Ring_Distal"

msgid "Ring_Tip"
msgstr "Ring_Tip"

msgid "Little_Metacarpal"
msgstr "Little_Metacarpal"

msgid "Little_Proximal"
msgstr "Little_Proximal"

msgid "Little_Intermediate"
msgstr "Little_Intermediate"

msgid "Little_Distal"
msgstr "Little_Distal"

msgid "Little_Tip"
msgstr "Little_Tip"

msgid ""
"Finally, and this is standard Godot functionality, a common addition to hand "
"tracking is to track the location of the tip of a finger for physics "
"interaction. This can be accomplished with the :ref:`BoneAttachment "
"<class_BoneAttachment>` node. Simply add this as a child node to the :ref:"
"`Skeleton <class_Skeleton>` node and select the bone you want to track. Now "
"you can add the desired physics object as a child to this node."
msgstr ""
"最后，跟踪指尖的位置进行物理交互是手势跟踪的常见附加功能，也是标准的 Godot 功"
"能。可以使用 :ref:`BoneAttachment <class_BoneAttachment>` 节点来实现。将其添"
"加为 :ref:`Skeleton <class_Skeleton>` 节点的子节点，并选择你想要跟踪的骨骼即"
"可。现在你就可以将所需的物理对象添加为这个节点的子项了。"

msgid "Translation status"
msgstr "翻译状态"
