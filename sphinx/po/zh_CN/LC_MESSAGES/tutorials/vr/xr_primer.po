# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2022, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-09 16:03+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "AR/VR primer"
msgstr "AR/VR 示例"

msgid ""
"This tutorial gives you a springboard into the world of AR and VR in the "
"Godot game engine."
msgstr "本教程为您提供了迈向Godot游戏引擎中AR和VR世界的跳板."

msgid ""
"A new architecture was introduced in Godot 3 called the AR/VR Server. On top "
"of this architecture, specific implementations are available as interfaces, "
"most of which are plugins based on GDNative. This tutorial focuses purely on "
"the core elements abstracted by the core architecture. This architecture has "
"enough features for you to create an entire VR experience that can then be "
"deployed for various interfaces. However, each platform often has some "
"unique features that are impossible to abstract. Such features will be "
"documented on the relevant interfaces and fall outside of the scope of this "
"primer."
msgstr ""
"Godot 3中引入了一个新的框架, 称为AR/VR服务器. 在这个框架之上, 具体的实现可以"
"将其作为接口使用, 其中大部分是基于GDNative的插件. 本教程只关注核心框架所抽象"
"出的核心元素. 这个框架有足够的功能让你创建一个完整的VR体验, 然后可以为各种接"
"口部署. 然而, 每个平台往往有一些独特的功能, 是不可能抽象出来的. 这样的功能将"
"被记录在相关的接口上, 不属于本入门手册的范围."

msgid "AR/VR server"
msgstr "AR/VR 服务器"

msgid ""
"When Godot starts, each available interface will make itself known to the AR/"
"VR server. GDNative interfaces are setup as singletons; as long as they are "
"added to the list of GDNative singletons in your project, they will make "
"themselves known to the server."
msgstr ""
"当Godot启动时, 每个可用的接口都会让AR/VR服务器知道.GDNative接口被设置为单例；"
"只要它们被添加到你项目中的GDNative单例列表中, 它们就会被服务器知道."

msgid ""
"You can use the function :ref:`get_interfaces() "
"<class_ARVRServer_method_get_interfaces>` to return a list of available "
"interfaces, but for this tutorial, we're going to use the :ref:`native "
"mobile VR interface <class_MobileVRInterface>` in our examples. This "
"interface is a straightforward implementation that uses the 3DOF sensors on "
"your phone for orientation and outputs a stereoscopic image to the screen. "
"It is also available in the Godot core and outputs to screen on desktop, "
"which makes it ideal for prototyping or a tutorial such as this one."
msgstr ""
"你可以使用函数 :ref:`get_interfaces() "
"<class_ARVRServer_method_get_interfaces>` 来返回一个可用的接口列表, 但在本教"
"程中, 我们将在我们的例子中使用 :ref:`native mobile VR interface "
"<class_MobileVRInterface>`. 这个接口是一个直接的实现, 使用手机上的3DOF传感器"
"来确定方向, 并向屏幕输出立体图像. 它也可以在Godot核心中使用, 并在桌面输出到屏"
"幕上, 这使它成为原型设计或像这样的教程的理想选择."

msgid "To enable an interface, you execute the following code:"
msgstr "要启用接口, 请执行以下代码:"

msgid ""
"This code finds the interface we wish to use, initializes it and, if that is "
"successful, binds the main viewport to the interface. This last step gives "
"some control over the viewport to the interface, which automatically enables "
"things like stereoscopic rendering on the viewport."
msgstr ""
"这段代码找到我们希望使用的接口, 并对其进行了初始化, 如果成功的话, 将主视窗与"
"该接口绑定. 这最后一步将视窗的一些控制权交给了接口, 从而自动实现了视窗上的立"
"体渲染等功能."

msgid ""
"For our mobile VR interface, and any interface where the main input is "
"directly displayed on screen, the main viewport needs to be the viewport "
"where :ref:`arvr<class_Viewport_property_arvr>` is set to ``true``. But for "
"interfaces that render on an externally attached device, you can use a "
"secondary viewport. In the latter case, a viewport that shows its output on "
"screen will show an undistorted version of the left eye, while showing the "
"fully processed stereoscopic output on the device."
msgstr ""
"对于我们的移动VR界面, 以及任何主要输入直接显示在屏幕上的界面, 主视窗需要是 :"
"ref:`arvr<class_Viewport_property_arvr>` 被设置为 ``true`` 的那个视窗. 但是对"
"于在外部连接设备上渲染的界面, 你可以使用一个辅助视窗. 在后一种情况下, 在屏幕"
"上显示其输出的视窗将显示左眼的未扭曲版本, 而在设备上显示完成处理的立体输出."

msgid ""
"Finally, you should only initialize an interface once; switching scenes and "
"reinitializing interfaces will just introduce a lot of overhead. If you want "
"to turn the headset off temporarily, just disable the viewport or set :ref:"
"`arvr<class_Viewport_property_arvr>` to ``false`` on the viewport. In most "
"scenarios though, you wouldn't disable the headset once you're in VR, this "
"can be disconcerting to the gamer."
msgstr ""
"最后, 您应该只初始化一次界面； 切换场景和重新初始化界面都会带来很多性能消耗. "
"如果您想暂时关闭耳机, 只需禁用视窗或在视窗上将 :ref:"
"`arvr<class_Viewport_property_arvr>` 设置为 ``false``. 不过, 在大多数情况下, "
"一旦玩家进入VR, 您最好不要禁用耳机, 因为这会让玩家感到很不舒服."

msgid "New AR/VR nodes"
msgstr "新的 AR/VR 节点"

msgid ""
"Three new node types have been added for supporting AR and VR in Godot and "
"one additional node type especially for AR. These are:"
msgstr ""
"添加了三种新节点类型, 用于支持Godot中的AR和VR, 以及一种额外的节点类型, 尤其是"
"AR. 这些是:"

msgid ":ref:`ARVROrigin <class_ARVROrigin>` - our origin point in the world"
msgstr ":ref:`ARVROrigin <class_ARVROrigin>` - 我们在世界上的起源点"

msgid ""
":ref:`ARVRCamera <class_ARVRCamera>` - a special subclass of the camera, "
"which is positionally tracked"
msgstr ""
":ref:`ARVRCamera <class_ARVRCamera>` - 一个特殊的相机子类, 可被定位追踪"

msgid ""
":ref:`ARVRController <class_ARVRController>` - a new spatial class, which "
"tracks the location of a controller"
msgstr ""
":ref:`ARVRController <class_ARVRController>` - 一个新的空间类, 它跟踪控制器的"
"位置"

msgid ""
":ref:`ARVRAnchor <class_ARVRAnchor>` - an anchor point for an AR "
"implementation mapping a real world location into your virtual world"
msgstr ""
":ref:`ARVRAnchor <class_ARVRAnchor>` - AR实现的一个定位点, 将真实世界的位置映"
"射到您的虚拟世界"

msgid ""
"The first two must exist in your scene for AR/VR to work and this tutorial "
"focuses purely on them."
msgstr "前两个必须存在于场景中,AR / VR才能工作, 本教程仅关注它们."

msgid ""
":ref:`ARVROrigin <class_ARVROrigin>` is an important node, you must have one "
"and only one of these somewhere in your scene. This node maps the center of "
"your real world tracking space to a location in your virtual world. "
"Everything else is positionally tracked in relation to this point. Where "
"this point lies exactly differs from one implementation to another, but the "
"best example to understand how this node works is to take a look at a room "
"scale location. While we have functions to adjust the point to center it on "
"the player by default, the origin point will be the center location of the "
"room you are in. As you physically walk around the room, the location of the "
"HMD is tracked in relation to this center position and the tracking is "
"mirror in the virtual world."
msgstr ""
":ref:`ARVROrigin <class_ARVROrigin>` 是一个重要的节点, 你必须在场景中某处有且"
"仅有一个这样的节点. 该节点将现实世界的跟踪空间中心映射到虚拟世界的某个位置. "
"其他所有的东西都是相对于这个点进行位置跟踪. 这个点处在哪里, 有不同的实现, 但"
"是理解这个节点如何工作的最好例子是看一个房间比例的位置. 虽然拥有函数可以调整"
"这个点, 使其默认在玩家身上居中, 但原点将是你所在房间的中心位置. 当你在房间里"
"实际走动时,HMD的位置会被跟踪到与这个中心位置的关系, 并且在虚拟世界中的跟踪是"
"镜像的."

msgid ""
"To keep things simple, when you physically move around your room, the ARVR "
"Origin point stays where it is, the position of the camera and controllers "
"will be adjusted according to your movements. When you move through the "
"virtual world, either through controller input or when you implement a "
"teleport system, it is the position of the origin point which you will have "
"to adjust."
msgstr ""
"为了简单起见, 当你在房间里实际移动时,ARVR原点保持在原处, 摄像机和控制器的位置"
"将根据你的移动而调整. 当你在虚拟世界中移动时, 无论是通过控制器输入还是实现传"
"送系统, 你必须调整的是原点的位置."

msgid ""
":ref:`ARVRCamera <class_ARVRCamera>` is the second node that must always be "
"a part of your scene and it must always be a child node of your origin node. "
"It is a subclass of Godot's normal camera. However, its position is "
"automatically updated each frame based on the physical orientation and "
"position of the HMD. Also due to the precision required for rendering to an "
"HMD or rendering an AR overlay over a real world camera, most of the "
"standard camera properties are ignored. The only properties of the camera "
"that are used are the near and far plane settings. The FOV, aspect ratio and "
"projection mode are all ignored."
msgstr ""
":ref:`ARVRCamera <class_ARVRCamera>` 是第二个节点, 它必须始终是你的场景的一部"
"分, 它必须始终是你的原始节点的子节点. 它是Godot普通摄像机的一个子类. 然而, 它"
"的位置在每一帧都会根据HMD的物理方向和位置自动更新. 同时, 由于向HMD渲染或在真"
"实世界的相机上渲染AR覆盖所需的精度, 大多数标准的相机属性被忽略了.FOV, 长宽比"
"和投影模式都被忽略了. 唯一使用的相机属性是近平面和远平面的设置."

msgid ""
"Note that, for our native mobile VR implementation, there is no positional "
"tracking, only the orientation of the phone and by extension, the HMD is "
"tracked. This implementation artificially places the camera at a height (Y) "
"of 1.85."
msgstr ""
"请注意, 对于我们的原生移动VR实现来说, 没有位置追踪, 只有手机的方向, 以及延伸"
"到HMD的方向被追踪. 这种实现方式人为地将摄像头置于1.85的高度(Y)."

msgid ""
"Conclusion: your minimum setup in your scene to make AR or VR work should "
"look like this:"
msgstr "结论: 你在场景中使AR或VR工作的最低设置应该是这样的:"

msgid ""
"And that's all you need to get started with the native mobile interface. "
"Obviously, you need to add something more into your scene, so there is "
"something to see, but after that, you can export the game to your phone of "
"choice, pop it into a viewer and away you go."
msgstr ""
"这就是你需要开始使用原生移动界面的全部内容. 显然, 你需要在你的场景中添加更多"
"的东西, 所以有一些东西可以看, 但在那之后, 你可以把游戏导出到你选择的手机上, "
"把它插入一个浏览器, 然后就可以了."

msgid "Official plugins and resources"
msgstr "官方插件和资源"

msgid ""
"As mentioned earlier, Godot does not support the various VR and AR SDKs out "
"of the box, you need a plugin for the specific SDK you want to use. There "
"are several official plugins available in the `GodotVR Repository <https://"
"github.com/GodotVR>`__."
msgstr ""
"前面提到过，Godot 没有自带对各种 VR 和 AR SDK 的支持，想要使用某个 SDK，就需"
"要使用插件。\\ `GodotVR 仓库 <https://github.com/GodotVR>`__\\ 中有一些官方插"
"件。"

msgid ""
"`Godot OpenXR <https://github.com/GodotVR/godot_openxr>`_: This is the "
"**official XR plugin** starting with Godot **3.4**. It supports OpenXR, an "
"open standard for designing and building cross-platform VR and AR software. "
"Tested with SteamVR, Monada and Oculus OpenXR (desktop and mobile) runtimes."
msgstr ""
"`Godot OpenXR <https://github.com/GodotVR/godot_openxr>`__\\ ：自 Godot "
"**3.4** 开始，这是\\ **官方 XR 插件**\\ 。支持 OpenXR，即设计与构建 VR 和 AR "
"软件的开放标准。已在 SteamVR、Monada、Oculus 的 OpenXR（桌面及移动平台）运行"
"时环境中测试通过。"

msgid "See :ref:`doc_openxr_introduction`."
msgstr "请参阅 :ref:`doc_openxr_introduction`\\ 。"

msgid ""
"`Godot Oculus Mobile <https://github.com/GodotVR/godot_oculus_mobile>`_ "
"provides :ref:`support for the Meta Quest <doc_developing_for_oculus_quest>`."
msgstr ""
"`Godot Oculus Mobile <https://github.com/GodotVR/godot_oculus_mobile>`_ 提供"
"\\ :ref:`对 Meta Quest 的支持 <doc_developing_for_oculus_quest>`\\ 。"

msgid ""
"**Note**: This plugin has been deprecated starting with Godot 3.4. We "
"recommend migrating to the `Godot OpenXR <https://github.com/GodotVR/"
"godot_openxr>`_ plugin instead."
msgstr ""
"**注意**\\ ：自 Godot 3.4 起，该插件已弃用。我们推荐迁移到 `Godot OpenXR "
"<https://github.com/GodotVR/godot_openxr>`_ 插件。"

msgid ""
"`Godot OpenVR <https://github.com/GodotVR/godot_openvr>`_ (not to be "
"confused with OpenXR) supports the OpenVR SDK used by Steam."
msgstr ""
"`Godot OpenVR <https://github.com/GodotVR/godot_openvr>`_\\ （不要与 OpenXR "
"混淆）支持 Steam 使用的 OpenVR SDK。"

msgid ""
"`Godot Oculus <https://github.com/GodotVR/godot_oculus>`__ supports the "
"Oculus SDK (desktop headsets only)."
msgstr ""
"`Godot Oculus <https://github.com/GodotVR/godot_oculus>`__ 支持 Oculus SDK"
"（仅桌面平台头戴设备）。"

msgid ""
"`Godot OpenHMD <https://github.com/GodotVR/godot_openhmd>`_ supports "
"OpenHMD, an open source API and drivers for headsets."
msgstr ""
"`Godot OpenHMD <https://github.com/GodotVR/godot_openhmd>`__ 支持 OpenHMD，这"
"是一个开源的头戴设备 API 和驱动程序。"

msgid "These plugins can be downloaded from GitHub or the Godot Asset Library."
msgstr "这些插件可以从 GitHub 或 Godot 素材库下载。"

msgid "In addition to the plugins, there are several official demos."
msgstr "除了插件之外，还有几个官方的 demo。"

msgid "`Godot Oculus Demo <https://github.com/GodotVR/godot-oculus-demo>`__."
msgstr ""
"`Godot Oculus Demo <https://github.com/GodotVR/godot-oculus-demo>`__\\ 。"

msgid ""
"`Godot OpenVR FPS <https://github.com/GodotVR/godot_openvr_fps>`__ (the "
"tutorial for this project is :ref:`doc_vr_starter_tutorial_part_one`)."
msgstr ""
"`Godot OpenVR FPS <https://github.com/GodotVR/godot_openvr_fps>`__\\ （这个项"
"目的教程是 :ref:`doc_vr_starter_tutorial_part_one`\\ ）。"

msgid ""
"`Godot XR tools <https://github.com/GodotVR/godot-xr-tools>`__, which shows "
"implementations for VR features such as movement and picking up objects."
msgstr ""
"`Godot XR 工具 <https://github.com/GodotVR/godot-xr-tools>`__\\ ，它展示了 "
"VR 功能的实现，如移动和拾取物体。"

msgid "Other things to consider"
msgstr "其他需要考虑的事情"

msgid ""
"There are a few other subjects that we need to briefly touch upon in this "
"primer that are important to know."
msgstr "我们需要在本入门手册中简要介绍一些其他一些重要的知识。"

msgid ""
"The first are our units. In normal 3D games, you don't have to think a lot "
"about units. As long as everything is at the same scale, a box sized 1 unit "
"by 1 unit by 1 unit can be any size from a cub you can hold in your hand to "
"something the size of a building. In AR and VR, this changes because things "
"in your virtual world are mapped to things in the real world. If you step 1 "
"meter forward in the real world, but you only move 1 cm forward in your "
"virtual world, you have a problem. The same with the position of your "
"controllers; if they don't appear in the right relative space, it breaks the "
"immersion for the player. Most VR platforms, including our AR/VR Server, "
"assume that 1 unit = 1 meter. The AR/VR server, however, has a property "
"that, for convenience, is also exposed on the ARVROrigin node called world "
"scale. For instance, setting this to a value of 10 changes our coordinate "
"system so 10 units = 1 meter."
msgstr ""
"首先是我们的单位。在一般的 3D 游戏中，你不需要考虑太多单位的问题。只要所有的"
"东西都是一样的比例，单位体积的盒子可以是任意大小，小到可以拿在手里小熊，大到"
"一栋楼房。在 AR 和 VR 中，这种情况会发生变化，因为虚拟世界中的东西会映射到现"
"实世界中。如果在现实世界中向前走 1 米，但在你的虚拟世界中只向前移动了 1 厘"
"米，就有了问题。你的控制器的位置也是一样的，如果它们没有出现在正确的相对空"
"间，就会打破玩家的沉浸感。大多数 VR 平台，包括 AR/VR 服务器，都假设 1 个单位 "
"= 1 米。不过为了方便起见，AR/VR 服务器还通过 ARVROrigin 节点暴露了一个属性，"
"叫做世界尺度。例如，将其设置为 10 的值，就会改变我们的坐标系，此时 10 个单位 "
"= 1 米。"

msgid ""
"Performance is another thing that needs to be carefully considered. "
"Especially VR taxes your game a lot more than most people realize. For "
"mobile VR, you have to be extra careful here, but even for desktop games, "
"there are three factors that make life extra difficult:"
msgstr ""
"性能是另一件需要仔细考虑的事情. 特别是VR对你的游戏的影响比大多数人意识到的要"
"大得多. 对于移动VR, 你必须在这里格外小心, 但即使是桌面游戏, 也有三个因素使生"
"活变得更加困难:"

msgid ""
"You are rendering stereoscopic, two for the price of one. While not exactly "
"doubling the work load and with things in the pipeline such as supporting "
"the new MultiView OpenGL extension in mind, there still is an extra workload "
"in rendering images for both eyes"
msgstr ""
"你渲染的是立体影像，一举两得。虽然并没有完全把工作量加倍，但要在管线中支持新"
"的 MultiView OpenGL 扩展之类的内容，为双眼渲染图像仍然存在额外的工作量"

msgid ""
"A normal game will run acceptably on 30fps and ideally manages 60fps. That "
"gives you a big range to play with between lower end and higher end "
"hardware. For any HMD application of AR or VR, however, 60fps is the "
"absolute minimum and you should target your games to run at a stable 90fps "
"to ensure your users don't get motion sickness right off the bat."
msgstr ""
"一个正常的游戏可以在30fps的情况下运行, 最好能达到60fps. 这让你在低端和高端硬"
"件之间有很大的发挥空间. 然而, 对于任何AR或VR的HMD应用,60fps是绝对的最低限度, "
"你应该把你的游戏定位在一个稳定的90fps运行, 以确保你的用户不会马上出现晕动症."

msgid ""
"The high FOV and related lens distortion effect require many VR experiences "
"to render at double the resolution. Yes a VIVE may only have a resolution of "
"1080x1200 per eye, we're rendering each eye at 2160x2400 as a result. This "
"is less of an issue for most AR applications."
msgstr ""
"高FOV和相关的镜头失真效果需要许多VR体验才能以两倍的分辨率呈现. 是的,VIVE可能"
"只有每只眼睛1080x1200的分辨率, 因此我们将每只眼睛渲染为2160x2400. 对于大多数"
"AR应用程序来说, 这不是一个问题."

msgid ""
"All in all, the workload your GPU has in comparison with a normal 3D game is "
"a fair amount higher. While things are in the pipeline to improve this, such "
"as MultiView and foveated rendering, these aren't supported on all devices. "
"This is why you see many VR games using a more art style and if you pay "
"close attention to those VR games that go for realism, you'll probably "
"notice they're a bit more conservative on the effects or use some good old "
"optical trickery."
msgstr ""
"总而言之, 与普通的3D游戏相比, 你的GPU的工作负荷要高得多. 虽然有一些事情正在进"
"行中, 以改善这一点, 如MultiView和foveated rendering, 但这些并不是所有设备都支"
"持的. 这就是为什么你看到许多VR游戏使用更多的艺术风格, 如果你密切关注那些追求"
"现实主义的VR游戏, 你可能会注意到他们在效果上更保守一些, 或者使用一些好的老式"
"光学技巧."

msgid "Translation status"
msgstr "翻译状态"
