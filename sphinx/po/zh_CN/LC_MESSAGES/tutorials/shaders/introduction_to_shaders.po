# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Introduction to shaders"
msgstr "着色器简介"

msgid ""
"This page explains what shaders are and will give you an overview of how "
"they work in Godot. For a detailed reference of the engine's shading "
"language, see :ref:`doc_shading_language`."
msgstr ""
"本页面会讲解什么是着色器，会为你综述其在 Godot 中的使用方法。引擎中着色语言的"
"详细参考见 :ref:`doc_shading_language`\\ 。"

msgid ""
"Shaders are a special kind of program that runs on Graphics Processing Units "
"(GPUs). They were initially used to shade 3D scenes but can nowadays do much "
"more. You can use them to control how the engine draws geometry and pixels "
"on the screen, allowing you to achieve all sorts of effects."
msgstr ""
"着色器（Shader）是一种在图形处理单元（GPU）上运行的特殊程序。他们最初使用来"
"为 3D 场景着色的，不过现在能做的事情就更多了。你可以用它们来控制引擎在屏幕上"
"绘制几何体以及像素的方式，可以用来实现各种特效。"

msgid ""
"Modern rendering engines like Godot draw everything with shaders: graphics "
"cards can run thousands of instructions in parallel, leading to incredible "
"rendering speed."
msgstr ""
"类似 Godot 的现代渲染引擎都会用着色器来执行所有绘制操作：图形卡可以并行执行成"
"千上万条指令，可以达到惊人的渲染速度。"

msgid ""
"Because of their parallel nature, though, shaders don't process information "
"the way a typical program does. Shader code runs on each vertex or pixel in "
"isolation. You cannot store data between frames either. As a result, when "
"working with shaders, you need to code and think differently from other "
"programming languages."
msgstr ""
"因为天生就是并行的，所以着色器处理信息的方式与普通的程序有所不同。着色器代码"
"是单独针对顶点或像素执行的。你也无法在帧与帧之间存储数据。因此，使用着色器"
"时，你需要使用与其他编程语言不同的编码和思考方式。"

msgid ""
"Suppose you want to update all the pixels in a texture to a given color. In "
"GDScript, your code would use ``for`` loops::"
msgstr ""
"假设你想要把纹理中的所有像素点都设置成某个给定的颜色。使用 GDScript，你的代码"
"会用 ``for`` 循环： ::"

msgid ""
"Your code is already part of a loop in a shader, so the corresponding code "
"would look like this."
msgstr "在着色器中，你的代码已经是循环的一部分了，所以对应的代码应该类似这样。"

msgid ""
"The graphics card calls the ``fragment()`` function once or more for each "
"pixel it has to draw. More on that below."
msgstr ""
"图形卡会为需要绘制的每一个像素调用若干次 ``fragment()`` 函数。后面会详细说"
"明。"

msgid "Shaders in Godot"
msgstr "Godot 中的着色器"

msgid ""
"Godot provides a shading language based on the popular OpenGL Shading "
"Language (GLSL) but simplified. The engine handles some of the lower-level "
"initialization work for you, making it easier to write complex shaders."
msgstr ""
"Godot 所提供的着色语言是基于流行的 OpenGL 着色语言（GLSL）的简化。引擎会为你"
"处理一些底层的初始化工作，让编写复杂着色器更为简单。"

msgid ""
"In Godot, shaders are made up of three main functions: ``vertex()``, "
"``fragment()``, and ``light()``."
msgstr ""
"在 Godot 中，着色器由三个主要函数组成：\\ ``vertex()``\\ 、\\ "
"``fragment()``\\ 、\\ ``light()``\\ 。"

msgid ""
"The ``vertex()`` function runs over all the vertices in the mesh and sets "
"their positions and some other per-vertex variables."
msgstr ""
"``vertex()`` 函数运行在网格的所有顶点上，会设置它们的位置和一些其他与该顶点相"
"关的变量。"

msgid ""
"The ``fragment()`` function runs for every pixel covered by the mesh. It "
"uses values output by the ``vertex()`` function, interpolated between the "
"vertices."
msgstr ""
"``fragment()`` 函数运行在网格所覆盖的每一个像素上。它会使用 ``vertex()`` 函数"
"所输出的值，这些值会在顶点之间进行插值。"

msgid ""
"The ``light()`` function runs for every pixel and for every light. It takes "
"variables from the ``fragment()`` function and from its previous runs."
msgstr ""
"``light()`` 函数运行在每一个像素以及每一盏灯光上。他的变量是从 "
"``fragment()`` 函数以及之前的运行中获取的。"

msgid ""
"The ``light()`` function won't run if the ``vertex_lighting`` render mode is "
"enabled, or if **Rendering > Quality > Shading > Force Vertex Shading** is "
"enabled in the Project Settings. It's enabled by default on mobile platforms."
msgstr ""
"如果启用了 ``vertex_lighting`` 渲染模式，或者在项目设置中启用了 **Rendering "
"> Quality > Shading > Force Vertex Shading**\\ （渲染 > 质量 > 着色 > 强制顶"
"点着色），则不会运行 ``light()`` 函数。在移动平台上默认启用。"

msgid "Shader types"
msgstr "着色器类型"

msgid ""
"Instead of supplying a general-purpose configuration for all uses (2D, 3D, "
"particles), you must specify the type of shader you're writing. Different "
"types support different render modes, built-in variables, and processing "
"functions."
msgstr ""
"你所编写的着色器必须指定类型（2D、3D、粒子），不存在所有场景都可以使用的通用"
"配置。不同的类型支持不同的渲染模式、内置变量、处理函数。"

msgid ""
"In Godot, all shaders need to specify their type in the first line, like so:"
msgstr "在 Godot 中，所有的着色器都需要在第一行指定它们的类型，类似这样："

msgid "Here are the available types:"
msgstr "有以下类型可用："

msgid ":ref:`spatial <doc_spatial_shader>` for 3D rendering."
msgstr "用于 3D 渲染的 :ref:`spatial <doc_spatial_shader>`\\ 。"

msgid ":ref:`canvas_item <doc_canvas_item_shader>` for 2D rendering."
msgstr "用于 2D 渲染的 :ref:`canvas_item <doc_canvas_item_shader>`\\ 。"

msgid ":ref:`particles <doc_particle_shader>` for particle systems."
msgstr "用于粒子系统的 :ref:`particles <doc_particle_shader>`\\ 。"

msgid "Render modes"
msgstr "渲染模式"

msgid ""
"Shaders have optional render modes you can specify on the second line, after "
"the shader type, like so:"
msgstr "可以在着色器的第二行，也就是在着色器类型之后，指定渲染模式，类似这样："

msgid ""
"Render modes alter the way Godot applies the shader. For example, the "
"``unshaded`` mode makes the engine skip the built-in light processor "
"function."
msgstr ""
"渲染模式会修改 Godot 应用着色器的方式。例如，\\ ``unshaded`` 模式会让引擎跳过"
"内置的光线处理器函数。"

msgid ""
"Each shader type has different render modes. See the reference for each "
"shader type for a complete list of render modes."
msgstr ""
"每种着色器类型都有不同的渲染模式。每种着色器类型的完整渲染模式列表请参阅参考"
"手册。"

msgid "Processor functions"
msgstr "处理器函数"

msgid ""
"Depending on the shader type, you can override different processor "
"functions. For ``spatial`` and ``canvas_item``, you have access to "
"``vertex()``, ``fragment()``, and ``light()``. For ``particles``, you only "
"have access to ``vertex()``."
msgstr ""
"根据着色器类型的不同，你可以覆盖不同的处理器函数。在 ``spatial`` 和 "
"``canvas_item`` 中，你可以使用 ``vertex()``\\ 、\\ ``fragment()``\\ 、\\ "
"``light()``\\ 。而在 ``particles`` 中则只能使用 ``vertex()``\\ 。"

msgid "Vertex processor"
msgstr "顶点处理器"

msgid ""
"The ``vertex()`` processing function is called once for every vertex in "
"``spatial`` and ``canvas_item`` shaders. For ``particles`` shaders, it is "
"called once for every particle."
msgstr ""
"在 ``spatial`` 和 ``canvas_item`` 着色器中，会为每一个顶点调用 ``vertex()`` "
"处理函数。在 ``particles`` 着色器中则会为每一个粒子调用一次。"

msgid ""
"Each vertex in your world's geometry has properties like a position and "
"color. The function modifies those values and passes them to the fragment "
"function. You can also use it to send extra data to the fragment function "
"using varyings."
msgstr ""
"你的世界中的几何体上，每一个顶点都有位置、颜色等属性。该函数会修改这些值，并"
"将其传入片段函数。你也可以借助 varying 向片段着色器传递额外的数据。"

msgid ""
"By default, Godot transforms your vertex information for you, which is "
"necessary to project geometry onto the screen. You can use render modes to "
"transform the data yourself; see the :ref:`Spatial shader doc "
"<doc_spatial_shader>` for an example."
msgstr ""
"默认情况下，Godot 会为你对顶点信息进行变换，这是将几何体投影到屏幕上所必须"
"的。你可以使用渲染模式来自行变换数据；示例见 :ref:`Spatial 着色器文档 "
"<doc_spatial_shader>`\\ 。"

msgid "Fragment processor"
msgstr "片段处理器"

msgid ""
"The ``fragment()`` processing function is used to set up the Godot material "
"parameters per pixel. This code runs on every visible pixel the object or "
"primitive draws. It is only available in ``spatial`` and ``canvas_item`` "
"shaders."
msgstr ""
"``fragment()`` 处理函数的作用是设置每一个像素的 Godot 材质参数。这里的代码会"
"在绘制的对象或图元的每一个可见像素上执行。只能在 ``spatial`` 和 "
"``canvas_item`` 着色器中使用。"

msgid ""
"The standard use of the fragment function is to set up material properties "
"used to calculate lighting. For example, you would set values for "
"``ROUGHNESS``, ``RIM``, or ``TRANSMISSION``, which would tell the light "
"function how the lights respond to that fragment. This makes it possible to "
"control a complex shading pipeline without the user having to write much "
"code. If you don't need this built-in functionality, you can ignore it and "
"write your own light processing function, and Godot will optimize it away. "
"For example, if you do not write a value to ``RIM``, Godot will not "
"calculate rim lighting. During compilation, Godot checks to see if ``RIM`` "
"is used; if not, it cuts all the corresponding code out. Therefore, you will "
"not waste calculations on the effects that you do not use."
msgstr ""
"片段函数的标准用途是设置用于计算光照的材质属性。例如，你可以为 "
"``ROUGHNESS``\\ 、\\ ``RIM``\\ 、\\ ``TRNASMISSION`` 等设置值，告诉光照函数光"
"照应该如何处理对应的片段。这样就可以控制复杂的着色管线，而不必让用户编写过多"
"的代码。如果你不需要这一内置功能，那么你可以忽略它，自行编写光照处理函数，"
"Godot 会将其优化掉。例如，如果你没有向 ``RIM`` 写入任何值，那么 Godot 就不会"
"计算边缘光照。编译时，Godot 会检查是否使用了 ``RIM``\\ ；如果没有，那么它就会"
"把对应的代码删除。因此，你就不会在没有使用的效果上浪费算力。"

msgid "Light processor"
msgstr "光照处理器"

msgid ""
"The ``light()`` processor runs per pixel too, and it runs once for every "
"light that affects the object. It does not run if no lights affect the "
"object. It exists as a function called inside the ``fragment()`` processor "
"and typically operates on the material properties setup inside the "
"``fragment()`` function."
msgstr ""
"``light()`` 处理器也会在每一个像素上运行，并且同时还会在每一个影响该对象的灯"
"光上运行。如果没有灯光影响该对象则不会运行。它会被用于 ``fragment()`` 处理"
"器，一般会在 ``fragment()`` 函数中进行材质属性设置时执行。"

msgid ""
"The ``light()`` processor works differently in 2D than it does in 3D; for a "
"description of how it works in each, see their documentation, :ref:"
"`CanvasItem shaders <doc_canvas_item_shader>` and :ref:`Spatial shaders "
"<doc_spatial_shader>`, respectively."
msgstr ""
"``light()`` 处理器在 2D 和 3D 中的工作方式不同；每种工作方式的详细描述请参阅"
"它们对应的文档 :ref:`CanvasItem 着色器 <doc_canvas_item_shader>` and :ref:"
"`Spatial 着色器 <doc_spatial_shader>`\\ 。"

msgid "Translation status"
msgstr "翻译状态"
