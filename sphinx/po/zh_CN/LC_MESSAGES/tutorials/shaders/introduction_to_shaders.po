# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Introduction to shaders"
msgstr "着色器简介"

msgid ""
"This page explains what shaders are and will give you an overview of how "
"they work in Godot. For a detailed reference of the engine's shading "
"language, see :ref:`doc_shading_language`."
msgstr ""
"本页面会讲解什么是着色器，会为你综述其在 Godot 中的使用方法。引擎中着色语言的"
"详细参考见 :ref:`doc_shading_language`\\ 。"

msgid ""
"Shaders are a special kind of program that runs on Graphics Processing Units "
"(GPUs). They were initially used to shade 3D scenes but can nowadays do much "
"more. You can use them to control how the engine draws geometry and pixels "
"on the screen, allowing you to achieve all sorts of effects."
msgstr ""
"着色器（Shader）是一种在图形处理单元（GPU）上运行的特殊程序。他们最初使用来"
"为 3D 场景着色的，不过现在能做的事情就更多了。你可以用它们来控制引擎在屏幕上"
"绘制几何体以及像素的方式，可以用来实现各种特效。"

msgid ""
"Modern rendering engines like Godot draw everything with shaders: graphics "
"cards can run thousands of instructions in parallel, leading to incredible "
"rendering speed."
msgstr ""
"类似 Godot 的现代渲染引擎都会用着色器来执行所有绘制操作：图形卡可以并行执行成"
"千上万条指令，可以达到惊人的渲染速度。"

msgid ""
"Because of their parallel nature, though, shaders don't process information "
"the way a typical program does. Shader code runs on each vertex or pixel in "
"isolation. You cannot store data between frames either. As a result, when "
"working with shaders, you need to code and think differently from other "
"programming languages."
msgstr ""
"因为天生就是并行的，所以着色器处理信息的方式与普通的程序有所不同。着色器代码"
"是单独针对顶点或像素执行的。你也无法在帧与帧之间存储数据。因此，使用着色器"
"时，你需要使用与其他编程语言不同的编码和思考方式。"

msgid ""
"Suppose you want to update all the pixels in a texture to a given color. In "
"GDScript, your code would use ``for`` loops::"
msgstr ""
"假设你想要把纹理中的所有像素点都设置成某个给定的颜色。使用 GDScript，你的代码"
"会用 ``for`` 循环： ::"

msgid ""
"Your code is already part of a loop in a shader, so the corresponding code "
"would look like this."
msgstr "在着色器中，你的代码已经是循环的一部分了，所以对应的代码应该类似这样。"

msgid ""
"The graphics card calls the ``fragment()`` function once or more for each "
"pixel it has to draw. More on that below."
msgstr ""
"图形卡会为需要绘制的每一个像素调用若干次 ``fragment()`` 函数。后面会详细说"
"明。"

msgid "Shaders in Godot"
msgstr "Godot 中的着色器"

msgid ""
"Godot provides a shading language based on the popular OpenGL Shading "
"Language (GLSL) but simplified. The engine handles some of the lower-level "
"initialization work for you, making it easier to write complex shaders."
msgstr ""
"Godot 所提供的着色语言是基于流行的 OpenGL 着色语言（GLSL）的简化。引擎会为你"
"处理一些底层的初始化工作，让编写复杂着色器更为简单。"

msgid ""
"In Godot, shaders are made up of main functions called \"processor "
"functions\". Processor functions are the entry point for your shader into "
"the program. There are seven different processor functions."
msgstr ""
"在 Godot 中，着色器由若干主函数组成，这些函数被称为“处理器函数”。处理器函数是"
"着色器程序的入口。有七种不同的处理器函数。"

msgid ""
"The ``vertex()`` function runs over all the vertices in the mesh and sets "
"their positions and some other per-vertex variables. Used in :ref:"
"`canvas_item shaders <doc_canvas_item_shader>` and :ref:`spatial shaders "
"<doc_spatial_shader>`."
msgstr ""
"``vertex()`` 函数会为网格中的所有顶点各运行一次，用来设置顶点的位置和其他与顶"
"点相关的变量。在 :ref:`canvas_item 着色器 <doc_canvas_item_shader>`\\ 和\\ :"
"ref:`空间着色器 <doc_spatial_shader>`\\ 中使用。"

msgid ""
"The ``fragment()`` function runs for every pixel covered by the mesh. It "
"uses values output by the ``vertex()`` function, interpolated between the "
"vertices. Used in :ref:`canvas_item shaders <doc_canvas_item_shader>` and :"
"ref:`spatial shaders <doc_spatial_shader>`."
msgstr ""
"``fragment()`` 函数会为网格所覆盖的所有像素各运行一次。这个函数会用到 "
"``vertex()`` 函数输出的值，这些值会在顶点之间进行插值。在 :ref:`canvas_item "
"着色器 <doc_canvas_item_shader>`\\ 和\\ :ref:`空间着色器 "
"<doc_spatial_shader>`\\ 中使用。"

msgid ""
"The ``light()`` function runs for every pixel and for every light. It takes "
"variables from the ``fragment()`` function and from its previous runs. Used "
"in :ref:`canvas_item shaders <doc_canvas_item_shader>` and :ref:`spatial "
"shaders <doc_spatial_shader>`."
msgstr ""
"``light()`` 函数会为每个像素和每个灯光各运行一次。这个函数会用到 "
"``fragment()`` 函数以及前几次运行中的变量。在 :ref:`canvas_item 着色器 "
"<doc_canvas_item_shader>`\\ 和\\ :ref:`空间着色器 <doc_spatial_shader>`\\ 中"
"使用。"

msgid ""
"The ``start()`` function runs for every particle in a particle system once "
"when the particle is first spawned. Used in :ref:`particles shaders "
"<doc_particle_shader>`."
msgstr ""
"``start()`` 函数会在粒子系统中的每个粒子出生时各运行一次。在\\ :ref:`粒子着色"
"器 <doc_particle_shader>`\\ 中使用。"

msgid ""
"The ``process()`` function runs for every particle in a particle system for "
"each frame. Used in :ref:`particles shaders <doc_particle_shader>`."
msgstr ""
"``start()`` 函数会为粒子系统中的每个粒子每帧时各运行一次。在\\ :ref:`粒子着色"
"器 <doc_particle_shader>`\\ 中使用。"

msgid ""
"The ``sky()`` function runs for every pixel in the radiance cubemap when the "
"radiance cubemap needs to be updated, and for every pixel on the current "
"screen. Used in :ref:`sky shaders <doc_sky_shader>`."
msgstr ""
"``sky()`` 函数会在辐射度立方体贴图需要更新时为辐射度立方体贴图中的每个像素各"
"运行一次，也会为当前屏幕上的每个像素运行一次。在\\ :ref:`天空着色器 "
"<doc_sky_shader>`\\ 中使用。"

msgid ""
"The ``fog()`` function runs for every froxel in the volumetric fog froxel "
"buffer that intersects with the :ref:`FogVolume <class_FogVolume>`. Used by :"
"ref:`fog shaders <doc_fog_shader>`."
msgstr ""
"``fog()`` 函数会为体积雾片段体素缓冲中与 :ref:`FogVolume <class_FogVolume>` "
"相交的每个片段体素运行一次。在\\ :ref:`雾着色器 <doc_fog_shader>`\\ 中使用。"

msgid ""
"The ``light()`` function won't run if the ``vertex_lighting`` render mode is "
"enabled, or if **Rendering > Quality > Shading > Force Vertex Shading** is "
"enabled in the Project Settings. It's enabled by default on mobile platforms."
msgstr ""
"如果启用了 ``vertex_lighting`` 渲染模式，或者在项目设置中启用了 **Rendering "
"> Quality > Shading > Force Vertex Shading**\\ （渲染 > 质量 > 着色 > 强制顶"
"点着色），则不会运行 ``light()`` 函数。在移动平台上默认启用。"

msgid ""
"Godot also exposes an API for users to write totally custom GLSL shaders. "
"For more information see :ref:`doc_compute_shaders`."
msgstr ""
"Godot 还为用户编写完全自定义的 GLSL 着色器暴露了 API。详见 :ref:"
"`doc_compute_shaders`\\ 。"

msgid "Shader types"
msgstr "着色器类型"

msgid ""
"Instead of supplying a general-purpose configuration for all uses (2D, 3D, "
"particles, sky, fog), you must specify the type of shader you're writing. "
"Different types support different render modes, built-in variables, and "
"processing functions."
msgstr ""
"你所编写的着色器必须指定类型（2D、3D、粒子、天空、雾），不存在所有场景都可以"
"使用的通用配置。不同的类型支持不同的渲染模式、内置变量、处理函数。"

msgid ""
"In Godot, all shaders need to specify their type in the first line, like so:"
msgstr "在 Godot 中，所有的着色器都需要在第一行指定它们的类型，类似这样："

msgid "Here are the available types:"
msgstr "有以下类型可用："

msgid ":ref:`spatial <doc_spatial_shader>` for 3D rendering."
msgstr "用于 3D 渲染的 :ref:`spatial <doc_spatial_shader>`\\ 。"

msgid ":ref:`canvas_item <doc_canvas_item_shader>` for 2D rendering."
msgstr "用于 2D 渲染的 :ref:`canvas_item <doc_canvas_item_shader>`\\ 。"

msgid ":ref:`particles <doc_particle_shader>` for particle systems."
msgstr "用于粒子系统的 :ref:`particles <doc_particle_shader>`\\ 。"

msgid ":ref:`sky <doc_sky_shader>` to render :ref:`Skies <class_Sky>`."
msgstr "用于渲染 :ref:`Skies <class_Sky>` 的 :ref:`sky <doc_sky_shader>`\\ 。"

msgid ""
":ref:`fog <doc_fog_shader>` to render :ref:`FogVolumes <class_FogVolume>`"
msgstr ""
"用于渲染 :ref:`FogVolumes <class_FogVolume>` 的 :ref:`fog <doc_fog_shader>`"

msgid "Render modes"
msgstr "渲染模式"

msgid ""
"Shaders have optional render modes you can specify on the second line, after "
"the shader type, like so:"
msgstr "可以在着色器的第二行，也就是在着色器类型之后，指定渲染模式，类似这样："

msgid ""
"Render modes alter the way Godot applies the shader. For example, the "
"``unshaded`` mode makes the engine skip the built-in light processor "
"function."
msgstr ""
"渲染模式会修改 Godot 应用着色器的方式。例如，\\ ``unshaded`` 模式会让引擎跳过"
"内置的光线处理器函数。"

msgid ""
"Each shader type has different render modes. See the reference for each "
"shader type for a complete list of render modes."
msgstr ""
"每种着色器类型都有不同的渲染模式。每种着色器类型的完整渲染模式列表请参阅参考"
"手册。"

msgid "Vertex processor"
msgstr "顶点处理器"

msgid ""
"The ``vertex()`` processing function is called once for every vertex in "
"``spatial`` and ``canvas_item`` shaders. For ``particles`` shaders, it is "
"called once for every particle."
msgstr ""
"在 ``spatial`` 和 ``canvas_item`` 着色器中，会为每一个顶点调用 ``vertex()`` "
"处理函数。在 ``particles`` 着色器中则会为每一个粒子调用一次。"

msgid ""
"Each vertex in your world's geometry has properties like a position and "
"color. The function modifies those values and passes them to the fragment "
"function. You can also use it to send extra data to the fragment function "
"using varyings."
msgstr ""
"你的世界中的几何体上，每一个顶点都有位置、颜色等属性。该函数会修改这些值，并"
"将其传入片段函数。你也可以借助 varying 向片段着色器传递额外的数据。"

msgid ""
"By default, Godot transforms your vertex information for you, which is "
"necessary to project geometry onto the screen. You can use render modes to "
"transform the data yourself; see the :ref:`Spatial shader doc "
"<doc_spatial_shader>` for an example."
msgstr ""
"默认情况下，Godot 会为你对顶点信息进行变换，这是将几何体投影到屏幕上所必须"
"的。你可以使用渲染模式来自行变换数据；示例见 :ref:`Spatial 着色器文档 "
"<doc_spatial_shader>`\\ 。"

msgid "Fragment processor"
msgstr "片段处理器"

msgid ""
"The ``fragment()`` processing function is used to set up the Godot material "
"parameters per pixel. This code runs on every visible pixel the object or "
"primitive draws. It is only available in ``spatial``, ``canvas_item``, and "
"``sky`` shaders."
msgstr ""
"``fragment()`` 处理函数的作用是设置每一个像素的 Godot 材质参数。这里的代码会"
"在绘制的对象或图元的每一个可见像素上执行。只能在 ``spatial``\\ 、\\ "
"``canvas_item``\\ 、\\ ``sky`` 着色器中使用。"

msgid ""
"The standard use of the fragment function is to set up material properties "
"used to calculate lighting. For example, you would set values for "
"``ROUGHNESS``, ``RIM``, or ``TRANSMISSION``, which would tell the light "
"function how the lights respond to that fragment. This makes it possible to "
"control a complex shading pipeline without the user having to write much "
"code. If you don't need this built-in functionality, you can ignore it and "
"write your own light processing function, and Godot will optimize it away. "
"For example, if you do not write a value to ``RIM``, Godot will not "
"calculate rim lighting. During compilation, Godot checks to see if ``RIM`` "
"is used; if not, it cuts all the corresponding code out. Therefore, you will "
"not waste calculations on the effects that you do not use."
msgstr ""
"片段函数的标准用途是设置用于计算光照的材质属性。例如，你可以为 "
"``ROUGHNESS``\\ 、\\ ``RIM``\\ 、\\ ``TRNASMISSION`` 等设置值，告诉光照函数光"
"照应该如何处理对应的片段。这样就可以控制复杂的着色管线，而不必让用户编写过多"
"的代码。如果你不需要这一内置功能，那么你可以忽略它，自行编写光照处理函数，"
"Godot 会将其优化掉。例如，如果你没有向 ``RIM`` 写入任何值，那么 Godot 就不会"
"计算边缘光照。编译时，Godot 会检查是否使用了 ``RIM``\\ ；如果没有，那么它就会"
"把对应的代码删除。因此，你就不会在没有使用的效果上浪费算力。"

msgid "Light processor"
msgstr "光照处理器"

msgid ""
"The ``light()`` processor runs per pixel too, and it runs once for every "
"light that affects the object. It does not run if no lights affect the "
"object. It exists as a function called inside the ``fragment()`` processor "
"and typically operates on the material properties setup inside the "
"``fragment()`` function."
msgstr ""
"``light()`` 处理器也会在每一个像素上运行，并且同时还会在每一个影响该对象的灯"
"光上运行。如果没有灯光影响该对象则不会运行。它会被用于 ``fragment()`` 处理"
"器，一般会在 ``fragment()`` 函数中进行材质属性设置时执行。"

msgid ""
"The ``light()`` processor works differently in 2D than it does in 3D; for a "
"description of how it works in each, see their documentation, :ref:"
"`CanvasItem shaders <doc_canvas_item_shader>` and :ref:`Spatial shaders "
"<doc_spatial_shader>`, respectively."
msgstr ""
"``light()`` 处理器在 2D 和 3D 中的工作方式不同；每种工作方式的详细描述请参阅"
"它们对应的文档 :ref:`CanvasItem 着色器 <doc_canvas_item_shader>` and :ref:"
"`Spatial 着色器 <doc_spatial_shader>`\\ 。"

msgid "Translation status"
msgstr "翻译状态"
