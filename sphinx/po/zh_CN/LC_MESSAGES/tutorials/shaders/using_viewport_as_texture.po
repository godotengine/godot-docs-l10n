# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using a Viewport as a texture"
msgstr "使用 Viewport 作为纹理"

msgid "Introduction"
msgstr "前言"

msgid ""
"This tutorial will introduce you to using the :ref:`Viewport "
"<class_Viewport>` as a texture that can be applied to 3D objects. In order "
"to do so, it will walk you through the process of making a procedural planet "
"like the one below:"
msgstr ""
"本教程将向您介绍如何使用 :ref:`Viewport <class_Viewport>` 作为可应用于 3D 对"
"象的纹理。为了做到这一点，它将引导您完成制作程序式星球的过程，如下所示："

msgid ""
"This tutorial does not cover how to code a dynamic atmosphere like the one "
"this planet has."
msgstr "本教程没有介绍如何编写像这个星球那样的动态氛围."

msgid ""
"This tutorial assumes you are familiar with how to set up a basic scene "
"including: a :ref:`Camera <class_Camera>`, a :ref:`light source "
"<class_OmniLight>`, a :ref:`Mesh Instance <class_MeshInstance>` with a :ref:"
"`Primitive Mesh <class_PrimitiveMesh>`, and applying a :ref:`SpatialMaterial "
"<class_SpatialMaterial>` to the mesh. The focus will be on using the :ref:"
"`Viewport <class_Viewport>` to dynamically create textures that can be "
"applied to the mesh."
msgstr ""
"本教程假定你熟悉如何设置基本场景，其中包括：一个\\ :ref:`摄像机 "
"<class_Camera>`\\ 、一个\\ :ref:`光源 <class_OmniLight>`\\ 、一个\\ :ref:`图"
"元网格 <class_PrimitiveMesh>`\\ 的\\ :ref:`网格实例 "
"<class_MeshInstance>`\\ ，并将一个 :ref:`SpatialMaterial "
"<class_SpatialMaterial>` 应用于网格。我们的重点将会是使用 :ref:`Viewport "
"<class_Viewport>` 来动态地创建可应用于网格的纹理。"

msgid "In this tutorial, we'll cover the following topics:"
msgstr "在本教程中, 我们将介绍以下主题:"

msgid "How to use a :ref:`Viewport <class_Viewport>` as a render texture"
msgstr "如何使用 :ref:`Viewport <class_Viewport>` 作为渲染纹理"

msgid "Mapping a texture to a sphere with equirectangular mapping"
msgstr "使用 equirectangular 映射将纹理映射到球体"

msgid "Fragment shader techniques for procedural planets"
msgstr "程序式行星的片段着色器技术"

msgid ""
"Setting a Roughness map from a :ref:`Viewport Texture "
"<class_ViewportTexture>`"
msgstr "从\\ :ref:`视口纹理 <class_ViewportTexture>`\\ 设置粗糙度贴图"

msgid "Setting up the Viewport"
msgstr "设置视口"

msgid "First, add a :ref:`Viewport <class_Viewport>` to the scene."
msgstr "首先, 在场景中添加 :ref:`Viewport <class_Viewport>` ."

msgid ""
"Next, set the size of the :ref:`Viewport <class_Viewport>` to ``(1024, "
"512)``. The :ref:`Viewport <class_Viewport>` can actually be any size so "
"long as the width is double the height. The width needs to be double the "
"height so that the image will accurately map onto the sphere, as we will be "
"using equirectangular projection, but more on that later."
msgstr ""
"接下来, 将 :ref:`Viewport <class_Viewport>` 的大小设置为 ``(1024, 512)`` . :"
"ref:`Viewport <class_Viewport>` 实际上可以是任何尺寸, 只要其宽度是高度的两"
"倍. 宽度需要是高度的两倍, 这样图像才能准确地映射到球体上, 因为我们将使用等量"
"矩形投影, 后面会有更多的介绍."

msgid ""
"Next, disable HDR and disable 3D. We don't need HDR because our planet's "
"surface will not be especially bright, so values between ``0`` and ``1`` "
"will be fine. And we will be using a :ref:`ColorRect <class_ColorRect>` to "
"render the surface, so we don't need 3D either."
msgstr ""
"接下来, 禁用HDR和禁用3D. 我们不需要HDR, 因为星球的表面不会特别亮, 所以数值在 "
"``0`` 和 ``1`` 之间就可以了. 将使用一个 :ref:`ColorRect <class_ColorRect>` 来"
"渲染表面, 所以我们也不需要3D."

msgid ""
"Select the Viewport and add a :ref:`ColorRect <class_ColorRect>` as a child."
msgstr "选择视口并添加 :ref:`ColorRect <class_ColorRect>` 作为子项."

msgid ""
"Set the anchors \"Right\" and \"Bottom\" to ``1``, then make sure all the "
"margins are set to ``0``. This will ensure that the :ref:`ColorRect "
"<class_ColorRect>` takes up the entire :ref:`Viewport <class_Viewport>`."
msgstr ""
"将“Right”和“Bottom”的 Anchor 设置为 ``1``\\ ，然后确保所有边距都设置为 "
"``0``\\ 。这样就确保 :ref:`ColorRect <class_ColorRect>` 占据了整个 :ref:"
"`Viewport <class_Viewport>`\\ 。"

msgid ""
"Next, we add a :ref:`Shader Material <class_ShaderMaterial>` to the :ref:"
"`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > Material "
"> ``New ShaderMaterial``)."
msgstr ""
"接下来, 我们为 :ref:`Shader Material <class_ShaderMaterial>` 添加一个 :ref:"
"`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > Material "
"> ``New ShaderMaterial``)."

msgid ""
"Basic familiarity with shading is recommended for this tutorial. However, "
"even if you are new to shaders, all the code will be provided, so you should "
"have no problem following along."
msgstr ""
"建议本教程基本了解阴影. 但是, 即使您不熟悉着色器, 也将提供所有代码, 因此后续"
"操作应该没有问题."

msgid ""
"ColorRect > CanvasItem > Material > Material > click / Edit > ShaderMaterial "
"> Shader > ``New Shader`` > click / Edit:"
msgstr ""
"ColorRect > CanvasItem > Material > Material > 点击 / 编辑 > ShaderMaterial "
"> Shader > ``新建 Shader`` > 点击 / 编辑："

msgid "The above code renders a gradient like the one below."
msgstr "上面的代码呈现如下所示的渐变。"

msgid ""
"Now we have the basics of a :ref:`Viewport <class_Viewport>` that we render "
"to and we have a unique image that we can apply to the sphere."
msgstr ""
"现在我们有一个基础 :ref:`Viewport <class_Viewport>` 我们渲染到的, 我们有一个"
"可以应用于球体的独特图像."

msgid "Applying the texture"
msgstr "应用纹理"

msgid ""
"MeshInstance > GeometryInstance > Geometry > Material Override > ``New "
"SpatialMaterial``:"
msgstr ""
"MeshInstance > GeometryInstance > Geometry > Material Override > ``新建 "
"SpatialMaterial``\\ ："

msgid ""
"Now we go into the :ref:`Mesh Instance <class_MeshInstance>` and add a :ref:"
"`SpatialMaterial <class_SpatialMaterial>` to it. No need for a special :ref:"
"`Shader Material <class_ShaderMaterial>` (although that would be a good idea "
"for more advanced effects, like the atmosphere in the example above)."
msgstr ""
"现在我们进入 :ref:`Mesh Instance <class_MeshInstance>` 并添加一个 :ref:"
"`SpatialMaterial <class_SpatialMaterial>` 给它. 不需要一个特殊的 :ref:"
"`Shader Material <class_ShaderMaterial>` (尽管这对于更高级的效果来说是个好主"
"意, 比如上面例子中的大气)."

msgid ""
"MeshInstance > GeometryInstance > Geometry > Material Override > ``click`` / "
"``Edit``:"
msgstr ""
"MeshInstance > GeometryInstance > Geometry > Material Override > ``点击`` / "
"``编辑``\\ ："

msgid ""
"Open the newly created :ref:`SpatialMaterial <class_SpatialMaterial>` and "
"scroll down to the \"Albedo\" section and click beside the \"Texture\" "
"property to add an Albedo Texture. Here we will apply the texture we made. "
"Choose \"New ViewportTexture\""
msgstr ""
"打开新创建的 :ref:`SpatialMaterial <class_SpatialMaterial>` , 向下滚动到 "
"\"Albedo\" 部分, 点击 \"Texture\" 属性旁边, 添加一个Albedo Texture. 这里我们"
"将应用制作的纹理. 选择 \"New ViewportTexture\""

msgid ""
"Then, from the menu that pops up, select the Viewport that we rendered to "
"earlier."
msgstr "然后, 从弹出的菜单中, 选择我们先前渲染的视图."

msgid ""
"Your sphere should now be colored in with the colors we rendered to the "
"Viewport."
msgstr "现在, 您的球体应使用我们渲染到视口的颜色进行着色."

msgid ""
"Notice the ugly seam that forms where the texture wraps around? This is "
"because we are picking a color based on UV coordinates and UV coordinates do "
"not wrap around the texture. This is a classic problem in 2D map projection. "
"Game developers often have a 2-dimensional map they want to project onto a "
"sphere, but when it wraps around, it has large seams. There is an elegant "
"workaround for this problem that we will illustrate in the next section."
msgstr ""
"注意到在纹理环绕的地方形成的丑陋缝隙吗？这是因为我们是根据UV坐标来选取颜色"
"的, 而UV坐标并不会环绕纹理. 这是二维地图投影中的一个典型问题. 游戏开发人员通"
"常有一个二维贴图, 他们想投射到一个球体上, 但是当它环绕时, 将有接缝. 这个问题"
"有一个优雅的解决方法, 我们将在下一节中说明."

msgid "Making the planet texture"
msgstr "制作行星纹理"

msgid ""
"So now, when we render to our :ref:`Viewport <class_Viewport>`, it appears "
"magically on the sphere. But there is an ugly seam created by our texture "
"coordinates. So how do we get a range of coordinates that wrap around the "
"sphere in a nice way? One solution is to use a function that repeats on the "
"domain of our texture. ``sin`` and ``cos`` are two such functions. Let's "
"apply them to the texture and see what happens."
msgstr ""
"所以现在我们渲染到我们的 :ref:`Viewport <class_Viewport>` 它在球体上神奇地出"
"现了. 但是我们的纹理坐标会产生一个丑陋的缝隙. 那么我们如何以一种很好的方式获"
"得围绕球体的一系列坐标？ 一种解决方案是使用在纹理域上重复的函数. ``sin`` 和 "
"``cos`` 是两个这样的函数. 让我们将它们应用于纹理, 看看会发生什么."

msgid ""
"Not too bad. If you look around, you can see that the seam has now "
"disappeared, but in its place, we have pinching at the poles. This pinching "
"is due to the way Godot maps textures to spheres in its :ref:"
"`SpatialMaterial <class_SpatialMaterial>`. It uses a projection technique "
"called equirectangular projection, which translates a spherical map onto a "
"2D plane."
msgstr ""
"不算太坏. 如果你环顾四周, 可以看到接缝现在已经消失了, 但在它所处位置, 会有两"
"极的挤压. 这种挤压是由于Godot在其 :ref:`SpatialMaterial "
"<class_SpatialMaterial>` 中把纹理映射到球体的方式造成的. 它使用了一种叫做 "
"\"等角投影\" 的投影技术, 将球面图形转化为一个二维平面."

msgid ""
"If you are interested in a little extra information on the technique, we "
"will be converting from spherical coordinates into Cartesian coordinates. "
"Spherical coordinates map the longitude and latitude of the sphere, while "
"Cartesian coordinates are, for all intents and purposes, a vector from the "
"center of the sphere to the point."
msgstr ""
"如果你对技术方面的一些额外信息感兴趣，我们将从球面坐标转换为直角坐标。球面坐"
"标映射的是球体的经度和纬度，而直角坐标则是从球体中心到点的一个向量。"

msgid ""
"For each pixel, we will calculate its 3D position on the sphere. From that, "
"we will use 3D noise to determine a color value. By calculating the noise in "
"3D, we solve the problem of the pinching at the poles. To understand why, "
"picture the noise being calculated across the surface of the sphere instead "
"of across the 2D plane. When you calculate across the surface of the sphere, "
"you never hit an edge, and hence you never create a seam or a pinch point on "
"the pole. The following code converts the ``UVs`` into Cartesian coordinates."
msgstr ""
"对于每个像素, 我们将计算它在球体上的三维位置. 由此, 我们将使用3D噪波来确定一"
"个颜色值. 通过计算3D噪波, 我们解决了两极的挤压问题. 要理解为什么, 想象一下在"
"球体表面而不是在二维平面上计算噪声. 当你跨越球体表面进行计算时, 你永远不会碰"
"到边缘, 因此你永远不会在极点上产生接缝或夹点。下面的代码会将“UV”转换为笛卡尔"
"坐标。"

msgid "And if we use ``unit`` as an output ``COLOR`` value, we get:"
msgstr "如果我们使用 ``unit`` 作为输出 ``COLOR`` 值, 我们可以得到:"

msgid ""
"Now that we can calculate the 3D position of the surface of the sphere, we "
"can use 3D noise to make the planet. We will be using this noise function "
"directly from a `Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_:"
msgstr ""
"现在我们可以计算出球体表面的3D位置, 可以使用3D噪声来制作球体. 直接从 "
"`Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_ 中使用这个噪声函数:"

msgid ""
"All credit goes to the author, Inigo Quilez. It is published under the "
"``MIT`` licence."
msgstr "所有功劳归作者Inigo Quilez所有. 它是在 ``MIT`` 许可下发布的."

msgid ""
"Now to use ``noise``, add the following to the    ``fragment`` function:"
msgstr "现在使用 ``noised`` , 将以下内容添加到 ``fragment`` 函数中:"

msgid "In order to highlight the texture, we set the material to unshaded."
msgstr "为了突出显示纹理, 我们将材质设置为无阴影."

msgid ""
"You can see now that the noise indeed wraps seamlessly around the sphere. "
"Although this looks nothing like the planet you were promised. So let's move "
"onto something more colorful."
msgstr ""
"你现在可以看到, 尽管这看起来完全不像所承诺的球体, 但噪音确实无缝地包裹着球"
"体. 对此, 让我们进入一些更丰富多彩的东西."

msgid "Coloring the planet"
msgstr "着色这个星球"

msgid ""
"Now to make the planet colors. While there are many ways to do this, for "
"now, we will stick with a gradient between water and land."
msgstr ""
"现在来制作行星的颜色. 虽然有很多方法可以做到这一点, 但目前, 我们将使用水和陆"
"地之间的梯度."

msgid ""
"To make a gradient in GLSL, we use the ``mix`` function. ``mix`` takes two "
"values to interpolate between and a third argument to choose how much to "
"interpolate between them; in essence, it *mixes* the two values together. In "
"other APIs, this function is often called ``lerp``. However, ``lerp`` is "
"typically reserved for mixing two floats together; ``mix`` can take any "
"values whether it be floats or vector types."
msgstr ""
"要在 GLSL 中创建渐变, 我们使用 ``mix`` 函数. ``mix`` 需要两个值来插值和第三个"
"参数来选择在它们之间插入多少, 实质上它将两个值 *混合* 在一起. 在其他API中, 此"
"函数通常称为 ``lerp`` . 虽然 ``lerp`` 通常用于将两个浮点数混合在一起, 但 "
"``mix`` 可以取任何值, 无论它是浮点数还是向量类型."

msgid ""
"The first color is blue for the ocean. The second color is a kind of reddish "
"color (because all alien planets need red terrain). And finally, they are "
"mixed together by ``n * 0.5 + 0.5``. ``n`` smoothly varies between ``-1`` "
"and ``1``. So we map it into the ``0-1`` range that ``mix`` expects. Now you "
"can see that the colors change between blue and red."
msgstr ""
"第一种颜色是蓝色, 代表海洋. 第二种颜色是一种偏红的颜色, 因为所有外星球都需要"
"红色的地形. 最后, 它们 ``n * 0.5 + 0.5`` 混合在一起. ``n`` 在 ``-1`` 和 "
"``1`` 之间平滑变化. 所以我们把它映射到 ``mix`` 预期的 ``0-1`` 范围内. 现在你"
"可以看到, 颜色在蓝色和红色之间变化."

msgid ""
"That is a little more blurry than we want. Planets typically have a "
"relatively clear separation between land and sea. In order to do that, we "
"will change the last term to ``smoothstep(-0.1, 0.0, n)``. And thus the "
"whole line becomes:"
msgstr ""
"这比我们想要的还要模糊一些. 行星通常在陆地和海洋之间有一个相对清晰的分隔. 为"
"了做到这一点, 我们将把最后一项改为 ``smoothstep(-0.1, 0.0, n)`` . 整条线就变"
"成了这样:"

msgid ""
"What ``smoothstep`` does is return ``0`` if the third argument is below the "
"first and ``1`` if the third argument is larger than the second and smoothly "
"blends between ``0`` and ``1`` if the third number is between the first and "
"the second. So in this line, ``smoothstep`` returns ``0`` whenever ``n`` is "
"less than ``-0.1`` and it returns ``1`` whenever ``n`` is above ``0``."
msgstr ""
"``smoothstep`` 所做的是, 如果第三个参数低于第一个参数, 则返回 ``0`` , 如果第"
"三个参数大于第二个参数, 则返回 ``1`` , 如果第三个数字在第一个和第二个之间, 则"
"在 ``0`` 和 ``1`` 之间平滑地混合. 所以在这一行中, 当 ``n`` 小于 ``-0.1`` 时, "
"``smoothstep`` 返回 ``0`` , 当 ``n`` 高于 ``0`` 时, 它返回 ``1`` ."

msgid ""
"One more thing to make this a little more planet-y. The land shouldn't be so "
"blobby; let's make the edges a little rougher. A trick that is often used in "
"shaders to make rough looking terrain with noise is to layer levels of noise "
"over one another at various frequencies. We use one layer to make the "
"overall blobby structure of the continents. Then another layer breaks up the "
"edges a bit, and then another, and so on. What we will do is calculate ``n`` "
"with four lines of shader code instead of just one. ``n`` becomes:"
msgstr ""
"还有一件事, 使其更像一个行星. 这片土地不应该是圆球状的；让我们把边缘变得更粗"
"糙一些. 在着色器中经常使用的一个技巧是在不同的频率下将不同层次的噪声叠加在一"
"起, 使地形看起来粗糙. 我们使用一个层来制作大陆的整体球状结构. 然后, 另一层将"
"边缘打碎, 然后是另一层, 以此类推. 我们要做的是用四行着色器代码来计算 ``n`` , "
"而不是只有一行. ``n`` 变成了:"

msgid "And now the planet looks like:"
msgstr "现在这个星球看起来像:"

msgid "And with shading turned back on, it looks like:"
msgstr "而在重新打开阴影后, 看起来就像:"

msgid "Making an ocean"
msgstr "制作海洋"

msgid ""
"One final thing to make this look more like a planet. The ocean and the land "
"reflect light differently. So we want the ocean to shine a little more than "
"the land. We can do this by passing a fourth value into the ``alpha`` "
"channel of our output ``COLOR`` and using it as a Roughness map."
msgstr ""
"让这个看起来更像是一颗行星的最后一件事. 海洋和陆地以不同的方式反射光线. 因"
"此, 我们希望海洋比陆地更加闪耀. 我们可以通过将第四个值传递到输出 ``COLOR`` "
"的 ``alpha`` 通道并将其用作粗糙度图来实现."

msgid ""
"This line returns ``0.3`` for water and ``1.0`` for land. This means that "
"the land is going to be quite rough, while the water will be quite smooth."
msgstr ""
"该行对于水返回 ``0.3`` , 对于土地返回 ``1.0`` . 这意味着土地将变得很粗糙, 而"
"水将变得非常光滑."

msgid ""
"And then, in the material, under the \"Metallic\" section, make sure "
"``Metallic`` is set to ``0`` and ``Specular`` is set to ``1``. The reason "
"for this is the water reflects light really well, but isn't metallic. These "
"values are not physically accurate, but they are good enough for this demo."
msgstr ""
"然后，在材质中，在“Metallic”（金属性）部分，请确保 ``Metallic`` 为 "
"``0``\\ 、\\ ``Specular`` 为 ``1``\\ 。这样做的原因是水对光线的反射非常好，但"
"它不是金属的。这些值在物理上并不准确，但对于这个演示来说已经足够好了。"

msgid ""
"Next, under the \"Roughness\" section, set ``Roughness`` to ``1`` and set "
"the roughness texture to a :ref:`Viewport Texture <class_ViewportTexture>` "
"pointing to our planet texture :ref:`Viewport <class_Viewport>`. Finally, "
"set the ``Texture Channel`` to ``Alpha``. This instructs the renderer to use "
"the ``alpha`` channel of our output ``COLOR`` as the ``Roughness`` value."
msgstr ""
"接下来, 在 \"Roughness\" 部分, 将 ``Roughness`` 设置为 ``1`` , 并将粗糙度纹理"
"设置为 :ref:`Viewport Texture <class_ViewportTexture>` , 指向我们的行星纹理 :"
"ref:`Viewport <class_Viewport>` . 最后, 将 ``Texture Channel`` 设置为 "
"``Alpha`` . 这将指示渲染器使用我们输出的 ``COLOR`` 的 ``alpha`` 通道作为 "
"``Roughness`` 值."

msgid ""
"You'll notice that very little changes except that the planet is no longer "
"reflecting the sky. This is happening because, by default, when something is "
"rendered with an alpha value, it gets drawn as a transparent object over the "
"background. And since the default background of the :ref:`Viewport "
"<class_Viewport>` is opaque, the ``alpha`` channel of the :ref:`Viewport "
"Texture <class_ViewportTexture>` is ``1``, resulting in the planet texture "
"being drawn with slightly fainter colors and a ``Roughness`` value of ``1`` "
"everywhere. To correct this, we go into the :ref:`Viewport <class_Viewport>` "
"and enable the \"Transparent Bg\" property. Since we are now rendering one "
"transparent object on top of another, we want to enable "
"``blend_premul_alpha``:"
msgstr ""
"你会注意到, 除了行星不再反射天空外, 几乎没有什么变化. 这是因为默认情况下, 当"
"某样东西以Alpha值渲染时, 它会被绘制为背景上的透明物体. 因为 :ref:`Viewport "
"<class_Viewport>` 的默认背景是不透明的, 所以 :ref:`Viewport Texture "
"<class_ViewportTexture>` 的 ``alpha`` 通道是 ``1`` , 导致行星纹理的颜色略微变"
"淡, 并且到处的 ``Roughness`` 值都是 ``1`` . 为了纠正这个问题, 我们转到 :ref:"
"`Viewport <class_Viewport>` 并启用 \"Transparent Bg\" 属性. 由于现在是在另一"
"个透明物体上渲染, 要启用 ``blend_premul_alpha`` :"

msgid ""
"This pre-multiplies the colors by the ``alpha`` value and then blends them "
"correctly together. Typically, when blending one transparent color on top of "
"another, even if the background has an ``alpha`` of ``0`` (as it does in "
"this case), you end up with weird color bleed issues. Setting "
"``blend_premul_alpha`` fixes that."
msgstr ""
"这是将颜色预先乘以 ``alpha`` 值, 然后将它们正确地混合在一起. 通常情况下, 当在"
"一个透明的颜色上混合另一个颜色时, 即使背景的 ``alpha`` 为 ``0`` (如本例), 也"
"会出现奇怪的颜色渗漏问题. 设置 ``blend_premul_alpha`` 可以解决这个问题."

msgid ""
"Now the planet should look like it is reflecting light on the ocean but not "
"the land. If you haven't done so already, add an :ref:`OmniLight "
"<class_OmniLight>` to the scene so you can move it around and see the effect "
"of the reflections on the ocean."
msgstr ""
"现在这个星球看起来海洋上能够反射光线, 而不是在陆地上. 如果你还没有这样做, 在"
"场景中添加一个 :ref:`OmniLight <class_OmniLight>` , 这样你就可以移动它, 看到"
"海洋上反射的效果."

msgid ""
"And there you have it. A procedural planet generated using a :ref:`Viewport "
"<class_Viewport>`."
msgstr ""
"这就是你的作品。使用 :ref:`Viewport <class_Viewport>` 生成的程序式行星。"

msgid "Translation status"
msgstr "翻译状态"
