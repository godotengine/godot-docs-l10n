# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-21 17:14+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom post-processing"
msgstr "自定义后期处理"

msgid "Introduction"
msgstr "前言"

msgid ""
"Godot provides many post-processing effects out of the box, including Bloom, "
"DOF, and SSAO. Sometimes you want to write your own custom effect. Here's "
"how you can do so."
msgstr ""
"Godot提供许多开箱即用的后期处理效果, 包括Bloom, DOF和SSAO. 有时你想编写自己的"
"自定义效果. 下面介绍如何做到这一点."

msgid ""
"Post-processing effects are shaders applied to a frame after Godot rendered "
"it. You first want to render your scene into a :ref:`Viewport "
"<class_Viewport>`, then render the ``Viewport`` inside a :ref:"
"`ViewportTexture <class_ViewportTexture>` and show it on the screen."
msgstr ""
"后期处理效果是在Godot渲染后应用于帧的着色器. 首先想要将场景渲染为 :ref:"
"`Viewport <class_Viewport>`, 然后在 :ref:`ViewportTexture "
"<class_ViewportTexture>` 中渲染 ``Viewport`` 并在屏幕上显示它."

msgid ""
"The easiest way to implement a custom post-processing shader is to use "
"Godot's built-in ability to read from the screen texture. If you're not "
"familiar with this, you should read the :ref:`Screen Reading Shaders "
"Tutorial <doc_screen-reading_shaders>` first."
msgstr ""
"实现自定义后期处理着色器的最简单方法是使用Godot的内置功能从屏幕纹理中读取. 如"
"果您不熟悉这个, 您应该先阅读 :ref:`屏幕阅读着色器教程 <doc_screen-"
"reading_shaders>` ."

msgid ""
"As of the time of writing, Godot does not support rendering to multiple "
"buffers at the same time. Your post-processing shader will not have access "
"to normals or other render passes. You only have access to the rendered "
"frame."
msgstr ""
"在撰写本文时,Godot不支持同时对多个缓冲区进行渲染. 处理之后着色器将无法访问法"
"线或其他渲染通道. 你只能访问已渲染的帧."

msgid "Single pass post-processing"
msgstr "单通后期处理"

msgid ""
"You will need a ``Viewport`` to render your scene to, and a scene to render "
"your ``Viewport`` on the screen. You can use a :ref:`ViewportContainer "
"<class_ViewportContainer>` to display your ``Viewport`` on the entire screen "
"or inside another :ref:`Control <class_Control>` node."
msgstr ""
"您需要一个 ``Viewport`` 来渲染场景, 一个场景在屏幕上渲染您的 ``Viewport`` . "
"您可以使用 :ref:`ViewportContainer <class_ViewportContainer>` 在整个屏幕上或"
"另一个屏幕内显示您的 ``Viewport`` :ref:`Control <class_Control>` 节点."

msgid ""
"Rendering using a ``Viewport`` gives you control over how the scene render, "
"including the framerate, and you can use the ``ViewportContainer`` to render "
"3D objects in a 2D scene."
msgstr ""
"使用 ``Viewport`` 进行渲染可以控制场景的渲染方式, 包括帧率, 你可以使用 "
"``ViewportContainer`` 来渲染2D场景中的3D对象."

msgid ""
"For this demo, we will use a :ref:`Node2D <class_Node2D>` with a "
"``ViewportContainer`` and finally a ``Viewport``. Your **Scene** tab should "
"look like this:"
msgstr ""
"在这个演示中, 我们将使用一个 :ref:`Node2D <class_Node2D>` 与一个 "
"``ViewportContainer`` 和一个 ``Viewport`` . 你的 **Scene** 选项卡应该看起来像"
"这样:"

msgid ""
"Inside the ``Viewport``, you can have whatever you want. This will contain "
"your main scene. For this tutorial, we will use a field of random boxes:"
msgstr ""
"在 ``Viewport`` 内, 你可以有任何你想要的东西. 这将包含你的主场景. 在本教程"
"中, 我们将使用一个随机盒子的领域:"

msgid ""
"Add a new :ref:`ShaderMaterial <class_ShaderMaterial>` to the "
"``ViewportContainer``, and assign a new shader resource to it. You can "
"access your rendered ``Viewport`` with the built-in ``TEXTURE`` uniform."
msgstr ""
"添加一个新的 :ref:`ShaderMaterial <class_ShaderMaterial>` 到 "
"``ViewportContainer`` , 并给它分配一个新的着色器资源. 你可以通过内置的 "
"``TEXTURE`` 制式来访问你渲染好的 ``Viewport`` ."

msgid ""
"You can choose not to use a ``ViewportContainer``, but if you do so, you "
"will need to create your own uniform in the shader and pass the ``Viewport`` "
"texture in manually, like so:"
msgstr ""
"你可以选择不使用 ``ViewportContainer`` , 但如果这样做, 将需要在着色器中创建你"
"自己的uniform, 并手动传递 ``Viewport`` 纹理, 像这样:"

msgid "And you can pass the texture into the shader from GDScript like so:"
msgstr "您可以将纹理从GDScript传递到着色器中, 如下所示:"

msgid ""
"Copy the following code to your shader. The above code is a single pass edge "
"detection filter, a `Sobel filter <https://en.wikipedia.org/wiki/"
"Sobel_operator>`_."
msgstr ""
"将以下代码复制到着色器. 上面的代码是单通道边缘检测滤波器, `Sobel 滤波器 "
"<https://en.wikipedia.org/wiki/Sobel_operator>`_ ."

msgid ""
"The Sobel filter reads pixels in a 9x9 grid around the current pixel and "
"adds them together, using weight. What makes it interesting is that it "
"assigns weights to each pixel; +1 for each of the eight around the center "
"and -8 for the center pixel. The choice of weights is called a \"kernel\". "
"You can use different kernels to create edge detection filters, outlines, "
"and all sorts of effects."
msgstr ""
"Sobel滤波器读取当前像素周围9x9网格中的像素, 并使用权重将它们加在一起. 令人感"
"兴趣的是它为每个像素分配权重; 围绕中心的八个中的每一个都是+1, 对于中心像素"
"是-8. 权重的选择称为 \"核心\". 您可以使用不同的内核来创建边缘检测过滤器, 轮廓"
"和各种效果."

msgid "Multi-pass post-processing"
msgstr "多通后期处理"

msgid ""
"Some post-processing effects like blur are resource intensive. If you break "
"them down in multiple passes however, you can make them run a lot faster. In "
"a multipass material, each pass takes the result from the previous pass as "
"an input and processes it."
msgstr ""
"像模糊这样的后期处理效果是资源密集型的. 但是如果您在多次通过中将它们分解, 您"
"可以让它们运行得更快. 在多通道材质中, 每次传递都将前一次传递的结果作为输入并"
"对其进行处理."

msgid ""
"To make a multi-pass post-processing shader, you stack ``Viewport`` nodes. "
"In the example above, you rendered the content of one ``Viewport`` object "
"into the root ``Viewport``, through a ``ViewportContainer`` node. You can do "
"the same thing for a multi-pass shader by rendering the content of one "
"``Viewport`` into another and then rendering the last ``Viewport`` into the "
"root ``Viewport``."
msgstr ""
"为了制作一个多通道的后期处理着色器, 你可以将 ``Viewport`` 节点堆叠起来. 在上"
"面的例子中, 通过一个 ``ViewportContainer`` 节点, 将一个 ``Viewport`` 对象的内"
"容渲染到根 ``Viewport`` . 通过将一个 ``Viewport`` 的内容渲染到另一个 "
"``Viewport`` 中, 然后将最后一个 ``Viewport`` 渲染到根 ``Viewport`` 中, 对一个"
"多通道着色器做相同的操作."

msgid "Your scene hierarchy will look something like this:"
msgstr "您的场景层次结构将如下所示："

msgid ""
"Godot will render the bottom ``Viewport`` node first. So if the order of the "
"passes matters for your shaders, make sure that you assign the shader you "
"want to apply first to the lowest ``ViewportContainer`` in the tree."
msgstr ""
"Godot将首先渲染底部的 ``Viewport`` 节点. 因此, 如果遍历的顺序对着色器很重要, "
"请确保将要首先应用的着色器指定给树中最低的 ``ViewportContainer`` ."

msgid ""
"You can also render your Viewports separately without nesting them like "
"this. You just need to use two Viewports and to render them one after the "
"other."
msgstr ""
"您也可以单独渲染视区, 而不必像这样嵌套它们. 您只需要使用两个视区并一个接一个"
"地渲染它们."

msgid ""
"Apart from the node structure, the steps are the same as with the single-"
"pass post-processing shader."
msgstr "除了节点结构外, 其步骤与单通道后期处理着色器相同."

msgid ""
"As an example, you could write a full screen Gaussian blur effect by "
"attaching the following pieces of code to each of the :ref:"
"`ViewportContainers <class_ViewportContainer>`. The order in which you apply "
"the shaders does not matter:"
msgstr ""
"例如, 您可以通过将以下代码段附加到以下每个代码来编写全屏高斯模糊效果 :ref:"
"`ViewportContainers <class_ViewportContainer>`. 应用着色器的顺序无关紧要:"

msgid ""
"Using the above code, you should end up with a full screen blur effect like "
"below."
msgstr "使用上面的代码, 您应该得到如下所示的全屏模糊效果."

msgid ""
"For more information on how ``Viewport`` nodes work, see the :ref:`Viewports "
"Tutorial <doc_viewports>`."
msgstr ""
"有关 ``Viewport`` 节点如何工作的更多信息，请参阅 :ref:`Viewport 教程 "
"<doc_viewports>`。"
