# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Your second 3D shader"
msgstr "您的第二个 3D 着色器"

msgid ""
"From a high-level, what Godot does is give the user a bunch of parameters "
"that can be optionally set (``AO``, ``SSS_Strength``, ``RIM``, etc.). These "
"parameters correspond to different complex effects (Ambient Occlusion, "
"SubSurface Scattering, Rim Lighting, etc.). When not written to, the code is "
"thrown out before it is compiled and so the shader does not incur the cost "
"of the extra feature. This makes it easy for users to have complex PBR-"
"correct shading, without writing complex shaders. Of course, Godot also "
"allows you to ignore all these parameters and write a fully customized "
"shader."
msgstr ""
"从高级设置开始,Godot所做的是为用户提供一组可选设置的参数(\"环境光遮蔽\" , "
"\"次表面散射强度\" , \"边缘\" 等等)这些参数对应不同的复杂效应(环境遮挡, 次表"
"面散射, 边缘照明等等)如果没有写入, 代码在编译之前被抛出, 因此着色器不会产生额"
"外特性的成本. 这使得用户很容易拥有复杂的支持PBR着色, 而不需要编写复杂的着色"
"器. 当然,Godot还允许您忽略所有这些参数, 并编写一个完全定制的着色器."

msgid ""
"For a full list of these parameters see the :ref:`spatial shader "
"<doc_spatial_shader>` reference doc."
msgstr ""
"有关这些参数的完整列表, 请参见 :ref:`空间着色器 <doc_spatial_shader>` 参考文"
"档."

msgid ""
"A difference between the vertex function and a fragment function is that the "
"vertex function runs per vertex and sets properties such as ``VERTEX`` "
"(position) and ``NORMAL``, while the fragment shader runs per pixel and, "
"most importantly, sets the ``ALBEDO`` color of the :ref:"
"`Mesh<class_MeshInstance>`."
msgstr ""
"顶点函数和片段函数的区别在于, 顶点函数是按顶点运行的, 并设置诸如 ``VERTEX`` "
"(坐标)和 ``NORMAL`` 等属性, 而片段着色器是按像素运行的, 最重要的是设置 :ref:"
"`Mesh<class_MeshInstance>` 的 ``ALBEDO`` 颜色."

msgid "Your first spatial fragment function"
msgstr "第一个空间片段函数"

msgid ""
"As mentioned in the previous part of this tutorial. The standard use of the "
"fragment function in Godot is to set up different material properties and "
"let Godot handle the rest. In order to provide even more flexibility, Godot "
"also provides things called render modes. Render modes are set at the top of "
"the shader, directly below ``shader_type``, and they specify what sort of "
"functionality you want the built-in aspects of the shader to have."
msgstr ""
"如本教程前一部分所述. 在Godot中, 片段函数的标准用法是设置不同的材质属性, 然后"
"让Godot处理剩下的部分. 为了提供更大的灵活性,Godot还提供了渲染模式. 渲染模式设"
"置在着色器的顶部, 直接在 \"着色_方式\" 下面, 它们指定了你想要着色器的内置方面"
"具有什么样的功能."

msgid ""
"For example, if you do not want to have lights affect an object, set the "
"render mode to ``unshaded``:"
msgstr "例如, 如果你不想让灯光影响一个物体, 设置渲染模式为 \"无阴影\":"

msgid ""
"You can also stack multiple render modes together. For example, if you want "
"to use toon shading instead of more-realistic PBR shading, set the diffuse "
"mode and specular mode to toon:"
msgstr ""
"您还可以将多个渲染模式堆叠在一起。例如，如果你想使用卡通材质而不是更真实的 "
"PBR 材质，将漫反射模式和镜面反射模式设置为卡通："

msgid ""
"This model of built-in functionality allows you to write complex custom "
"shaders by changing only a few parameters."
msgstr "这个内置功能模型允许您通过更改几个参数来编写复杂的自定义着色器."

msgid ""
"For a full list of render modes see the :ref:`Spatial shader reference "
"<doc_spatial_shader>`."
msgstr ""
"有关渲染模式的完整列表, 请参见空间着色器参考 :ref:`Spatial shader reference "
"<doc_spatial_shader>`."

msgid ""
"In this part of the tutorial, we will walk through how to take the bumpy "
"terrain from the previous part and turn it into an ocean."
msgstr "在本教程的这一部分中, 我们将介绍如何将前一部分的崎岖地形变成海洋."

msgid ""
"First let's set the color of the water. We do that by setting ``ALBEDO``."
msgstr "首先让我们设置水的颜色. 我们通过设置 ``ALBEDO`` 来做到这一点."

msgid "``ALBEDO`` is a ``vec3`` that contains the color of the object."
msgstr "``ALBEDO`` 是一个 ``vec3`` , 包含物体的颜色."

msgid "Let's set it to a nice shade of blue."
msgstr "我们把它调成蓝色."

msgid ""
"We set it to a very dark shade of blue because most of the blueness of the "
"water will come from reflections from the sky."
msgstr "我们将其设置为深蓝色, 因为水的大部分蓝色来自天空的反射."

msgid ""
"The PBR model that Godot uses relies on two main parameters: ``METALLIC`` "
"and ``ROUGHNESS``."
msgstr "PBR模型的Godot用户两个主要参数:\"金属度\" 和 \"粗糙度\"."

msgid ""
"``ROUGHNESS`` specifies how smooth/rough the surface of a material is. A low "
"``ROUGHNESS`` will make a material appear like a shiny plastic, while a high "
"roughness makes the material appear more solid in color."
msgstr ""
"粗糙度是指材料表面的光滑程度. 低 \"粗糙度\" 会使材料看起来像闪亮的塑料, 而高"
"粗糙度使材料在颜色上看起来更坚实."

msgid ""
"``METALLIC`` specifies how much like a metal the object is. It is better set "
"close to ``0`` or ``1``. Think of ``METALLIC`` as changing the balance "
"between the reflection and the ``ALBEDO`` color. A high ``METALLIC`` almost "
"ignores ``ALBEDO`` altogether, and looks like a mirror of the sky. While a "
"low ``METALLIC`` has a more equal representation of sky color and ``ALBEDO`` "
"color."
msgstr ""
"``METALLIC`` 指定该物体有多像金属, 它最好设置为接近 ``0`` 或 ``1`` . 把 "
"``METALLIC`` 看作是改变反射和 ``ALBEDO`` 颜色之间的平衡. 高的 ``METALLIC`` 几"
"乎完全忽略了 ``ALBEDO`` , 看起来像天空的镜子. 而低的 ``METALLIC`` 对天空的颜"
"色和 ``ALBEDO`` 的颜色有一个更平实的表现."

msgid ""
"``ROUGHNESS`` increases from ``0`` to ``1`` from left to right while "
"``METALLIC`` increase from ``0`` to ``1`` from top to bottom."
msgstr "\"粗糙度\" 从左到右从0增加到1, 而 \"金属度\" 从上到下从0增加到1."

msgid ""
"``METALLIC`` should be close to ``0`` or ``1`` for proper PBR shading. Only "
"set it between them for blending between materials."
msgstr ""
"对恰当的PBR阴影,\"金属度\" 应当接近0或者1. 为了混合不同的材料, 只有将其设置在"
"0和1之间."

msgid ""
"Water is not a metal, so we will set its ``METALLIC`` property to ``0.0``. "
"Water is also highly reflective, so we will set its ``ROUGHNESS`` property "
"to be quite low as well."
msgstr ""
"水不是金属，所以我们将其 ``METALLIC`` 属性设置成 ``0.0``\\ 。水的反射性也很"
"高，因此我们将其``ROUGHNESS`` 属性也设置得非常低。"

msgid ""
"Now we have a smooth plastic looking surface. It is time to think about some "
"particular properties of water that we want to emulate. There are two main "
"ones that will take this from a weird plastic surface to nice stylized "
"water. The first is specular reflections. Specular reflections are those "
"bright spots you see from where the sun reflects directly into your eye. The "
"second is fresnel reflectance. Fresnel reflectance is the property of "
"objects to become more reflective at shallow angles. It is the reason why "
"you can see into water below you, but farther away it reflects the sky."
msgstr ""
"现在，我们有了光滑的塑料外观表面。现在该考虑要模拟的水的某些特定属性了。这里"
"有两种主要的方法可以把诡异的塑料表面变成好看的水。首先是镜面反射"
"（Specular）。镜面反射是那些来自太阳直接反射到你眼里的明亮斑点。第二个是菲涅"
"耳反射（Fresnel）。菲涅尔反射是物体在小角度下更具反射性的属性。这就是为什么你"
"可以看见自己身下的水，却在更远处看见天空倒影的原因。"

msgid ""
"In order to increase the specular reflections, we will do two things. First, "
"we will change the render mode for specular to toon because the toon render "
"mode has larger specular highlights."
msgstr ""
"为了增强镜面反射，我们需要做两件事。首先，由于卡通渲染模式具有更高的镜面反射"
"高光，我们将更改镜面反射为卡通渲染模式。"

msgid ""
"Second we will add rim lighting. Rim lighting increases the effect of light "
"at glancing angles. Usually it is used to emulate the way light passes "
"through fabric on the edges of an object, but we will use it here to help "
"achieve a nice watery effect."
msgstr ""
"其次, 我们将添加边缘照明. 边缘照明增加了掠射角度的光线效果. 通常, 它用于模拟"
"光线穿过对象边缘上的织物的路径, 但是我们将在此处使用它来帮助实现良好的水润效"
"果."

msgid ""
"In order to add fresnal reflectance, we will compute a fresnel term in our "
"fragment shader. Here, we aren't going to use a real fresnel term for "
"performance reasons. Instead, we'll approximate it using the dot product of "
"the ``NORMAL`` and ``VIEW`` vectors. The ``NORMAL`` vector points away from "
"the mesh's surface, while the ``VIEW`` vector is the direction between your "
"eye and that point on the surface. The dot product between them is a handy "
"way to tell when you are looking at the surface head-on or at a glancing "
"angle."
msgstr ""
"为了增加菲涅耳反射率，我们将在片段着色器中计算菲涅耳项。在这里，出于性能方面"
"的考虑，我们将不使用真正的菲涅耳术语。取而代之的是，我们将使用 ``NORMAL`` 和 "
"``VIEW`` 向量的点积对其进行近似。\\ ``NORMAL`` 向量指向远离网格物体表面的位"
"置，而 ``VIEW`` 向量则是您的眼睛与该表面上的点之间的方向。它们之间的点积是一"
"种可以告诉您何时正视或掠过某个角度的方便方法。"

msgid ""
"And mix it into both ``ROUGHNESS`` and ``ALBEDO``. This is the benefit of "
"ShaderMaterials over SpatialMaterials. With SpatialMaterial, we could set "
"these properties with a texture, or to a flat number. But with shaders we "
"can set them based on any mathematical function that we can dream up."
msgstr ""
"并将其混合到 ``ROUGHNESS`` 和 ``ALBEDO``\\ 。这是 ShaderMaterial 比 "
"SpatialMaterial 的好处。使用 SpatialMaterial，我们可以用纹理来设置这些属性，"
"或者设置成一个统一的数字。但是用着色器，我们可以根据我们能想到的任何数学函数"
"来设置它们。"

msgid ""
"And now, with only 5 lines of code, you can have complex looking water. Now "
"that we have lighting, this water is looking too bright. Let's darken it. "
"This is done easily by decreasing the values of the ``vec3`` we pass into "
"``ALBEDO``. Let's set them to ``vec3(0.01, 0.03, 0.05)``."
msgstr ""
"而现在, 只需要5行代码, 你就可以拥有看起来很复杂的水. 现在, 我们有了照明, 这个"
"水看起来太亮了. 让我们把它变暗. 这可以通过减少我们传入 ``ALBEDO`` 的 "
"``vec3`` 的值来轻松实现. 让我们把它们设置为 ``vec3(0.01, 0.03, 0.05)`` ."

msgid "Animating with ``TIME``"
msgstr "用 ``TIME`` 做动画"

msgid ""
"Going back to the vertex function, we can animate the waves using the built-"
"in variable ``TIME``."
msgstr "回到顶点功能，我们可以使用内置变量 ``TIME`` 对波浪进行动画处理。"

msgid ""
"``TIME`` is a built-in variable that is accessible from the vertex and "
"fragment functions."
msgstr "``TIME`` 是一个内置变量，可从顶点和片段函数访问。"

msgid ""
"In the last tutorial we calculated height by reading from a heightmap. For "
"this tutorial, we will do the same. Put the heightmap code in a function "
"called ``height()``."
msgstr ""
"在上一个教程中，我们通过从高度图读取来计算高度。对于本教程，我们将做同样的事"
"情。将高度图代码放在一个名为 ``height()`` 的函数中。"

msgid ""
"In order to use ``TIME`` in the ``height()`` function, we need to pass it in."
msgstr "为了在 ``height()`` 函数中使用 ``TIME``\\ ，我们需要将其传递进去。"

msgid "And make sure to correctly pass it in inside the vertex function."
msgstr "确保其正确传递到顶点函数中."

msgid ""
"Instead of using a normalmap to calculate normals. We are going to compute "
"them manually in the ``vertex()`` function. To do so use the following line "
"of code."
msgstr ""
"而不是使用法线贴图来计算法线。我们将在 ``vertex()`` 函数中手动计算它们。为"
"此，请使用以下代码行。"

msgid ""
"We need to compute ``NORMAL`` manually because in the next section we will "
"be using math to create complex-looking waves."
msgstr ""
"我们需要手动计算 ``NORMAL``\\ ，因为在下一节中，我们将使用数学来创建外观复杂"
"的波形。"

msgid ""
"Now, we are going to make the ``height()`` function a little more "
"complicated by offsetting ``position`` by the cosine of ``TIME``."
msgstr ""
"现在，我们要通过使 ``positon`` 偏移 ``TIME`` 的余弦来使 ``height()`` 函数更加"
"复杂。"

msgid ""
"This results in waves that move slowly, but not in a very natural way. The "
"next section will dig deeper into using shaders to create more complex "
"effects, in this case realistic waves, by adding a few more mathematical "
"functions."
msgstr ""
"这会实现缓慢移动的波纹效果, 但显得有点不自然. 下一节将深入探讨, 通过加入更多"
"的数学函数, 来用着色器实现更复杂的效果, 比如更加真实的波纹."

msgid "Advanced effects: waves"
msgstr "进阶效果：水波"

msgid ""
"What makes shaders so powerful is that you can achieve complex effects by "
"using math. To illustrate this, we are going to take our waves to the next "
"level by modifying the ``height()`` function and by introducing a new "
"function called ``wave()``."
msgstr ""
"利用数学, 着色器可以实现复杂的效果, 这是着色器的强大之处. 为阐述这一点, 我们"
"将修改 ``height()`` 函数和引入新函数 ``wave()`` , 来让波纹效果更进一层."

msgid ""
"``wave()`` has one parameter, ``position``, which is the same as it is in "
"``height()``."
msgstr "``wave()`` 有一个参数, ``position``, 和在 ``height()`` 中一样."

msgid ""
"We are going to call ``wave()`` multiple times in ``height()`` in order to "
"fake the way waves look."
msgstr ""
"我们将在 ``height()`` 函数中多次调用 ``wave()`` 函数, 来改变波纹的样子."

msgid "At first this looks complicated. So let's go through it line-by-line."
msgstr "这在一开始会让人觉得很复杂, 所以我们一行一行地来实现."

msgid ""
"Offset the position by the ``noise`` texture. This will make the waves "
"curve, so they won't be straight lines completely aligned with the grid."
msgstr ""
"通过 ``noise`` 纹理来偏移位置. 这将会使波浪成为曲线, 所以它们将不会是与网格所"
"对齐的直线."

msgid ""
"Define a wave-like function using ``sin()`` and ``position``. Normally "
"``sin()`` waves are very round. We use ``abs()`` to absolute to give them a "
"sharp ridge and constrain them to the 0-1 range. And then we subtract it "
"from ``1.0`` to put the peak on top."
msgstr ""
"用 ``sin()`` 和 ``position`` 定义一个类似波浪的函数. 通常 ``sin()`` 波是很圆"
"的. 我们使用 ``abs()`` 去将其绝对化, 让它有一个尖锐波峰, 并将其约束于0-1的范"
"围内. 然后我们再从 ``1.0`` 中减去, 将峰值放在上方."

msgid ""
"Multiply the x-directional wave by the y-directional wave and raise it to a "
"power to sharpen the peaks. Then subtract that from ``1.0`` so that the "
"ridges become peaks and raise that to a power to sharpen the ridges."
msgstr ""
"将x方向的波乘以y方向的波, 并将其提高到使峰值变得尖锐的幂. 然后从 ``1.0`` 中减"
"去它, 使山脊成为山峰, 并提高山脊锐化的能力."

msgid ""
"We can now replace the contents of our ``height()`` function with ``wave()``."
msgstr "现在我们可以用 ``wave()`` 代替 ``height()`` 函数的内容."

msgid "Using this, you get:"
msgstr "这样一来, 你会得到:"

msgid ""
"The shape of the sin wave is too obvious. So let's spread the waves out a "
"bit. We do this by scaling ``position``."
msgstr ""
"正弦曲线的形状太明显了. 所以让我们把波型分散一下. 我们通过缩放 ``位置`` 来实"
"现."

msgid "Now it looks much better."
msgstr "现在它看起来好多了."

msgid ""
"We can do even better if we layer multiple waves on top of each other at "
"varying frequencies and amplitudes. What this means is that we are going to "
"scale position for each one to make the waves thinner or wider (frequency). "
"And we are going to multiply the output of the wave to make them shorter or "
"taller (amplitude)."
msgstr ""
"如果我们将多个波以不同的频率和幅度彼此叠加, 则可以做得更好. 这意味着我们将按"
"比例缩放每个位置, 以使波形更细或更宽(频率). 我们将乘以波的输出, 以使它们变低"
"或变高(振幅)."

msgid ""
"Here is an example for how you could layer the four waves to achieve nicer "
"looking waves."
msgstr "下面以四种波形为例, 说明如何将四种波形分层, 以达到更漂亮的波形效果."

msgid ""
"Note that we add time to two and subtract it from the other two. This makes "
"the waves move in different directions creating a complex effect. Also note "
"that the amplitudes (the number the result is multiplied by) all add up to "
"``1.0``. This keeps the wave in the 0-1 range."
msgstr ""
"请注意, 我们把时间加到两个上, 再从另外两个上减去. 这使得波在不同的方向上移"
"动, 产生了复杂的效果. 还要注意, 振幅(结果乘以的数字)全部加起来是 ``1.0``. 这"
"使波浪保持在0-1的范围内."

msgid ""
"With this code you should end up with more complex looking waves and all you "
"had to do was add a bit of math!"
msgstr ""
"有了这段代码, 你应该可以得到更复杂的波形, 而你所要做的只是增加一点数学运算！"

msgid ""
"For more information about Spatial shaders read the :ref:`Shading Language "
"<doc_shading_language>` doc and the :ref:`Spatial Shaders "
"<doc_spatial_shader>` doc. Also look at more advanced tutorials in the :ref:"
"`Shading section <toc-learn-features-shading>` and the :ref:`3D <toc-learn-"
"features-3d>` sections."
msgstr ""
"有关空间着色器的更多信息, 请阅读 :ref:`Shading Language "
"<doc_shading_language>` 文档和 :ref:`Spatial Shaders <doc_spatial_shader>` 文"
"档. 也可以看看 :ref:`Shading 部分 <toc-learn-features-shading>` 和 :ref:`3D "
"<toc-learn-features-3d>` 部分的高级教程."

msgid "Translation status"
msgstr "翻译状态"
