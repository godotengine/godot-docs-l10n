# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "CanvasItem shaders"
msgstr "CanvasItem 着色器"

msgid ""
"CanvasItem shaders are used to draw all 2D elements in Godot. These include "
"all nodes that inherit from CanvasItems, and all GUI elements."
msgstr ""
"画布组件着色器用于绘制Godot中的所有二维元素. 这包括从画布组件继承的所有节点, "
"以及所有图形用户界面元素."

msgid ""
"CanvasItem shaders contain less built-in variables and functionality than "
"Spatial shaders, but they maintain the same basic structure with vertex, "
"fragment, and light processor functions."
msgstr ""
"画布组件着色器比空间着色器包含更少的内置变量和功能, 但它们与顶点, 片段和光处"
"理器功能保持相同的基本结构."

msgid "Render modes"
msgstr "渲染模式"

msgid "Render mode"
msgstr "渲染模式"

msgid "Description"
msgstr "描述"

msgid "**blend_mix**"
msgstr "**blend_mix**"

msgid "Mix blend mode (alpha is transparency), default."
msgstr "混合混合模式（Alpha 为透明度），默认。"

msgid "**blend_add**"
msgstr "**blend_add**"

msgid "Additive blend mode."
msgstr "叠加混合模式。"

msgid "**blend_sub**"
msgstr "**blend_sub**"

msgid "Subtractive blend mode."
msgstr "减法混合模式。"

msgid "**blend_mul**"
msgstr "**blend_mul**"

msgid "Multiplicative blend mode."
msgstr "乘法混合模式。"

msgid "**blend_premul_alpha**"
msgstr "**blend_premul_alpha**"

msgid "Pre-multiplied alpha blend mode."
msgstr "预乘 Alpha 混合模式。"

msgid "**blend_disabled**"
msgstr "**blend_disabled**"

msgid "Disable blending, values (including alpha) are written as-is."
msgstr "禁用混合，值（包括 Alpha）会按原样写入。"

msgid "**unshaded**"
msgstr "**unshaded**"

msgid "Result is just albedo. No lighting/shading happens in material."
msgstr "结果只使用反照率。材质中不会发生照明/阴影。"

msgid "**light_only**"
msgstr "**light_only**"

msgid "Only draw on light pass."
msgstr "仅在光通过时绘制."

msgid "**skip_vertex_transform**"
msgstr "**skip_vertex_transform**"

msgid "VERTEX/NORMAL/etc need to be transformed manually in vertex function."
msgstr "VERTEX/NORMAL/等需要在顶点函数中手动转换."

msgid "Built-ins"
msgstr "内置"

msgid ""
"Values marked as \"in\" are read-only. Values marked as \"out\" are for "
"optional writing and will not necessarily contain sensible values. Values "
"marked as \"inout\" provide a sensible default value, and can optionally be "
"written to. Samplers are not subjects of writing and they are not marked."
msgstr ""
"标记为 \"in\" 的值是只读的. 标记为 \"out\" 的值是可以选择写入的, 不一定包含合"
"理的值. 标记为 \"inout\" 的值提供一个合理的默认值, 并且可以选择写入. 采样器不"
"是写入的对象, 它们没有被标记."

msgid "Global built-ins"
msgstr "全局内置"

msgid "Global built-ins are available everywhere, including custom functions."
msgstr "全局内置的功能随处可见, 包括自定义功能."

msgid "Built-in"
msgstr "内置"

msgid "in float **TIME**"
msgstr "in float **TIME**"

msgid ""
"Global time since the engine has started, in seconds (always positive). It's "
"subject to the rollover setting (which is 3,600 seconds by default). It's "
"not affected by :ref:`time_scale<class_Engine_property_time_scale>` or "
"pausing, but you can override the ``TIME`` variable's time scale by calling "
"``VisualServer.set_shader_time_scale()`` with the desired time scale factor "
"as parameter (``1.0`` being the default)."
msgstr ""
"引擎启动后的全局时间, 以秒为单位(始终为正数). 这取决于翻转(rollover)设置(默认"
"为3600秒). 不受 :ref:`time_scale<class_Engine_property_time_scale>` 或暂停的"
"影响, 但可以通过调用 ``VisualServer.set_shader_time_Scale()`` 来覆盖 "
"``TIME`` 变量的时标, 并将所需的时标因子作为参数( ``1.0`` 为默认值)."

msgid "Vertex built-ins"
msgstr "顶点内置"

msgid ""
"Vertex data (``VERTEX``) is presented in local space (pixel coordinates, "
"relative to the camera). If not written to, these values will not be "
"modified and be passed through as they came."
msgstr ""
"顶点数据( ``VERTEX`` )是以局部空间(像素坐标, 相对于摄像机)呈现. 如果不写入, "
"这些值将不会被修改, 并按其来时的样子传递."

msgid ""
"The user can disable the built-in modelview transform (projection will still "
"happen later) and do it manually with the following code:"
msgstr ""
"用户可以禁用内置的modelview变换(以后仍然会发生投影), 并通过以下代码手动完成:"

msgid ""
"``WORLD_MATRIX`` is actually a modelview matrix. It takes input in local "
"space and transforms it into view space."
msgstr ""
"``WORLD_MATRIX`` 实际上是一个模型视图矩阵。它接受本地空间的输入并将其转换为视"
"图空间。"

msgid ""
"In order to get the world space coordinates of a vertex, you have to pass in "
"a custom uniform like so:"
msgstr "为了得到顶点的世界空间坐标, 你必须通过一个自定义uniform值, 如下所示:"

msgid "Then, in your vertex shader:"
msgstr "然后, 在你的顶点着色器:"

msgid ""
"``world_position`` can then be used in either the vertex or fragment "
"functions."
msgstr "``world_position`` 可用于顶点函数或片段函数."

msgid ""
"Other built-ins, such as UV and COLOR, are also passed through to the "
"fragment function if not modified."
msgstr "其他内置程序, 如UV和COLOR, 如果没有修改, 也会传递给片段函数."

msgid ""
"For instancing, the INSTANCE_CUSTOM variable contains the instance custom "
"data. When using particles, this information is usually:"
msgstr ""
"对于实例化，INSTANCE_CUSTOM变量包含实例自定义数据. 使用粒子时, 此信息通常是:"

msgid "**x**: Rotation angle in radians."
msgstr "**x**\\ ：旋转角度，单位为弧度。"

msgid "**y**: Phase during lifetime (0 to 1)."
msgstr "**y**\\ ：生命周期的阶段（0 到 1）。"

msgid "**z**: Animation frame."
msgstr "**z**\\ ：动画帧。"

msgid "in mat4 **WORLD_MATRIX**"
msgstr "in mat4 ** WORLD_MATRIX **"

msgid "Image space to view space transform."
msgstr "图像空间到视图空间的转换."

msgid "in mat4 **EXTRA_MATRIX**"
msgstr "in mat4 **EXTRA_MATRIX**"

msgid "Extra transform."
msgstr "额外的变换矩阵."

msgid "in mat4 **PROJECTION_MATRIX**"
msgstr "in mat4 **PROJECTION_MATRIX**"

msgid "View space to clip space transform."
msgstr "视图空间向裁剪空间变换."

msgid "in vec4 **INSTANCE_CUSTOM**"
msgstr "in vec4 **INSTANCE_CUSTOM**"

msgid "Instance custom data."
msgstr "实例自定义数据."

msgid "in bool **AT_LIGHT_PASS**"
msgstr "in bool **AT_LIGHT_PASS**"

msgid "``true`` if this is a light pass."
msgstr "如果 ``true`` 代表光照通道."

msgid "inout vec2 **VERTEX**"
msgstr "inout vec2 **VERTEX**"

msgid "Vertex, in image space."
msgstr "顶点, 在图像空间."

msgid "in vec2 **TEXTURE_PIXEL_SIZE**"
msgstr "in vec2 **TEXTURE_PIXEL_SIZE**"

msgid ""
"Normalized pixel size of default 2D texture. For a Sprite with a texture of "
"size 64x32px, **TEXTURE_PIXEL_SIZE** = :code:`vec2(1/64, 1/32)`"
msgstr ""
"默认 2D 纹理的标准化像素大小。对于纹理大小为 64x32px 的 Sprite，\\ "
"**TEXTURE_PIXEL_SIZE** = :code:`vec2(1/64, 1/32)`"

msgid "inout vec2 **UV**"
msgstr "inout vec2 **UV**"

msgid "Texture coordinates."
msgstr "纹理坐标。"

msgid "inout vec4 **COLOR**"
msgstr "inout vec4 **COLOR**"

msgid "Color from vertex primitive."
msgstr "来自顶点原语的颜色."

msgid "in vec4 **MODULATE**"
msgstr "输入vec4 **MODULATE**"

msgid ""
"Final modulate color. If used, **COLOR** will not be multiplied by modulate "
"automatically after the fragment function."
msgstr "最终调制颜色. 如果使用, **COLOR** 不会在片段函数后自动调制相乘."

msgid "inout float **POINT_SIZE**"
msgstr "inout float **POINT_SIZE**"

msgid "Point size for point drawing."
msgstr "点绘图的点大小."

msgid "Fragment built-ins"
msgstr "片段内置"

msgid ""
"Certain Nodes (for example, :ref:`Sprites <class_Sprite>`) display a texture "
"by default. However, when a custom fragment function is attached to these "
"nodes, the texture lookup needs to be done manually. Godot does not provide "
"the texture color in the ``COLOR`` built-in variable; to read the texture "
"color for such nodes, use:"
msgstr ""
"某些节点（例如 :ref:`Sprite <class_Sprite>`\\ ）默认会显示纹理。但是，当自定"
"义片段函数附加到这些节点时，就需要手工完成纹理的查找。Godot 在 ``COLOR`` 内置"
"变量中不提供纹理颜色；要读取这些节点的纹理颜色，请使用："

msgid ""
"This differs from the behavior of the built-in normal map. If a normal map "
"is attached, Godot uses it by default and assigns its value to the built-in "
"``NORMAL`` variable. If you are using a normal map meant for use in 3D, it "
"will appear inverted. In order to use it in your shader, you must assign it "
"to the ``NORMALMAP`` property. Godot will handle converting it for use in 2D "
"and overwriting ``NORMAL``."
msgstr ""
"这与内置法线贴图的行为不同. 如果附加了法线贴图,Godot默认使用它, 并将其值分配"
"给内置的 ``NORMAL`` 变量. 如果你使用的是用于3D的法线贴图, 它将出现倒置. 为了"
"在你的着色器中使用它, 必须把它分配给 ``NORMALMAP`` 属性.Godot会将其转换为2D使"
"用, 并覆盖 ``NORMAL`` ."

msgid "in vec4 **FRAGCOORD**"
msgstr "in vec4 **FRAGCOORD**"

msgid ""
"Coordinate of pixel center. In screen space. ``xy`` specifies position in "
"window, ``z`` specifies fragment depth if ``DEPTH`` is not used. Origin is "
"lower-left."
msgstr ""
"像素中心的坐标。在屏幕空间中，\\ ``xy`` 表示窗口中的位置，如果没有用 "
"``DEPTH``\\ ，则 ``z`` 表示片段深度。原点位于左下角。"

msgid "inout vec3 **NORMAL**"
msgstr "inout vec3 **NORMAL**"

msgid "Normal read from **NORMAL_TEXTURE**. Writable."
msgstr "从 ** NORMAL_TEXTURE ** 中正常读取. 可写的."

msgid "out vec3 **NORMALMAP**"
msgstr "out vec3 **NORMALMAP**"

msgid ""
"Configures normal maps meant for 3D for use in 2D. If used, overwrites "
"**NORMAL**."
msgstr "配置用于三维的法线贴图, 以便在二维中使用. 如果使用, 则覆盖 **法线** ."

msgid "inout float **NORMALMAP_DEPTH**"
msgstr "inout float **NORMALMAP_DEPTH**"

msgid "Normalmap depth for scaling."
msgstr "用于缩放的法线贴图深度."

msgid "in vec2 **UV**"
msgstr "in vec2 **UV**"

msgid "UV from vertex function."
msgstr "来自顶点功能的UV."

msgid ""
"Color from vertex function and output fragment color. If unused, will be set "
"to **TEXTURE** color."
msgstr "从顶点函数和输出片段颜色. 如果未使用, 将设置为 **纹理** 颜色."

msgid "in sampler2D **TEXTURE**"
msgstr "输入sampler2D **TEXTURE**"

msgid "Default 2D texture."
msgstr "默认的2D纹理."

msgid "in sampler2D **NORMAL_TEXTURE**"
msgstr "输入sampler2D **NORMAL_TEXTURE**"

msgid "Default 2D normal texture."
msgstr "默认 2D 法线纹理。"

msgid "in vec2 **SCREEN_UV**"
msgstr "in vec2 **SCREEN_UV**"

msgid "Screen UV for use with **SCREEN_TEXTURE**."
msgstr "与 **SCREEN_TEXTURE** 一起使用的屏幕UV."

msgid "in vec2 **SCREEN_PIXEL_SIZE**"
msgstr "in vec2 **SCREEN_PIXEL_SIZE**"

msgid "Size of individual pixels. Equal to inverse of resolution."
msgstr "单个像素的大小. 等于分辨率的倒数."

msgid "in vec2 **POINT_COORD**"
msgstr "in vec2 **POINT_COORD**"

msgid "Coordinate for drawing points."
msgstr "所绘制点的坐标。"

msgid "in sampler2D **SCREEN_TEXTURE**"
msgstr "输入sampler2D **SCREEN_TEXTURE**"

msgid "Screen texture, mipmaps contain gaussian blurred versions."
msgstr "屏幕纹理,mipmap包含高斯模糊版本."

msgid "Light built-ins"
msgstr "内置灯光"

msgid ""
"Light processor functions work differently in 2D than they do in 3D. In "
"CanvasItem shaders, the shader is called once for the object being drawn, "
"and then once for each light touching that object in the scene. Use "
"render_mode ``unshaded`` if you do not want any light passes to occur for "
"that object. Use render_mode ``light_only`` if you only want light passes to "
"occur for that object; this can be useful when you only want the object "
"visible where it is covered by light."
msgstr ""
"光照处理器功能在 2D 中与在 3D 中工作不同。在 CanvasItem 着色器中，这个着色器"
"会为被绘制的对象调用一次，然后再为每一束接触场景中该物体的光调用一次。如果您"
"不希望该对象发生任何光传递，请使用 render_mode ``unshaded``\\ 。如果您只想让"
"光通过该对象，使用 render_mode ``light_only``\\ ；当您只想让被光覆盖的对象可"
"见时，这是非常有用的。"

msgid ""
"When the shader is on a light pass, the ``AT_LIGHT_PASS`` variable will be "
"``true``."
msgstr "当着色器处于光通道时，\\ ``AT_LIGHT_PASS`` 变量将为 ``true``\\ 。"

msgid "in vec3 **NORMAL**"
msgstr "in vec3 **NORMAL**"

msgid ""
"Input Normal. Although this value is passed in, **normal calculation still "
"happens outside of this function**."
msgstr "输入正常. 虽然传入了这个值, 但 **正常计算仍然发生在此函数之外** ."

msgid "UV from vertex function, equivalent to the UV in the fragment function."
msgstr "来自顶点函数的UV, 相当于片段函数中的UV."

msgid "in vec4 **COLOR**"
msgstr "in vec4 **COLOR**"

msgid ""
"Input Color. This is the output of the fragment function (with final "
"modulation applied, if **MODULATE** is not used in any function of the "
"shader)."
msgstr ""
"输入颜色. 这是片段函数的输出(如果在着色器的任何函数中没有使用 **MODULATE** , "
"则应用最终调制)."

msgid "sampler2D **TEXTURE**"
msgstr "sampler2D **TEXTURE**"

msgid "Current texture in use for CanvasItem."
msgstr "CanvasItem使用的当前纹理."

msgid "**SCREEN_TEXTURE** Coordinate (for using with screen texture)."
msgstr "**SCREEN_TEXTURE** 坐标(与屏幕纹理一起使用)."

msgid "UV for Point Sprite."
msgstr "点精灵的UV."

msgid "inout vec2 **LIGHT_VEC**"
msgstr "inout vec2 **LIGHT_VEC**"

msgid ""
"Vector from light to fragment in local coordinates. It can be modified to "
"alter illumination direction when normal maps are used."
msgstr ""
"从光线到片段的局部坐标向量. 当使用法线贴图时, 它可以被修改以改变光照方向."

msgid "inout vec2 **SHADOW_VEC**"
msgstr "inout vec2 **SHADOW_VEC**"

msgid ""
"Vector from light to fragment in local coordinates. It can be modified to "
"alter shadow computation."
msgstr "局部坐标中从光到片段的向量. 它可以被修改以改变阴影的计算."

msgid "inout float **LIGHT_HEIGHT**"
msgstr "inout float **LIGHT_HEIGHT**"

msgid "Height of Light. Only effective when normals are used."
msgstr "光照的高度. 只有在使用法线时才有效."

msgid "inout vec4 **LIGHT_COLOR**"
msgstr "inout vec4 **LIGHT_COLOR**"

msgid "Color of Light."
msgstr "光的颜色."

msgid "in vec2 **LIGHT_UV**"
msgstr "输入vec2 **LIGHT_UV**"

msgid "UV for Light texture."
msgstr "紫外线对质地轻."

msgid "out vec4 **SHADOW_COLOR**"
msgstr "out vec4 **SHADOW_COLOR**"

msgid "Shadow Color of Light."
msgstr "光的阴影颜色."

msgid "inout vec4 **LIGHT**"
msgstr "inout vec4 **LIGHT**"

msgid ""
"Value from the Light texture and output color. Can be modified. If not used, "
"the light function is ignored."
msgstr "值从浅色纹理和输出颜色. 可以修改. 如果不使用, 则忽略光照函数."

msgid "Translation status"
msgstr "翻译状态"
