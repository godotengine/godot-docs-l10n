# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GDNative C++ example"
msgstr "GDNative C++ 示例"

msgid "Introduction"
msgstr "前言"

msgid ""
"This tutorial builds on top of the information given in the :ref:`GDNative C "
"example <doc_gdnative_c_example>`, so we highly recommend you read that "
"first."
msgstr ""
"本教程建立在 :ref:`GDNative C example <doc_gdnative_c_example>` 中给出的信息"
"之上, 因此我们强烈建议您先阅读."

msgid ""
"The C++ bindings for GDNative are built on top of the NativeScript GDNative "
"API and provide a nicer way to \"extend\" nodes in Godot using C++. This is "
"equivalent to writing scripts in GDScript, but in C++ instead."
msgstr ""
"GDNative的C++绑定构建在NativeScript GDNative API之上, 并提供了一种使用C++在"
"Godot中 \"扩展\" 节点的更好方法. 这相当于在GDScript中编写脚本, 而是在C++中编"
"写脚本."

msgid ""
"You can download the full example we'll be creating in this tutorial `on "
"GitHub <https://github.com/BastiaanOlij/gdnative_cpp_example>`__."
msgstr ""
"你可以在 `GitHub <https://github.com/BastiaanOlij/gdnative_cpp_example>`__ 上"
"下载我们将在本教程中创建的完整例子。"

msgid "Setting up the project"
msgstr "设置项目"

msgid "There are a few prerequisites you'll need:"
msgstr "您需要一些先决条件："

msgid "a Godot 3.x executable,"
msgstr "Godot 3.x 可执行文件，"

msgid "a C++ compiler,"
msgstr "C++ 编译器，"

msgid "SCons as a build tool,"
msgstr "SCons 作为构建工具，"

msgid ""
"a copy of the `godot-cpp repository <https://github.com/godotengine/godot-"
"cpp>`__."
msgstr ""
"`godot-cpp 仓库 <https://github.com/godotengine/godot-cpp>`__\\ 的副本。"

msgid ""
"See also :ref:`Compiling <toc-devel-compiling>` as the build tools are "
"identical to the ones you need to compile Godot from source."
msgstr ""
"另请参阅\\ :ref:`《编译》 <toc-devel-compiling>`\\ ，因为构建工具与从源代码编"
"译 Godot 所需的构建工具相同。"

msgid ""
"You can download these repositories from GitHub or let Git do the work for "
"you. Note that these repositories now have different branches for different "
"versions of Godot. GDNative modules written for an earlier version of Godot "
"will work in newer versions (with the exception of one breaking change in "
"ARVR interfaces between 3.0 and 3.1) but not vice versa so make sure you "
"download the correct branch. Also note that the version of Godot you use to "
"generate the ``api.json`` with becomes your minimum version."
msgstr ""
"您可以从 GitHub 下载这些仓库，或让 Git 为您完成这些工作。请注意，这些仓库现在"
"对于不同版本的 Godot 具有不同的分支。为早期版本的 Godot 编写的 GDNative 模块"
"可以在较新版本中运行（除了 3.0 和 3.1 之间的 ARVR 接口的一次重大更改），但反"
"之则不行，因此请确保下载正确的分支。还要注意，您用于生成 ``api.json`` 的 "
"Godot 版本将成为最低版本。"

msgid ""
"`GDExtension <https://godotengine.org/article/introducing-gd-extensions>`__ "
"has been merged in the ``master`` branch of godot-cpp, but it is only "
"compatible with the upcoming Godot 4.0. Therefore, you need to use the ``3."
"x`` branch of godot-cpp to use GDNative and follow this example."
msgstr ""
"`GDExtension <https://godotengine.org/article/introducing-gd-extensions>`__ "
"已经被合并到 godot-cpp 的 ``master`` 分支中，但它只与即将推出的 Godot 4.0 兼"
"容。因此，您需要使用 GDNative ，需使用 godot-cpp 的 ``3.x`` 分支，并按照此示"
"例进行操作。"

msgid ""
"This tutorial covers only GDNative in Godot 3.x, *not* GDExtension in Godot "
"4.0."
msgstr ""
"本教程只会涉及 Godot 3.x 中的 GDNative，\\ *不会涉及* Godot 4.0 中的 "
"GDExtension。"

msgid ""
"If you are versioning your project using Git, it is a good idea to add them "
"as Git submodules:"
msgstr "如果您使用 Git 对项目进行版本控制，最好将它们添加为 Git 子模块："

msgid ""
"If you decide to just download the repositories or clone them into your "
"project folder, make sure to keep the folder layout identical to the one "
"described here, as much of the code we'll be showcasing here assumes the "
"project follows this layout."
msgstr ""
"如果您决定只下载仓库或将它们克隆到项目文件夹中，请确保文件夹布局与此处描述的"
"相同，因为我们将在此处展示的代码假定项目遵循此布局。"

msgid "Do make sure you clone recursive to pull in both repositories:"
msgstr "确保克隆递归以拉入两个仓库："

msgid ""
"``godot-cpp`` now includes ``godot-headers`` as a nested submodule, if "
"you've manually downloaded them please make sure to place ``godot-headers`` "
"inside of the ``godot-cpp`` folder."
msgstr ""
"``godot-cpp`` 现在包含 ``godot-headers`` 作为嵌套的子模块，如果你手动下载它"
"们，请确保将 ``godot-headers`` 放在 ``godot-cpp`` 文件夹内。"

msgid ""
"You don't have to do it this way, but we've found it easiest to manage. If "
"you decide to download the repositories or clone them into your folder, make "
"sure to keep the folder layout the same as we've setup here. Much of the "
"code we'll be showcasing here assumes the project has this layout."
msgstr ""
"这样做不是必须的，但我们发现这样最容易管理。如果您决定只下载仓库或只是将它们"
"克隆到您的文件夹中，请确保文件夹布局与我们在此处设置的相同。我们接下来将展示"
"的代码，很多都假定项目具有这样的布局。"

msgid ""
"If you cloned the example from the link specified in the introduction, the "
"submodules are not automatically initialized. You will need to execute the "
"following commands:"
msgstr ""
"如果从介绍中指定的链接克隆示例, 子模块不会自动初始化. 您需要执行以下命令:"

msgid "This will clone these two repositories into your project folder."
msgstr "这会将这两个仓库克隆到您的项目文件夹中。"

msgid "Building the C++ bindings"
msgstr "构建 C++ 绑定"

msgid ""
"Now that we've downloaded our prerequisites, it is time to build the C++ "
"bindings."
msgstr "现在我们已经下载了我们的先决条件, 现在是构建C++绑定的时候了."

msgid ""
"The repository contains a copy of the metadata for the current Godot "
"release, but if you need to build these bindings for a newer version of "
"Godot, simply call the Godot executable:"
msgstr ""
"仓库包含当前 Godot 版本的元数据副本，但如果您需要为较新版本的 Godot 构建这些"
"绑定，只需调用 Godot 可执行文件："

msgid ""
"Place the resulting ``api.json`` file in the project folder and add "
"``use_custom_api_file=yes custom_api_file=../api.json`` to the scons command "
"below."
msgstr ""
"将生成的 ``api.json`` 文件放在项目文件夹中, 并将 ``use_custom_api_file = yes "
"custom_api_file = .. / api.json`` 添加到下面的scons命令中."

msgid ""
"To generate and compile the bindings, use this command (replacing "
"``<platform>`` with ``windows``, ``linux`` or ``osx`` depending on your OS):"
msgstr ""
"要生成和编译绑定, 使用这个命令(根据你的操作系统, 用 ``windows`` , ``linux`` "
"或 ``osx`` 代替 ``<platform>`` ):"

msgid ""
"To speed up compilation, add `-jN` at the end of the SCons command line "
"where `N` is the number of CPU threads you have on your system. The example "
"below uses 4 threads."
msgstr ""
"为了加快编译速度, 在SCons命令行的末尾添加 `-jN`, 其中 `N` 是你系统中的CPU线程"
"数. 下面的例子使用了4个线程."

msgid ""
"This step will take a while. When it is completed, you should have static "
"libraries that can be compiled into your project stored in ``godot-cpp/bin/"
"``."
msgstr ""
"这一步将需要一段时间. 完成后, 您应该有一个静态库, 可以编译到您的项目中, 存储"
"在 ``godot-cpp / bin /`` 中."

msgid "You may need to add ``bits=64`` to the command on Windows or Linux."
msgstr "您可能需要在 Windows 或 Linux 的命令行中添加 ``bits=64``\\ 。"

msgid "Creating a simple plugin"
msgstr "创建一个简单的插件"

msgid ""
"Now it's time to build an actual plugin. We'll start by creating an empty "
"Godot project in which we'll place a few files."
msgstr ""
"现在是构建实际插件的时候了. 我们首先创建一个空的Godot项目, 我们将在其中放置一"
"些文件."

msgid ""
"Open Godot and create a new project. For this example, we will place it in a "
"folder called ``demo`` inside our GDNative module's folder structure."
msgstr ""
"打开Godot并创建一个新项目. 对于这个示例, 我们将它放在我们的GDNative模块的文件"
"夹结构中名为 ``demo`` 的文件夹中."

msgid ""
"In our demo project, we'll create a scene containing a Node called \"Main\" "
"and we'll save it as ``main.tscn``. We'll come back to that later."
msgstr ""
"在我们的演示项目中, 我们将创建一个包含名为 \"Main\" 的节点的场景, 我们将其保"
"存为 ``main.tscn`` . 我们稍后再回过头来看看."

msgid ""
"Back in the top-level GDNative module folder, we're also going to create a "
"subfolder called ``src`` in which we'll place our source files."
msgstr ""
"回到顶级GDNative模块文件夹, 我们还将创建一个名为 ``src`` 的子文件夹, 我们将在"
"其中放置源文件."

msgid ""
"You should now have ``demo``, ``godot-cpp``, ``godot-headers``, and ``src`` "
"directories in your GDNative module."
msgstr ""
"您现在应该在您的GDNative模块中有 ``demo`` , ``godot-cpp``, ``godot_headers`` "
"和 ``src`` 目录."

msgid ""
"In the ``src`` folder, we'll start with creating our header file for the "
"GDNative node we'll be creating. We will name it ``gdexample.h``:"
msgstr ""
"在 ``src`` 文件夹中, 我们将首先为我们将要创建的GDNative节点创建头文件. 我们将"
"它命名为 ``gdexample.h`` :"

msgid ""
"There are a few things of note to the above. We're including ``Godot.hpp`` "
"which contains all our basic definitions. After that, we include ``Sprite."
"hpp`` which contains bindings to the Sprite class. We'll be extending this "
"class in our module."
msgstr ""
"以上有一些注意事项. 我们包括 ``Godot.hpp`` , 其中包含我们所有的基本定义. 之"
"后, 我们包含 ``Sprite.hpp`` , 它包含对Sprite类的绑定. 我们将在我们的模块中扩"
"展这个类."

msgid ""
"We're using the namespace ``godot``, since everything in GDNative is defined "
"within this namespace."
msgstr ""
"我们使用命名空间 ``godot`` , 因为GDNative中的所有内容都在此命名空间中定义."

msgid ""
"Then we have our class definition, which inherits from our Sprite through a "
"container class. We'll see a few side effects of this later on. The "
"``GODOT_CLASS`` macro sets up a few internal things for us."
msgstr ""
"然后我们有了我们的类定义, 它通过容器类从我们的Sprite继承. 我们稍后会看到一些"
"副作用. 这也是NativeScript 1.1中将要改进的主要部分. ``GODOT_CLASS`` 宏为我们"
"设置了一些内部事物."

msgid "After that, we declare a single member variable called ``time_passed``."
msgstr "之后, 我们声明一个名为 ``time_passed`` 的成员变量."

msgid ""
"In the next block we're defining our methods, we obviously have our "
"constructor and destructor defined, but there are two other functions that "
"will likely look familiar to some, and one new method."
msgstr ""
"在下一个块中我们定义了我们的方法, 我们显然已经定义了构造函数和析构函数, 但是"
"还有其他两个函数可能看起来很熟悉."

msgid ""
"The first is ``_register_methods``, which is a static function that Godot "
"will call to find out which methods can be called on our NativeScript and "
"which properties it exposes. The second is our ``_process`` function, which "
"will work exactly the same as the ``_process`` function you're used to in "
"GDScript. The third is our ``_init`` function which is called after Godot "
"has properly set up our object. It has to exist even if you don't place any "
"code in it."
msgstr ""
"第一个是 ``_register_methods`` , 这是一个静态函数,Godot将调用它来找出可以在我"
"们的NativeScript上调用哪些方法以及它暴露的属性. 第二个是我们的 ``_process`` "
"函数, 它与您在GDScript中习惯的 ``_process`` 函数完全相同. 第三个是我们的 "
"``_init`` 函数, 它是在Godot正确设置我们的对象之后调用的. 即使您没有在其中放置"
"任何代码, 它也必须存在."

msgid "Let's implement our functions by creating our ``gdexample.cpp`` file:"
msgstr "所以, 让我们通过创建 ``gdexample.cpp`` 文件来实现我们的函数:"

msgid ""
"This one should be straightforward. We're implementing each method of our "
"class that we defined in our header file. Note that the ``register_method`` "
"call **must** expose the ``_process`` method, otherwise Godot will not be "
"able to use it. However, we do not have to tell Godot about our constructor, "
"destructor and ``_init`` functions."
msgstr ""
"这个应该是直截了当的. 我们正在实现我们在头文件中定义的每个类的方法. 注意 "
"``register_method`` 调用 **必须** 公开 ``_process`` 方法, 否则Godot将无法使用"
"它. 但是, 我们不必告诉Godot我们的构造函数, 析构函数和 ``_init`` 函数."

msgid ""
"The other method of note is our ``_process`` function, which simply keeps "
"track of how much time has passed and calculates a new position for our "
"sprite using a sine and cosine function. What stands out is calling ``owner-"
">set_position`` to call one of the built-in methods of our Sprite. This is "
"because our class is a container class; ``owner`` points to the actual "
"Sprite node our script relates to."
msgstr ""
"另一个注意的方法是我们的 ``_process`` 函数，它的作用就是记录已经过了多少时"
"间，并使用正弦和余弦函数计算我们的精灵的新位置。需要注意的是调用 ``owner-"
">set_position`` 来调用我们的 Sprite 的一个内置方法。这是因为我们的类是一个容"
"器类；\\ ``owner`` 指向我们脚本所涉及的实际 Sprite 节点。"

msgid ""
"There is one more C++ file we need; we'll name it ``gdlibrary.cpp``. Our "
"GDNative plugin can contain multiple NativeScripts, each with their own "
"header and source file like we've implemented ``GDExample`` up above. What "
"we need now is a small bit of code that tells Godot about all the "
"NativeScripts in our GDNative plugin."
msgstr ""
"还有一个我们需要的C++文件; 我们将它命名为 ``gdlibrary.cpp`` . 我们的GDNative"
"插件可以包含多个NativeScripts, 每个都有自己的头文件和源文件, 就像我们在上面实"
"现了 ``GDExample`` 一样. 我们现在需要的是一小段代码, 告诉Godot我们的GDNative"
"插件中的所有NativeScripts."

msgid ""
"Note that we are not using the ``godot`` namespace here, since the three "
"functions implemented here need to be defined without a namespace."
msgstr ""
"请注意, 我们这里没有使用 ``godot`` 命名空间, 因为这里实现的三个函数需要在没有"
"命名空间的情况下定义."

msgid ""
"The ``godot_gdnative_init`` and ``godot_gdnative_terminate`` functions get "
"called respectively when Godot loads our plugin and when it unloads it. All "
"we're doing here is parse through the functions in our bindings module to "
"initialize them, but you might have to set up more things depending on your "
"needs."
msgstr ""
"当Godot加载我们的插件并卸载它时, 分别调用 ``godot_gdnative_init`` 和 "
"``godot_gdnative_terminate`` 函数. 我们在这里所做的只是解析我们的绑定模块中的"
"函数来初始化它们, 但您可能需要根据需要设置更多内容."

msgid ""
"The important function is the third function called "
"``godot_nativescript_init``. We first call a function in our bindings "
"library that does its usual stuff. After that, we call the function "
"``register_class`` for each of our classes in our library."
msgstr ""
"重要的功能是第三个函数叫做 ``godot_nativescript_init`` . 我们首先在我们的绑定"
"库中调用一个函数来执行它常用的东西. 之后, 我们为库中的每个类调用函数 "
"``register_class`` ."

msgid "Compiling the plugin"
msgstr "编译插件"

msgid ""
"We cannot easily write by hand a ``SConstruct`` file that SCons would use "
"for building. For the purpose of this example, just use :download:`this "
"hardcoded SConstruct file <files/cpp_example/SConstruct>` we've prepared. "
"We'll cover a more customizable, detailed example on how to use these build "
"files in a subsequent tutorial."
msgstr ""
"手工编写 SCons 用于构建的 ``SConstruct`` 文件并不容易。出于这个示例的目的，只"
"需使用我们已经准备好的\\ :download:`这个硬编码的 SConstruct 文件 <files/"
"cpp_example/SConstruct>`\\ 。我们将在后续教程中介绍如何使用这些构建文件的更可"
"定制的详细示例。"

msgid ""
"This ``SConstruct`` file was written to be used with the latest ``godot-"
"cpp`` master, you may need to make small changes using it with older "
"versions or refer to the ``SConstruct`` file in the Godot 3.0 documentation."
msgstr ""
"这个 ``SConstruct`` 文件被编写为与最新的godot-cpp master分支一起使用, 您可能"
"需要使用旧版本进行小的更改, 或者参考Godot 3.0文档中的 ``SConstruct`` 文件."

msgid ""
"Once you've downloaded the ``SConstruct`` file, place it in your GDNative "
"module folder besides ``godot-cpp``, ``godot-headers`` and ``demo``, then "
"run:"
msgstr ""
"一旦你下载了 ``SConstruct`` 文件，把它放在你的GDNative模块文件夹中，除了 "
"``godot-cpp`` 、 ``godot-headers`` 和 ``demo`` 之外，然后运行:"

msgid "You should now be able to find the module in ``demo/bin/<platform>``."
msgstr "您现在应该能够在 ``demo / bin / <platform>`` 中找到该模块."

msgid ""
"Here, we've compiled both godot-cpp and our gdexample library as debug "
"builds. For optimized builds, you should compile them using the "
"``target=release`` switch."
msgstr ""
"在这里, 我们编译了godot-cpp和我们的gdexample库作为调试版本. 对于优化的构建, "
"您应该使用 ``target = release`` 开关编译它们."

msgid "Using the GDNative module"
msgstr "使用 GDNative 模块"

msgid ""
"Before we jump back into Godot, we need to create two more files in ``demo/"
"bin/``. Both can be created using the Godot editor, but it may be faster to "
"create them directly."
msgstr ""
"在我们跳回Godot之前, 我们需要在 ``demo / bin /`` 中再创建两个文件. 两者都可以"
"使用Godot编辑器创建, 但直接创建它们可能会更快."

msgid ""
"The first one is a file that lets Godot know what dynamic libraries should "
"be loaded for each platform and is called ``gdexample.gdnlib``."
msgstr ""
"第一个是一个文件, 让Godot知道应该为每个平台加载什么动态库, 并称为 "
"``gdexample.gdnlib`` ."

msgid ""
"This file contains a ``general`` section that controls how the module is "
"loaded. It also contains a prefix section which should be left on ``godot_`` "
"for now. If you change this, you'll need to rename various functions that "
"are used as entry points. This was added for the iPhone platform because it "
"doesn't allow dynamic libraries to be deployed, yet GDNative modules are "
"linked statically."
msgstr ""
"该文件包含一个 \"general\" 部分, 用于控制模块的加载方式. 它还包含一个前缀部"
"分, 现在应该留在 ``godot_`` . 如果更改此设置, 则需要重命名用作入口点的各种函"
"数. 这是为iPhone平台添加的, 因为它不允许部署动态库, 但GDNative模块是静态链接"
"的."

msgid ""
"The ``entry`` section is the important bit: it tells Godot the location of "
"the dynamic library in the project's filesystem for each supported platform. "
"It will also result in *just* that file being exported when you export the "
"project, which means the data pack won't contain libraries that are "
"incompatible with the target platform."
msgstr ""
"``entry`` 部分是重要的一点: 它告诉Godot每个支持平台的项目文件系统中动态库的位"
"置. 导出项目时, 这也将导致 *仅* 导出该文件, 这意味着数据包不会包含与目标平台"
"不兼容的库."

msgid ""
"Finally, the ``dependencies`` section allows you to name additional dynamic "
"libraries that should be included as well. This is important when your "
"GDNative plugin implements someone else's library and requires you to supply "
"a third-party dynamic library with your project."
msgstr ""
"最后, ``dependencies`` 部分允许您命名应包含的其他动态库. 当您的GDNative插件实"
"现其他人的库并要求您为项目提供第三方动态库时, 这一点非常重要."

msgid ""
"If you double click on the ``gdexample.gdnlib`` file within Godot, you'll "
"see there are far more options to set:"
msgstr ""
"如果您双击Godot中的 ``gdexample.gdnlib`` 文件, 您会看到还有更多的选项要设置:"

msgid ""
"The second file we need to create is a file used by each NativeScript we've "
"added to our plugin. We'll name it ``gdexample.gdns`` for our gdexample "
"NativeScript."
msgstr ""
"我们需要创建的第二个文件是我们添加到插件中的每个NativeScript使用的文件. 我们"
"将它命名为 ``gdexample.gdns`` 用于我们的gdexample NativeScript."

msgid ""
"This is a standard Godot resource; you could just create it directly in your "
"scene, but saving it to a file makes it much easier to reuse it in other "
"places. This resource points to our gdnlib file, so that Godot can know "
"which dynamic library contains our NativeScript. It also defines the "
"``class_name`` which identifies the NativeScript in our plugin we want to "
"use."
msgstr ""
"这是标准的Godot资源; 您可以直接在场景中创建它, 但将其保存到文件可以更容易地在"
"其他地方重用它. 这个资源指向我们的gdnlib文件, 因此Godot可以知道哪个动态库包含"
"我们的NativeScript. 它还定义了 ``class_name`` , 它标识了我们想要使用的插件中"
"的NativeScript."

msgid ""
"Time to jump back into Godot. We load up the main scene we created way back "
"in the beginning and now add a Sprite to our scene:"
msgstr ""
"是时候跳回Godot了. 我们在开始时加载我们创建的主场景, 现在为场景添加一个"
"Sprite:"

msgid ""
"We're going to assign the Godot logo to this sprite as our texture, disable "
"the ``centered`` property and drag our ``gdexample.gdns`` file onto the "
"``script`` property of the sprite:"
msgstr ""
"我们要将Godot徽标指定给这个精灵作为我们的纹理, 禁用 ``centered`` 属性并将我们"
"的 ``gdexample.gdns`` 文件拖到精灵的 ``script`` 属性中:"

msgid "We're finally ready to run the project:"
msgstr "我们终于准备好运行这个项目了:"

msgid "Adding properties"
msgstr "添加属性"

msgid ""
"GDScript allows you to add properties to your script using the ``export`` "
"keyword. In GDNative you have to register the properties and there are two "
"ways of doing this. You can either bind directly to a member or use a setter "
"and getter function."
msgstr ""
"GDScript允许您使用 ``export`` 关键字向脚本添加属性. 在GDNative中, 您必须注册"
"属性, 有两种方法可以执行此操作. 您可以直接绑定到成员, 也可以使用setter和"
"getter函数."

msgid ""
"There is a third option, just like in GDScript you can directly implement "
"the ``_get_property_list``, ``_get`` and ``_set`` methods of an object but "
"that goes far beyond the scope of this tutorial."
msgstr ""
"还有第三种选择, 就像在GDScript中一样, 您可以直接实现一个对象的 "
"``_get_property_list`` , ``_get`` 和 ``_set`` 方法, 但这远远超出了本教程的范"
"围."

msgid ""
"We'll examine both starting with the direct bind. Lets add a property that "
"allows us to control the amplitude of our wave."
msgstr ""
"我们将从直接绑定开始检查两者. 让我们添加一个允许我们控制波浪幅度的属性."

msgid ""
"In our ``gdexample.h`` file we simply need to add a member variable like so:"
msgstr "在我们的 ``gdexample.h`` 文件中, 我们只需添加一个成员变量, 如下所示:"

msgid ""
"In our ``gdexample.cpp`` file we need to make a number of changes, we will "
"only show the methods we end up changing, don't remove the lines we're "
"omitting:"
msgstr ""
"在我们的 ``gdexample.cpp`` 文件中, 我们需要进行一些更改, 我们只会显示我们最终"
"更改的方法, 不要删除我们省略的行:"

msgid ""
"Once you compile the module with these changes in place, you will see that a "
"property has been added to our interface. You can now change this property "
"and when you run your project, you will see that our Godot icon travels "
"along a larger figure."
msgstr ""
"使用这些更改编译模块后，就会看到界面上加入了一个属性。您现在可以更改此属性，"
"当您运行项目时，您将看到我们的 Godot 图标沿着更大的数字移动。"

msgid ""
"The ``reloadable`` property in the ``gdexample.gdnlib`` file must be set to "
"``true`` for the Godot editor to automatically pick up the newly added "
"property."
msgstr ""
"``gdexample.gdnlib`` 文件中的 ``reloadable`` 属性必须设定为 ``true``\\ ，"
"Godot 编辑器才能自动获取到新添加的属性。"

msgid ""
"However, this setting should be used with care, especially when tool classes "
"are used, as the editor might hold objects then that have script instances "
"attached to them that are managed by a GDNative library."
msgstr ""
"但是，使用该设置时要特别小心，特别是在使用工具类时，因为编辑器可能会持有对"
"象，然后将脚本实例附加到对象上，这些对象由 GDNative 库管理。"

msgid ""
"Let's do the same but for the speed of our animation and use a setter and "
"getter function. Our ``gdexample.h`` header file again only needs a few more "
"lines of code:"
msgstr ""
"让我们做同样的事情但是为了我们动画的速度并使用 setter 和 getter 函数。我们的 "
"``gdexample.h`` 头文件再次只需要几行代码："

msgid ""
"This requires a few more changes to our ``gdexample.cpp`` file, again we're "
"only showing the methods that have changed so don't remove anything we're "
"omitting:"
msgstr ""
"这需要对我们的 ``gdexample.cpp`` 文件进行一些更改, 同样我们只显示已更改的方"
"法, 所以不要删除我们忽略的任何内容:"

msgid ""
"Now when the project is compiled, we'll see another property called speed. "
"Changing its value will make the animation go faster or slower."
msgstr ""
"编译完项目后，我们就会看到另一个名为 speed 的属性。更改其值将使动画更快或更"
"慢。"

msgid ""
"For this example, there is no obvious advantage of using a setter and "
"getter. A good reason for a setter would be if you wanted to react on the "
"variable being changed. If you don't need to do something like that, binding "
"the variable is enough."
msgstr ""
"在这个例子中，使用 setter 和 getter 并没有明显的优势。如果你想要对变量的赋值"
"作出反应，那么使用 setter 就很合适。如果你必须要做类似的事情，绑定变量就足够"
"了。"

msgid ""
"Getters and setters become far more useful in more complex scenarios where "
"you need to make additional choices based on the state of your object."
msgstr ""
"在需要根据对象状态做出其他选择的更复杂场景中,getter和setter变得更加有用."

msgid ""
"For simplicity, we've left out the optional parameters in the "
"register_property<class, type> method call. These parameters are "
"``rpc_mode``, ``usage``, ``hint`` and ``hint_string``. These can be used to "
"further configure how properties are displayed and set on the Godot side."
msgstr ""
"为简单起见，我们在 register_property<class, type> 方法调用中省略了可选的参"
"数。这些参数有 ``rpc_mode``\\ 、\\ ``usage``\\ 、\\ ``hint``\\ 、\\ "
"``hint_string``\\ 。这些可用于进一步配置属性在 Godot 方面的显示和设置方式。"

msgid ""
"Modern C++ compilers are able to infer the class and variable type and allow "
"you to omit the ``<GDExample, float>`` part of our ``register_property`` "
"method. We've had mixed experiences with this however."
msgstr ""
"现代C++编译器能够推断出类和变量类型, 并允许您省略 ``register_property`` 方法"
"的 ``<GDExample,float>`` 部分. 然而, 我们在这方面的经验好坏参半."

msgid "Signals"
msgstr "信号"

msgid ""
"Last but not least, signals fully work in GDNative as well. Having your "
"module react to a signal given out by another object requires you to call "
"``connect`` on that object. We can't think of a good example for our "
"wobbling Godot icon, we would need to showcase a far more complete example."
msgstr ""
"最后但同样重要的是, 信号也完全适用于GDNative. 让模块对另一个对象发出的信号作"
"出反应, 需要在该对象上调用 ``connect`` . 我们想不出一个摆动Godot图标的好示"
"例, 我们需要展示一个更完整的示例."

msgid "This is the required syntax:"
msgstr "这是必需的语法："

msgid ""
"Note that you can only call ``my_method`` if you've previously registered it "
"in your ``_register_methods`` method."
msgstr ""
"请注意, 如果您之前在 ``_register_methods`` 方法中注册了它, 则只能调用 "
"``my_method`` ."

msgid ""
"Having your object sending out signals is more common. For our wobbling "
"Godot icon, we'll do something silly just to show how it works. We're going "
"to emit a signal every time a second has passed and pass the new location "
"along."
msgstr ""
"让对象发出信号更为常见。对于我们摇摆不定的 Godot 图标，我们会做一些愚蠢的事情"
"来展示它是如何工作的。每过一秒钟我们就会发出一个信号并传递新的位置。"

msgid ""
"In our ``gdexample.h`` header file, we need to define a new member "
"``time_emit``:"
msgstr ""
"在我们的 ``gdexample.h`` 头文件中，我们需要定义一个新成员 ``time_emit``\\ ："

msgid ""
"This time, the changes in ``gdexample.cpp`` are more elaborate. First, "
"you'll need to set ``time_emit = 0.0;`` in either our ``_init`` method or in "
"our constructor. We'll look at the other 2 needed changes one by one."
msgstr ""
"``gdexample.cpp`` 这次的修改有点复杂。首先，你需要在我们的 ``_init`` 方法或构"
"造函数中设置 ``time_emit = 0.0``\\ 。另外两个修改我们将逐一查看。"

msgid ""
"In our ``_register_methods`` method, we need to declare our signal. This is "
"done as follows:"
msgstr ""
"在我们的 ``_register_methods`` 方法中，我们需要声明我们的信号。按如下方式实"
"现："

msgid ""
"Here, our ``register_signal`` method can be a single call first taking the "
"signals name, then having pairs of values specifying the parameter name and "
"type of each parameter we'll send along with this signal."
msgstr ""
"我们这里调用的 ``register_signal`` 方法，第一个参数是信号的名称，后续是两两一"
"组的值，用于指定与该信号一同发送的参数名及对应的类型。"

msgid "Next, we'll need to change our ``_process`` method:"
msgstr "接下来我们需要修改我们的 ``_process`` 方法："

msgid ""
"After a second has passed, we emit our signal and reset our counter. We can "
"add our parameter values directly to ``emit_signal``."
msgstr ""
"经过一秒钟后， 我们发出信号并重置我们的计数器。我们可以将参数值直接添加给 "
"``emit_signal``\\ 。"

msgid ""
"Once the GDNative library is compiled, we can go into Godot and select our "
"sprite node. In the **Node** dock, we can find our new signal and link it up "
"by pressing the **Connect** button or double-clicking the signal. We've "
"added a script on our main node and implemented our signal like this:"
msgstr ""
"完成 GDNative 库的编译后，我们可以进入 Godot 并选择我们的精灵节点。在\\ **节"
"点**\\ 面板上，我们可以找到我们新建的信号，并通过点按\\ **连接**\\ 按钮或双击"
"信号将其链接起来。我们在主节点上添加了一个脚本并实现了这样的信号："

msgid "Every second, we output our position to the console."
msgstr "每一秒，我们都会将我们的位置输出到控制台。"

msgid "Next steps"
msgstr "下一步"

msgid ""
"The above is only a simple example, but we hope it shows you the basics. You "
"can build upon this example to create full-fledged scripts to control nodes "
"in Godot using C++."
msgstr ""
"以上只是一个简单的示例, 但我们希望它向您展示基础知识. 您可以在此示例的基础上"
"构建完整的脚本, 以使用C++控制Godot中的节点."

msgid ""
"To edit and recompile the plugin while the Godot editor remains open, re-run "
"the project after the library has finished building."
msgstr ""
"要在 Godot 编辑器打开时编辑并重新编译插件，请在完成库的构建后重新运行项目。"

msgid "Translation status"
msgstr "翻译状态"
