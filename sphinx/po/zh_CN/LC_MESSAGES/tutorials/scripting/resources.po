# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Resources"
msgstr "资源"

msgid "Nodes and resources"
msgstr "节点和资源"

msgid ""
"Up to this tutorial, we focused on the :ref:`Node <class_Node>` class in "
"Godot as that's the one you use to code behavior and most of the engine's "
"features rely on it. There is another datatype that is just as important: :"
"ref:`Resource <class_Resource>`."
msgstr ""
"在本教程之前, 我们重点研究Godot中的 :ref:`Node <class_Node>` 类, 因为它是你用"
"来编码行为的类, 并且引擎的大多数功能都依赖于该类. 还有另一个同样重要的数据类"
"型: :ref:`Resource <class_Resource>`."

msgid ""
"*Nodes* give you functionality: they draw sprites, 3D models, simulate "
"physics, arrange user interfaces, etc. **Resources** are **data "
"containers**. They don't do anything on their own: instead, nodes use the "
"data contained in resources."
msgstr ""
"*节点* 为你提供功能: 它们绘制精灵, 3D模型, 模拟物理, 排列用户界面等. **资源"
"** 是 **数据容器** . 它们自己不能做任何事情: 而是, 节点使用资源中包含的数据."

msgid ""
"Anything Godot saves or loads from disk is a resource. Be it a scene (a ``."
"tscn`` or an ``.scn`` file), an image, a script... Here are some :ref:"
"`Resource <class_Resource>` examples:"
msgstr ""
"Godot 保存到磁盘、从磁盘读取的都是资源。资源可以是场景（\\ ``.tscn`` 或 ``."
"scn`` 文件）、图像、脚本……以下是一些 :ref:`Resource <class_Resource>` 的示"
"例："

msgid ":ref:`Texture <class_Texture>`"
msgstr ":ref:`Texture <class_Texture>`"

msgid ":ref:`Script <class_Script>`"
msgstr ":ref:`Script <class_Script>`"

msgid ":ref:`Mesh <class_Mesh>`"
msgstr ":ref:`Mesh <class_Mesh>`"

msgid ":ref:`Animation <class_Animation>`"
msgstr ":ref:`Animation <class_Animation>`"

msgid ":ref:`AudioStream <class_AudioStream>`"
msgstr ":ref:`AudioStream <class_AudioStream>`"

msgid ":ref:`Font <class_Font>`"
msgstr ":ref:`Font <class_Font>`"

msgid ":ref:`Translation <class_Translation>`"
msgstr ":ref:`Translation <class_Translation>`"

msgid ""
"When the engine loads a resource from disk, **it only loads it once**. If a "
"copy of that resource is already in memory, trying to load the resource "
"again will return the same copy every time. As resources only contain data, "
"there is no need to duplicate them."
msgstr ""
"当引擎从磁盘加载资源时, **它只加载一次** . 如果该资源的副本已在内存中, 则每次"
"尝试再次加载该资源将返回相同的副本. 由于资源只包含数据, 因此无需复制它们."

msgid ""
"Every object, be it a Node or a Resource, can export properties. There are "
"many types of Properties, like String, integer, Vector2, etc., and any of "
"these types can become a resource. This means that both nodes and resources "
"can contain resources as properties:"
msgstr ""
"每个对象(无论是节点还是资源)都可以导出属性. 属性有很多类型, 例如String, "
"integer, Vector2等, 并且任何这些类型都可以成为资源. 这意味着节点和资源都可以"
"包含资源以作为属性:"

msgid "External vs built-in"
msgstr "外部与内置"

msgid "There are two ways to save resources. They can be:"
msgstr "有两种保存资源的方法. 它们是:"

msgid "**External** to a scene, saved on the disk as individual files."
msgstr "**外部** , 对于场景, 作为单独文件保存在磁盘上."

msgid ""
"**Built-in**, saved inside the ``.tscn`` or the ``.scn`` file they're "
"attached to."
msgstr "**内置**\\ ，保存在它们所附加的 ``.tscn`` 或 ``.scn`` 文件内。"

#, fuzzy
msgid ""
"To be more specific, here's a :ref:`Texture2D <class_Texture2D>` in a :ref:"
"`Sprite2D <class_Sprite2D>` node:"
msgstr ""
"更具体地说, 这是一个 :ref:`Sprite <class_Sprite>` 节点中的一个 :ref:`Texture "
"<class_Texture>`:"

#, fuzzy
msgid ""
"Clicking the resource preview allows us to view the resource's properties."
msgstr "点击资源预览可以使我们查看和编辑资源的属性."

msgid ""
"The path property tells us where the resource comes from. In this case, it "
"comes from a PNG image called ``robi.png``. When the resource comes from a "
"file like this, it is an external resource. If you erase the path or this "
"path is empty, it becomes a built-in resource."
msgstr ""
"``Path`` 属性告诉我们资源来自何处. 在这里, 它来自一个叫 ``robi.png`` 的PNG图"
"像. 当资源来自这样的文件时, 它属于外部资源. 如果你去掉这个路径或此路径为空, "
"则它将成为内置资源."

msgid ""
"The switch between built-in and external resources happens when you save the "
"scene. In the example above, if you erase the path ``\"res://robi.png\"`` "
"and save, Godot will save the image inside the ``.tscn`` scene file."
msgstr ""
"保存场景时, 将在内置资源和外部资源之间进行切换. 在上面的示例中, 如果删除路径 "
"``\"res://robi.png\"`` 并保存,Godot会将图像保存在 ``.tscn`` 场景文件中."

msgid ""
"Even if you save a built-in resource, when you instance a scene multiple "
"times, the engine will only load one copy of it."
msgstr ""
"即使你保存一个内置资源, 当多次实例化一个场景时, 引擎也只会加载该场景的一个副"
"本."

msgid "Loading resources from code"
msgstr "从代码中加载资源"

msgid ""
"There are two ways to load resources from code. First, you can use the "
"``load()`` function anytime:"
msgstr "有两种方法可以从代码加载资源. 首先, 你可以随时使用 ``load()`` 函数:"

#, fuzzy
msgid ""
"You can also ``preload`` resources. Unlike ``load``, this function will read "
"the file from disk and load it at compile-time. As a result, you cannot call "
"``preload`` with a variable path: you need to use a constant string."
msgstr ""
"您也可以 ``预加载(preload)`` 资源. 与 ``load`` 不同, ``preload`` 会从硬盘中读"
"取文件, 并在编译时加载它. 因此, 您不能使用一个变量化的路径调用预加载: 您需要"
"使用常量字符串."

msgid "Loading scenes"
msgstr "加载场景"

#, fuzzy
msgid ""
"Scenes are also resources, but there is a catch. Scenes saved to disk are "
"resources of type :ref:`PackedScene <class_PackedScene>`. The scene is "
"packed inside a :ref:`Resource <class_Resource>`."
msgstr ""
"场景也是资源, 但也有一个陷阱. 保存到磁盘的场景是 :ref:`PackedScene "
"<class_PackedScene>` 类型的资源. 该场景被打包在资源内部."

#, fuzzy
msgid ""
"To get an instance of the scene, you have to use the :ref:`PackedScene."
"instantiate() <class_PackedScene_method_instantiate>` method."
msgstr ""
"要获取场景的实例, 您必须使用 :ref:`PackedScene.instance() "
"<class_PackedScene_method_instance>` 方法."

msgid ""
"This method creates the nodes in the scene's hierarchy, configures them, and "
"returns the root node of the scene. You can then add it as a child of any "
"other node."
msgstr ""
"此方法在场景的层次结构中创建节点, 对其进行配置, 然后返回场景的根节点. 然后, "
"你可以将其添加为任何其他节点的子级."

#, fuzzy
msgid ""
"The approach has several advantages. As the :ref:`PackedScene.instantiate() "
"<class_PackedScene_method_instantiate>` function is fast, you can create new "
"enemies, bullets, effects, etc. without having to load them again from disk "
"each time. Remember that, as always, images, meshes, etc. are all shared "
"between the scene instances."
msgstr ""
"该方法有几个优点. 由于 :ref:`PackedScene.instance() "
"<class_PackedScene_method_instance>` 函数速度相当快, 您可以创建新的敌人, 子"
"弹, 效果等, 而无需每次都从磁盘再次加载它们. 请记住, 像往常一样, 图像, 网格等"
"都是在场景实例之间共享的."

msgid "Freeing resources"
msgstr "释放资源"

#, fuzzy
msgid ""
"When a :ref:`Resource <class_Resource>` is no longer in use, it will "
"automatically free itself. Since, in most cases, Resources are contained in "
"Nodes, when you free a node, the engine frees all the resources it owns as "
"well if no other node uses them."
msgstr ""
"当 ``资源(Resource)`` 不再使用时, 它将自动释放自己. 由于在大多数情况下, 资源"
"包含在节点中, 因此当您释放节点时, 如果没有其他节点使用该节点拥有的所有资源, "
"则引擎也会释放它们."

msgid "Creating your own resources"
msgstr "创建自己的资源"

msgid ""
"Like any Object in Godot, users can also script Resources. Resource scripts "
"inherit the ability to freely translate between object properties and "
"serialized text or binary data (\\*.tres, \\*.res). They also inherit the "
"reference-counting memory management from the Reference type."
msgstr ""
"像Godot中的任何Object一样, 用户也可以编写资源脚本. 资源脚本继承了object类属性"
"和序列化文本或二进制数据( ``*.tres`` , ``*.res`` )之间自由转换的能力. 它们还"
"从 ``Reference`` 类型继承引用计数内存管理."

#, fuzzy
msgid ""
"This comes with many distinct advantages over alternative data structures, "
"such as JSON, CSV, or custom TXT files. Users can only import these assets "
"as a :ref:`Dictionary <class_Dictionary>` (JSON) or as a :ref:`FileAccess "
"<class_FileAccess>` to parse. What sets Resources apart is their inheritance "
"of :ref:`Object <class_Object>`, :ref:`RefCounted <class_RefCounted>`, and :"
"ref:`Resource <class_Resource>` features:"
msgstr ""
"与其他替代数据结构(如JSON, CSV或自定义TXT文件)相比, 它具有许多明显的优势. 用"
"户只能将这些资源导入为 :ref:`Dictionary <class_Dictionary>` (JSON)或要解析"
"的 :ref:`File <class_File>`. 将资源区分开来的是它们对 :ref:`Object "
"<class_Object>`, :ref:`Reference <class_Reference>`, 和 :ref:`Resource "
"<class_Resource>` 功能的继承:"

msgid ""
"They can define constants, so constants from other data fields or objects "
"are not needed."
msgstr "它们可以定义常量, 因此不需要其他数据字段或对象中的常量."

msgid ""
"They can define methods, including setter/getter methods for properties. "
"This allows for abstraction and encapsulation of the underlying data. If the "
"Resource script's structure needs to change, the game using the Resource "
"need not also change."
msgstr ""
"它们可以定义方法, 包括属性的 ``setter/getter`` 方法. 这允许对基础数据进行抽象"
"和封装. 如果资源脚本的结构需要更改, 则使用资源的游戏则不必更改."

msgid ""
"They can define signals, so Resources can trigger responses to changes in "
"the data they manage."
msgstr "它们可以定义信号, 因此 ``Resources`` 可以触发对所管理数据更改的响应."

msgid ""
"They have defined properties, so users know 100% that their data will exist."
msgstr "它们具有已定义的属性, 因此用户知道其数据将100％存在."

msgid ""
"Resource auto-serialization and deserialization is a built-in Godot Engine "
"feature. Users do not need to implement custom logic to import/export a "
"resource file's data."
msgstr ""
"资源自动序列化和反序列化是一个Godot引擎的内置功能. 用户无需实现自定义逻辑即可"
"导入/导出资源文件的数据."

msgid ""
"Resources can even serialize sub-Resources recursively, meaning users can "
"design even more sophisticated data structures."
msgstr "资源甚至可以递归地序列化子资源, 这意味着用户可以设计更复杂的数据结构."

msgid ""
"Users can save Resources as version-control-friendly text files (\\*.tres). "
"Upon exporting a game, Godot serializes resource files as binary files (\\*."
"res) for increased speed and compression."
msgstr ""
"用户可以将资源保存为版本控制友好的文本文件(``*.tres``). 导出游戏后,Godot将资"
"源文件序列化为二进制文件(``*.res``), 以提高速度和压缩率."

msgid ""
"Godot Engine's Inspector renders and edits Resource files out-of-the-box. As "
"such, users often do not need to implement custom logic to visualize or edit "
"their data. To do so, double-click the resource file in the FileSystem dock "
"or click the folder icon in the Inspector and open the file in the dialog."
msgstr ""
"Godot 引擎的检查器开箱即用地渲染和编辑资源文件。这样，用户通常不需要实现自定"
"义逻辑即可可视化或编辑其数据。为此，请在文件系统面板中双击资源文件，或在检查"
"器中点击文件夹图标，然后在对话框中打开该文件。"

msgid ""
"They can extend **other** resource types besides just the base Resource."
msgstr "它们可以扩展除基本 Resource 之外的\\ **其他**\\ 资源类型。"

msgid "Godot makes it easy to create custom Resources in the Inspector."
msgstr "Godot 可以轻松地在检查器面板中创建自定义 Resource。"

msgid ""
"Create a plain Resource object in the Inspector. This can even be a type "
"that derives Resource, so long as your script is extending that type."
msgstr ""
"在检查器面板中创建一个普通的 Resource 对象。只要是扩展自 Resource 的类型，你"
"的脚本就可以去扩展。"

msgid "Set the ``script`` property in the Inspector to be your script."
msgstr "将检查器中的 ``script`` 属性设置为你的脚本。"

msgid ""
"The Inspector will now display your Resource script's custom properties. If "
"one edits those values and saves the resource, the Inspector serializes the "
"custom properties too! To save a resource from the Inspector, click the "
"Inspector's tools menu (top right), and select \"Save\" or \"Save As...\"."
msgstr ""
"现在，检查器将显示 Resource 脚本的自定义属性。如果编辑这些值并保存资源，则检"
"查器也会序列化自定义属性！要从检查器中保存资源，请点击检查器的工具菜单（右上"
"角），然后选择“保存”或“另存为...”。"

msgid ""
"If the script's language supports :ref:`script classes "
"<doc_gdscript_basics_class_name>`, then it streamlines the process. Defining "
"a name for your script alone will add it to the Inspector's creation dialog. "
"This will auto-add your script to the Resource object you create."
msgstr ""
"如果脚本的语言支持\\ :ref:`脚本类 <doc_gdscript_basics_class_name>`\\ ，则可"
"以简化该过程。仅为脚本定义名称会将其添加到“检查器”的创建对话框。这会将脚本自"
"动添加到你创建的 Resource 对象中。"

msgid ""
"Let's see some examples. Create a :ref:`Resource <class_Resource>` and name "
"it ``bot_stats``. It should appear in your file tab with the full name "
"``bot_stats.tres``. Without a script, it's useless, so let's add some data "
"and logic! Attach a script to it named ``bot_stats.gd`` (or just create a "
"new script, and then drag it to it)."
msgstr ""

msgid ""
"Now, create a :ref:`CharacterBody3D <class_CharacterBody3D>`, name it "
"``Bot``, and add the following script to it:"
msgstr ""

msgid ""
"Now, select the :ref:`CharacterBody3D <class_CharacterBody3D>` node which we "
"named ``bot``, and drag&drop the ``bot_stats.tres`` resource onto the "
"Inspector. It should print 10! Obviously, this setup can be used for more "
"advanced features than this, but as long you really understand *how* it all "
"worked, you should figure out everything else related to Resources."
msgstr ""

msgid ""
"Resource scripts are similar to Unity's ScriptableObjects. The Inspector "
"provides built-in support for custom resources. If desired though, users can "
"even design their own Control-based tool scripts and combine them with an :"
"ref:`EditorPlugin <class_EditorPlugin>` to create custom visualizations and "
"editors for their data."
msgstr ""
"资源脚本类似于 Unity 的 ScriptableObject。检查器为自定义资源提供内置支持。如"
"果需要的话，用户甚至可以设计自己的基于 Control 控件的工具脚本，并将它们与一"
"个 :ref:`EditorPlugin <class_EditorPlugin>` 结合起来，以为他们的数据创建自定"
"义的可视化和编辑器。"

#, fuzzy
msgid ""
"Unreal Engine's DataTables and CurveTables are also easy to recreate with "
"Resource scripts. DataTables are a String mapped to a custom struct, similar "
"to a Dictionary mapping a String to a secondary custom Resource script."
msgstr ""
"虚幻 4 引擎的数据表 DataTable 和 CurveTable 也很容易使用资源脚本重新创建。数"
"据表 DataTable 是映射到自定义结构的字符串，类似于将字符串映射到辅助自定义资源"
"脚本的字典。"

msgid ""
"Instead of inlining the Dictionary values, one could also, alternatively:"
msgstr "除了内联 Dictionary 值之外，还可以选择："

msgid ""
"Import a table of values from a spreadsheet and generate these key-value "
"pairs."
msgstr "从电子表格导入值表并生成这些键值对。"

msgid ""
"Design a visualization within the editor and create a plugin that adds it to "
"the Inspector when you open these types of Resources."
msgstr ""
"在编辑器中设计可视化方法，创建一个简单的插件，在你打开这些类型的 Resource "
"时，将其添加到检查器中。"

msgid ""
"CurveTables are the same thing, except mapped to an Array of float values or "
"a :ref:`Curve <class_Curve>`/:ref:`Curve2D <class_Curve2D>` resource object."
msgstr ""
"CurveTable 是相同的东西，除了映射到一个浮点值数组或一个 :ref:`Curve "
"<class_Curve>`/ :ref:`Curve2D <class_Curve2D>` 资源对象之外。"

msgid ""
"Beware that resource files (\\*.tres/\\*.res) will store the path of the "
"script they use in the file. When loaded, they will fetch and load this "
"script as an extension of their type. This means that trying to assign a "
"subclass, i.e. an inner class of a script (such as using the ``class`` "
"keyword in GDScript) won't work. Godot will not serialize the custom "
"properties on the script subclass properly."
msgstr ""
"请注意，资源文件（\\*.tres/\\*.res）将在文件中存储它们使用的脚本的路径。加载"
"后，它们将获取并加载此脚本作为其类型的扩展。这意味着尝试指定一个子类，即脚本"
"的内部类（例如在 GDScript 中使用 ``class`` 关键字）将不起作用。Godot 将无法正"
"确序列化脚本子类上的自定义属性。"

msgid ""
"In the example below, Godot would load the ``Node`` script, see that it "
"doesn't extend ``Resource``, and then determine that the script failed to "
"load for the Resource object since the types are incompatible."
msgstr ""
"在下面的示例中，Godot 将加载 ``Node`` 脚本，并看到它没有扩展 "
"``Resource``\\ ，然后判断脚本由于类型不兼容而无法为 Resource 对象加载。"

msgid "Translation status"
msgstr "翻译状态"
