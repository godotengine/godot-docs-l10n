# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-29 23:14+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Nodes and scene instances"
msgstr "节点与场景实例"

msgid ""
"This guide explains how to get nodes, create nodes, add them as a child, and "
"instantiate scenes from code."
msgstr ""
"本指南将介绍如何获取节点、创建节点、将节点添加为子项、使用代码实例化场景。"

msgid "Getting nodes"
msgstr "获取节点"

msgid ""
"You can get a reference to a node by calling the :ref:`Node.get_node() "
"<class_Node_method_get_node>` method. For this to work, the child node must "
"be present in the scene tree. Getting it in the parent node's ``_ready()`` "
"function guarantees that."
msgstr ""
"你可以通过调用 :ref:`Node.get_node() <class_Node_method_get_node>` 方法来获取"
"节点的引用。子节点必须在场景树中才能成功。在父节点的 ``_ready()`` 函数中获取"
"就可以保证这一点。"

msgid ""
"If, for example,  you have a scene tree like this, and you want to get a "
"reference to the Sprite2D and Camera2D nodes to access them in your script."
msgstr ""
"例如，如果有这样的场景树，并且你希望获得对 Sprite2D 和 Camera2D 节点的引用，"
"以便在脚本中访问它们。"

msgid "To do so, you can use the following code."
msgstr "那么，你可以使用如下代码。"

msgid ""
"Note that you get nodes using their name, not their type. Above, "
"\"Sprite2D\" and \"Camera2D\" are the nodes' names in the scene."
msgstr ""
"请注意，你是通过名称来获取节点的，而不是节点的类型。上面"
"的“Sprite2D”和“Camera2D”都是这些节点在场景中的名字。"

msgid ""
"If you rename the Sprite2D node as Skin in the Scene dock, you have to "
"change the line that gets the node to ``get_node(\"Skin\")`` in the script."
msgstr ""
"如果你在“场景”面板中将“Sprite2D”节点重命名为“Skin”，那就必须在脚本里把获得节"
"点的那一行语句写成 ``get_node(\"Skin\")``\\ 。"

msgid "Node paths"
msgstr "节点路径"

msgid ""
"When getting a reference to a node, you're not limited to getting a direct "
"child. The ``get_node()`` function supports paths, a bit like when working "
"with a file browser. Add a slash to separate nodes."
msgstr ""
"获取节点的引用时，并不仅限于直接子节点。\\ ``get_node()`` 函数支持使用路径，"
"有点类似文件浏览器里的路径。可以用斜杠分隔节点。"

msgid ""
"Take the following example scene, with the script attached to the "
"UserInterface node."
msgstr "在下面这个实例场景中，脚本是附加在 UserInterface 节点上的。"

msgid "To get the AnimationPlayer node, you would use the following code."
msgstr "要获取 AnimationPlayer 节点，你可以使用如下代码。"

msgid ""
"As with file paths, you can use \"..\" to get a parent node. The best "
"practice is to avoid doing that though not to break encapsulation. You can "
"also start the path with a forward slash to make it absolute, in which case "
"your topmost node would be \"/root\", the application's predefined root "
"viewport."
msgstr ""
"和文件路径一样，你可以使用“..”来获取父节点。最佳实践是不要这么做，避免破坏封"
"装。你还可以让路径以斜杠开头，这样的路径是绝对路径，最上层的节点就是“/root”，"
"即程序的预定义根视口。"

msgid "Syntactic sugar"
msgstr "语法糖"

msgid ""
"You can use two shorthands to shorten your code in GDScript. Firstly, "
"putting the ``@onready`` annotation before a member variable makes it "
"initialize right before the ``_ready()`` callback."
msgstr ""
"GDScript 中有两个速写法可以用来缩短代码。首先是在成员变量的前面写上 "
"``@onready`` 关键字，这样这个变量就会刚好在 ``_ready()`` 回调之前初始化。"

msgid ""
"There is also a short notation for ``get_node()``: the dollar sign, \"$\". "
"You place it before the name or path of the node you want to get."
msgstr ""
"还有一个 ``get_node()`` 的速记法：美元符号“$”。可以把它放在想要获取的名称或者"
"节点路径之前。"

msgid "Creating nodes"
msgstr "创建节点"

msgid ""
"To create a node from code, call its ``new()`` method like for any other "
"class-based datatype."
msgstr ""
"要通过代码创建节点，请像其他任何基于类的数据类型一样，调用其 ``new()`` 方法。"

msgid ""
"You can store the newly created node's reference in a variable and call "
"``add_child()`` to add it as a child of the node to which you attached the "
"script."
msgstr ""
"你可以将新创建的节点的引用保存在一个变量中，然后调用 ``add_child()`` 将其添加"
"为脚本所在节点的子项。"

msgid ""
"To delete a node and free it from memory, you can call its ``queue_free()`` "
"method. Doing so queues the node for deletion at the end of the current "
"frame after it has finished processing. At that point, the engine removes "
"the node from the scene and frees the object in memory."
msgstr ""
"要删除节点、将其从内容中释放，你可以调用其 ``queue_free()`` 方法。这样该节点"
"的删除任务就会被添加到队列中，在当前帧完成处理后就会执行。删除时，引擎会把该"
"节点从场景中删除，然后释放对象内存中的对象。"

#, fuzzy
msgid ""
"Before calling ``sprite2d.queue_free()``, the remote scene tree looks like "
"this."
msgstr "在调用 ``sprite.queue_free()`` 之前，远程场景树是类似这样的。"

msgid ""
"After the engine freed the node, the remote scene tree doesn't display the "
"sprite anymore."
msgstr "在引擎释放节点后，远程场景树就不会再现实这个精灵了。"

msgid ""
"You can alternatively call ``free()`` to immediately destroy the node. You "
"should do this with care as any reference to it will instantly become "
"``null``. We recommend using ``queue_free()`` unless you know what you're "
"doing."
msgstr ""
"你也可以调用 ``free()`` 来立即删除该节点。调用时需要小心，因为所有对它的引用"
"都会立即变成 ``null``\\ 。除非你知道自己在干什么，否则我们建议使用 "
"``queue_free()``\\ 。"

msgid ""
"When you free a node, it also frees all its children. Thanks to this, to "
"delete an entire branch of the scene tree, you only have to free the topmost "
"parent node."
msgstr ""
"释放节点时也会释放它的所有子项。多亏如此，只需删除最顶端的父节点，就可以删除"
"整个场景树分支了。"

msgid "Instancing scenes"
msgstr "实例化场景"

msgid ""
"Scenes are templates from which you can create as many reproductions as "
"you'd like. This operation is called instancing, and doing it from code "
"happens in two steps:"
msgstr ""
"场景就是模板，你可以用来来创建任意数量的复制品。这样的操作叫作实例化"
"（instancing），在代码中进行实例化总共分两步："

msgid "Loading the scene from the local drive."
msgstr "从本地硬盘加载场景。"

msgid ""
"Creating an instance of the loaded :ref:`PackedScene <class_PackedScene>` "
"resource."
msgstr "创建加载到的 :ref:`PackedScene <class_PackedScene>` 资源的实例。"

msgid ""
"Preloading the scene can improve the user's experience as the load operation "
"happens when the compiler reads the script and not at runtime. This feature "
"is only available with GDScript."
msgstr ""
"预加载场景可以提升用户体验，因为加载操作发生在编译器读取脚本时，而非运行时。"
"这个特性是 GDScript 独有的。"

msgid ""
"At that point, ``scene`` is a packed scene resource, not a node. To create "
"the actual node, you need to call :ref:`PackedScene.instantiate() "
"<class_PackedScene_method_instantiate>`. It returns a tree of nodes that you "
"can use as a child of your current node."
msgstr ""
"此时的 ``scene`` 是个打包场景资源，而不是节点。要创建实际的节点，你需要调用 :"
"ref:`PackedScene.instantiate() <class_PackedScene_method_instantiate>`\\ 。它"
"会返回一棵节点树，你可以将其添加为当前节点的子节点。"

msgid ""
"The advantage of this two-step process is you can keep a packed scene loaded "
"and create new instances on the fly. For example, to quickly instance "
"several enemies or bullets."
msgstr ""
"此两步过程的优点在于，打包的场景可以保持加载状态并可以随时使用。例如，你就可"
"以快速地对许多敌人或子弹进行实例化。"

msgid "Translation status"
msgstr "翻译状态"
