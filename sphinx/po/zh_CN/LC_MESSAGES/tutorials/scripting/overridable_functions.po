# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-29 23:14+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Overridable functions"
msgstr "可覆盖函数"

msgid ""
"Godot's Node class provides virtual functions you can override to update "
"nodes every frame or on specific events, like when they enter the scene tree."
msgstr ""
"Godot 的 Node 类提供了虚函数，你可以通过覆盖虚函数来在每帧或发生特定事件时更"
"新节点，比如进入场景树时。"

msgid "This document presents the ones you'll use most often."
msgstr "本文档中会展示你会经常用到的那些。"

msgid ""
"Under the hood, these functions rely on Godot's low-level notifications "
"system. To learn more about it, see :ref:`doc_godot_notifications`."
msgstr ""
"这些函数在引擎内部会依赖 Godot 的底层通知系统。要了解相关学习，请参阅 :ref:"
"`doc_godot_notifications`\\ 。"

#, fuzzy
msgid ""
"Two functions allow you to initialize and get nodes besides the class's "
"constructor: ``_enter_tree()`` and ``_ready()``."
msgstr ""
"除了类的构造函数之外，还有两个函数可以用来初始化并获取节点：\\ "
"``_enter_tree()`` 和 ``_ready()``\\ 。"

msgid ""
"When the node enters the Scene Tree, it becomes active and the engine calls "
"its ``_enter_tree()`` method. That node's children may not be part of the "
"active scene yet. As you can remove and re-add nodes to the scene tree, this "
"function may be called multiple times throughout a node's lifetime."
msgstr ""
"节点进入场景树时就会被激活，引擎会调用其 ``_enter_tree()`` 方法。该节点的子项"
"可能还不是活动场景的一部分。因为你可以从场景树中移除节点然后重新添加，在一个"
"节点的生命期中，这个函数可能会被调用多次。"

#, fuzzy
msgid ""
"Most of the time, you'll use ``_ready()`` instead. This function is called "
"only once in a node's lifetime, after ``_enter_tree()``. ``_ready()`` "
"ensures that all children have entered the scene tree first, so you can "
"safely call ``get_node()`` on them."
msgstr ""
"你在大多数时候用的其实是 ``_ready()``\\ 。这个函数只会在节点的生命期中被调用"
"一次，在 ``_enter_tree()`` 之后。\\ ``_ready()`` 可以保证所有子项都已经进入了"
"场景树，所以你可以安全地去调用 ``get_node()``\\ 。"

msgid ""
"To learn more about getting node references, read :ref:"
"`doc_nodes_and_scene_instances`."
msgstr ""
"要学习更多关于节点引用的知识，请阅读 :ref:"
"`doc_nodes_and_scene_instances`\\ 。"

#, fuzzy
msgid ""
"Another related callback is ``_exit_tree()``, which the engine calls every "
"time a node is about to exit the scene tree. This can be when you call :ref:"
"`Node.remove_child() <class_Node_method_remove_child>` or when you free a "
"node."
msgstr ""
"另一个有关的回调是 ``_exit_tree()``\\ ，引擎会在节点退出场景树时调用。既可以"
"是你调用 :ref:`Node.remove_child() <class_Node_method_remove_child>` 时，也可"
"以是你释放这个节点时。"

msgid ""
"The two virtual methods ``_process()`` and ``_physics_process()`` allow you "
"to update the node, every frame and every physics frame respectively. For "
"more information, read the dedicated documentation: :ref:"
"`doc_idle_and_physics_processing`."
msgstr ""
"虚函数 ``_process()`` 和 ``_physics_process()`` 可以分别用来对节点进行每帧和"
"每物理帧的更新。要了解更多信息，请阅读专门的文档：\\ :ref:"
"`doc_idle_and_physics_processing`\\ 。"

#, fuzzy
msgid ""
"Two more essential built-in node callback functions are :ref:`Node."
"_unhandled_input() <class_Node_private_method__unhandled_input>` and :ref:"
"`Node._input() <class_Node_private_method__input>`, which you use to both "
"receive and process individual input events. The ``_unhandled_input()`` "
"method receives every key press, mouse click, etc. that have not been "
"handled already in an ``_input()`` callback or in a user interface "
"component. You want to use it for gameplay input in general. The "
"``_input()`` callback allows you to intercept and process input events "
"before ``_unhandled_input()`` gets them."
msgstr ""
"还有两个关键的内置节点回调函数 :ref:`Node._input() "
"<class_Node_method__input>` 和 :ref:`Node._unhandled_input() "
"<class_Node_method__unhandled_input>`\\ 。两者都可以用来接收并处理单独的输入"
"事件。如果按键、鼠标点击等事件没有被 ``_input()`` 回调或用户界面组件处理，\\ "
"``_unhandled_input()`` 方法才会收到这个事件。游戏中的输入通常是使用后者处理"
"的。\\ ``_input()`` 回调可以用来在 ``_unhandled_input()`` 获取前拦截并处理输"
"入事件。"

msgid ""
"To learn more about inputs in Godot, see the :ref:`Input section <toc-learn-"
"features-inputs>`."
msgstr ""
"要学习更多关于 Godot 中输入的内容，请参阅\\ :ref:`输入章节 <toc-learn-"
"features-inputs>`\\ 。"

#, fuzzy
msgid ""
"There are some more overridable functions like :ref:`Node."
"_get_configuration_warnings() "
"<class_Node_private_method__get_configuration_warnings>`. Specialized node "
"types provide more callbacks like :ref:`CanvasItem._draw() "
"<class_CanvasItem_private_method__draw>` to draw programmatically or :ref:"
"`Control._gui_input() <class_Control_private_method__gui_input>` to handle "
"clicks and input on UI elements."
msgstr ""
"还有 :ref:`Node._get_configuration_warning() "
"<class_Node_method__get_configuration_warning>` 等更多的可覆盖函数。特定的节"
"点类型也会提供很多回调，比如 :ref:`CanvasItem._draw() "
"<class_CanvasItem_method__draw>` 可以用程序来绘图，\\ :ref:`Control."
"_gui_input() <class_Control_method__gui_input>` 可以处理 UI 元素上的点击和输"
"入。"

msgid "Translation status"
msgstr "翻译状态"
