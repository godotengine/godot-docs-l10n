# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Singletons (Autoload)"
msgstr "单例（自动加载）"

msgid "Introduction"
msgstr "前言"

msgid ""
"Godot's scene system, while powerful and flexible, has a drawback: there is "
"no method for storing information (e.g. a player's score or inventory) that "
"is needed by more than one scene."
msgstr ""
"Godot 的场景系统虽然强大而灵活，但有一个缺点：无法保存多个场景都需要的信息"
"（例如玩家的分数或者背包）。"

msgid ""
"It's possible to address this with some workarounds, but they come with "
"their own limitations:"
msgstr "可以通过一些变通方法来解决此问题，但是它们有其自身的局限性："

msgid ""
"You can use a \"master\" scene that loads and unloads other scenes as its "
"children. However, this means you can no longer run those scenes "
"individually and expect them to work correctly."
msgstr ""
"你可以使用“主”场景来把其它场景当作自己的子节点来加载和卸载。然而，这就意味着"
"这些场景无法再独立正常运行。"

msgid ""
"Information can be stored to disk in ``user://`` and then loaded by scenes "
"that require it, but frequently saving and loading data is cumbersome and "
"may be slow."
msgstr ""
"信息可以存储在磁盘的 ``user://`` 下，然后由需要它的场景加载，但是经常保存和加"
"载数据很麻烦并且可能很慢。"

msgid ""
"The `Singleton pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`_ "
"is a useful tool for solving the common use case where you need to store "
"persistent information between scenes. In our case, it's possible to reuse "
"the same scene or class for multiple singletons as long as they have "
"different names."
msgstr ""
"`单例模式 <https://en.wikipedia.org/wiki/Singleton_pattern>`_\\ 是解决需要在"
"场景之间存储持久性信息的常见用例的实用工具。在我们的示例中，只要多个单例具有"
"不同的名称，就可以复用相同的场景或类。"

msgid "Using this concept, you can create objects that:"
msgstr "利用这个概念，你可以创建这样的对象："

msgid "Are always loaded, no matter which scene is currently running."
msgstr "无论当前运行哪个场景，始终加载。"

msgid "Can store global variables such as player information."
msgstr "可以存储全局变量，如玩家信息。"

msgid "Can handle switching scenes and between-scene transitions."
msgstr "可以处理切换场景和场景间的过渡。"

msgid ""
"*Act* like a singleton, since GDScript does not support global variables by "
"design."
msgstr "*行为*\\ 类似单例，因为 GDScript 在设计上就不支持全局变量。"

msgid "Autoloading nodes and scripts can give us these characteristics."
msgstr "自动加载的节点和脚本可以为我们提供这些特征。"

#, fuzzy
msgid ""
"Godot won't make an Autoload a \"true\" singleton as per the singleton "
"design pattern. It may still be instanced more than once by the user if "
"desired."
msgstr ""
"Godot 不会让自动加载变成单例设计模式里的那种“真”单例。如果需要，还是可以把它"
"进行多次实例化的。"

msgid ""
"If you're creating an autoload as part of an editor plugin, consider :ref:"
"`registering it automatically in the Project Settings "
"<doc_making_plugins_autoload>` when the plugin is enabled."
msgstr ""
"如果你创建的自动加载是编辑器插件的一部分，请考虑在启用插件时\\ :ref:`将其自动"
"注册到项目设置中 <doc_making_plugins_autoload>`。"

msgid "Autoload"
msgstr "自动加载"

#, fuzzy
msgid ""
"You can create an Autoload to load a scene or a script that inherits from :"
"ref:`class_Node`."
msgstr ""
"你可以创建自动加载（AutoLoad）来加载场景或者继承自 :ref:`class_Node` 的脚本。"

msgid ""
"When autoloading a script, a :ref:`class_Node` will be created and the "
"script will be attached to it. This node will be added to the root viewport "
"before any other scenes are loaded."
msgstr ""
"自动加载脚本时，会创建一个 :ref:`class_Node` 并把脚本附加上去。加载其它任何场"
"景前，这个节点就会被加到根视图上。"

#, fuzzy
msgid ""
"To autoload a scene or script, select **Project > Project Settings** from "
"the menu and switch to the **Autoload** tab."
msgstr ""
"要自动加载场景或脚本，请从菜单中选择\\ **项目 > 项目设置**\\ ，然后切换到\\ "
"**自动加载**\\ 选项卡。"

msgid ""
"Here you can add any number of scenes or scripts. Each entry in the list "
"requires a name, which is assigned as the node's ``name`` property. The "
"order of the entries as they are added to the global scene tree can be "
"manipulated using the up/down arrow keys. Like regular scenes, the engine "
"will read these nodes in top-to-bottom order."
msgstr ""
"你可以在这里添加任意数量的场景或脚本。列表中的每个条目都需要一个名称，会被用"
"来给该节点的 ``name`` 属性赋值。使用上下箭头键可以操纵将条目添加到全局场景树"
"时的顺序。与普通场景一样，引擎读取这些节点的顺序是从上到下的。"

msgid ""
"This means that any node can access a singleton named \"PlayerVariables\" "
"with:"
msgstr "这意味着，任何节点都可以访问并使用一个名为“PlayerVariables”的单例："

#, fuzzy
msgid ""
"If the **Enable** column is checked (which is the default), then the "
"singleton can be accessed directly in GDScript, without requiring "
"``get_node()``:"
msgstr ""
"如果勾选了\\ **启用**\\ 一栏（默认勾选），那么就可以直接访问该单例而不需要 "
"``get_node()``\\ ："

msgid ""
"Note that autoload objects (scripts and/or scenes) are accessed just like "
"any other node in the scene tree. In fact, if you look at the running scene "
"tree, you'll see the autoloaded nodes appear:"
msgstr ""
"请注意，访问自动加载对象（脚本、场景）的方式和访问场景树中的任何其他节点是一"
"样的。实际上，如果你查看正在运行的场景树，就会看到自动加载的节点出现："

msgid ""
"Autoloads must **not** be removed using ``free()`` or ``queue_free()`` at "
"runtime, or the engine will crash."
msgstr ""
"运行时绝对\\ **不能**\\ 通过 ``free()`` 或 ``queue_free()`` 去移除自动加载，"
"否则引擎会崩溃。"

msgid "Custom scene switcher"
msgstr "自定义场景切换器"

#, fuzzy
msgid ""
"This tutorial will demonstrate building a scene switcher using autoloads. "
"For basic scene switching, you can use the :ref:`SceneTree."
"change_scene_to_file() <class_SceneTree_method_change_scene_to_file>` method "
"(see :ref:`doc_scene_tree` for details). However, if you need more complex "
"behavior when changing scenes, this method provides more functionality."
msgstr ""
"本教程将演示如何使用自动加载来构建场景切换器。基本的场景切换可以使用 :ref:"
"`SceneTree.change_scene() <class_SceneTree_method_change_scene>`\\ （详情请参"
"见 :ref:`doc_scene_tree`\\ ）。然而，如果在更改场景时需要更复杂的行为，这个方"
"法可提供更多功能。"

#, fuzzy
msgid ""
"To begin, download the template from here: `singleton_autoload_starter.zip "
"<https://github.com/godotengine/godot-docs-project-starters/releases/"
"download/latest-4.x/singleton_autoload_starter.zip>`_ and open it in Godot."
msgstr ""
"首先，请下载模板 :download:`autoload.zip <files/autoload.zip>` 并在 Godot 中"
"打开。"

#, fuzzy
msgid ""
"The project contains two scenes: ``scene_1.tscn`` and ``scene_2.tscn``. Each "
"scene contains a label displaying the scene name and a button with its "
"``pressed()`` signal connected. When you run the project, it starts in "
"``scene_1.tscn``. However, pressing the button does nothing."
msgstr ""
"该项目包含两个场景：\\ ``Scene1.tscn`` 和 ``Scene2.tscn``\\ 。每个场景都包含"
"一个显示场景名称的标签和一个连接了 ``pressed()`` 信号的按钮。运行该项目时，它"
"将从 ``Scene1.tscn`` 开始，但是按下按钮不会执行任何操作。"

#, fuzzy
msgid "Creating the script"
msgstr "创建脚本"

#, fuzzy
msgid ""
"Open the **Script** window and create a new script called ``global.gd``. "
"Make sure it inherits from ``Node``:"
msgstr ""
"切换到 **Script（脚本）** 选项卡，然后新建一个名为 ``Global.gd`` 的脚本。确保"
"它继承自 ``Node``\\ ："

#, fuzzy
msgid ""
"The next step is to add this script to the autoLoad list. Open **Project > "
"Project Settings** from the menu, switch to the **Autoload** tab and select "
"the script by clicking the browse button or typing its path: ``res://global."
"gd``. Press **Add** to add it to the autoload list:"
msgstr ""
"下一步是将此脚本添加到自动加载列表中。从菜单中打开\\ **项目 > 项目设置**\\ ，"
"切换到\\ **自动加载**\\ 选项卡，然后单击文件浏览按钮或键入其路径：\\ ``res://"
"Global.gd``\\ 。按\\ **添加**\\ 将其添加到自动加载列表："

msgid ""
"Now whenever we run any scene in the project, this script will always be "
"loaded."
msgstr "现在，无论何时在项目中运行任何场景，该脚本都将始终加载。"

#, fuzzy
msgid ""
"Returning to the script, it needs to fetch the current scene in the "
"`_ready()` function. Both the current scene (the one with the button) and "
"``global.gd`` are children of root, but autoloaded nodes are always first. "
"This means that the last child of root is always the loaded scene."
msgstr ""
"返回到脚本，它需要在 ``_ready()`` 函数中获取当前场景。当前场景（带有按钮的那"
"个）和 ``global.gd`` 都是根节点的子节点，但是自动加载的节点始终是第一个。这意"
"味着根节点的最后一个子节点始终是加载的场景。"

msgid ""
"Now we need a function for changing the scene. This function needs to free "
"the current scene and replace it with the requested one."
msgstr ""
"现在我们需要一个用于更改场景的函数。这个函数需要释放当前场景，并将其替换为请"
"求的场景。"

msgid ""
"Using :ref:`Object.call_deferred() <class_Object_method_call_deferred>`, the "
"second function will only run once all code from the current scene has "
"completed. Thus, the current scene will not be removed while it is still "
"being used (i.e. its code is still running)."
msgstr ""
"使用 :ref:`Object.call_deferred() <class_Object_method_call_deferred>`，第二"
"个函数将仅在当前场景中的所有代码完成后运行。因此，当前场景在仍在使用（即其代"
"码仍在运行）时不会被删除。"

msgid ""
"Finally, we need to fill the empty callback functions in the two scenes:"
msgstr "最后，我们需要在两个场景中填充空的回调函数："

msgid "and"
msgstr "以及"

msgid ""
"Run the project and test that you can switch between scenes by pressing the "
"button."
msgstr "运行该项目，并测试你可以通过按下按钮来切换场景。"

msgid ""
"When scenes are small, the transition is instantaneous. However, if your "
"scenes are more complex, they may take a noticeable amount of time to "
"appear. To learn how to handle this, see the next tutorial: :ref:"
"`doc_background_loading`."
msgstr ""
"当场景较小时，过渡是瞬时的。但是，如果你的场景比较复杂，则可能需要花费相当长"
"的时间才能显示出来。要了解如何处理此问题，请参阅下一个教程：\\ :ref:"
"`doc_background_loading`。"

msgid ""
"Alternatively, if the loading time is relatively short (less than 3 seconds "
"or so), you can display a \"loading plaque\" by showing some kind of 2D "
"element just before changing the scene. You can then hide it just after the "
"scene is changed. This can be used to indicate to the player that a scene is "
"being loaded."
msgstr ""
"另外，如果加载时间相对较短（少于 3 秒左右），你可以在改变场景之前，通过显示某"
"种 2D 元素来显示一个“加载中图标”，然后在改变场景后隐藏它。这能让玩家知道场景"
"正在载入。"

msgid "Translation status"
msgstr "翻译状态"
