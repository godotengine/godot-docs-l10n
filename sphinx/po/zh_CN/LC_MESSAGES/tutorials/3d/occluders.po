# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Occluder Nodes"
msgstr "遮挡器节点"

msgid ""
"In addition to occlusion via :ref:`doc_rooms_and_portals`, Godot also has "
"the ability to provide basic occlusion using simple geometric ``Occluder`` "
"nodes. These are geometric shapes that are shown in the editor using gizmos, "
"but are invisible at runtime."
msgstr ""
"除了通过 :ref:`doc_rooms_and_portals` 实现遮挡外，Godot 还提供了使用简单几何 "
"``Occluder``\\ （遮挡器）节点进行简单遮挡的能力。这些几何体形状会在编辑器中以"
"小工具的形式显示，在运行时不可见。"

msgid ""
"Any object that is fully occluded by the shape (behind or in some cases "
"inside) will be culled at runtime. They are designed to be simple to use and "
"inexpensive at runtime, but the trade off is they may not be as effective at "
"culling as :ref:`doc_rooms_and_portals`. Nevertheless they can still "
"significantly boost performance in some situations."
msgstr ""
"完全被该形状遮挡（位于背部或内部）的对象在运行时会被剔除。它们是以简单易用、"
"不带来运行时负担为目的而设计的，但也因此可能没有 :ref:"
"`doc_rooms_and_portals` 高效。然而，在某些情况下仍然会带来显著的性能提升。"

msgid ""
"It is important to understand that geometric occluders work by testing the "
"axis aligned bounding box (``AABB``) of the occludee against the occluder. "
"The AABB must be *fully occluded* to be culled. The consequence of this is "
"that smaller objects are more likely to be effectively culled than larger "
"objects, and larger occluders tend to be much more effective than smaller "
"ones."
msgstr ""
"需要重点注意的是，几何体遮挡器的工作原理是检查遮挡器和被遮挡物体的轴对齐包围"
"盒（\\ ``AABB``\\ ）。AABB 被\\ *完全遮挡*\\ 才会进行剔除。因此，剔除较小的对"
"象比剔除较大的对象更高效，较大的遮挡器通常比较小的遮挡器效率更高。"

msgid ""
"A major advantage to Occluder nodes is that they are fully dynamic. For "
"example if you place an occluder node as a child of a spaceship, it will "
"move as you move the parent object."
msgstr ""
"Occluder 节点的主要优势在于它们是完全动态的。例如你为宇宙飞船添加了遮挡器子节"
"点，那么这个遮挡器就会跟随父对象移动。"

msgid ""
"The reason that Occluder nodes are so cheap in performance terms is that the "
"engine dynamically chooses the most relevant occluders at runtime, based on "
"the current viewpoint of the Camera. This means you can often have hundreds "
"of occluders present in the scene. Only the most relevant will be active at "
"any one time."
msgstr ""
"Occluder 节点之所以对性能影响那么小，是因为引擎在运行时会根据当前 Camera 的视"
"角动态选择最相关的遮挡器。也就是说, 你可以在一个场景里拥有上百个遮挡器，在同"
"一时间，只有那个最相关的会被激活。"

msgid ""
"The Occluder node itself is a holder for an OccluderShape resource, which "
"determines the functionality. To get started, add an Occluder node to your "
"scene tree."
msgstr ""
"Occluder 节点自身就是 OccluderShape 资源的持有者，功能顾名思义。首先，在你的"
"场景树中添加一个 Occluder 节点。"

msgid ""
"You will see a yellow warning triangle that lets you know that you must set "
"an OccluderShape from the inspector before the ``Occluder`` becomes "
"functional."
msgstr ""
"你会看到一个黄色的警告三角形，表示在 ``Occluder`` 可以生效之前，你必须在检查"
"器中为其设置一个 OccluderShape。"

msgid "OccluderShapeSphere"
msgstr "OccluderShapeSphere"

msgid ""
"The sphere is one of the simplest and fastest occluders, and is easy to "
"setup and position. The downside is that the sphere only tends to make sense "
"in certain game level designs, and is more suited to terrain or organic "
"background geometry."
msgstr ""
"球体是最简单快速的遮挡器之一，设置和摆放都很方便。缺点是球体往往只在特定的游"
"戏关卡设计中有意义，更适用于地形和有机背景几何体。"

msgid ""
"Once you have added an OccluderNode and chosen to add a new "
"``OccluderShapeSphere`` in the inspector, click the OccluderShapeSphere in "
"the inspector to bring up the parameters."
msgstr ""
"添加 OccluderNode 并在检查器中新建 ``OccluderShapeSphere`` 后，点击检查器中"
"的 OccluderShapeSphere 调出它的参数。"

msgid ""
"Unlike many Nodes, the ``OccluderShapeSphere`` can store multiple spheres in "
"the same object. This is more efficient in the engine, and keeps your "
"SceneTree clearer. You don't have to store all your spheres in one Occluder "
"as it could become tricky to manage, but it is perfectly reasonable to add "
"10 or so spheres or more. They are very cheap, and often the more you place, "
"the better the match you will get to your geometry."
msgstr ""
"与很多 Node 节点不同，\\ ``OccluderShapeSphere`` 可以在一个对象中存储多个球"
"体。在引擎中更高效，也能让你的 SceneTree 场景树更清爽。你不必把所有的球体都保"
"存在同一个 Occluder 里，管理起来会很麻烦，加 10 个左右的球体是比较合理的。这"
"些球体非常轻量，而且通常加得越多越能与几何体相匹配。"

msgid ""
"In order to store multiple spheres, they are stored as an Array. If you "
"click on the Array in the inspector, you can increase the size of the Array "
"to add one."
msgstr ""
"为了保存多个球体，它们会被存入 Array 数组。你可以在检查器中点击 Array，然后"
"把 Array 的大小增大，来添加一个球体。"

msgid ""
"The sphere will appear as a small pink spherical object in the editor "
"window. There are two handles on each sphere. The larger middle handle "
"enables you to move the sphere around in the local space of the Occluder, "
"and the small handle enables you to adjust the radius."
msgstr ""
"编辑器窗口中，这个球体会显示为一个小小的粉色圆形物体。每个球体有两个句柄。中"
"间较大的的句柄可以用来在 Occluder 的局部空间中移动球体，较小的句柄可以用来调"
"整半径。"

msgid ""
"Although you can change the position of the sphere using the Occluder Node "
"transform in the inspector, this moves *the entire array* of spheres. When "
"you want to use multiple spheres in one occluder, the handles do this job. "
"In order to allow positioning in 3D, the gizmo will only move the 3D "
"position in the two principal axes depending on the viewpoint in the editor. "
"This is easier for you to get the hang of by trying it out than by "
"explanation."
msgstr ""
"虽然你也可以通过在检查器中修改 Occluder 节点的变换属性来改变这个球体的位置，"
"但是这样就会移动\\ *数组中的所有*\\ 球体。如果你想在一个遮挡器中使用多个球"
"体，请使用那些句柄来调整位置。因为要支持 3D 空间中的定位，小工具会根据编辑器"
"的视点，只允许移动 3D 位置中的两个主轴。百闻不如一试。"

msgid ""
"There is one more handy function in the editor when using multiple spheres. "
"If you click the `Center Node` toolbar button it will recalculate the local "
"positions of the spheres relative to the average of the entire node, and "
"change the transform of the Occluder Node. This is a handy convenience "
"function to make it easier to place them."
msgstr ""
"使用多个球体时，编辑器还提供了一个便捷的功能。如果你单击工具栏上的\\ `居中节"
"点`\\ 按钮，就会重新计算这些球体相对于整个节点的局部位置，然后修改 Occluder "
"节点的变换。这个功能可以让排布小球变得更方便。"

msgid ""
"At runtime the spheres can be switched on and off changing the Occluder node "
"visibility, and the Node can be moved and scaled and rotated etc."
msgstr ""
"在运行时，你可以通过修改 Occluder 节点的可见性来开关这些球体，这个节点也能进"
"行移动、缩放、旋转等操作。"

msgid ""
"A common use case for occluder spheres is providing occlusion on "
"mountainous / hilly terrain. By placing spheres inside mountains you can "
"prevent trees, plants, building and objects rendering behind mountains. With "
"some creativity they can also be used for moving objects such as large "
"spacecraft, planets etc."
msgstr ""
"球体遮挡器的常见使用场景是为山体/丘陵地形提供遮挡。把球体放在山体内部，你就可"
"以防止渲染山背面的树木、植物、建筑、对象等内容。如果发挥想象力，还可以把它们"
"用于大型飞行器、星球等移动对象。"

msgid "OccluderShapePolygon"
msgstr "OccluderShapePolygon"

msgid ""
"The polygon is a generalist occluder. It can be made to work well in almost "
"all situations, and can quickly provide a degree of occlusion culling to "
"most scenes."
msgstr ""
"多边形是通用的遮挡器，几乎在任何情况下都可以使用，可以迅速为大多数场景提供一"
"定程度的遮挡剔除。"

msgid ""
"As with all geometric occluders, the key to success is to make them large. "
"They do not have to match rendered geometry, and in many cases they will "
"work better if you extend them past rendered geometry to make them as big as "
"possible (without blocking legitimate lines of sight). The reason why they "
"need to be large is that in general, they will only cull objects whose "
"``AABB`` is completely hidden by the polygon. For large objects to be "
"culled, you will need large occluders."
msgstr ""
"和所有几何体遮挡器一样，成功的关键是把它们变大。它们不必和渲染的几何体完全一"
"致，很多情况下让它们超过渲染的几何体，（在不阻挡有效的视线的前提下）尽可能地"
"大反而效果更好。背后的原因是，一般来说多边形只会剔除 ``AABB`` 完全被它们遮挡"
"的对象。要剔除较大的对象，你就需要更大的遮挡器。"

msgid ""
"Like all occluders, polygons **can** overlap, and in many cases they will "
"work better if you overlap them (they are more likely to cull objects on "
"boundaries)."
msgstr ""
"和所有遮挡器一样，多边形是\\ **可以**\\ 重叠的，很多情况下重叠起来效果更好"
"（剔除位于边界的对象的几率更大）。"

msgid "Editing and details"
msgstr "编辑与细节"

msgid ""
"Occluder polygons are edited as a list of points which define a *convex* "
"polygon, on a single plane. In order to confine the polygon to a single "
"plane, the points are defined in 2D space rather than 3D. The orientation, "
"position and scale of the polygon is taken instead from the transform of the "
"``Occluder`` Node."
msgstr ""
"遮挡器多边形是以顶点列表的形式编辑的，这个列表定义的是位于同一平面上的\\ *凸"
"*\\ 多边形。为了保证多边形位于同一平面，这些顶点是定义在 2D 空间，而不是 3D "
"空间中的。该多边形的朝向、位置、缩放是从该 ``Occluder`` 节点的变换中获取的。"

msgid ""
"If you create an Occluder and add to it a ``OccluderShapePolygon`` resource, "
"by default it will create 4 starting points forming a rectangle. If you move "
"the position and rotation of the Occluder Node you will see how the "
"rectangle follows the node. When the Occluder is selected in the editor, "
"handles will appear for each of the points. You can actually click and drag "
"these handles, to match your polygon to the environment of your scene."
msgstr ""
"如果你创建一个 Occluder 并为其添加一个 ``OccluderShapePolygon`` 资源，默认会"
"创建 4 个起始点，组成一个矩形。如果你修改该 Occluder 节点的位置和旋转，就可以"
"看到该矩形会跟着节点一同变化。在编辑器中选中该 Occluder 时，每个节点都会出现"
"一个句柄。你可以点击并拖动这些句柄，让你的多边形与场景中的环境相匹配。"

msgid ""
"You are not restricted to 4 points, you can add and remove points in the "
"Inspector, but note that:"
msgstr ""
"你并不限于 4 个顶点，你可以在检查器中对顶点进行添加和移除，不过请注意："

msgid ""
"The editor will automatically sanitize your points to form a convex polygon. "
"If you drag a point into a position that would form a concave polygon, it "
"will be ignored."
msgstr ""
"编辑器会自动清理这些顶点，让它们组成凸多边形。如果你把某个顶点拖到了可能形成"
"凹多边形的位置，那么这个顶点就会被忽略。"

msgid ""
"In general, the less edges (and thus points), the faster the polygon will "
"work at runtime. A polygon with 6 edges will have to make twice the "
"calculations of a polygon with 3 edges. In most cases 4 is a good number."
msgstr ""
"一般而言，边越少（顶点也越少），多边形在运行时就越快。6 条边的多边形要花费 3 "
"条边的多边形两倍的计算量。在大多数情况下，有 4 个顶点就不错了。"

msgid "Holes"
msgstr "空洞"

msgid ""
"Real world game levels don't always have large continuous areas that should "
"be occluded. Often walls will have a door or windows, caves will have an "
"entrance, etc. In some cases we have to make do by placing several "
"OccluderShapePolygons around such an opening, but Occluder polygons have one "
"more trick up their sleeve - they can have \"holes\"."
msgstr ""
"现实世界的游戏关卡并不总是存在大片连续的需要遮挡的区域。墙上一般都有门窗，山"
"洞会有入口，等等。有些情况下，我们需要围绕这种缺口放置若干个 "
"OccluderShapePolygon，但 Occluder 多边形还有一个生活小妙招——它们可以有“空"
"洞”。"

msgid ""
"In the inspector you will notice that as well as a set of points for the "
"polygon, the polygon has a set of points for a single \"hole\". If you add 3 "
"or 4 to your polygon, you will see they appear in the editor as smaller "
"handles. You can drag these around just like the polygon handles, to form a "
"convex hole."
msgstr ""
"在检查器里，你会发现多边形除了有一组顶点之外，还有一组“空洞”的顶点。如果你为"
"你的多边形添加 3 到 4 个这样的顶点，你会看到编辑器中出现了一些更小的句柄。这"
"些句柄可以和多边形句柄一样拖动，形成一个凸洞。"

msgid ""
"The hole can be totally within the polygon (such as a window), abutting the "
"edge (like a door) or crossing the edge of the polygon completely, to make "
"the occluder concave. The way the hole works is that the culling follows a "
"simple rule:"
msgstr ""
"空洞可以完全在多边形内部（例如窗户）、接近边界（类似门）、或者与某一条边相"
"切，让整个遮挡器变成凹的。空洞的工作原理遵循以下简单的规则："

msgid ""
"If the object to be culled is totally hidden by the polygon, it then looks "
"to see whether it can be seen *through* the hole. If the object touches the "
"hole, it is not culled, but if hidden by the polygon and not seen through "
"the hole it is culled."
msgstr ""
"如果要剔除的对象完全被多边形遮蔽，那么它就会去看是否可以\\ *透过*\\ 空洞看到"
"自己。如果该对象碰到了空洞，那么就不会被剔除，但如果是被多边形遮蔽并且无法透"
"过空洞看到那么就会被剔除。"

msgid ""
"Placing holes is usually far more convenient, and works faster and better at "
"runtime, than creating lots of smaller OccluderShapePolygons."
msgstr ""
"相比于创建很多个比较小的 OccluderShapePolygon，添加空洞一般更加便捷，在运行时"
"也更快更好。"

msgid "Hole Limits"
msgstr "空洞的限制"

msgid ""
"The main limitation of holes is that there can only be one per polygon. If "
"you have a situation which requires two or more holes, you have a choice:"
msgstr ""
"空洞的主要限制是每个多边形只能有一个空洞。如果你存在需要两个或更多的空洞的场"
"景，你可以选择："

msgid ""
"Combine the area of the two holes into one bigger hole (if they are close "
"together)."
msgstr "把两个空洞的区域联合为一个较大的空洞（如果它们靠得比较近）。"

msgid "Use two or more OccluderPolygons."
msgstr "使用两个或更多的 OccluderPolygon。"

msgid ""
"Remember that if you are using more than one polygon, they can overlap, and "
"you should use this to your advantage."
msgstr "请记住，多个多边形是可以重叠的，你应该利用这一点。"

msgid "How many Occluder polys are needed?"
msgstr "需要多少 Occluder 多边形呢？"

msgid ""
"This very much depends on your scene, but generally you can start getting a "
"good benefit from 3 or 4 well placed polygons. After that it is totally up "
"to you how much time you want to spend. Placing occluders is a bit of an art "
"form, and you will get better at it and learn new tricks the more you work "
"with them."
msgstr ""
"这很大程度上取决于你的场景，不过一般而言，从 3 到 4 个精心布置的多边形开始就"
"可以获得不错的效果。在此之后，就完全取决于你打算花费多少时间了。遮挡器的放置"
"可以算是一种艺术形式，用得越多，掌握得也就越好，也能从中学得新的技巧。"

msgid "Some ideas:"
msgstr "一些想法："

msgid "Build your levels to take advantage of occlusion."
msgstr "在构建关卡时考虑遮挡。"

msgid ""
"This is one of the secrets of the pros. A good level design is not just "
"about what the gameplay demands, it should also be built with occlusion in "
"mind."
msgstr ""
"这就是很多专业人士的秘密。好的关卡设计并不只是满足游戏性的需求，也应该同时考"
"虑遮挡。"

msgid ""
"When in a building with multiple floors, try placing an occluder polygon "
"between each floor, with a hole for where the staircase transitions between "
"them. This can potentially cull out entire floors and greatly improve "
"performance."
msgstr ""
"在多层建筑中，可以试试在楼层之间放置一个多边形遮挡器，然后在楼层之间楼梯井的"
"位置放一个空洞。这样就应该能够剔除整个楼层，大幅提升性能。"

msgid ""
"Don't be afraid to extend your occluder polygons far past the edges of "
"visible geometry to cull more objects - for instance far into the ground or "
"sky."
msgstr ""
"不要害怕将你的多边形遮挡器延伸到可见几何体边界之外的地方，这样可以剔除更多的"
"对象——例如一直延伸到地面或这天空之中。"

msgid "Using polygons dynamically"
msgstr "动态地使用多边形"

msgid ""
"Like all geometric occluders, polygons are not confined to static (non-"
"moving) geometry. You can place them on moving objects. You can even change "
"the relative position of the points in realtime."
msgstr ""
"和所有几何体遮挡器一样，多边形并不局限于静态（不移动）的几何体，可以在移动的"
"对象上放置。你甚至可以实时地改变顶点的相对位置。"

msgid "Some guidelines:"
msgstr "一些规范："

msgid ""
"There is a slight cost to moving polygons, the points of the polygons must "
"be transformed on the CPU each time their transform changes."
msgstr ""
"移动多边形是有较小的花费的，多边形顶点的变换每发生一次变化，都必须在 CPU 上进"
"行变换。"

msgid ""
"This is not something to worry excessively about, even CPUs are reasonably "
"fast at transforming points, and generally polygons have very few points "
"compared to rendered geometry. But it is something to consider, if you "
"wanted to create e.g. 10,000 simultaneous spaceships all with occluder polys."
msgstr ""
"不用太过于担心这些，即便是 CPU 也能对顶点进行比较快速的变换，一般而言多边形比"
"渲染的几何体上的顶点要少得多。不过如果你想要为 10000 个同屏的飞船创建多边形遮"
"挡器，那还是需要进行考量的。"

msgid ""
"Changing the transform of the polygon Node (e.g. by moving the parent "
"object) is cheaper than changing the points themselves. Use the former "
"rather than the latter wherever possible."
msgstr ""
"改变多边形节点的变换（例如移动父级对象）比改变顶点本身要轻量。请尽可能使用前"
"者而不是后者。"

msgid "Translation status"
msgstr "翻译状态"
