# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using 3D transforms"
msgstr "使用 3D 变换"

msgid "Introduction"
msgstr "前言"

msgid ""
"If you have never made 3D games before, working with rotations in three "
"dimensions can be confusing at first. Coming from 2D, the natural way of "
"thinking is along the lines of *\"Oh, it's just like rotating in 2D, except "
"now rotations happen in X, Y and Z\"*."
msgstr ""
"如果你以前从未制作过3D游戏, 那么一开始在三维环境中进行旋转可能会让人感到困"
"惑. 从2D来的人, 自然的思维方式就是类似于 *\"噢, 它就像2D旋转一样, 只是现在旋"
"转发生在X,Y和Z轴上\"* ."

msgid ""
"At first, this seems easy. For simple games, this way of thinking may even "
"be enough. Unfortunately, it's often incorrect."
msgstr ""
"起初这似乎很简单。对于简单的游戏，这种思维方式甚至可能足够了。不幸的是，这往"
"往是不正确的。"

msgid ""
"Angles in three dimensions are most commonly referred to as \"Euler Angles\"."
msgstr "三维角度通常被称为“欧拉角”。"

msgid ""
"Euler angles were introduced by mathematician Leonhard Euler in the early "
"1700s."
msgstr "欧拉角是由数学家莱昂哈德·欧拉在 1700 年代初引入的。"

msgid ""
"This way of representing 3D rotations was groundbreaking at the time, but it "
"has several shortcomings when used in game development (which is to be "
"expected from a guy with a funny hat). The idea of this document is to "
"explain why, as well as outlining best practices for dealing with transforms "
"when programming 3D games."
msgstr ""
"这种代表三维旋转的方式在当时是开创性的, 但在游戏开发中使用时有一些缺点(这毕竟"
"是一个戴着滑稽帽子的家伙想出来的). 本文的主旨是解释其原因, 并概述在编写3D游戏"
"时处理变换的最佳做法."

msgid "Problems of Euler angles"
msgstr "欧拉角的问题"

msgid ""
"While it may seem intuitive that each axis has a rotation, the truth is that "
"it's just not practical."
msgstr "虽然看起来很直观, 每个轴都有一个旋转, 但事实是它就是不实用."

msgid "Axis order"
msgstr "轴顺序"

msgid ""
"The main reason for this is that there isn't a *unique* way to construct an "
"orientation from the angles. There isn't a standard mathematical function "
"that takes all the angles together and produces an actual 3D rotation. The "
"only way an orientation can be produced from angles is to rotate the object "
"angle by angle, in an *arbitrary order*."
msgstr ""
"这样的主要原因是没有一种 *单一* 的从角度构建方向的方法. 没有一个标准的数学函"
"数可以将所有角度放在一起并产生实际的3D旋转. 从角度产生方向的唯一方法是以 *任"
"意顺序* 按角度旋转物体角度."

msgid ""
"This could be done by first rotating in *X*, then *Y* and then in *Z*. "
"Alternatively, you could first rotate in *Y*, then in *Z* and finally in "
"*X*. Anything works, but depending on the order, the final orientation of "
"the object will *not necessarily be the same*. Indeed, this means that there "
"are several ways to construct an orientation from 3 different angles, "
"depending on *the order of the rotations*."
msgstr ""
"这可以通过先旋转 *X* , 然后 *Y* , 然后旋转 *Z* 来完成. 或者, 你可以先以旋转 "
"*Y* , 然后旋转 *Z* , 最后旋转 *X* . 怎样都行, 但根据顺序不同, 对象的最终方向 "
"*不一定是相同的* . 事实上, 这意味着有多种方法可以从3个不同的角度构建方向, 具"
"体取决于 *旋转的顺序* ."

msgid ""
"Following is a visualization of rotation axes (in X, Y, Z order) in a gimbal "
"(from Wikipedia). As you can see, the orientation of each axis depends on "
"the rotation of the previous one:"
msgstr ""
"下图是一个万向结(来自维基百科), 它有可视化的旋转轴(以XYZ顺序). 如你所见, 每个"
"轴的方向取决于前一个轴的旋转方向:"

msgid ""
"You may be wondering how this affects you. Let's look at a practical example:"
msgstr "你可能想知道这是如何影响你的. 我们来看一个实际的示例:"

msgid ""
"Imagine you are working on a first-person controller (e.g. an FPS game). "
"Moving the mouse left and right controls your view angle parallel to the "
"ground, while moving it up and down moves the player's view up and down."
msgstr ""
"想象一下, 你正在做一个第一人称控制器(例如FPS游戏). 向左和向右移动鼠标可以控制"
"与地面平行的视角, 同时上下移动可以调整游戏角色上下的视野."

msgid ""
"In this case to achieve the desired effect, rotation must be applied first "
"in the *Y* axis (\"up\" in this case, since Godot uses a \"Y-Up\" "
"orientation), followed by rotation in the *X* axis."
msgstr ""
"为了实现希望的效果, 必须先在 *Y* 轴上应用旋转(在这种情况下为 \"up(向上)\", 因"
"为Godot中Y轴指向正上方(\" Y-Up\" 方向)), 然后在 *X* 轴上旋转."

msgid ""
"If we were to apply rotation in the *X* axis first, and then in *Y*, the "
"effect would be undesired:"
msgstr ""
"如果我们首先在 *X* 轴上应用旋转, 然后再在 *Y* 轴上应用旋转, 则效果会不理想:"

msgid ""
"Depending on the type of game or effect desired, the order in which you want "
"axis rotations to be applied may differ. Therefore, applying rotations in X, "
"Y, and Z is not enough: you also need a *rotation order*."
msgstr ""
"根据所需的游戏类型或效果, 你想要应用轴旋转的顺序可能会有所不同. 因此, 在X,Y和"
"Z中应用旋转是不够的: 你还需要 *旋转顺序* ."

msgid "Interpolation"
msgstr "插值"

msgid ""
"Another problem with using Euler angles is interpolation. Imagine you want "
"to transition between two different camera or enemy positions (including "
"rotations). One logical way to approach this is to interpolate the angles "
"from one position to the next. One would expect it to look like this:"
msgstr ""
"使用欧拉角的另一个问题是插值. 设想你想在两个不同的相机或敌人位置(包括旋转)之"
"间转换. 解决这个问题的一个合乎逻辑的方法是从一个位置插值到下一个位置. 人们会"
"期望它看起来像这样:"

msgid "But this does not always have the expected effect when using angles:"
msgstr "但是, 在使用角度时, 这并不总是有预期的效果:"

msgid "The camera actually rotated the opposite direction!"
msgstr "相机实际上旋转去了相反的方向！"

msgid "There are a few reasons this may happen:"
msgstr "这可能有几个原因:"

msgid ""
"Rotations don't map linearly to orientation, so interpolating them does not "
"always result in the shortest path (i.e., to go from ``270`` to ``0`` "
"degrees is not the same as going from ``270`` to ``360``, even though the "
"angles are equivalent)."
msgstr ""
"旋转不会线性映射到方向, 因此它们插值并不总是会形成最短路径(即从 ``270`` 到 "
"``0`` 的度数与从 ``270`` 开始到 ``360`` 的度数不同, 即使角度是相同的)."

msgid ""
"Gimbal lock is at play (first and last rotated axis align, so a degree of "
"freedom is lost). See `Wikipedia's page on Gimbal Lock <https://en.wikipedia."
"org/wiki/Gimbal_lock>`_ for a detailed explanation of this problem."
msgstr ""
"\"万向节锁死\" 正在发挥作用(第一个和最后一个旋转的轴对齐, 因此失去了一个自由"
"度). 请参阅 `维基百科关于Gimbal Lock 的页面 <https://en.wikipedia.org/wiki/"
"Gimbal_lock>`_ 以了解这个问题的详细解释."

msgid "Say no to Euler angles"
msgstr "对欧拉角说不"

msgid ""
"The result of all this is that you should **not use** the ``rotation`` "
"property of :ref:`class_Node3D` nodes in Godot for games. It's there to be "
"used mainly in the editor, for coherence with the 2D engine, and for simple "
"rotations (generally just one axis, or even two in limited cases). As much "
"as you may be tempted, don't use it."
msgstr ""
"所有这些的结论是，你 **不应该** 在游戏中使用 Godot :ref:`class_Node3D` 节点"
"的 ``rotation`` 属性。它主要用在编辑器中，为了与2D引擎一致，并且用于简单的旋"
"转（通常只有一个轴，或者，在有限的情况下，两个）。尽管你可能会受到诱惑，但不"
"要使用它。"

msgid "Instead, there is a better way to solve your rotation problems."
msgstr "相反, 有一个更好的方法来解决你的旋转问题."

msgid "Introducing transforms"
msgstr "变换的介绍"

msgid ""
"Godot uses the :ref:`class_Transform3D` datatype for orientations. Each :ref:"
"`class_Node3D` node contains a ``transform`` property which is relative to "
"the parent's transform, if the parent is a Node3D-derived type."
msgstr ""
"Godot 里的方向使用 :ref:`class_Transform3D` 数据类型。每个 :ref:"
"`class_Node3D` 节点都包含一个与父级变换相关的 ``transform`` 属性（如果父级是 "
"Node3D 派生类型）。"

msgid ""
"It is also possible to access the world coordinate transform via the "
"``global_transform`` property."
msgstr "也可以通过 ``global_transform`` 属性访问世界坐标变换."

msgid ""
"A transform has a :ref:`class_Basis` (transform.basis sub-property), which "
"consists of three :ref:`class_Vector3` vectors. These are accessed via the "
"``transform.basis`` property and can be accessed directly by ``transform."
"basis.x``, ``transform.basis.y``, and ``transform.basis.z``. Each vector "
"points in the direction its axis has been rotated, so they effectively "
"describe the node's total rotation. The scale (as long as it's uniform) can "
"also be inferred from the length of the axes. A *basis* can also be "
"interpreted as a 3x3 matrix and used as ``transform.basis[x][y]``."
msgstr ""
"变换拥有一个基 :ref:`class_Basis`\\ （transform.basis 子属性），它由三个 :"
"ref:`class_Vector3` 向量组成。这些向量可以通过 ``transform.basis`` 属性访问，"
"也可以使用 ``transform.basis.x``\\ 、\\ ``transform.basis.y``\\ 、\\ "
"``transform.basis.z`` 直接访问。每个向量指向它的轴被旋转的方向，因此它们可以"
"有效地描述节点的总旋转。比例（只要它三个轴长度是一致的）也可以从轴的长度推断"
"出来。一个\\ *基*\\ 也可以被解释为一个 3x3 矩阵并像 ``transform.basis[x]"
"[y]`` 这样使用。"

msgid "A default basis (unmodified) is akin to:"
msgstr "默认的基（未经修改）类似于："

msgid "This is also an analog of a 3x3 identity matrix."
msgstr "这也类似于一个 3x3 单位矩阵。"

msgid ""
"Following the OpenGL convention, ``X`` is the *Right* axis, ``Y`` is the "
"*Up* axis and ``Z`` is the *Forward* axis."
msgstr "遵循OpenGL惯例, ``X`` 是 *右* 轴, ``Y`` 是 *上* 轴, ``Z`` 是 *前* 轴."

msgid ""
"Together with the *basis*, a transform also has an *origin*. This is a "
"*Vector3* specifying how far away from the actual origin ``(0, 0, 0)`` this "
"transform is. Combining the *basis* with the *origin*, a *transform* "
"efficiently represents a unique translation, rotation, and scale in space."
msgstr ""
"变换除了\\ *基*\\ 以外还有一个\\ *原点*\\ 。这是一个 *Vector3*\\ ，用于指定该"
"变换距离实际原点 ``(0, 0, 0)`` 有多远。\\ *变换*\\ 是\\ *基*\\ 与\\ *原点*\\ "
"的组合，可以有效地表示空间中特定的平移、旋转和缩放。"

msgid ""
"One way to visualize a transform is to look at an object's 3D gizmo while in "
"\"local space\" mode."
msgstr "可视化变换的一种方法是在“本地空间”模式下查看该对象的 3D 小工具。"

msgid ""
"The gizmo's arrows show the ``X``, ``Y``, and ``Z`` axes (in red, green, and "
"blue respectively) of the basis, while the gizmo's center is at the object's "
"origin."
msgstr ""
"小工具的箭头显示的是基的 ``X``\\ 、\\ ``Y``\\ 、\\ ``Z`` 轴（分别为红色、绿"
"色、蓝色），小工具的中心位于该对象的原点。"

msgid ""
"For more information on the mathematics of vectors and transforms, please "
"read the :ref:`doc_vector_math` tutorials."
msgstr ""
"有关向量和变换在数学方面的更多信息, 请阅读 :ref:`doc_vector_math` 教程."

msgid "Manipulating transforms"
msgstr "操作变换"

msgid ""
"Of course, transforms are not as straightforward to manipulate as angles and "
"have problems of their own."
msgstr "当然, 变换并不像角度那样容易控制, 并且有它自己的问题."

msgid ""
"It is possible to rotate a transform, either by multiplying its basis by "
"another (this is called accumulation), or by using the rotation methods."
msgstr ""
"可以对变换进行旋转，方法是将基与另一个基相乘（称作累加），或者使用其旋转方"
"法。"

msgid "A method in Node3D simplifies this:"
msgstr "Node3D 中的一种方法简化了这个操作："

msgid "This rotates the node relative to the parent node."
msgstr "这会相对于父节点来旋转节点."

msgid ""
"To rotate relative to object space (the node's own transform), use the "
"following:"
msgstr "要相对于对象空间旋转(节点自己的变换), 请使用下面的方法:"

msgid "Precision errors"
msgstr "精度误差"

msgid ""
"Doing successive operations on transforms will result in a loss of precision "
"due to floating-point error. This means the scale of each axis may no longer "
"be exactly ``1.0``, and they may not be exactly ``90`` degrees from each "
"other."
msgstr ""
"对变换执行连续的操作将导致由于浮点错误导致的精度损失. 这意味着每个轴的比例可"
"能不再精确地为 ``1.0`` , 并且它们可能不完全相互为 ``90`` 度."

msgid ""
"If a transform is rotated every frame, it will eventually start deforming "
"over time. This is unavoidable."
msgstr ""
"如果一个变换每帧旋转一次, 它最终会随着时间的推移开始变形. 这是不可避免的."

msgid ""
"There are two different ways to handle this. The first is to "
"*orthonormalize* the transform after some time (maybe once per frame if you "
"modify it every frame):"
msgstr ""
"有两种不同的方法来处理这个问题. 首先是在一段时间后对变换进行 *正交归一化"
"(orthonormalize)* 处理(如果每帧修改一次, 则可能每帧一次):"

msgid ""
"This will make all axes have ``1.0`` length again and be ``90`` degrees from "
"each other. However, any scale applied to the transform will be lost."
msgstr ""
"这将使所有的轴再次拥有有 ``1.0`` 的长度并且彼此成 ``90`` 度角. 但是, 应用于变"
"换的任何缩放都将丢失."

msgid ""
"It is recommended you not scale nodes that are going to be manipulated; "
"scale their children nodes instead (such as MeshInstance3D). If you "
"absolutely must scale the node, then re-apply it at the end:"
msgstr ""
"建议你不要缩放将要操作的节点；而是缩放其子节点（例如 MeshInstance3D）。如果你"
"绝对必须要缩放节点，请在最后重新应用它："

msgid "Obtaining information"
msgstr "获取信息"

msgid ""
"You might be thinking at this point: **\"Ok, but how do I get angles from a "
"transform?\"**. The answer again is: you don't. You must do your best to "
"stop thinking in angles."
msgstr ""
"现在你可能在想: **\"好吧, 但是我怎么从变换中获得角度？\"** . 答案又一次是: 没"
"有必要. 你必须尽最大努力停止用角度思考."

msgid ""
"Imagine you need to shoot a bullet in the direction your player is facing. "
"Just use the forward axis (commonly ``Z`` or ``-Z``)."
msgstr ""
"想象一下, 你需要朝你的游戏角色面对的方向射击子弹. 只需使用向前的轴(通常为 "
"``Z`` 或 ``-Z`` )."

msgid ""
"Is the enemy looking at the player? Use the dot product for this (see the :"
"ref:`doc_vector_math` tutorial for an explanation of the dot product):"
msgstr ""
"敌人在看着游戏角色吗？ 为此判断你可以使用点积（请参阅 :ref:`doc_vector_math` "
"教程以获取对点积的解释）："

msgid "Strafe left:"
msgstr "向左平移:"

msgid "Jump:"
msgstr "跳跃:"

msgid "All common behaviors and logic can be done with just vectors."
msgstr "所有常见的行为和逻辑都可以用向量来完成."

msgid "Setting information"
msgstr "设置信息"

msgid ""
"There are, of course, cases where you want to set information to a "
"transform. Imagine a first person controller or orbiting camera. Those are "
"definitely done using angles, because you *do want* the transforms to happen "
"in a specific order."
msgstr ""
"当然, 有些情况下你想要将一些信息赋予到变换上. 想象一下第一人称控制器或环绕旋"
"转的摄像机. 那些肯定是用角度来完成的, 因为你 *确实希望* 变换以特定的顺序进行."

msgid ""
"For such cases, keep the angles and rotations *outside* the transform and "
"set them every frame. Don't try to retrieve and reuse them because the "
"transform is not meant to be used this way."
msgstr ""
"对于这种情况，请保证角度和旋转在变换 *外部* ，并在每帧设置他们。不要尝试获取"
"并重新使用它们，因为变换是不应该以这种方式使用的。"

msgid "Example of looking around, FPS style:"
msgstr "环顾四周,FPS风格的示例:"

msgid ""
"As you can see, in such cases it's even simpler to keep the rotation "
"outside, then use the transform as the *final* orientation."
msgstr ""
"如你所见, 在这种情况下, 保持外部旋转更为简单, 然后使用变换作为 *最后的* 方向."

msgid "Interpolating with quaternions"
msgstr "用四元数插值"

msgid ""
"Interpolating between two transforms can efficiently be done with "
"quaternions. More information about how quaternions work can be found in "
"other places around the Internet. For practical use, it's enough to "
"understand that pretty much their main use is doing a closest path "
"interpolation. As in, if you have two rotations, a quaternion will smoothly "
"allow interpolation between them using the closest axis."
msgstr ""
"用四元数能有效率地完成两个变换之间的插值. 有关四元数如何工作的更多信息可以在"
"互联网上的其他地方找到. 在实际应用中, 了解它们的主要用途是做最短路插值就足够"
"了. 同样, 如果你有两个旋转, 四元数将平滑地使用最近的轴在它们之间进行插值."

msgid "Converting a rotation to quaternion is straightforward."
msgstr "将旋转转换为四元数很简单."

msgid ""
"The :ref:`class_Quaternion` type reference has more information on the "
"datatype (it can also do transform accumulation, transform points, etc., "
"though this is used less often). If you interpolate or apply operations to "
"quaternions many times, keep in mind they need to be eventually normalized. "
"Otherwise, they will also suffer from numerical precision errors."
msgstr ""
":ref:`class_Quaternion` 类型参考包含有关数据类型的更多信息（它还可以进行变换"
"累积、变换点等，尽管使用较少）。如果你多次对四元数进行插值或应用运算，请记住"
"它们最终需要归一化。否则，会带来数值精度误差。"

msgid ""
"Quaternions are useful when doing camera/path/etc. interpolations, as the "
"result will always be correct and smooth."
msgstr ""
"四元数在处理相机/路径/等东西的移动轨迹时很有用. 插值的结果总会是正确且平滑的."

msgid "Transforms are your friend"
msgstr "变换是你的朋友"

msgid ""
"For most beginners, getting used to working with transforms can take some "
"time. However, once you get used to them, you will appreciate their "
"simplicity and power."
msgstr ""
"对于大多数初学者来说, 习惯于使用变换可能需要一些时间. 但是, 一旦你习惯了它"
"们, 你会欣赏他们的简单而有力."

msgid ""
"Don't hesitate to ask for help on this topic in any of Godot's `online "
"communities <https://godotengine.org/community>`_ and, once you become "
"confident enough, please help others!"
msgstr ""
"不要犹豫, 在Godot的任何 `线上社区 <https://godotengine.org/community>`_ 网站"
"上寻求帮助, 一旦你变得足够自信, 请帮助其他人！"

msgid "Translation status"
msgstr "翻译状态"
