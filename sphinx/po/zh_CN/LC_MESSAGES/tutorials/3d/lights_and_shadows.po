# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "3D lights and shadows"
msgstr "3D 灯光和阴影"

msgid "Introduction"
msgstr "前言"

msgid ""
"Light sources emit light that mixes with the materials and produces a "
"visible result. Light can come from several types of sources in a scene:"
msgstr ""
"灯发出的光与材质混合并产生可见的结果. 光可以来自场景中的几种类型的光源:"

msgid ""
"From the Material itself in the form of the emission color (though it does "
"not affect nearby objects unless baked)."
msgstr ""
"以自发光颜色的形式从材 Material 本身发出（虽然除非烘焙贴图，否则它不会影响附"
"近的物体）。"

msgid "Light Nodes: Directional, Omni and Spot."
msgstr "光节点: 方向光(Directional), 万向光(Omni), 和聚光灯(Spot)."

msgid "Ambient Light in the :ref:`Environment <class_Environment>`."
msgstr ":ref:`Environment <class_Environment>` 中的环境光."

msgid "Baked Light (read :ref:`doc_baked_lightmaps`)."
msgstr "烘焙光 (参见 :ref:`doc_baked_lightmaps`)."

msgid ""
"The emission color is a material property. You can read more about it in "
"the :ref:`doc_spatial_material` tutorial."
msgstr ""
"自发光颜色是材质特性. 可以在 :ref:`doc_spatial_material` 教程中阅读更多相关内"
"容."

msgid "Light nodes"
msgstr "光节点"

msgid ""
"There are three types of light nodes: `Directional light`_, `Omni light`_ "
"and `Spot light`_. Let's take a look at the common parameters for lights:"
msgstr ""
"如前所述，有三种类型的光节点：方向光 `Directional light`_\\ 、全向光 `Omni "
"light`_ 、聚光 `Spot light`_\\ 。让我们来看看光的通用参数："

msgid "Each one has a specific function:"
msgstr "它们每一个都有特定的功能:"

msgid "**Color**: Base color for emitted light."
msgstr "**Color(颜色)** : 发光的基色."

msgid ""
"**Energy**: Energy multiplier. This is useful for saturating lights or "
"working with :ref:`doc_high_dynamic_range`."
msgstr ""
"**Energy(能量)** : 能量乘数. 这对于使灯光饱和或使用 :ref:"
"`doc_high_dynamic_range` 非常有用."

msgid ""
"**Indirect Energy**: Secondary multiplier used with indirect light (light "
"bounces). This works in baked light or GIProbe."
msgstr ""
"**Indirect Energy(间接能量)** : 与间接光一起使用的次级乘数(光是会反弹的). 这"
"适用于烘焙的光线或GIProbe(GI探针)."

msgid ""
"**Negative**: Light becomes subtractive instead of additive. It's sometimes "
"useful to manually compensate some dark corners."
msgstr ""
"**Negative(减色)** : 光变为减色而不是添加. 手动补偿一些黑暗角落有时很有用."

msgid ""
"**Specular**: Affects the intensity of the specular blob in objects affected "
"by this light. At zero, this light becomes a pure diffuse light."
msgstr ""
"**Specular（镜面反射）**\\ ：影响受此光影响的物体中镜面反射斑点的强度。值为零"
"时，该光变为纯漫反射光。"

msgid ""
"**Bake Mode**: Sets the bake mode for the light. For more information see :"
"ref:`doc_baked_lightmaps`"
msgstr ""
"**Bake Mode（烘焙模式）** ：设置灯光的烘焙模式。更多信息见 :ref:"
"`doc_baked_lightmaps`"

msgid ""
"**Cull Mask**: Objects that are in the selected layers below will be "
"affected by this light. Note that objects disabled via this cull mask will "
"still cast shadows. If you don't want disabled objects to cast shadows, "
"adjust the ``cast_shadow`` property on the GeometryInstance to the desired "
"value."
msgstr ""
"**剔除蒙版Cull Mask**: 在下面选定的图层中的物体将受到此光的影响。请注意，通过"
"这个遮罩禁用的对象仍然会投射阴影。如果你不希望被禁用的物体投射阴影，请将"
"GeometryInstance上的 ``cast_shadow`` 属性调整为所需值。"

msgid "Shadow mapping"
msgstr "阴影贴图"

msgid ""
"Lights can optionally cast shadows. This gives them greater realism (light "
"does not reach occluded areas), but it can incur a bigger performance cost. "
"There is a list of generic shadow parameters, each also has a specific "
"function:"
msgstr ""
"灯光可以可选地投射阴影. 这使它们具有更好的真实感(光线不会照到被遮挡的区域), "
"但它会带来更大的性能开销. 有一个通用阴影参数列表, 每个参数也有一个特定的功能:"

msgid "**Enabled**: Check to enable shadow mapping in this light."
msgstr "**Enabled(启用)** : 勾选以启用阴影贴图."

msgid ""
"**Color**: Areas occluded are multiplied by this color. It is black by "
"default, but it can be changed to tint shadows."
msgstr ""
"**Color(颜色)** : 遮挡的区域会被乘以此颜色. 默认为黑色, 但可以更改来给阴影染"
"色."

msgid ""
"**Bias**: When this parameter is too small, self shadowing occurs. When too "
"large, shadows separate from the casters. Tweak to what works best for you."
msgstr ""
"**Bias（偏置）**\\ ：当此参数太小时，阴影会打在物体自己身上。当太大时，阴影会"
"与物体本体分开。请调整到最适合你的状态。"

msgid ""
"**Contact**: Performs a short screen-space raycast to reduce the gap "
"generated by the bias. Contact shadows are only available when using the "
"GLES3 backend."
msgstr ""
"**Contact（接触）**\\ ：执行一个短促的屏幕空间光线投射，以减少上述偏置产生的"
"间隙。接触阴影仅在使用 GLES3 后端时可用。"

msgid ""
"**Reverse Cull Face**: Some scenes work better when shadow mapping is "
"rendered with face-culling inverted."
msgstr ""
"\\ **Reverse Cull Face**\\ : 反转表面剔除，当阴影贴图使用反转表面剔除渲染时，"
"在某些场景表现更好。"

msgid ""
"Below is an image of what tweaking bias looks like. Default values work for "
"most cases, but in general it depends on the size and complexity of geometry."
msgstr ""
"下图是调整偏置的样子。默认值适用于大多数情况，但通常取决于几何的大小和复杂程"
"度。"

msgid ""
"Finally, if gaps can't be solved, the **Contact** option can help (at a "
"performance cost):"
msgstr ""
"最后，如果无法解决缝隙，\\ **Contact**\\ 选项会有所帮助，但以性能为代价："

msgid ""
"Any sort of bias issues can always be fixed by increasing the shadow map "
"resolution, although that may lead to decreased performance."
msgstr ""
"任何偏置问题都可以通过提高阴影贴图分辨率来解决，尽管可能会导致性能下降。"

msgid ""
"If shadow biasing is a problem in your scene, the following settings are a "
"good starting point:"
msgstr "如果您的场景中存在阴影偏置问题，那么以下设置是个好的开始："

msgid ""
"Enable **Reverse Cull Face**. This reduces shadow peter-panning "
"significantly and prevents lights from exhibiting shadow acne at grazing "
"angles. The main downside is that it may cause lighting to leak in some "
"corners. The other downside is that materials that have their cull mode set "
"to **Disabled** or MeshInstances with Cast Shadow set to **Double-Sided** "
"may exhibit shadow acne."
msgstr ""
"启用反转表面剔除\\ **Reverse Cull Face**\\ 。这大大减少阴影悬浮，并防止灯光在"
"掠过角时呈现出阴影失真。主要的缺点是，它可能会导致灯光在某些角落泄漏。另一个"
"缺点是，那些将剔除模式设置为 \\ **Disabled**\\ 的材质或将Cast Shadow设置为\\ "
"**Double-Sided**\\ 的网格实例可能会出现阴影失真。"

msgid ""
"Set **Bias** to ``-0.01``. The bias should be a negative value when "
"**Reverse Cull Face** is enabled, but it should be a positive value when "
"it's disabled."
msgstr ""
"将\\ **Bias**\\ 设置为 ``-0.01``\\ 。当\\ **Reverse Cull Face**\\ 被启用时，"
"偏置应该是负值，而当它被禁用时，应该是正值。"

msgid ""
"For DirectionalLight, set the directional shadow **Normal Bias** to ``0.0`` "
"and **Bias Split Scale** to ``0.0``. Depending on your scene, you may also "
"want to further decrease **Bias** to a value between ``-0.05`` and ``-0.1``."
msgstr ""
"对于平行光，将定向阴影的 **Normal Bias** 设置为 ``0.0`` ，\\ **Bias Split "
"Scale** 为 ``0.0``\\ 。按照你的场景，可能还想进一步减少 **Bias** 的值到 "
"``-0.05`` 和 ``-0.1`` 之间。"

msgid ""
"Following the above tips should make it possible to avoid gaps in shadows "
"without resorting to contact shadows (which have many issues of their own). "
"If shadow acne is still visible after performing the above tweaks, try "
"subdividing your meshes further in your 3D modeling software."
msgstr ""
"遵循上述提示，应该可以避免阴影产生缝隙，而不必依靠接触阴影，它本身就有一些问"
"题。如果在进行了上述调整后，阴影失真仍然存在，可以尝试在你的三维建模软件中进"
"一步细分你的网格。"

msgid "Directional light"
msgstr "平行光"

msgid ""
"This is the most common type of light and represents a light source very far "
"away (such as the sun). It is also the cheapest light to compute and should "
"be used whenever possible (although it's not the cheapest shadow-map to "
"compute, but more on that later)."
msgstr ""
"这是最常见的光线类型, 代表了很远的光源(如太阳). 它也是计算中最便宜的光, 应该"
"尽可能使用(虽然它不是计算起来最便宜的阴影贴图, 但这点稍后再说)."

msgid ""
"Directional light models an infinite number of parallel light rays covering "
"the whole scene. The directional light node is represented by a big arrow "
"which indicates the direction of the light rays. However, the position of "
"the node does not affect the lighting at all and can be anywhere."
msgstr ""
"平行光模拟覆盖整个场景的无限数量的平行光线。平行光节点由指示光线方向的大箭头"
"表示。但是，节点的位置根本不会影响照明，它可以在任何地方。"

msgid ""
"Every face whose front-side is hit by the light rays is lit, while the "
"others stay dark. Most light types have specific parameters, but directional "
"lights are pretty simple in nature, so they don't."
msgstr ""
"每个表面的正面被光线照射，而其他部分则保持黑暗。大多数灯光类型都有特定的参"
"数，但平行光本质上非常简单，所以它们没有。"

msgid "Directional shadow mapping"
msgstr "方向光阴影贴图"

msgid ""
"To compute shadow maps, the scene is rendered (only depth) from an "
"orthogonal point of view that covers the whole scene (or up to the max "
"distance). There is, however, a problem with this approach because objects "
"closer to the camera receive blocky shadows."
msgstr ""
"为了计算阴影贴图, 会从正交视图(仅深度)渲染整个场景(或直到最大距离). 但是, 这"
"种方法存在问题, 因为靠近相机的物体会得到块状阴影."

msgid ""
"To fix this, a technique named \"Parallel Split Shadow Maps\" (or PSSM) is "
"used. This splits the view frustum in 2 or 4 areas. Each area gets its own "
"shadow map. This allows small areas close to the viewer to have the same "
"shadow resolution as a huge, far-away area."
msgstr ""
"为了解决这个问题, 使用了名为\"Parallel Split Shadow Maps\"(平行分割阴影, 或"
"PSSM)的技术. 这将视锥体分成2或4个区域. 每个区域都有自己的阴影贴图. 这允许靠近"
"观察者的小区域具有与巨大的遥远区域相同的阴影分辨率."

msgid "With this, shadows become more detailed:"
msgstr "有了它, 阴影变得更加详细:"

msgid "To control PSSM, a number of parameters are exposed:"
msgstr "为了控制PSSM, 暴露了许多参数:"

msgid ""
"Each split distance is controlled relative to the camera far (or shadow "
"**Max Distance** if greater than zero), so *0.0* is the eye position and "
"*1.0* is where the shadow ends at a distance. Splits are in-between. Default "
"values generally work well, but tweaking the first split a bit is common to "
"give more detail to close objects (like a character in a third person game)."
msgstr ""
"每个分割距离都是相对于相机最远处(或阴影 **Max Distance(最大距离)** , 如果大于"
"零)控制的, 因此 *0.0* 是眼睛位置, *1.0* 是阴影在一定距离处结束的位置. 分割介"
"于两者之间. 默认值通常效果很好, 但调整第一个分割数值是很常见的, 可以为近处对"
"象提供更多细节(比如第三人称游戏中的角色)."

msgid ""
"Always make sure to set a shadow *Max Distance* according to what the scene "
"needs. A lower maximum distance will result in better-looking shadows."
msgstr ""
"始终确保根据场景需要设置阴影 *Max Distance(最大距离)* . 最大距离越近, 阴影的"
"质量越高."

msgid ""
"Sometimes, the transition between a split and the next can look bad. To fix "
"this, the **\"Blend Splits\"** option can be turned on, which sacrifices "
"detail in exchange for smoother transitions:"
msgstr ""
"有时, 一个分割与下一个之间的过渡看起来很糟糕. 要解决此问题, 可以打开 "
"**\"Blend Splits\"(混合分割)** 选项, 牺牲细节以换取更平滑的过渡:"

msgid ""
"The **\"Normal Bias\"** parameter can be used to fix special cases of self "
"shadowing when objects are perpendicular to the light. The only downside is "
"that it makes the shadow a bit thinner."
msgstr ""
"当物体垂直于光线时，\\ **\"Normal Bias\"（法线偏置）** 参数可用于修复自阴影的"
"特殊情况。唯一的缺点是它使阴影更薄。"

msgid ""
"The **\"Bias Split Scale\"** parameter can control extra bias for the splits "
"that are far away. If self shadowing occurs only on the splits far away, "
"this value can fix them."
msgstr ""
"**\"Bias Split Scale\"（偏置分割缩放）** 参数可以控制远处分割的额外偏置。如果"
"仅在远处的分割上发生自阴影，则此值可以修复它们。"

msgid "Finally, the **\"Depth Range\"** has two settings:"
msgstr "最后, **\"Depth Range\"(深度范围)** 有两个设置:"

msgid ""
"**Stable**: Keeps the shadow stable while the camera moves, and the blocks "
"that appear in the outline when close to the shadow edges remain in-place. "
"This is the default and generally desired, but it reduces the effective "
"shadow resolution."
msgstr ""
"**Stable(稳定)** : 在相机移动时保持阴影稳定, 并且当靠近阴影边缘时出现在轮廓中"
"的块保持原位. 这是默认, 通常想要的设置, 但会降低有效的阴影分辨率."

msgid ""
"**Optimized**: Tries to achieve the maximum resolution available at any "
"given time. This may result in a \"moving saw\" effect on shadow edges, but "
"at the same time the shadow looks more detailed (so this effect may be "
"subtle enough to be forgiven)."
msgstr ""
"**Optimized(最优)** : 会尝试在任何给定时间达到最大可用分辨率. 这可能会导致阴"
"影边缘出现 \"移动锯\" 效果, 但同时阴影看起来更加细致(因此这种效果可能非常轻"
"微, 可以被原谅)."

msgid "Just experiment which setting works better for your scene."
msgstr "尝试哪种设置更适合你的场景."

msgid ""
"Shadowmap size for directional lights can be changed in Project Settings -> "
"Rendering -> Quality:"
msgstr "可以在“项目设置 -> 渲染 -> 质量”中更改平行光的阴影贴图大小："

msgid ""
"Increasing it can solve bias problems, but decrease performance. Shadow "
"mapping is an art of tweaking."
msgstr "增加它可以解决偏置问题，但会降低性能。阴影贴图是一门调整的艺术。"

msgid "Omni light"
msgstr "全向光"

msgid ""
"Omni light is a point source that emits light spherically in all directions "
"up to a given radius."
msgstr "全向光是一种点光源，可在所有方向上发射光，直至给定的半径。"

msgid ""
"In real life, light attenuation is an inverse function, which means omni "
"lights don't have a radius. This is a problem because it means computing "
"several omni lights would become demanding."
msgstr ""
"在现实生活中，光衰减是个和距离成反比的函数，这意味着全向光没有半径。这是一个"
"问题，因为这意味着计算几个全向光会变得很困难。"

msgid ""
"To solve this, a *Range* is introduced together with an attenuation function."
msgstr "为了解决这个问题, 引入了 *Range(范围)* 和衰减函数."

msgid ""
"These two parameters allow tweaking how this works visually in order to find "
"aesthetically pleasing results."
msgstr "这两个参数允许调整其在视觉上的工作方式, 以便找到美学上令人愉悦的结果."

msgid "Omni shadow mapping"
msgstr "全向光阴影贴图"

msgid ""
"Omni light shadow mapping is relatively straightforward. The main issue that "
"needs to be considered is the algorithm used to render it."
msgstr "全向光的阴影贴图相对简单。需要考虑的主要问题是用于渲染它的算法。"

msgid ""
"Omni Shadows can be rendered as either **\"Dual Paraboloid\" or \"Cube "
"Mapped\"**. The former renders quickly, but can cause deformations, while "
"the later is more correct, but costlier."
msgstr ""
"全向光阴影可以渲染为 **\"Dual Paraboloid\"(双抛物面)或\"Cube Mapped\"(方形映"
"射)** . 前者渲染速度很快但会导致变形, 而后者更正确但成本更高."

msgid ""
"If the objects being rendered are mostly irregular, Dual Paraboloid is "
"usually enough. In any case, as these shadows are cached in a shadow atlas "
"(more on that at the end), it may not make a difference in performance for "
"most scenes."
msgstr ""
"如果渲染的对象大部分是不规则的, 那么Dual Paraboloid 通常就足够了. 无论怎么"
"说, 由于这些阴影被缓存在阴影图集中(后面会详细讲), 对于大多数场景而言, 它可能"
"不会对性能产生影响."

msgid "Spot light"
msgstr "聚光"

msgid ""
"Spot lights are similar to omni lights, except they emit light only into a "
"cone (or \"cutoff\"). They are useful to simulate flashlights, car lights, "
"reflectors, spots, etc. This type of light is also attenuated towards the "
"opposite direction it points to."
msgstr ""
"聚光与全向光类似，但是它们只发光到锥形（或“截断”）中。它们可用于模拟手电筒、"
"车灯、反射器、聚光灯等。这种类型的光也会向其指向的相反方向衰减。"

msgid ""
"Spot lights share the same **Range** and **Attenuation** as **OmniLight**, "
"and add two extra parameters:"
msgstr ""
"聚光和 **OmniLight（全向光）**\\ 共用 **Range（范围）**\\ 和 **Attenuation"
"（衰减）**\\ ，并添加了两个额外参数："

msgid "**Angle**: The aperture angle of the light"
msgstr "**Angle(角度)** : 光线的光圈角度"

msgid ""
"**Angle Attenuation**: The cone attenuation, which helps soften the cone "
"borders."
msgstr "**Angle Attenuation(角度衰减)** : 锥形衰减, 有助于软化锥形边界."

msgid "Spot shadow mapping"
msgstr "聚光灯阴影贴图"

msgid ""
"Spots don't need any parameters for shadow mapping. Keep in mind that, at "
"more than 89 degrees of aperture, shadows stop functioning for spots, and "
"you should consider using an Omni light instead."
msgstr ""
"聚光不需要任何阴影映射参数。请记住，在超过 89 度的光圈下，阴影会停止对聚光起"
"作用，你应该考虑使用全向光。"

msgid "Shadow atlas"
msgstr "影子图集"

msgid ""
"Unlike Directional lights, which have their own shadow texture, Omni and "
"Spot lights are assigned to slots of a shadow atlas. This atlas can be "
"configured in Project Settings -> Rendering -> Quality -> Shadow Atlas."
msgstr ""
"与具有自己的阴影纹理的平行光不同，全向光和聚光被分配了阴影图集的槽位。可以"
"在“项目设置 -> 渲染 -> 质量 -> 阴影图集”中配置此图集。"

msgid ""
"The resolution applies to the whole Shadow Atlas. This atlas is divided into "
"four quadrants:"
msgstr "这个分辨率适用于整个阴影图集。该图集分为四个象限："

msgid ""
"Each quadrant can be subdivided to allocate any number of shadow maps; the "
"following is the default subdivision:"
msgstr "每个象限可以细分，分配任意数量的阴影贴图。以下是默认细分方式："

msgid ""
"The allocation logic is simple. The biggest shadow map size (when no "
"subdivision is used) represents a light the size of the screen (or bigger). "
"Subdivisions (smaller maps) represent shadows for lights that are further "
"away from view and proportionally smaller."
msgstr ""
"分配逻辑很简单. 最大的阴影贴图大小(当不使用细分时)表示一个屏幕大小(或更大)的"
"光. 细分区块(较小的贴图)表示远离视图并且成比例地较小的光的阴影."

msgid "Every frame, the following procedure is performed for all lights:"
msgstr "每一帧, 以下过程被应用于所有光:"

msgid ""
"Check if the light is on a slot of the right size. If not, re-render it and "
"move it to a larger/smaller slot."
msgstr ""
"检查灯光是否在正确大小的插槽上. 如果没有, 重新渲染它并将其移动到更大/更小的插"
"槽."

msgid ""
"Check if any object affecting the shadow map has changed. If it did, re-"
"render the light."
msgstr "检查影响阴影贴图的任何对象是否已更改. 如果是的话, 重新渲染光线."

msgid ""
"If neither of the above has happened, nothing is done, and the shadow is "
"left untouched."
msgstr "如果上述情况均未发生, 则不执行任何操作, 阴影保持不变."

msgid ""
"If the slots in a quadrant are full, lights are pushed back to smaller "
"slots, depending on size and distance."
msgstr ""
"如果一个象限中的槽位满了, 光线会被推回到更小的槽位中, 取决于大小和距离."

msgid ""
"This allocation strategy works for most games, but you may want to use a "
"separate one in some cases (for example, a top-down game where all lights "
"are around the same size and quadrants may all have the same subdivision)."
msgstr ""
"此分配策略适用于大多数游戏, 但在某些情况下你可能会想用一个单独分开的贴图(例"
"如, 一个自上向下看的游戏, 其中所有灯光大小大概相同, 所有象限的细分可能会具有"
"相同大小)."

msgid "Shadow filter quality"
msgstr "阴影滤波质量"

msgid ""
"The filter quality of shadows can be tweaked. This can be found in Project "
"Settings -> Rendering -> Quality -> Shadows. Godot supports no filter, PCF5 "
"and PCF13."
msgstr ""
"可以调整阴影的滤波质量。这可以在“项目设置 -> Rendering -> Quality -> "
"Shadows”（渲染 -> 质量 -> 阴影）中找到。Godot 支持无滤波、PCF5 和 PCF13。"

msgid "It affects the blockyness of the shadow outline:"
msgstr "它会影响阴影轮廓的块状程度:"

msgid "Translation status"
msgstr "翻译状态"
