# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using the ArrayMesh"
msgstr "使用 ArrayMesh"

msgid ""
"This tutorial will present the basics of using an :ref:`ArrayMesh "
"<class_arraymesh>`."
msgstr "本教程将介绍使用 :ref:`ArrayMesh <class_arraymesh>` 的基础知识。"

msgid ""
"To do so, we will use the function :ref:`add_surface_from_arrays() "
"<class_ArrayMesh_method_add_surface_from_arrays>`, which takes up to four "
"parameters. The first two are required, while the second two are optional."
msgstr ""
"为此, 我们将使用函数 :ref:`add_surface_from_arrays() "
"<class_ArrayMesh_method_add_surface_from_arrays>` , 它最多需要四个参数. 前两"
"个参数是必须的, 后两个参数是可选的."

msgid ""
"The first parameter is the ``PrimitiveType``, an OpenGL concept that "
"instructs the GPU how to arrange the primitive based on the vertices given, "
"i.e. whether they represent triangles, lines, points, etc. See :ref:`Mesh."
"PrimitiveType <enum_Mesh_PrimitiveType>` for the options available."
msgstr ""
"第一个参数是 ``PrimitiveType``\\ （图元类型），这是 OpenGL 中的概念，用于指"
"示 GPU 如何根据给定的顶点来安排图元，即它们表示的是三角形、线、还是点等等。可"
"选项见 :ref:`Mesh.PrimitiveType <enum_Mesh_PrimitiveType>`。"

msgid ""
"The second parameter, ``arrays``, is the actual Array that stores the mesh "
"information. The array is a normal Godot array that is constructed with "
"empty brackets ``[]``. It stores a ``Pool**Array`` (e.g. PoolVector3Array, "
"PoolIntArray, etc.) for each type of information that will be used to build "
"the surface."
msgstr ""
"第二各参数 ``arrays`` 是存储网格信息的实际 Array。该数组是一个普通的 Godot 数"
"组，用空括号 ``[]`` 构造。它为每一种类型的信息存储一个 ``Pool**Array``\\ "
"（如 PoolVector3Array、PoolIntArray 等），用于构建表面。"

msgid ""
"The possible elements of ``arrays`` are listed below, together with the "
"position they must have within ``arrays``. See also :ref:`Mesh.ArrayType "
"<enum_Mesh_ArrayType>`."
msgstr ""
"``arrays`` 可能包含下列元素，另外还必须在 ``arrays`` 中包含位置信息。另请参"
"阅 :ref:`Mesh.ArrayType <enum_Mesh_ArrayType>`。"

msgid "Index"
msgstr "索引"

msgid "Mesh.ArrayType Enum"
msgstr "Mesh.ArrayType 枚举"

msgid "Array type"
msgstr "数组类型"

msgid "0"
msgstr "0"

msgid "``ARRAY_VERTEX``"
msgstr "``ARRAY_VERTEX``"

msgid ""
":ref:`PoolVector3Array <class_PoolVector3Array>` or :ref:`PoolVector2Array "
"<class_PoolVector2Array>`"
msgstr ""
":ref:`PoolVector3Array <class_PoolVector3Array>` 或 :ref:`PoolVector2Array "
"<class_PoolVector2Array>`"

msgid "1"
msgstr "1"

msgid "``ARRAY_NORMAL``"
msgstr "``ARRAY_NORMAL``"

msgid ":ref:`PoolVector3Array <class_PoolVector3Array>`"
msgstr ":ref:`PoolVector3Array <class_PoolVector3Array>`"

msgid "2"
msgstr "2"

msgid "``ARRAY_TANGENT``"
msgstr "``ARRAY_TANGENT``"

msgid ""
":ref:`PoolRealArray <class_PoolRealArray>` of groups of 4 floats. First 3 "
"floats determine the tangent, and the last the binormal direction as -1 or 1."
msgstr ""
"4 个浮点数一组的 :ref:`PoolRealArray <class_PoolRealArray>`。前 3 个浮点数决"
"定切线，最后一个决定双法线方向，为 -1 或 1。"

msgid "3"
msgstr "3"

msgid "``ARRAY_COLOR``"
msgstr "``ARRAY_COLOR``"

msgid ":ref:`PoolColorArray <class_PoolColorArray>`"
msgstr ":ref:`PoolColorArray <class_PoolColorArray>`"

msgid "4"
msgstr "4"

msgid "``ARRAY_TEX_UV``"
msgstr "``ARRAY_TEX_UV``"

msgid ""
":ref:`PoolVector2Array <class_PoolVector2Array>` or :ref:`PoolVector3Array "
"<class_PoolVector3Array>`"
msgstr ""
":ref:`PoolVector2Array <class_PoolVector2Array>` 或 :ref:`PoolVector3Array "
"<class_PoolVector3Array>`"

msgid "5"
msgstr "5"

msgid "``ARRAY_TEX_UV2``"
msgstr "``ARRAY_TEX_UV2``"

msgid "6"
msgstr "6"

msgid "``ARRAY_BONES``"
msgstr "``ARRAY_BONES``"

msgid ""
":ref:`PoolRealArray <class_PoolRealArray>` of groups of 4 floats or :ref:"
"`PoolIntArray <class_PoolIntArray>` of groups of 4 ints. Each group lists "
"indexes of 4 bones that affects a given vertex."
msgstr ""
"4 个 float 一组的 :ref:`PoolRealArray <class_PoolRealArray>` 或 4 个 int 一组"
"的 :ref:`PoolIntArray <class_PoolIntArray>`。每一组都列出了影响某个特定顶点"
"的 4 根骨骼。"

msgid "7"
msgstr "7"

msgid "``ARRAY_WEIGHTS``"
msgstr "``ARRAY_WEIGHTS``"

msgid ""
":ref:`PoolRealArray <class_PoolRealArray>` of groups of 4 floats. Each float "
"lists the amount of weight an determined bone on ``ARRAY_BONES`` has on a "
"given vertex."
msgstr ""
"4 个 float 一组的 :ref:`PoolRealArray <class_PoolRealArray>`。每个 float 都列"
"出了给定顶点对 ``ARRAY_BONES`` 中特定骨骼的权重。"

msgid "8"
msgstr "8"

msgid "``ARRAY_INDEX``"
msgstr "``ARRAY_INDEX``"

msgid ":ref:`PoolIntArray <class_PoolIntArray>`"
msgstr ":ref:`PoolIntArray <class_PoolIntArray>`"

msgid ""
"The array of vertices (at index 0) is always required. The index array is "
"optional and will only be used if included. We won't use it in this tutorial."
msgstr ""
"顶点数组（索引为 0）始终是必须的。索引数组是可选的，包含时才会用到。在这个教"
"程中我们不会用到。"

msgid ""
"All the other arrays carry information about the vertices. They are also "
"optional and will only be used if included. Some of these arrays (e.g. "
"``ARRAY_COLOR``) use one entry per vertex to provide extra information about "
"vertices. They must have the same size as the vertex array. Other arrays (e."
"g. ``ARRAY_TANGENT``) use four entries to describe a single vertex. These "
"must be exactly four times larger than the vertex array."
msgstr ""
"其他所有数组包含的都是关于顶点的信息。他们也是可选的，包含时才会用到。有些数"
"组（例如 `ARRAY_COLOR``\\ ）用每个顶点一个元素的形式来提供额外的顶点信息。他"
"们的大小必须与顶点数组一致。另一些数组（例如 ``ARRAY_TANGENT``\\ ）用四个元素"
"来描述一个顶点。他们必须正好是顶点数组的四倍大小。"

msgid ""
"For normal usage, the last two parameters in :ref:`add_surface_from_arrays() "
"<class_arraymesh_method_add_surface_from_arrays>` are typically left empty."
msgstr ""
"正常的使用场景下，\\ :ref:`add_surface_from_arrays() "
"<class_arraymesh_method_add_surface_from_arrays>` 的最后两个参数通常都是留空"
"的。"

msgid "ArrayMesh"
msgstr "ArrayMesh"

msgid ""
"In the editor, create a :ref:`MeshInstance <class_meshinstance>` and add an :"
"ref:`ArrayMesh <class_arraymesh>` to it in the Inspector. Normally, adding "
"an ArrayMesh in the editor is not useful, but in this case it allows us to "
"access the ArrayMesh from code without creating one."
msgstr ""
"在编辑器中，创建一个 :ref:`MeshInstance <class_meshinstance>` 并在检查器中为"
"其添加一个 :ref:`ArrayMesh <class_arraymesh>`\\ 。通常，在编辑器里添加 "
"ArrayMesh 没什么用，但这里可以让我们免去用代码创建的麻烦，直接使用这个 "
"ArrayMesh。"

msgid "Next, add a script to the MeshInstance."
msgstr "接下来，在 MeshInstance 上添加一个脚本。"

msgid "Under ``_ready()``, create a new Array."
msgstr "在 ``_ready()`` 下创建一个新的数组。"

msgid ""
"This will be the array that we keep our surface information in - it will "
"hold all the arrays of data that the surface needs. Godot will expect it to "
"be of size ``Mesh.ARRAY_MAX``, so resize it accordingly."
msgstr ""
"这将是保存表面信息的数组——将保存表面需要的所有数据数组。Godot 希望它的大小是 "
"``Mesh.ARRAY_MAX``\\ ，所以要相应地调整。"

msgid "Next create the arrays for each data type you will use."
msgstr "接下来, 为您将使用的每种数据类型创建数组."

msgid ""
"Once you have filled your data arrays with your geometry you can create a "
"mesh by adding each array to ``surface_array`` and then committing to the "
"mesh."
msgstr ""
"一旦你用几何体填充了你的数据数组, 就可以通过将每个数组添加到 "
"``surface_array`` , 然后提交到网格中来创建网格."

msgid ""
"In this example, we used ``Mesh.PRIMITIVE_TRIANGLES``, but you can use any "
"primitive type available from mesh."
msgstr ""
"在这个例子中，使用了 ``Mesh.PRIMITIVE_TRIANGLES``\\ ，但你也可以使用网格所提"
"供的任何图元类型。"

msgid "Put together, the full code looks like:"
msgstr "把这些放到一起，完整的代码是这样的："

msgid ""
"The code that goes in the middle can be whatever you want. Below we will "
"present some example code for generating a sphere."
msgstr "中间可以放你想要的任何代码。下面我们会给出一些示例代码，用于生成球体。"

msgid "Generating geometry"
msgstr "生成几何体"

msgid ""
"Here is sample code for generating a sphere. Although the code is presented "
"in GDScript, there is nothing Godot specific about the approach to "
"generating it. This implementation has nothing in particular to do with "
"ArrayMeshes and is just a generic approach to generating a sphere. If you "
"are having trouble understanding it or want to learn more about procedural "
"geometry in general, you can use any tutorial that you find online."
msgstr ""
"这是生成球体的示例代码。尽管代码是用 GDScript 编写的，但是 Godot 并没有指定用"
"特定的方式来实现它。这种实现方式与 ArrayMesh 无关，仅仅是一种通用的生成球体的"
"方式。如果您觉得这比较难以理解，或者想更全面地了解程序式几何体，可以在网上寻"
"找相关的教程进行学习。"

msgid "Saving"
msgstr "保存"

msgid ""
"Finally, we can use the :ref:`ResourceSaver <class_resourcesaver>` class to "
"save the ArrayMesh. This is useful when you want to generate a mesh and then "
"use it later without having to re-generate it."
msgstr ""
"最后，我们可以使用 :ref:`ResourceSaver <class_resourcesaver>` 类来保存该 "
"ArrayMesh。当你想生成一个网格，然后在以后使用它而不需要重新生成时，这个方法很"
"有用。"

msgid "Translation status"
msgstr "翻译状态"
