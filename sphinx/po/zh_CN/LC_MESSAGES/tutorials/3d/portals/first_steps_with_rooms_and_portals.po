# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "First steps with Rooms and Portals"
msgstr "房间和入口的第一步"

msgid "The RoomManager"
msgstr "房间管理器"

msgid ""
"Anytime you want to use the portal system, you need to include a special "
"node in your scene tree, called the :ref:`RoomManager<class_RoomManager>`. "
"The RoomManager is responsible for the runtime maintenance of the system, "
"especially converting the objects in your rooms into a *room graph* which is "
"used at runtime to perform occlusion culling and other tasks."
msgstr ""
"你想使用入口系统时，都需要在场景树中包含特殊的节点，叫做 :ref:"
"`RoomManager<class_RoomManager>`\\ 。RoomManager 负责系统的运行维护，特别是将"
"你的房间中的对象转换为\\ *房间图*\\ ，在运行时用于进行遮挡剔除和其他任务。"

msgid "Room Conversion"
msgstr "房间转换"

msgid ""
"This conversion must take place every time you want to activate the system. "
"It does not store the *room graph* in your project (for flexibility and to "
"save memory). You can either trigger it by pressing the **Convert Rooms** "
"button in the editor toolbar (which also has a keyboard shortcut) or by "
"calling the ``rooms_convert()`` method in the RoomManager. The latter method "
"will be what you use in-game. Note that for safety, best practice is to call "
"``rooms_clear()`` before unloading or changing levels."
msgstr ""
"每次要激活系统时都必须进行此转换。它不会在项目中存储\\ *房间图*\\ （为了灵活"
"性和节省内存）。您可以通过按下编辑器工具栏中的\\ **转换房间**\\ 按钮来触发它"
"（也有键盘快捷键），或者可以调用 RoomManager 中的 ``rooms_convert()`` 方法。"
"后一种方法在你的游戏中使用。请注意，为了安全起见，最佳做法是在卸载或更改关卡"
"之前调用 ``rooms_clear()`` 。"

msgid ""
"If you convert the level while the editor is running, the portal culling "
"system will take over from the normal Godot frustum culling, potentially "
"interfering with editor features. To get around this, you can turn portal "
"culling on and off using either the **View Portal Culling** toggle in the "
"**View** menu on the editor toolbar (which also has a keyboard shortcut) or "
"the **Active** setting in the RoomManager node."
msgstr ""
"如果你在编辑器运行时转换关卡，入口剔除系统将取代正常的 Godot 视锥剔除，可能会"
"影响一些编辑器的功能。要避免这样的情况，你可以使用编辑器工具栏上的\\ **视图"
"**\\ 菜单中的\\ **查看入口剔除**\\ 切换，或者通过 RoomManager 节点中的 "
"**Active** 设置来打开和关闭入口剔除。"

msgid ""
"To use the RoomManager, you have to tell it where the rooms are in your "
"scene tree, or, more specifically, where the RoomList node is. This RoomList "
"is the parent of your rooms - see below. If the RoomList is not set, "
"conversion will fail, and you will see a warning dialog box."
msgstr ""
"要使用 RoomManager，你必须给它告知房间在场景树中的位置，或者准确地说是 "
"RoomList 节点的位置。这个 RoomList 是房间的父节点——见下文。如果没有设置 "
"RoomList，转换将失败，你将收到一个警告对话框。"

msgid "The RoomList"
msgstr "房间列表"

msgid ""
"Before we create any rooms, we must first create a node to be the parent of "
"all the static objects, rooms, roomgroups, and so on in our level. This node "
"is referred to as the the ``RoomList``."
msgstr ""
"在我们创建任意房间之前，必须首先创建一个节点，作为我们关卡中所有静态对象、房"
"间、房间组等的父节点。这个节点称为 ``RoomList``\\ 。"

msgid ""
"The roomlist is **not** a special node type – it can just be a regular "
"Spatial."
msgstr "房间列表\\ **不是**\\ 的特殊节点类型——它可以是普通的 Spatial 节点。"

msgid ""
"You will need to assign the roomlist node in the RoomManager so that it "
"knows where to find the rooms."
msgstr ""
"你需要在 RoomManager 中指定房间列表节点，这样它就知道可以在哪里找到房间。"

msgid ""
"Why do we use a specific branch of the scene tree and not the scene root? "
"The answer is that there are many internal details of the system which are "
"easier to manage if the rooms are placed on their own branch."
msgstr ""
"为什么我们要使用场景树的一个特定分支，而不是使用场景的根节点？答案是，如果房"
"间被放在自己的分支上，系统的许多内部细节就更容易管理。"

msgid ""
"Often you will end up completely replacing the roomlist branch at runtime in "
"your game as you load and unload levels."
msgstr "当你加载和卸载关卡时，通常最终会在游戏运行时完全替换房间列表分支。"

msgid "Rooms"
msgstr "房间"

msgid "What is a room?"
msgstr "什么是房间？"

msgid ""
":ref:`Room<class_Room>`\\ s are a way of spatially partitioning your level "
"into areas that make sense in terms of level design. Rooms often quite "
"literally *are* rooms (like in a building). Ultimately though, as far as the "
"engine is concerned, a room represents a **non-overlapping** convex volume "
"in which you typically place most of your objects that fall within that area."
msgstr ""
":ref:`Room<class_Room>`\\ 是一种将关卡空间划分为区域的方式，在关卡设计方面是"
"有意义的。房间往往从字面上看\\ *是*\\ 房间（例如建筑物中的房间）。但从根本上"
"就引擎而言，房间表示的是\\ **不重叠的**\\ 凸面体，你通常会在其中放置大部分属"
"于该区域的物体。"

msgid ""
"A room doesn't need to correspond to a literal room. It could, for example, "
"also be a canyon in an outdoor area or a smaller part of a concave room. "
"With a little imagination, you can use the system in almost any scenario."
msgstr ""
"房间不需要对应字面上的房间。比如，它也可以是户外的一个峡谷，或一个凹形房间的"
"较小部分。只要有想象力，你几乎可在任何场景下使用这个系统。"

msgid "Why convex?"
msgstr "为什么要凸起？"

msgid ""
"Rooms are defined as convex volumes (or *convex hulls*) because it's trivial "
"to mathematically determine whether a point is within a convex hull. A "
"simple plane check will tell you the distance of a point from a plane. If a "
"point is behind all the planes bounding the convex hull, then by definition "
"it is inside the room. This makes all kinds of things easier in the "
"internals of the system, such as checking which room a camera is within."
msgstr ""
"房间之所以被定义为凸体（或者\\ *凸壳*\\ ）是因为在数学上确定点是否在凸体之内"
"非常容易。简单的平面检查，就能获得点与平面的距离。如果一个点在所有包围凸体外"
"壳的平面之后，那么根据定义，它就在房间内。这使得系统内部各种事项变得更加容"
"易，比如检查相机在哪个房间内。"

msgid ""
"*A convex hull. The hull is defined as a series of planes facing outward. If "
"a point is behind all the planes, it is within the hull.*"
msgstr ""
"*凸体。定义为一系列朝外的平面。如果一个点在所有平面之后，点就在凸体之内。*"

msgid "Why non-overlapping?"
msgstr "为什么是不重叠的？"

msgid ""
"If two rooms overlap, and a camera or player is in this overlapping zone, "
"then there is no way to tell which room the object should be in (and hence "
"render from), or be rendered in. This requirement for non-overlapping rooms "
"does have implications for level design."
msgstr ""
"如果两个房间重叠，而相机或玩家在这个重叠区域，那么就没有办法知道这个物体应该"
"在哪个房间，或者在哪个房间渲染。对于房间是非重叠的这一要求，的确对于关卡设计"
"有影响。"

msgid ""
"If you accidentally create overlapping rooms, the editor will warn you when "
"you convert the rooms, indicating any overlapping zones in red."
msgstr ""
"如果你不小心创建了重叠的房间，编辑器会在你转换房间时给出警告，用红色表示所有"
"重叠的区域。"

msgid ""
"The system does attempt to cope with overlapping rooms as best as possible "
"by making the current room *\"sticky\"*. Each object remembers which room it "
"was in during the previous frame and stays within it as long as it does not "
"move outside the convex hull room bound. This can result in some hysteresis "
"in these overlapping zones."
msgstr ""
"该系统试图通过使当前房间\\ *“粘性”*\\ 来尽可能地应对重叠房间。每个物体都会记"
"住它上一帧所在的房间，只要它不移动到凸体房间的范围之外，就会留在这个房间里。"
"这可能会导致这些重叠区域出现一些延迟现象。"

msgid ""
"There is one exception, however, for :ref:`internal "
"rooms<doc_rooms_and_portals_internal_rooms>`. You do not have to worry about "
"these to start with."
msgstr ""
"但\\ :ref:`内部房间 <doc_rooms_and_portals_internal_rooms>`\\ 是例外。初学时"
"不必担心这些。"

msgid "How do I create a room?"
msgstr "如何创建房间？"

msgid ""
"A :ref:`Room<class_Room>` is a node type that can be added to the scene tree "
"like any other. You can place objects within the room by making them "
"children and grand-children of the Room node."
msgstr ""
":ref:`Room<class_Room>` 是一种节点类型，可以像其他类型一样添加到场景树。将对"
"象添加为 Room 节点的子级，以放置在房间内。"

msgid "How do I define the shape and position of my room convex hull?"
msgstr "如何定义房间凸体的形状和位置？"

msgid ""
"Because defining the room bound is the most important aspect of the system, "
"there are THREE methods available to define the shape of a room in Godot:"
msgstr ""
"因为定义房间边界是系统最重要的方面，因此在 Godot 提供三种方法来定义房间的形"
"状："

msgid ""
"Use the geometry of the objects contained within the room to automatically "
"create an approximate bound."
msgstr "使用房间内包含的物体的几何形状来自动创建一个近似的边界。"

msgid ""
"Manually edit the points that define the convex hull in the room inspector "
"or drag the points around using the editor gizmo (see :ref:"
"`doc_room_point_editing`)."
msgstr ""
"通过在房间检查器中手动编辑定义凸体的点，或使用编辑器小工具拖动这些点（见 :"
"ref:`doc_room_point_editing`）。"

msgid ""
"Provide a manual bound. This is a MeshInstance in the room that has geometry "
"in the shape of the desired bound, with a name with the postfix ``-bound``. "
"This is something you might choose to do if you create your levels in "
"Blender or similar (see :ref:`doc_rooms_and_portals_blender`)."
msgstr ""
"提供手动绑定。这是房间中的网络实例，具有所需范围形状的几何体，名称带有后缀 "
"``-bound``\\ 。如果您在 Blender 或类似软件中创建关卡，可能会选择这样做（见 :"
"ref:`doc_rooms_and_portals_blender`）。"

msgid ""
"While the first option can be all that is required, particularly with simple "
"rooms or for pre-production, using manual bounds gives you ultimate control "
"at the expense of a small amount of editing. You can also combine the two "
"approaches, perhaps using automatic bounds for most rooms but manually "
"editing problem areas."
msgstr ""
"虽然第一个选择可以满足所有需要，特别是简单的房间或者草稿，手动指定边界可以通"
"过少量的编辑达到完全控制的效果。也可以将这两种方法结合起来，或许可以大多数房"
"间使用自动边界，对问题区域手动编辑。"

msgid "The automatic method is used whenever a manual bound is not supplied."
msgstr "只要未提供手动绑定，就会使用自动方法。"

msgid ""
"*A simple pair of rooms. The portal margin is shown with translucent red, "
"and the room hulls are shown with green wireframe.*"
msgstr "*一对简单的房间。入口边缘以半透明红色显示，房间外体以绿色线框显示。*"

msgid "Portals"
msgstr "入口"

msgid ""
"If you create some rooms, place objects within them, then convert the level "
"in the editor, you will see the objects in the rooms appearing and showing "
"as you move between rooms. There is one problem, however! Although you can "
"see the objects within the room that the camera is in, you can't see to any "
"neighbouring rooms! For that we need portals."
msgstr ""
"如果您创建一些房间，在其中放置对象，然后在编辑器中转换关卡，您将在房间之间移"
"动时，能看到房间中的对象出现和显示。然而有一个问题！虽然您可以看到摄像机所在"
"房间内的物体，但看不到任何相邻的房间！为此，需要有入口。"

msgid ""
":ref:`Portal<class_Portal>`\\ s are special convex polygons that you "
"position over the openings between rooms in order to allow the system to see "
"between them. You can create a portal node directly in the editor. The "
"default portal has 4 points and behaves much like a ``plane`` :ref:"
"`MeshInstance<class_MeshInstance>`. You can add or remove points using the "
"inspector. A portal requires at least 3 points to work - this is because it "
"needs to form a polygon rather than a point or line."
msgstr ""
"入口 :ref:`Portal<class_Portal>` 是特殊的凸形多边形，你将其定位在房间之间的开"
"口处，以便让系统看到房间之间的情况。你可以在编辑器中直接创建入口节点。默认的"
"入口有 4 个点，其行为很像平面 ``plane`` :ref:"
"`MeshInstance<class_MeshInstance>`\\ 。可以使用检查器添加或删除点。一个入口至"
"少需要 3 个点，这是因为它需要形成多边形而不仅是点或线。"

msgid ""
"To save editing effort, **only one Portal is required between each pair of "
"Rooms**. You *do not need* to (and indeed should not) create two Portals "
"that overlap in opposite directions. Portals default to being two-way, but "
"you can make them one-way in the Portal inspector."
msgstr ""
"为了节省编辑工作，\\ **每对房间之间只须一个入口**\\ 。你\\ **不需要**\\ （也"
"不应该）创建两个重叠且相对的入口。入口默认是双向的，但您可以在入口设置中把它"
"们变成单向。"

msgid ""
"You should therefore place a portal in only one of each pair of neighbouring "
"rooms - this is the portal's *\"source room\"*. Generally it doesn't matter "
"which you choose as the source room. The portal normal (the arrow in the "
"gizmo) should face *outward* from the source room."
msgstr ""
"因此，你应该在每一对相邻房间中只放置一个入口，这就是入口的\\ *“源房间”* 。一"
"般来说，你选择哪个房间作为源房间并不重要。入口的法线（表示为小工具的箭头）应"
"该从源房间朝\\ *外*\\ 。"

msgid ""
"Do not be confused by the arrow. Although the arrow shows which direction "
"the portal faces, most portals will be *two-way*, and can be seen through "
"from both directions. The arrow is more important for ensuring that the "
"portal links to the correct neighbouring room."
msgstr ""
"不要被这个箭头所迷惑。虽然箭头显示了入口的方向，但大多数入口都是\\ *双向的"
"*\\ ，从两个方向都可以看到。箭头更为重要是确保入口连接到正确的邻近房间。"

msgid "Portal linking"
msgstr "入口链接"

msgid "There are two ways to specify which room the portal should link to:"
msgstr "指定入口应链接到哪个房间有两种方法："

msgid ""
"Leave the **Linked Room** in the inspector blank. The system will attempt to "
"*autolink* the portal to the nearest neighbour room during conversion. This "
"works fine in most cases."
msgstr ""
"将检查器中的 **Linked Room** 留空。在转换过程中，系统将尝试把入口\\ *自动链接"
"*\\ 到相邻最近的房间。这在大多数情况下能正常工作。"

msgid ""
"Explicitly specify the room by setting the **Linked Room** in the inspector."
msgstr "在检查器中设置 **Linked Room** 来显式指定房间。"

msgid ""
"Portals are defined as a set of 2D points. This ensures that the polygon "
"formed is in a single plane. The transform determines the portal "
"orientation. The points must also form a *convex* polygon. This is enforced "
"by validating the points you specify, ignoring any that do not form a convex "
"shape. This makes editing easier while making it difficult to break the "
"system."
msgstr ""
"入口由一组 2D 点来定义。这确保所形成的多边形位于单个平面中，而入口的朝向由变"
"换确定。这些点必须形成\\ *凸*\\ 多边形。通过验证，忽略任何不能形成凸面形状的"
"点。这使得编辑更容易，同时更难破坏系统。"

msgid "Trying it out"
msgstr "试一试"

msgid ""
"By now you should be able to create a couple of rooms, add some nodes such "
"as MeshInstances within the rooms, and add a portal between the rooms. Try "
"converting the rooms in the editor and see if you can now view the objects "
"in neighbouring rooms through the portal."
msgstr ""
"现在您应该能够创建几个房间，在房间内添加 MeshInstance 等节点，并在房间之间添"
"加一个入口。尝试在编辑器中转换房间，看看您现在是否可以通过入口看到相邻房间中"
"的对象。"

msgid "You have now mastered the basic principles of the system."
msgstr "您现在已经掌握了系统的基本原理。"

msgid ""
"The next step is to look at the different types of objects that can be "
"managed by the system."
msgstr "下一步是查看可以由系统管理的不同类型的对象。"

msgid "Translation status"
msgstr "翻译状态"
