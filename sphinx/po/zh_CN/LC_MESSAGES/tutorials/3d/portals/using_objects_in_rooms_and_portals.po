# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2022, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-08 13:53+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using objects in Rooms and Portals"
msgstr "在房间和入口中使用对象"

msgid ""
"Normally, when you use Godot, all objects that you can see (:ref:"
"`VisualInstance<class_VisualInstance>`\\ s) are treated in the same way by "
"the engine. The portal renderer is slightly different, in that it makes a "
"distinction between the different roles objects will have in your game. It "
"makes this distinction to define the :ref:`Room<class_Room>`\\ s, and to "
"render and process everything in the most efficient way."
msgstr ""
"通常，当您使用 Godot 时，引擎会以相同的方式处理您可以看到的所有对象（\\ :ref:"
"`VisualInstance<class_VisualInstance>`\\ ）。入口渲染器略有不同，因为它区分在"
"您的游戏中具有的不同对象角色。它通过这种区分来定义 :ref:"
"`Room<class_Room>`\\ ，并以最有效的方式渲染和处理。"

msgid "Portal mode"
msgstr "入口的模式"

msgid ""
"If you look in the inspector, every VisualInstance in Godot is derived from "
"a :ref:`CullInstance<class_CullInstance>`, where you can set a "
"``PortalMode``. This determines how objects will behave in the portal system."
msgstr ""
"如果你在检查器中查看，Godot 中的每个 VisualInstance 都是从 :ref:"
"`CullInstance<class_CullInstance>` 派生而来，你可以设置它的 "
"``PortalMode``\\ ，这决定了对象在入口系统中的行为方式。"

msgid "STATIC"
msgstr "STATIC"

msgid ""
"The default mode for objects is ``STATIC``. Static objects are objects "
"within rooms that will not move throughout the lifecycle of the level. "
"Things like floors, walls, ceilings are good candidates for ``STATIC`` "
"objects."
msgstr ""
"对象的默认模式是 ``STATIC``\\ 。静态物体是房间内的物体，在关卡的整个生命周期"
"内不会移动。像地板、墙壁、天花板都是 ``STATIC`` 对象的良好候选。"

msgid "DYNAMIC"
msgstr "DYNAMIC"

msgid ""
"Dynamic mode is for objects that are expected to move during the game. But "
"there is a limitation - **they must not move outside of their original "
"room**. These objects are handled very efficiently by the system. Examples "
"might include moving platforms, and elevators."
msgstr ""
"动态模式适用于预期在游戏过程中移动的对象。但有一个限制，\\ **他们不能离开原来"
"的房间**\\ 。这些对象由系统非常有效地处理。可能的示例如移动平台和电梯。"

msgid "ROAMING"
msgstr "ROAMING"

msgid ""
"Roaming mode is for objects that can move between rooms. Things like players "
"and enemies should be marked as roaming. These are more expensive to "
"calculate than ``STATIC`` or ``DYNAMIC`` modes, because the system has to "
"keep track of which room a roaming object is within."
msgstr ""
"漫游模式适用于可以在房间之间移动的对象。比如玩家和敌人这样的事物应该被标记为"
"漫游。这些计算比 ``STATIC`` 或 ``DYNAMIC`` 模式更消耗，因为系统必须跟踪漫游对"
"象在哪个房间内。"

msgid "GLOBAL"
msgstr "GLOBAL"

msgid ""
"Global mode is for objects that you don't want occlusion culled at all. "
"Things like a main player's weapon, bullets and some particle effects are "
"good candidates for ``GLOBAL`` mode."
msgstr ""
"全局模式适用于您根本不希望遮挡剔除的对象。比如主要玩家的武器、子弹和一些粒子"
"效果之类的东西都是 ``GLOBAL`` 模式的理想选择。"

msgid "IGNORE"
msgstr "IGNORE"

msgid ""
"Ignore is a special mode for objects that will be essentially free in the "
"system. Manual bounds (``-bound``) get converted to ignore portal mode "
"automatically. They don't need to show up during the game, but are kept in "
"the scene tree in case you need to convert the level multiple times (e.g. in "
"the Editor). You might also choose to use this for objects that you *only* "
"want to show up in the editor (when RoomManager is inactive)."
msgstr ""
"忽略是一种特殊的模式，适用于在系统中基本上是自由的对象。手动界线（ ``-"
"bound`` ）会自动转换为忽略入口模式。它们不需要在游戏过程中显示出来，但会保留"
"在场景树中，以防你需要多次转换关卡（例如在编辑器中）。你也可以选择对那些\\ *"
"只想*\\ 在编辑器中显示的对象使用这个方法（当 RoomManager 不活动时）。"

msgid "Should you place objects within rooms (in the scene tree) or not?"
msgstr "您是否应该将对象放置在房间内（在场景树中）？"

msgid ""
"``STATIC`` and ``DYNAMIC`` objects are ideally placed within rooms in the "
"scene tree. The system needs to know which room they are in during "
"conversion as it assumes they will never change room. Placing them within "
"rooms in the scene tree allows you to explicitly tell the system where you "
"want them."
msgstr ""
"``STATIC`` 和 ``DYNAMIC`` 对象最好放在场景树中的房间内。系统需要知道他们在转"
"换期间在哪个房间，因为系统假设它们永远不会改变房间。将它们放置在场景树中的房"
"间内，以明确告知系统你想得到它们的位置。"

msgid "Autoplace"
msgstr "自动放置"

msgid ""
"However, for ease of use, it is also possible to place ``STATIC`` and "
"``DYNAMIC`` objects *outside* the rooms in the scene tree, but within the "
"RoomList branch. The system will attempt to **autoplace** the objects into "
"the appropriate room. This works in most cases but if in doubt, use the "
"explicit approach. The explicit approach is especially needed when dealing "
"with internal rooms, which have some restrictions for sprawling objects."
msgstr ""
"但是，为了便于使用，也可以将 ``STATIC`` 和 ``DYNAMIC`` 对象放置在场景树中房间"
"的 *外部* ，但还在 RoomList 分支内。系统将尝试\\ **自动放置**\\ 物体到合适的"
"房间。这在大多数情况下都有效，但如果有问题，请使用显式方法。尤其在处理内部房"
"间时需要显式方法，房间对庞大的对象有一定限制。"

msgid ""
"Note that if you place ``STATIC`` and ``DYNAMIC`` objects outside of rooms, "
"they will not contribute to the room bound. If you are using the room "
"geometry to derive the bound, tables and chairs can be placed outside the "
"room. However, walls and floors should be explicitly within the Room's "
"branch of the scene tree to ensure the bound is correct."
msgstr ""
"请注意，如果您将 ``STATIC`` 和 ``DYNAMIC`` 对象放置在房间之外，它们将不会影响"
"房间边界。如果您使用房间几何体来得到边界，桌椅可以放置在房间外。但是，墙壁和"
"地板应明确位于场景树的房间分支内，以确保边界正确。"

msgid ""
"``ROAMING`` and ``GLOBAL`` objects are recommended to be kept in a branch of "
"the scene tree outside of any rooms or the RoomList. They *can* be placed "
"inside the rooms, but to save confusion, they are normally better kept on "
"their own branch. There are no restrictions on the placement of ``IGNORE`` "
"objects."
msgstr ""
"建议将 ``ROAMING`` 和 ``GLOBAL`` 对象保存在任何房间或 RoomList 之外的场景树的"
"分支中。它们 *可以* 放置在房间内，但为了避免混淆，通常最好把它们放在自己的分"
"支上。对 ``IGNORE`` 对象的放置没有限制。"

msgid "Object Lifetimes"
msgstr "对象生命周期"

msgid ""
"It is important to note that the lifetime of ``STATIC`` and ``DYNAMIC`` "
"objects is tied to the lifetime of the level, between when you call "
"``rooms_convert()`` to activate the portal system, and calling "
"``rooms_clear()`` to unload the system. This is because quite a bit of pre-"
"processing goes on during the conversion phase in order to render them "
"efficiently."
msgstr ""
"重要的是，要注意 ``STATIC`` 和 ``DYNAMIC`` 对象的生命周期与关卡的生命周期相"
"关，即从调用 ``rooms_convert()`` 以激活入口系统和调用 ` `rooms_clear()`` 卸载"
"系统。这是因为在转换阶段有相当多的预处理工作，以便有效地渲染它们。"

msgid ""
"You should therefore not try to create or delete ``STATIC`` or ``DYNAMIC`` "
"objects while the portal system is active. Doing so will cause the system to "
"automatically unload because it is in an invalid state. You can however, "
"freely ``show()`` and ``hide()`` these objects."
msgstr ""
"因此，当入口系统处于活动状态时，你不应该尝试创建或删除 ``STATIC`` 或 "
"``DYNAMIC`` 对象。这样做会导致系统自动卸载，因为它处于无效的状态。然而，你可"
"以自由地 ``show()`` 和 ``hide()`` 这些对象。"

msgid "The sequence should be therefore:"
msgstr "因此，顺序应该是："

msgid "Load your level."
msgstr "加载您的关卡。"

msgid "Place any ``STATIC`` or ``DYNAMIC`` objects."
msgstr "放置任何 ``STATIC`` 或 ``DYNAMIC`` 对象。"

msgid ""
"Then run ``rooms_convert()`` *after* all the ``STATIC`` and ``DYNAMIC`` "
"objects were added to the scene tree."
msgstr ""
"然后运行 ``rooms_convert()`` 在所有 ``STATIC`` 和 ``DYNAMIC`` 对象被添加到场"
"景树 *之后* 。"

msgid ""
"Objects that are ``ROAMING``, ``GLOBAL`` or ``IGNORE`` can be freely created "
"and deleted as required."
msgstr ""
"属于 ``ROAMING`` 、 ``GLOBAL`` 或 ``IGNORE`` 的对象可以根据需要自由创建和删"
"除。"

msgid "Sprawling"
msgstr "蔓延"

msgid ""
"Although users can usually ignore the internals of the portal system, they "
"should be aware that it is capable of handling objects that are so big they "
"end up in more than one room. Each object has a central room, but using the "
"AABB or geometry the system can detect when an object extends across a "
"portal into a neighbouring room (or several rooms). This is referred to as "
"**sprawling**."
msgstr ""
"尽管用户通常可以忽略入口系统的内部结构，但他们应该意识到系统能够处理庞杂的对"
"象，以至于对象最终会出现在一个以上的房间中。每个对象都有一个核心房间，但使用 "
"AABB 或几何图形，系统可以检测对象何时穿过入口进入相邻房间（或多个房间）。这被"
"称为\\ **蔓延**\\ 。"

msgid ""
"This means that if the corner of an object extends into a neighbouring room, "
"but the object's main room is not showing (e.g. a train where the end is in "
"a different room), the object will not be culled, and will still be shown. "
"The object will only be culled if it is not present in any of the rooms that "
"are visible."
msgstr ""
"这意味着，如果一个物体的角落延伸到邻近的房间，但该物体的主要房间没有显示（例"
"如，火车的末端在不同的房间），该物体将不会被剔除，仍然会被显示。只有当对象不"
"存在于任何可见的房间时，才会被剔除。"

msgid "Portal Margins"
msgstr "入口边距"

msgid ""
"It is hard to place objects exactly at the edges of rooms, and if we chose "
"to sprawl objects to the adjacent room the moment a portal was crossed (even "
"by a very small amount), there would be an unnecessary amount of sprawling, "
"and objects would end up being rendered when not really required. To counter "
"this, portals have an adjustable ``margin`` over which an object can cross "
"without being considered in the next room. The margin is shown in the editor "
"gizmo as a red translucent area."
msgstr ""
"我们很难将物体准确地放置在房间的边缘，如果我们选择在入口被越过的那一刻将物体"
"扩展到相邻的房间，即使是非常小的数量，就会出现不必要的扩展，而物体最终会在不"
"是真正需要的时候被渲染。为了解决这个问题，入口有一个可调整的 ``margin``\\ ，"
"物体越过这个边距就不会被考虑到下一个房间。边缘在编辑器中显示为红色的半透明区"
"域。"

msgid ""
"You can set the margin globally in the RoomManager. You can also override "
"this margin value in any portal if you need to finetune things. As you edit "
"the margin values in the inspector, you should see the margins update in the "
"3D editor viewport."
msgstr ""
"您可以在 RoomManager 中设置全局边距。如果您需要微调，可以在入口中覆盖此边距"
"值。当您在检查器中编辑边距值时，应该会在 3D 编辑器视窗中看到边距更新。"

msgid "Include in Bound"
msgstr "包含在边界中"

msgid ""
"The support for objects that are larger than a single room has one side "
"effect. You may not want to include some objects in the calculation of the "
"automatic room bound. You can turn this on and off in the inspector for each "
"object. See **Cull Instance > Include In Bound**."
msgstr ""
"对大于单个房间的对象的支持有另一种作用。您可能不想在自动房间边界的计算中包含"
"某些对象。可以在检查器中为单个对象打开和关闭此功能。参阅\\ **Cull Instance > "
"Include In Bound**\\ 。"

msgid ""
"While sprawling works great for large moving objects, it also gives you a "
"lot more leeway in level design. You can for instance create a large terrain "
"section and have it present in multiple rooms, without having to split up "
"the mesh."
msgstr ""
"虽然蔓延非常适合大型移动物体，同时它也为您提供了更多的关卡设计余地。例如，您"
"可以创建一个大型地形部分并将其存在于多个房间中，而无需拆分网格。"

msgid "Lighting"
msgstr "灯光"

msgid ""
"In general lights are handled like any other visual instance. They can be "
"placed in rooms, and they will sprawl to affect neighbouring rooms, "
"following the dimensions and direction of the light. The exception to this "
"is :ref:`DirectionalLight<class_DirectionalLight>`\\ s. DirectionalLights "
"have no source room as they affect *everywhere*. They should therefore not "
"be placed in a room. As DirectionalLights can be expensive, it is a good "
"idea to turn them off when inside, see the later :ref:"
"`doc_rooms_and_portals_roomgroups` section for details on how to do this."
msgstr ""
"通常，灯光的处理与其他可视化实例一样。可以放置在房间里，会按照灯光的大小和方"
"向扩展到邻近的房间。例外的是 :ref:"
"`DirectionalLight<class_DirectionalLight>`. 平行光没有源房间，影响 *任何地方"
"* 。因此它们不应该被放置在房间中。由于平行光可能很消耗，所以在室内时最好将其"
"关闭，参阅 :ref:`doc_rooms_and_portals_roomgroups` 部分。"

msgid ""
"Congratulations! You have now mastered the intermediate techniques required "
"to use rooms and portals. You can use these to make games already, but there "
"are many more features."
msgstr ""
"祝贺！您现在已经掌握了使用房间和入口所需的中阶技术，已经可以使用这些来制作游"
"戏，虽然还有更多功能。"

msgid "Translation status"
msgstr "翻译状态"
