# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Baked lightmaps"
msgstr "烘焙光照贴图"

msgid "Introduction"
msgstr "前言"

msgid ""
"Baked lightmaps are an alternative workflow for adding indirect (or fully "
"baked) lighting to a scene. Unlike the :ref:`doc_gi_probes` approach, baked "
"lightmaps work fine on low-end PCs and mobile devices, as they consume "
"almost no resources at run-time. Also unlike GIProbe, baked lightmaps can "
"optionally be used to store direct lighting, which provides even further "
"performance gains."
msgstr ""
"烘焙的光照贴图也是一种为场景添加间接光照（也叫全烘焙光照）的工作流程。与 :"
"ref:`doc_gi_probes` 的方法不同，烘焙光照贴图在低端PC和移动设备上运行良好，因"
"为在运行时几乎不消耗资源。与 GIProbe 的另一个不同点是，烘焙光照贴图还能够用来"
"保存直接光照，可以进一步提升性能。"

msgid ""
"Unlike GIProbes, Baked Lightmaps are completely static. Once baked, they "
"can't be modified at all. They also don't provide the scene with "
"reflections, so using :ref:`doc_reflection_probes` together with it on "
"interiors (or using a Sky on exteriors) is a requirement to get good quality."
msgstr ""
"烘焙光照贴图与 GIProbe 不同，是完全静态的，一旦被烘焙就完全不能被修改。它也不"
"能为场景提供反射，所以如果要达到较好的画质，在室内场景（或者是使用 Sky 的室外"
"场景）中就需要和 :ref:`doc_reflection_probes` 搭配使用。"

msgid ""
"As they are baked, they have fewer problems than ``GIProbe`` regarding light "
"bleeding, and indirect light will often look better. The downside is that "
"baking lightmaps takes much longer than baking a GIProbe. While baking a "
"GIProbe can be done in a matter of seconds, baking lightmaps will take "
"several minutes if not more. This can slow down iteration speed "
"significantly, so it is recommended to bake lightmaps only when you actually "
"need to see changes in lighting."
msgstr ""
"因为是烘焙出来的，所以在光线渗透方面的问题就比 ``GIProbe`` 少很多，并且间接光"
"照也会看上去更漂亮。烘焙光照贴图的缺点是烘焙所需的时间比 GIProbe 长很多，"
"GIProbe 几秒钟就能搞定的烘焙，换成烘焙光照贴图就可能至少得花上几分钟。这会严"
"重拖慢迭代速度，所以推荐只在确实有查看光照变化的需求时进行光照贴图的烘焙。"

msgid ""
"Baking lightmaps will also reserve baked materials' UV2 slot, which means "
"you can no longer use it for other purposes in materials (either in the "
"built-in :ref:`doc_spatial_material` or in custom shaders)."
msgstr ""
"烘焙光照贴图还会占用被烘焙材质的 UV2 栏位，也就是说你无法再把 UV2 用于该材质"
"的其它用途（无论是内置的 :ref:`doc_spatial_material` 还是自定义着色器）。"

msgid ""
"In the end, deciding which indirect lighting approach is better depends on "
"your use case. In general, GIProbe is easier to set up and works better with "
"dynamic objects. For mobile or low-end compatibility, though, baked "
"lightmaps are your only choice."
msgstr ""
"最后，决定哪种间接光照方式更好取决于你的用途。一般来说，GIProbe 用起来更方便"
"并且能够更好地应用到动态对象。但如果需要兼容移动设备和低端设备，你只能选择烘"
"焙光照贴图。"

msgid "Visual comparison"
msgstr "视觉比较"

msgid ""
"Here are some comparisons of how BakedLightmap vs. GIProbe look. Notice that "
"lightmaps are more accurate, but also suffer from the fact that lighting is "
"on an unwrapped texture, so transitions and resolution may not be that good. "
"GIProbe looks less accurate (as it's an approximation), but smoother overall."
msgstr ""
"以下是 BakedLightmap 和 GIProbe 的一些显示效果比较。可以看到光照贴图更精确，"
"但由于使用的是展开后的纹理，所以过渡以及分辨率可能就没有那么理想。GIProbe 看"
"上去没有那么精确（因为是近似估算），但总体上更平滑。"

msgid "Setting up"
msgstr "设置"

msgid ""
"First of all, before the lightmapper can do anything, the objects to be "
"baked need an UV2 layer and a texture size. An UV2 layer is a set of "
"secondary texture coordinates that ensures any face in the object has its "
"own place in the UV map. Faces must not share pixels in the texture."
msgstr ""
"首先，在光照贴图器可以执行任何操作之前，要烘焙的对象需要 UV2 图层和纹理大小。"
"UV2 图层是一组辅助纹理坐标，可确保对象中的任何面在 UV 贴图中都有自己的位置。"
"面与面之间不得共享纹理中的像素。"

msgid ""
"There are a few ways to ensure your object has a unique UV2 layer and "
"texture size:"
msgstr "这里有几种方法可以确保您的对象具有唯一的 UV2 层和纹理大小："

msgid "Unwrap on scene import"
msgstr "场景导入时展开"

msgid ""
"This is probably the best approach overall. The only downside is that, on "
"large models, unwrapping can take a while on import. Nonetheless, Godot will "
"cache the UV2 across reimports, so it will only be regenerated when needed."
msgstr ""
"总体来说，这可能是最好的方法。唯一的缺点是，在大型模型上，导入时展开可能需要"
"一段时间。不过Godot会在重新导入时缓存UV2，所以只会在需要时重新生成。"

msgid ""
"Select the imported scene in the filesystem dock, then go to the **Import** "
"dock. There, the following option can be modified:"
msgstr ""
"在文件系统面板中选择被导入的场景，然后切换到\\ **导入**\\ 面板。这里可以修改"
"以下选项："

msgid ""
"The **Light Baking** mode needs to be set to **Gen Lightmaps**. A texel size "
"in world units must also be provided, as this will determine the final size "
"of the lightmap texture (and, in consequence, the UV padding in the map)."
msgstr ""
"需要把 **Light Baking** 光照烘焙模式设置为 **Gen Lightmaps**\\ ，同时还必须提"
"供世界单位的纹素大小，因为这将确定光照贴图纹理的最终大小（由此确定地图中的 "
"UV 填充）。"

msgid ""
"The effect of setting this option is that all meshes within the scene will "
"have their UV2 maps properly generated."
msgstr "设置此选项的效果是场景中的所有网格都将正确生成其UV2贴图."

msgid ""
"When reusing a mesh within a scene, keep in mind that UVs will be generated "
"for the first instance found. If the mesh is re-used with different scales "
"(and the scales are wildly different, more than half or twice), this will "
"result in inefficient lightmaps. Don't reuse a source mesh at significantly "
"different scales if you are planning to use lightmapping."
msgstr ""
"如果在场景中复用了网格，请注意生成 UV 时只会使用第一个找到的实例。如果复用时"
"使用了不同的缩放比例（并且相差很大，超过了一半或者两倍），会导致生成低效的光"
"照贴图。如果你想用光照贴图，就不要在复用原始网格时使用明显不同的缩放比例。"

msgid ""
"Also, the ``*.unwrap_cache`` files should *not* be ignored in version "
"control as these files guarantee that UV2 reimports are consistent across "
"platforms and engine versions."
msgstr ""
"另外，请\\ *不要*\\ 在版本控制系统中忽略 ``*.unwrap_cache`` 文件，这些文件可"
"以用来保证不同平台、不同版本的引擎在重新导入 UV2 时的一致性。"

msgid "Unwrap from within Godot"
msgstr "使用 Godot 进行展开"

msgid ""
"Godot has an option to unwrap meshes and visualize the UV channels. It can "
"be found in the Mesh menu:"
msgstr "Godot可以选择打开网格并可视化UV通道. 它可以在Mesh菜单中找到:"

msgid ""
"This will generate a second set of UV2 coordinates which can be used for "
"baking, and it will also set the texture size automatically."
msgstr "这将生成第二组UV2坐标, 可用于烘焙, 并且还将自动设置纹理大小."

msgid "Unwrap from your 3D DCC"
msgstr "使用 3D DCC 展开"

msgid ""
"The last option is to do it from your favorite 3D app. This approach is "
"generally not recommended, but it's explained first so that you know it "
"exists. The main advantage is that, on complex objects that you may want to "
"re-import a lot, the texture generation process can be quite costly within "
"Godot, so having it unwrapped before import can be faster."
msgstr ""
"最后一种方法是在你喜欢的 3D 应用程序中进行操作。通常不推荐这种做法，但为了让"
"你知道它的存在，这里还是解释一下。这种做法的主要优势在于，针对可能要经常重新"
"导入的复杂对象，在 Godot 中进行纹理生成的代价可能相当高，所以在导入前展开可以"
"提高速度。"

msgid "Simply do an unwrap on the second UV2 layer."
msgstr "只需在第二个UV2层上进行展开即可。"

msgid ""
"Then import the 3D scene normally. Remember you will need to set the texture "
"size on the mesh after import."
msgstr "然后正常导入 3D 场景。记得在导入后为网格设置纹理大小。"

msgid ""
"If you use external meshes on import, the size will be kept. Be wary that "
"most unwrappers in 3D DCCs are not quality oriented, as they are meant to "
"work quickly. You will mostly need to use seams or other techniques to "
"create better unwrapping."
msgstr ""
"如果在导入时使用外部网格, 则将保留大小. 请注意,3D DCC中的大多数解包器都不是面"
"向质量的, 因为它们可以快速工作. 您通常需要使用接缝或其他技术来创建更好的展开."

msgid "Checking UV2"
msgstr "检查 UV2"

msgid ""
"In the mesh menu mentioned before, the UV2 texture coordinates can be "
"visualized. Make sure, if something is failing, to check that the meshes "
"have these UV2 coordinates:"
msgstr ""
"在前面提到的网格菜单中, 可以显示UV2纹理坐标. 如果出现问题, 请确保检查网格是否"
"具有以下UV2坐标:"

msgid "Setting up the scene"
msgstr "设置场景"

msgid ""
"Before anything is done, a **BakedLightmap** node needs to be added to a "
"scene. This will enable light baking on all nodes (and sub-nodes) in that "
"scene, even on instanced scenes."
msgstr ""
"首先需要在场景中添加一个 **BakedLightmap** 节点。添加后，场景中的所有节点（和"
"子节点）就都可以进行光照烘焙了，甚至实例化的场景也可以。"

msgid ""
"A sub-scene can be instanced several times, as this is supported by the "
"baker, and each will be assigned a lightmap of its own (just make sure to "
"respect the rule about scaling mentioned before):"
msgstr ""
"烘焙器支持同一子场景存在多个实例，它们会有各自独立的光照贴图（前提是你得遵守"
"之前提过的关于缩放的规则）："

msgid "Configure bounds"
msgstr "配置边界"

msgid ""
"Lightmap needs an approximate volume of the area affected because it uses it "
"to transfer light to dynamic objects inside it (more on that later). Just "
"cover the scene with the volume as you do with ``GIProbe``:"
msgstr ""
"光线贴图(Lightmap)需要一个受影响区域的近似体积, 因为它将光线传递给在该体积内"
"部的动态对象(稍后再谈). 就像使用 ``GIProbe`` 一样, 用体积覆盖场景:"

msgid "Setting up meshes"
msgstr "设置网格"

msgid ""
"For a **MeshInstance** node to take part in the baking process, it needs to "
"have the **Use in Baked Light** property enabled."
msgstr ""
"如果需要让 **MeshInstance** 节点参与烘焙，需要启用 **Use in Baked Light** 属"
"性。"

msgid ""
"When auto-generating lightmaps on scene import, this is enabled "
"automatically."
msgstr "在场景导入时自动生成光照贴图时, 会自动启用此功能."

msgid "Setting up lights"
msgstr "设置灯光"

msgid ""
"Lights are baked with indirect light by default. This means that "
"shadowmapping and lighting are still dynamic and affect moving objects, but "
"light bounces from that light will be baked."
msgstr ""
"默认情况下, 灯光采用间接灯光烘焙. 这意味着阴影贴图和光照仍然是动态的并影响移"
"动的物体, 但是光线反射的光将被烘焙."

msgid ""
"Lights can be disabled (no bake) or be fully baked (direct and indirect). "
"This can be controlled from the **Bake Mode** menu in lights:"
msgstr ""
"灯可以禁用(不烘焙)或完全烘焙(直接和间接). 这可以通过灯光中的 **烘焙模式** 菜"
"单进行控制:"

msgid "The modes are:"
msgstr "模式有："

msgid "Disabled"
msgstr "Disabled（禁用）"

msgid ""
"The light is ignored when baking lightmaps. Keep in mind hiding a light will "
"have no effect for baking, so this must be used instead of hiding the Light "
"node."
msgstr ""
"烘焙光照贴图时忽略灯光。注意烘焙时隐藏灯光是无效的，必须在这里设置禁用才能达"
"到隐藏灯光节点的效果。"

msgid ""
"This is the mode to use for dynamic lighting effects such as explosions and "
"weapon effects."
msgstr "这个模式可以用于动态光照效果，例如爆炸和武器特效。"

msgid "Indirect"
msgstr "Indirect（间接）"

msgid ""
"This is the default mode, and is a compromise between performance and real-"
"time friendliness. Only indirect lighting will be baked. Direct light and "
"shadows are still real-time, as they would be without BakedLightmap."
msgstr ""
"这是默认的模式，是性能与实时友好性的折衷。只会烘焙间接光照。直接灯光和阴影仍"
"旧是实时的，与不使用 BakedLightmap 时一致。"

msgid ""
"This mode allows performing *subtle* changes to a light's color, energy and "
"position while still looking fairly correct. For example, you can use this "
"to create flickering static torches that have their indirect light baked."
msgstr ""
"这个模式可以在保持显示效果相对正确的同时，允许进行灯光颜色、能量、以及位置的 "
"*微调* 。例如，你可以借此实现静态火把的闪烁，它的间接光照仍然是烘焙的。"

msgid "All"
msgstr "All（全部）"

msgid ""
"Both indirect and direct lighting will be baked. Since static surfaces can "
"skip lighting and shadow computations entirely, this mode provides the best "
"performance along with smooth shadows that never fade based on distance. The "
"real-time light will not affect baked surfaces anymore, but it will still "
"affect dynamic objects. When using the **All** bake mode on a light, dynamic "
"objects will not cast real-time shadows onto baked surfaces, so you need to "
"use a different approach such as blob shadows instead. Blob shadows can be "
"implemented with a Sprite3D + RayCast setup, or a negative SpotLight "
"pointing down with its bake mode set to **Disabled**."
msgstr ""
"间接和直接光照都会被烘焙。因为静态表面可以完全跳过光照和阴影的计算，所以这个"
"模式可以提供最佳的性能，并且实现不随距离衰减的平滑的阴影。实时灯光不会再影响"
"烘焙的表面，但仍然可以影响动态的对象。在光源上使用 **All** （全部）烘焙模式"
"时，动态对象不会在烘焙表面上投射阴影，所以你需要使用别的方法，比如软阴影。软"
"阴影既可以通过 Sprite3D + RayCast 实现，也可以通过把朝下的反 SpotLight 的烘焙"
"模式设置成 **禁用** 实现。"

msgid ""
"The light will not be adjustable at all during gameplay. Moving the light "
"and changing its color or energy will not have any effect on static surfaces."
msgstr ""
"游戏过程中无法调整灯光。灯光的移动、变色、能量调整不会对静态表面产生影响。"

msgid ""
"Since bake modes can be adjusted on a per-light basis, it is possible to "
"create hybrid baked light setups. One popular option is to use a real-time "
"DirectionalLight with its bake mode set to **Indirect**, and use the **All** "
"bake mode for OmniLights and SpotLights. This provides good performance "
"while still allowing dynamic objects to cast real-time shadows in outdoor "
"areas."
msgstr ""
"因为烘焙模式可以分光源调整，所以可以设置出混合的烘焙光照。一个比较流行的做法"
"是使用实时 DirectionalLight 并把它的烘焙模式设置成 **Indirect**\\ ，然后把 "
"OmniLight 和 SpotLight 的烘焙模式都设置成 **All**\\ 。这样做的性能不错，同时"
"也允许动态对象在室外投射实时阴影。"

msgid ""
"After selecting the **All** bake mode on a light, you can optionally specify "
"a **Size** greater than 0 for the light in the inspector. This size is used "
"to provide softer shadows depending on the distance between the shadow "
"caster and the object receiving the shadow. This mimics real life shadow "
"appearance:"
msgstr ""
"选中灯光的 *All* 烘焙选项之后，你还可以在检查器中将灯光的 *Size*\\ （大小）设"
"置为大于 0 的值。这个大小值可以用来根据投射阴影与接受阴影物体之间的距离来提供"
"更柔和的阴影。这样就可以模拟现实生活中影子的样子："

msgid ""
"The light's **Size** property is ignored for real-time shadows; it will only "
"affect baked shadows. When the **Size** property is changed, lightmaps must "
"be baked again to make changes visible."
msgstr ""
"灯光的 **Size** 属性会被实时阴影忽略；只有烘焙阴影会受其影响。改变 **Size** "
"后，必须重新生成光照贴图才能让修改效果显现出来。"

msgid "Baking"
msgstr "烘焙"

msgid ""
"To begin the bake process, just push the **Bake Lightmaps** button on top "
"when selecting the BakedLightmap node:"
msgstr ""
"开始烘焙只需在选中 BakedLightmap 节点后点击上方的 **烘焙光照贴图** 按钮："

msgid ""
"This can take from seconds to minutes (or hours) depending on scene size, "
"bake method and quality selected."
msgstr ""
"根据场景大小、所选烘焙方法以及质量的不同，其过程可能花费几秒钟到几分钟不等"
"（也可能是几小时）。"

msgid "Balancing bake times with quality"
msgstr "平衡烘焙时间和质量"

msgid ""
"Since high-quality bakes can take very long (up to several hours for large "
"complex scenes), it is recommended to use lower quality settings at first. "
"Then, once you are confident with your scene's lighting setup, raise the "
"quality settings and perform a \"final\" bake before exporting your project."
msgstr ""
"因为高质量的烘焙可能花费非常长的时间（大型复杂场景可能需要若干小时），推荐首"
"先设置成较低质量，将场景中的灯光布置成满意的效果后再改成较高的质量，在导出项"
"目前进行“终极”烘焙。"

msgid ""
"By default, the lightmap baker will use all the system's logical CPU cores "
"to speed up baking. This can reduce system responsiveness. To preserve "
"system responsiveness while lightmaps are baking, you can reduce the number "
"of CPU threads used to bake lightmaps. Keeping 1 or 2 CPU threads free will "
"help improve system responsiveness, which is useful when multi-tasking while "
"lightmaps are baking at the cost of slowing down lightmap baking slightly."
msgstr ""
"默认情况下，光照贴图烘焙器会使用系统中所有逻辑 CPU 核心来加速烘焙，可能会降低"
"系统的响应能力。要在烘焙光照贴图时保留系统的响应能力，你可以减少用于烘焙光照"
"贴图的 CPU 线程数。保留 1 到 2 个 CPU 线程可以帮助提高系统响应能力，有利于在"
"烘焙光照贴图时进行多任务，但也会稍微降低光照贴图的烘焙速度。"

msgid ""
"To do so, open **Editor > Editor Settings** and adjust **Editors > 3d > "
"Lightmap Baking Number Of Cpu Threads**. The default value (``0``) uses all "
"of the system's logical CPU cores. Positive values will specify a number of "
"threads to use, while negative values will subtract from the total number of "
"logical CPU cores in the system. For example, on a system with 8 logical CPU "
"cores, adjusting the setting to ``-1`` will use 7 CPU threads for lightmap "
"baking."
msgstr ""
"实现方法是，打开\\ *编辑器 -> 编辑器设置**\\ 并调整 **Editors > 3d > "
"Lightmap Baking Number Of Cpu Threads**\\ （编辑器 > 3D > 光照贴图烘焙 CPU 线"
"程数）。默认值（\\ ``0``\\ ）会使用所有的系统逻辑 CPU 核心。正值可以指定所使"
"用的线程数，负值则是从系统逻辑 CPU 核心的总数中去减。例如，在拥有 8 个逻辑 "
"CPU 核心的系统上，将其设置为 ``-1`` 会在烘焙光照贴图时使用 7 个 CPU 线程。"

msgid "Configuring bake"
msgstr "配置烘焙"

msgid "Several more options are present for baking:"
msgstr "烘焙还有几个选项："

msgid ""
"**Bake Extents**: The size of the area affected. This can be edited in the "
"3D editor viewport using the handles. Any object that can have lightmaps "
"baked and is *touching* the bake extents will have lightmaps baked for it, "
"but dynamic object capture will only work within the extents."
msgstr ""
"**Bake Extents（烘焙界限）** ：受影响的区域大小，也可以使用 3D 编辑器视图中的"
"手柄进行编辑。所有支持烘焙光照贴图并且与烘焙界限 *有交集* 的对象都会被烘焙上"
"光照贴图，但动态对象捕获也只会在界限之中进行。"

msgid "Tweaks"
msgstr "Tweaks（调整）"

msgid ""
"**Quality:** Four bake quality modes are provided: Low, Medium, High, and "
"Ultra. Higher quality takes more time, but result in a better-looking "
"lightmap with less noise. The difference is especially noticeable with "
"emissive materials or areas that get little to no direct lighting."
msgstr ""
"**Quality（质量）**\\ ：提供了四种烘焙质量：Low（低级）、Medium（中级）、High"
"（高级）、Ultra（超级）。质量越高所需的时间越长，但最终光照贴图的显示效果越"
"好、噪点也越少。针对发光材质或者几乎没有直接光照的地方，不同质量之间的区别尤"
"为显著。"

msgid ""
"**Bounces:** The number of bounces to use for indirect lighting. The default "
"value (3) is a good compromise between bake times and quality. Higher values "
"will make light bounce around more times before it stops, which makes "
"indirect lighting look smoother (but also brighter). During the initial "
"lighting iteration work, it is recommended to decrease the number of bounces "
"to 1 to speed up baking. Remember that your scene will be darker when "
"decreasing the number of bounces."
msgstr ""
"**Bounces（反弹）** ：间接光照的反弹次数。默认值（3）是烘焙时间和质量之间的一"
"个平衡点。取值越高，光线在停止之前反弹的次数越多，间接光照的效果也就越好（同"
"时也越亮）。在做最初的光照迭代工作时，建议把反弹次数减小到 1，这样可以加快烘"
"焙速度。注意降低反弹次数会让场景变暗。"

msgid ""
"**Use Denoiser:** If enabled, uses OpenImageDenoise to make the lightmap "
"significantly less noisy. This increases bake times and can occasionally "
"introduce artifacts, but the result is often worth it."
msgstr ""
"**Use Denoiser（使用降噪器）** ：启用时，会使用 OpenImageDenoise 显著降低光照"
"贴图中的噪点。在增加烘焙时间的同时有时也会引入伪影，不过获得的效果经常是物有"
"所值的。"

msgid ""
"**Use Hdr:** If disabled, lightmaps are smaller on disk, but they won't be "
"able to capture any light over white (1.0). This will result in visible "
"clipping if you have bright lights in your scene. When HDR is disabled, "
"banding may also be visible in the lightmap."
msgstr ""
"**Use Hdr（使用 HDR）** ：禁用时，光照贴图会占用更少的磁盘空间，但就会无法捕"
"捉过亮（大于 1.0）的灯光。如果场景中存在较亮的光源，就会造成可见的边界。禁用 "
"HDR 后光照贴图中也有可能出现条状区域。"

msgid ""
"**Use Color:** If disabled, lightmaps are smaller on disk, but the lightmap "
"won't be able to store colored lighting. When baking indirect light only, "
"the difference may be barely visible since indirect light is generally not "
"highly saturated. However, when baking both direct and indirect lighting "
"using the **All** bake mode on a light, this will turn colored lighting into "
"grayscale lighting. This can be disabled together with HDR to get the "
"smallest possible lightmap file at a given resolution."
msgstr ""
"**Use Color（使用彩色）** ：禁用时，光照贴图会占用更少的磁盘空间，但就会无法"
"保存彩色灯光。仅烘焙间接光照时，由于间接灯光通常对比度不高，所以可能几乎看不"
"出区别。然而使用 **All** 烘焙模式同时烘焙直接和间接光照时，就会导致彩色灯光变"
"成灰度灯光。该选项和 HDR 一起禁用后可以得到相同分辨率下最小的光照贴图。"

msgid ""
"**Bias:** The offset value to use for shadows in 3D units. You generally "
"don't need to change this value, except if you run into issues with light "
"bleeding or dark spots in your lightmap after baking. This setting does not "
"affect real-time shadows casted on baked surfaces."
msgstr ""
"**Bias（偏置）** ：阴影的偏移量，使用 3D 单位。除非你遇到了光线渗透问题或者光"
"照贴图在烘焙后存在暗区，否则通常情况下不需要修改这个值。该选项不会影响投射在"
"烘焙表面上的实时阴影。"

msgid ""
"**Default Texels Per Unit:** For meshes that do not specify their own "
"lightmap texel density, this will be used as the value. Higher values result "
"in *lower-resolution* lightmaps, which result in faster bake times and lower "
"file sizes at the cost of blurrier indirect lighting and shadows."
msgstr ""
"**Default Texels Per Unit（默认单位纹素数）**\\ ：未指定光照贴图纹素密度的网"
"格会使用此值。取值越高，光照贴图的\\ *分辨率越低*\\ ，使用模糊的间接光影换取"
"更快的烘焙时间以及更小的文件大小。"

msgid "Atlas"
msgstr "Atlas（图谱）"

msgid ""
"**Generate:** If enabled, a texture atlas will be generated for the "
"lightmap. This results in more efficient rendering, but is only compatible "
"with the GLES3 rendering backend. Disable this setting if your project is "
"allowed to fall back to GLES2. (This is not the case by default and must be "
"enabled in the Project Settings.) *This setting is ignored when the project "
"is configured to use GLES2 by default.*"
msgstr ""
"**Generate（生成）** ：启用时，会为光照贴图生成图谱纹理，可以让渲染更高效，但"
"仅适用于 GLES3 渲染器。所以如果你的项目允许退回到 GLES2（默认未启用，只能在项"
"目设置中手动启用），请禁用此选项。 *如果项目使用 GLES2，那么该选项默认会被忽"
"略。*"

msgid ""
"**Max Size:** The maximum size of the atlas in pixels. Higher values result "
"in a more efficient atlas, but are less compatible with old/low-end "
"hardware. If in doubt, leave this setting on its default value (4096)."
msgstr ""
"**Max Size（最大尺寸）** ：图谱的最大尺寸，单位为像素。取值越高，图谱效率越"
"高，但也就越不兼容较旧或者低端的硬件。如果没有把握，就请使用该选项的默认值"
"（4096）。"

msgid "Capture"
msgstr "Capture（捕获）"

msgid ""
"**Enabled:** This enables probe capture so that dynamic objects can "
"*receive* indirect lighting. Regardless of this setting's value, dynamic "
"objects will not be able to *contribute* indirect lighting to the scene. "
"This is a limitation of lightmaps."
msgstr ""
"**Enabled（启用）** ：启用探针捕获，使得动态对象能够 *接受* 间接光照。无论此"
"选项是否启用，动态对象都无法对场景 *造成* 间接光照，这是光照贴图的局限性。"

msgid ""
"**Cell Size:** The distance between lightmap probes in 3D units. Higher "
"values result in more sparse probe placement, which decreases bake times and "
"file size at the cost of lower lighting accuracy for dynamic objects."
msgstr ""
"**Cell Size（单元格大小）** ：光照贴图探针的间距，使用 3D 单位。取值越高，探"
"针布置地越稀疏，通过牺牲动态对象光照的精确度带来烘焙时间的缩短以及文件大小的"
"减小。"

msgid ""
"**Quality:** The lightmap probe generation quality. Higher values result in "
"more accurate lighting, but take longer to bake. This setting does not "
"affect the *density* of the lightmap probes, only their quality."
msgstr ""
"**Quality（质量）** ：光照贴图探针的生成质量。取值越高，光照越精确，烘焙时间"
"也越长。此选项不会影响光照贴图探针的 *密度* ，只影响质量。"

msgid ""
"**Propagation:** Similar to :ref:`GIProbe <doc_gi_probes>`'s Propagation "
"property. Higher values result in brighter and more diffuse indirect "
"lighting for dynamic objects. Adjust this value depending on your scene to "
"make dynamic objects better fit with static baked lighting."
msgstr ""
"**Propagation（传播）** ：类似于 :ref:`GIProbe <doc_gi_probes>` 的 "
"Propagation 属性。取值越高，动态对象间接光照就越亮、漫反射越强。根据场景的实"
"际情况调整此选项，可以让动态对象更好地融入静态的烘焙光照。"

msgid "Data"
msgstr "数据"

msgid ""
"**Light Data**: Contains the light baked data after baking. Textures are "
"saved to disk, but this also contains the capture data for dynamic objects, "
"which can be heavy. If you are using a scene in ``.tscn`` format, you should "
"save this resource to an external binary ``.lmbake`` file to avoid bloating "
"the ``.tscn`` scene with binary data encoded in Base64."
msgstr ""
"**Light Data（光照数据）** ：烘焙后包含光照烘焙数据。纹理会被保存到磁盘上，但"
"这里还会包含动态对象的捕获数据，数据量可能非常大。如果你使用的是 ``.tscn`` 格"
"式的场景，应该将此资源保存成外部的二进制 ``.lmbake`` 文件，否则 ``.tscn`` 场"
"景可能因为使用 Base64 编码二进制数据而变得巨大。"

msgid ""
"The Light Data resource can be edited to adjust two additional properties:"
msgstr "光照数据资源里有两个额外的属性可供编辑："

msgid ""
"**Energy:** Adjusts the lightmap's brightness. Higher values result in "
"brighter lightmaps. This can be adjusted at run-time for short-lived dynamic "
"effects such as thunderstorms. However, keep in mind that it will affect "
"*all* baked lights."
msgstr ""
"**Energy（能量）** ：调整光照贴图的亮度。取值越高，光照贴图越亮。此选项可以在"
"运行时调整，用来实现类似雷暴的短期的动态效果。不过请注意，修改会影响 *所有* "
"被烘焙的灯光。"

msgid ""
"**Interior:** If enabled, dynamic objects will not make use of environment "
"lighting and will use light probes for ambient lighting exclusively. If "
"disabled, both environment lighting and light probes are used to light up "
"dynamic objects."
msgstr ""
"**Interior（室内）** ：启用时，动态对象不会使用环境的光照设置，只会使用光照探"
"针作为环境光。禁用时，环境的光照设置和光照探针会同时作用于动态对象的光照。"

msgid ""
"The generated EXR file can be viewed and even edited using an image editor "
"to perform post-processing if needed. However, keep in mind that changes to "
"the EXR file will be lost when baking lightmaps again."
msgstr ""
"如果有后期处理的需要，可以使用图像编辑器查看并编辑所生成的 EXR 文件。不过请注"
"意，重新烘焙贴图会覆盖你对 EXR 文件的修改。"

msgid "Dynamic objects"
msgstr "动态对象"

msgid ""
"In other engines or lightmapper implementations, you are generally required "
"to manually place small objects called \"lightprobes\" all around the level "
"to generate *capture* data. This is then used to transfer the light to "
"dynamic objects that move around the scene."
msgstr ""
"在其它引擎以及光照贴图器的实现中，一般会需要你在关卡中手动放置一些叫做“光照探"
"针”的细小对象，用以生成\\ *捕获*\\ 数据。然后就会借此将光照传递给在场景中到处"
"移动的动态对象。"

msgid ""
"However, this implementation of lightmapping uses a different method. The "
"process is automatic, so you don't have to do anything. Just move your "
"objects around, and they will be lit accordingly. Of course, you have to "
"make sure you set up your scene bounds accordingly or it won't work."
msgstr ""
"但是，本光照映射器的实现使用了一种不同的方法，其过程是自动的，不需要你做任何"
"事情，只要移动物体就能得到对应的光照。当然，你还是需要确保相应地设置场景边"
"界，否则会将无法正常工作。"

msgid "Translation status"
msgstr "翻译状态"
