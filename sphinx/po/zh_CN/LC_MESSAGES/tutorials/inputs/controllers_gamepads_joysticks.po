# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-16 15:51+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Controllers, gamepads, and joysticks"
msgstr "控制器、手柄和摇杆"

msgid ""
"Godot supports hundreds of controller models thanks to the community-sourced "
"`SDL game controller database <https://github.com/gabomdq/"
"SDL_GameControllerDB>`__."
msgstr ""
"Godot支持数百种控制器模型，这要归功于社区提供的 `SDL游戏控制器数据库 "
"<https://github.com/gabomdq/SDL_GameControllerDB>`__ 。"

msgid ""
"Controllers are supported on Windows, macOS, Linux, Android, iOS, and HTML5."
msgstr "控制器支持Windows、macOS、Linux、Android、iOS和HTML5。"

msgid ""
"Note that more specialized devices such as steering wheels, rudder pedals "
"and `HOTAS <https://en.wikipedia.org/wiki/HOTAS>`__ are less tested and may "
"not always work as expected. If you have access to one of those devices, "
"don't hesitate to `report bugs on GitHub <https://github.com/godotengine/"
"godot/blob/master/CONTRIBUTING.md#reporting-bugs>`__."
msgstr ""
"请注意，诸如方向盘、方向盘踏板和 `HOTAS <https://en.wikipedia.org/wiki/"
"HOTAS>`__ 等更专业的设备测试较少，可能并不总是按照预期工作。如果你有机会使用"
"这些设备，不要犹豫 `在GitHub <https://github.com/godotengine/godot/blob/"
"master/CONTRIBUTING.md#reporting-bugs>`__ 上报告错误。"

msgid "In this guide, you will learn:"
msgstr "在本指南中，您将学会："

msgid ""
"**How to write your input logic to support both keyboard and controller "
"inputs.**"
msgstr "**如何编写你的输入逻辑以支持键盘和控制器输入.**"

msgid "**How controllers can behave differently from keyboard/mouse input.**"
msgstr "**控制器的行为如何与键盘/鼠标输入不同.**"

msgid "**Troubleshooting issues with controllers in Godot.**"
msgstr "**解决Godot中控制器的问题**"

msgid "Supporting universal input"
msgstr "支持通用导出"

msgid ""
"Thanks to Godot's input action system, Godot makes it possible to support "
"both keyboard and controller input without having to write separate code "
"paths. Instead of hardcoding keys or controller buttons in your scripts, you "
"should create *input actions* in the Project Settings which will then refer "
"to specified key and controller inputs."
msgstr ""
"由于Godot的输入动作系统，Godot使得支持键盘和控制器输入成为可能，而不需要编写"
"单独的代码路径。你应该在项目设置中创建 *输入动作* ，然后引用指定的按键和控制"
"器输入，而不是在你的脚本中硬编码按键或控制器按钮。"

msgid ""
"Input actions are explained in detail on the :ref:`doc_inputevent` page."
msgstr "输入动作在 :ref:`doc_inputevent` 页面上有详细解释。"

msgid ""
"Unlike keyboard input, supporting both mouse and controller input for an "
"action (such as looking around in a first-person game) will require "
"different code paths since these have to be handled separately."
msgstr ""
"与键盘输入不同，支持鼠标和控制器输入的动作将需要不同的代码路径，例如在第一人"
"称游戏中四处查看，因为这些必须被分开处理。"

msgid "Which Input singleton method should I use?"
msgstr "我应该使用哪个输入单例方法？"

msgid "There are 3 ways to get input in an analog-aware way:"
msgstr "有3种方式可以以模拟感知的方式获得输入:"

msgid ""
"When you have two axes (such as joystick or WASD movement) and want both "
"axes to behave as a single input, use ``Input.get_vector()``:"
msgstr ""
"当你有两个轴，如操纵杆或WASD运动，并希望两个轴都表现为单一输入时，使用 "
"``Input.get_vector()`` :"

msgid ""
"When you have one axis that can go both ways (such as a throttle on a flight "
"stick), or when you want to handle separate axes individually, use ``Input."
"get_axis()``:"
msgstr ""
"当你有一个轴可以双向移动时，比如飞行操纵杆上的油门，或者你想单独处理不同的轴"
"时，使用 ``Input.get_axis()`` :"

msgid ""
"For other types of analog input, such as handling a trigger or handling one "
"direction at a time, use ``Input.get_action_strength()``:"
msgstr ""
"对于其他类型的模拟输入，例如处理一个触发器或一次处理一个方向，使用 ``Input."
"get_action_strength()`` :"

msgid ""
"For non-analog digital/boolean input (only \"pressed\" or \"not pressed\" "
"values), such as controller buttons, mouse buttons or keyboard keys, use "
"``Input.is_action_pressed()``:"
msgstr ""
"对于非模拟数字/布尔输入（只有 \"按下 \" 或 \"未按下 \" 的值），如控制器按钮、"
"鼠标按钮或键盘按键，使用 ``Input.is_action_pressed()`` :"

msgid ""
"In Godot versions before 3.4, such as 3.3, ``Input.get_vector()`` and "
"``Input.get_axis()`` aren't available. Only ``Input.get_action_strength()`` "
"and ``Input.is_action_pressed()`` are available in Godot 3.3."
msgstr ""
"在3.4之前的Godot版本，如3.3， ``Input.get_vector()`` 和 ``Input.get_axis()`` "
"不可用。只有 ``Input.get_action_strength()`` 和 ``Input."
"is_action_pressed()`` 在Godot 3.3中可用。"

msgid "Differences between keyboard/mouse and controller input"
msgstr "键盘/鼠标和控制器输入之间的差异"

msgid ""
"If you're used to handling keyboard and mouse input, you may be surprised by "
"how controllers handle specific situations."
msgstr ""
"如果您习惯于处理键盘和鼠标输入，可能会对控制器处理特定情况的方式感到惊讶。"

msgid "Dead zone"
msgstr "盲区"

msgid ""
"Unlike keyboards and mice, controllers offer axes with *analog* inputs. The "
"upside of analog inputs is that they offer additional flexibility for "
"actions. Unlike digital inputs which can only provide strengths of ``0.0`` "
"and ``1.0``, an analog input can provide *any* strength between ``0.0`` and "
"``1.0``. The downside is that without a deadzone system, an analog axis' "
"strength will never be equal to ``0.0`` due to how the controller is "
"physically built. Instead, it will linger at a low value such as ``0.062``. "
"This phenomenon is known as *drifting* and can be more noticeable on old or "
"faulty controllers."
msgstr ""
"与键盘和鼠标不同，控制器提供带有\\ *模拟*\\ 输入的轴。模拟输入的好处是它们为"
"动作提供了额外的灵活性。不像数字输入只能提供 ``0.0`` 和 ``1.0`` 的强度，模拟"
"输入可以提供 ``0.0`` 和 ``1.0`` 之间的\\ *任何*\\ 强度。缺点是没有死区系统，"
"由于控制器的物理结构，模拟轴的强度永远不会等于 ``0.0``\\ 。相反，它将徘徊在一"
"个低值，如 ``0.062``\\ 。这种现象被称为\\ *漂移*\\ ，在旧的或有问题的控制器上"
"会更加明显。"

msgid ""
"Let's take a racing game as a real-world example. Thanks to analog inputs, "
"we can steer the car slowly in one direction or another. However, without a "
"deadzone system, the car would slowly steer by itself even if the player "
"isn't touching the joystick. This is because the directional axis strength "
"won't be equal to ``0.0`` when we expect it to. Since we don't want our car "
"to steer by itself in this case, we define a \"dead zone\" value of ``0.2`` "
"which will ignore all input whose strength is lower than ``0.2``. An ideal "
"dead zone value is high enough to ignore the input caused by joystick "
"drifting, but is low enough to not ignore actual input from the player."
msgstr ""
"让我们把赛车游戏作为一个现实世界的例子。由于有了模拟输入，我们可以将汽车慢慢"
"地转向一个或另一个方向。然而，如果没有死区系统，即使玩家不接触操纵杆，汽车也"
"会自己慢慢转向。这是因为方向轴的强度在我们期望的时候不会等于 ``0.0``\\ 。因为"
"我们不希望我们的车在这种情况下自动转向，我们定义了一个“死区”值 ``0.2``\\ ，它"
"将忽略所有强度低于 ``0.2`` 的输入。一个理想的死区值是足够高的，可以忽略操纵杆"
"漂移引起的输入，但又足够低，不会忽略玩家的实际输入。"

msgid ""
"Godot features a built-in dead zone system to tackle this problem. The "
"default value is ``0.2``, but you can increase it or decrease it on a per-"
"action basis in the Project Settings' Input Map tab. For ``Input."
"get_vector()``, the deadzone can be specified, or otherwise it will "
"calculate the average deadzone value from all of the actions in the vector."
msgstr ""
"Godot有一个内置的死区系统来解决这个问题。默认值是 ``0.2`` ，但你可以在项目设"
"置的输入映射选项卡中根据每个动作增加或减少它。对于 ``Input.get_vector()`` ，"
"可以指定死区，否则它将从向量中的所有动作计算出平均死区值。"

msgid "\"Echo\" events"
msgstr "“回声”事件"

msgid ""
"Unlike keyboard input, holding down a controller button such as a D-pad "
"direction will **not** generate repeated input events at fixed intervals "
"(also known as \"echo\" events). This is because the operating system never "
"sends \"echo\" events for controller input in the first place."
msgstr ""
"与键盘输入不同，按住一个控制器按钮，如十字方向键，\\ **不会**\\ 产生固定间隔"
"的重复输入事件（也被称为“回声”事件）。这是因为操作系统首先不会为控制器输入发"
"送“回声”事件。"

msgid ""
"If you want controller buttons to send echo events, you will have to "
"generate :ref:`class_InputEvent` objects by code and parse them using :ref:"
"`Input.parse_input_event() <class_Input_method_parse_input_event>` at "
"regular intervals. This can be accomplished with the help of a :ref:"
"`class_Timer` node."
msgstr ""
"如果你想让控制器按钮发送回声事件，你将不得不通过代码生成 :ref:"
"`class_InputEvent` 对象，并使用 :ref:`Input.parse_input_event() "
"<class_Input_method_parse_input_event>` 定期解析它们。这可以在 :ref:"
"`class_Timer` 节点的帮助下完成。"

msgid "Troubleshooting"
msgstr "故障排除"

msgid ""
"You can view a list of `known issues with controller support <https://github."
"com/godotengine/godot/issues?q=is%3Aopen+is%3Aissue+label%3Atopic%3Ainput"
"+gamepad>`__ on GitHub."
msgstr ""
"你可以在 GitHub 上查看\\ `控制器支持的已知问题列表 <https://github.com/"
"godotengine/godot/issues?q=is%3Aopen+is%3Aissue+label%3Atopic%3Ainput"
"+gamepad>`__\\ 。"

msgid "My controller isn't recognized by Godot."
msgstr "Godot 无法识别我的控制器。"

msgid ""
"First, check that your controller is recognized by other applications. You "
"can use the `Gamepad Tester <https://gamepad-tester.com/>`__ website to "
"confirm that your controller is recognized."
msgstr ""
"首先，检查你的控制器是否被其他应用程序识别。你可以使用 `Gamepad Tester "
"<https://gamepad-tester.com/>`__ 网站来确认你的控制器被识别。"

msgid "My controller has incorrectly mapped buttons or axes."
msgstr "我的控制器的按钮或轴映射不正确。"

msgid ""
"If buttons are incorrectly mapped, this may be due to an erroneous mapping "
"from the `SDL game controller database <https://github.com/gabomdq/"
"SDL_GameControllerDB>`__. You can contribute an updated mapping to be "
"included in the next Godot version by opening a pull request on the linked "
"repository."
msgstr ""
"如果按钮被错误地映射，这可能是由于来自 `SDL 游戏控制器数据库 <https://github."
"com/gabomdq/SDL_GameControllerDB>`__\\ 的错误的映射。你可以在链接的存储库中打"
"开一个拉取请求，为下一个 Godot 版本提供一个更新的映射。"

msgid ""
"There are many ways to create mappings. One option is to use the mapping "
"wizard in the `official Joypads demo <https://godotengine.org/asset-library/"
"asset/140>`__. Once you have a working mapping for your controller, you can "
"test it by defining the ``SDL_GAMECONTROLLERCONFIG`` environment variable "
"before running Godot:"
msgstr ""
"有很多方法来创建映射。一个选择是使用 `官方Joypads演示 <https://godotengine."
"org/asset-library/asset/140>`__ 中的映射向导。一旦你有了控制器可工作的映射，"
"你可以在运行Godot之前通过定义 ``SDL_GAMECONTROLLERCONFIG`` 环境变量来测试它:"

msgid ""
"To test mappings on non-desktop platforms or to distribute your project with "
"additional controller mappings, you can add them by calling :ref:`Input."
"add_joy_mapping() <class_Input_method_add_joy_mapping>` as early as possible "
"in a script's ``_ready()`` function."
msgstr ""
"要在非桌面平台上测试映射，或者用额外的控制器映射来分发你的项目，你可以通过调"
"用 :ref:`Input.add_joy_mapping() <class_Input_method_add_joy_mapping>` 尽早在"
"脚本的 `_ready()` 函数中添加它们。"

msgid "My controller works on a given platform, but not on another platform."
msgstr "我的控制器在特定的平台上工作，但在另一个平台上却不能。"

msgid "macOS"
msgstr "macOS"

msgid ""
"Controllers are currently only supported on x86-based Macs. This means "
"controllers won't work on Macs featuring ARM processors such as the Apple M1."
msgstr ""
"控制器目前只支持基于x86的Mac电脑。这意味着控制器不能在采用ARM处理器的Mac上工"
"作，如苹果M1。"

msgid "Linux"
msgstr "Linux"

msgid ""
"Prior to Godot 3.3, official Godot binaries were compiled with udev support "
"but self-compiled binaries were compiled *without* udev support unless "
"``udev=yes`` was passed on the SCons command line. This made controller "
"hotplugging support unavailable in self-compiled binaries."
msgstr ""
"在 Godot 3.3 之前，官方的 Godot 可执行文件在编译时支持 udev，但自编译的可执行"
"文件在编译时\\ *不支持* udev，除非在 SCons 命令行中传递 ``udev=yes``\\ 。这使"
"得控制器的热插拔支持在自编译的可执行文件中不可用。"

msgid "HTML5"
msgstr "HTML5"

msgid ""
"HTML5 controller support is often less reliable compared to \"native\" "
"platforms. The quality of controller support tends to vary wildly across "
"browsers. As a result, you may have to instruct your players to use a "
"different browser if they can't get their controller to work."
msgstr ""
"与 \"本地\" 平台相比，HTML5 控制器的支持通常不太可靠。各个浏览器对控制器的支"
"持质量往往相差甚远。因此，如果玩家无法使用他们的控制器，你可能不得不指示他们"
"使用不同的浏览器。"

msgid ""
"Also, note that `controller support was significantly improved <https://"
"github.com/godotengine/godot/pull/45078>`__ in Godot 3.3 and later."
msgstr ""
"另外，请注意，在Godot 3.3及以后的版本中，对 `控制器的支持得到了很大的改善 "
"<https://github.com/godotengine/godot/pull/45078>`__ 。"
