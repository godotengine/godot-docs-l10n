# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Controllers, gamepads, and joysticks"
msgstr "控制器、手柄和摇杆"

msgid ""
"Godot supports hundreds of controller models thanks to the community-sourced "
"`SDL game controller database <https://github.com/gabomdq/"
"SDL_GameControllerDB>`__."
msgstr ""
"Godot支持数百种控制器模型，这要归功于社区提供的 `SDL游戏控制器数据库 "
"<https://github.com/gabomdq/SDL_GameControllerDB>`__ 。"

msgid ""
"Controllers are supported on Windows, macOS, Linux, Android, iOS, and HTML5."
msgstr "控制器支持Windows、macOS、Linux、Android、iOS和HTML5。"

msgid ""
"Note that more specialized devices such as steering wheels, rudder pedals "
"and `HOTAS <https://en.wikipedia.org/wiki/HOTAS>`__ are less tested and may "
"not always work as expected. Overriding force feedback for those devices is "
"also not implemented yet. If you have access to one of those devices, don't "
"hesitate to `report bugs on GitHub <https://github.com/godotengine/godot/"
"blob/master/CONTRIBUTING.md#reporting-bugs>`__."
msgstr ""
"请注意，诸如方向盘、方向盘踏板和 `HOTAS <https://en.wikipedia.org/wiki/"
"HOTAS>`__ 等更专业的设备测试较少，可能并不总是按照预期工作。目前尚未实现在这"
"些设备上的力反馈覆盖。如果你有机会使用这些设备，请不要犹豫，\\ `在 GitHub "
"<https://github.com/godotengine/godot/blob/master/CONTRIBUTING.md#reporting-"
"bugs>`__ 上报告错误。"

msgid "In this guide, you will learn:"
msgstr "在本指南中，您将学会："

msgid ""
"**How to write your input logic to support both keyboard and controller "
"inputs.**"
msgstr "**如何编写你的输入逻辑，从而支持键盘和控制器输入。**"

msgid "**How controllers can behave differently from keyboard/mouse input.**"
msgstr "**控制器的行为如何与键盘/鼠标输入不同。**"

msgid "**Troubleshooting issues with controllers in Godot.**"
msgstr "**解决 Godot 中控制器的问题。**"

msgid "Supporting universal input"
msgstr "支持通用导出"

msgid ""
"Thanks to Godot's input action system, Godot makes it possible to support "
"both keyboard and controller input without having to write separate code "
"paths. Instead of hardcoding keys or controller buttons in your scripts, you "
"should create *input actions* in the Project Settings which will then refer "
"to specified key and controller inputs."
msgstr ""
"得益于 Godot 的输入动作系统，Godot 可以同时支持键盘和控制器输入，而不需要编写"
"单独的代码路径。你不应该在脚本中对控制器的按键进行硬编码，应该在项目设置中创"
"建\\ *输入动作*\\ ，这些动作引用按键和控制器输入。"

msgid ""
"Input actions are explained in detail on the :ref:`doc_inputevent` page."
msgstr "输入动作在 :ref:`doc_inputevent` 页面上有详细解释。"

msgid ""
"Unlike keyboard input, supporting both mouse and controller input for an "
"action (such as looking around in a first-person game) will require "
"different code paths since these have to be handled separately."
msgstr ""
"与键盘输入不同，支持鼠标和控制器输入的动作将需要不同的代码路径，例如在第一人"
"称游戏中四处查看，因为这些必须被分开处理。"

msgid "Which Input singleton method should I use?"
msgstr "我应该使用哪个输入单例方法？"

msgid "There are 3 ways to get input in an analog-aware way:"
msgstr "有3种方式可以以模拟感知的方式获得输入:"

msgid ""
"When you have two axes (such as joystick or WASD movement) and want both "
"axes to behave as a single input, use ``Input.get_vector()``:"
msgstr ""
"当你有两个轴，如操纵杆或WASD运动，并希望两个轴都表现为单一输入时，使用 "
"``Input.get_vector()`` :"

msgid ""
"When you have one axis that can go both ways (such as a throttle on a flight "
"stick), or when you want to handle separate axes individually, use ``Input."
"get_axis()``:"
msgstr ""
"当你有一个轴可以双向移动时，比如飞行操纵杆上的油门，或者你想单独处理不同的轴"
"时，使用 ``Input.get_axis()`` :"

msgid ""
"For other types of analog input, such as handling a trigger or handling one "
"direction at a time, use ``Input.get_action_strength()``:"
msgstr ""
"对于其他类型的模拟输入，例如处理一个触发器或一次处理一个方向，使用 ``Input."
"get_action_strength()`` :"

msgid ""
"For non-analog digital/boolean input (only \"pressed\" or \"not pressed\" "
"values), such as controller buttons, mouse buttons or keyboard keys, use "
"``Input.is_action_pressed()``:"
msgstr ""
"对于非模拟数字/布尔输入（只有 \"按下 \" 或 \"未按下 \" 的值），如控制器按钮、"
"鼠标按钮或键盘按键，使用 ``Input.is_action_pressed()`` :"

msgid ""
"In Godot versions before 3.4, such as 3.3, ``Input.get_vector()`` and "
"``Input.get_axis()`` aren't available. Only ``Input.get_action_strength()`` "
"and ``Input.is_action_pressed()`` are available in Godot 3.3."
msgstr ""
"在3.4之前的Godot版本，如3.3， ``Input.get_vector()`` 和 ``Input.get_axis()`` "
"不可用。只有 ``Input.get_action_strength()`` 和 ``Input."
"is_action_pressed()`` 在Godot 3.3中可用。"

msgid "Differences between keyboard/mouse and controller input"
msgstr "键盘/鼠标和控制器输入之间的差异"

msgid ""
"If you're used to handling keyboard and mouse input, you may be surprised by "
"how controllers handle specific situations."
msgstr ""
"如果您习惯于处理键盘和鼠标输入，可能会对控制器处理特定情况的方式感到惊讶。"

msgid "Dead zone"
msgstr "死区"

msgid ""
"Unlike keyboards and mice, controllers offer axes with *analog* inputs. The "
"upside of analog inputs is that they offer additional flexibility for "
"actions. Unlike digital inputs which can only provide strengths of ``0.0`` "
"and ``1.0``, an analog input can provide *any* strength between ``0.0`` and "
"``1.0``. The downside is that without a deadzone system, an analog axis' "
"strength will never be equal to ``0.0`` due to how the controller is "
"physically built. Instead, it will linger at a low value such as ``0.062``. "
"This phenomenon is known as *drifting* and can be more noticeable on old or "
"faulty controllers."
msgstr ""
"与键盘和鼠标不同，控制器提供带有\\ *模拟*\\ 输入的轴。模拟输入的好处是它们为"
"动作提供了额外的灵活性。不像数字输入只能提供 ``0.0`` 和 ``1.0`` 的强度，模拟"
"输入可以提供 ``0.0`` 和 ``1.0`` 之间的\\ *任何*\\ 强度。缺点是没有死区系统，"
"由于控制器的物理结构，模拟轴的强度永远不会等于 ``0.0``\\ 。相反，它将徘徊在一"
"个低值，如 ``0.062``\\ 。这种现象被称为\\ *漂移*\\ ，在旧的或有问题的控制器上"
"会更加明显。"

msgid ""
"Let's take a racing game as a real-world example. Thanks to analog inputs, "
"we can steer the car slowly in one direction or another. However, without a "
"deadzone system, the car would slowly steer by itself even if the player "
"isn't touching the joystick. This is because the directional axis strength "
"won't be equal to ``0.0`` when we expect it to. Since we don't want our car "
"to steer by itself in this case, we define a \"dead zone\" value of ``0.2`` "
"which will ignore all input whose strength is lower than ``0.2``. An ideal "
"dead zone value is high enough to ignore the input caused by joystick "
"drifting, but is low enough to not ignore actual input from the player."
msgstr ""
"让我们把赛车游戏作为一个现实世界的例子。由于有了模拟输入，我们可以将汽车慢慢"
"地转向一个或另一个方向。然而，如果没有死区系统，即使玩家不接触操纵杆，汽车也"
"会自己慢慢转向。这是因为方向轴的强度在我们期望的时候不会等于 ``0.0``\\ 。因为"
"我们不希望我们的车在这种情况下自动转向，我们定义了一个“死区”值 ``0.2``\\ ，它"
"将忽略所有强度低于 ``0.2`` 的输入。一个理想的死区值是足够高的，可以忽略操纵杆"
"漂移引起的输入，但又足够低，不会忽略玩家的实际输入。"

msgid ""
"Godot features a built-in dead zone system to tackle this problem. The "
"default value is ``0.2``, but you can increase it or decrease it on a per-"
"action basis in the Project Settings' Input Map tab. For ``Input."
"get_vector()``, the deadzone can be specified, or otherwise it will "
"calculate the average deadzone value from all of the actions in the vector."
msgstr ""
"Godot 有一个内置的死区系统来解决这个问题。默认值是 ``0.2``\\ ，但你可以在“项"
"目设置”的“按键映射”选项卡中根据每个动作增加或减少它。对于 ``Input."
"get_vector()``\\ ，可以指定死区，否则它将从向量中的所有动作计算出平均死区值。"

msgid "\"Echo\" events"
msgstr "“回声”事件"

msgid ""
"Unlike keyboard input, holding down a controller button such as a D-pad "
"direction will **not** generate repeated input events at fixed intervals "
"(also known as \"echo\" events). This is because the operating system never "
"sends \"echo\" events for controller input in the first place."
msgstr ""
"与键盘输入不同，按住一个控制器按钮，如十字方向键，\\ **不会**\\ 产生固定间隔"
"的重复输入事件（也被称为“回声”事件）。这是因为操作系统首先不会为控制器输入发"
"送“回声”事件。"

msgid ""
"If you want controller buttons to send echo events, you will have to "
"generate :ref:`class_InputEvent` objects by code and parse them using :ref:"
"`Input.parse_input_event() <class_Input_method_parse_input_event>` at "
"regular intervals. This can be accomplished with the help of a :ref:"
"`class_Timer` node."
msgstr ""
"如果你想让控制器按钮发送回声事件，你将不得不通过代码生成 :ref:"
"`class_InputEvent` 对象，并使用 :ref:`Input.parse_input_event() "
"<class_Input_method_parse_input_event>` 定期解析它们。这可以在 :ref:"
"`class_Timer` 节点的帮助下完成。"

msgid "Troubleshooting"
msgstr "故障排除"

msgid ""
"You can view a list of `known issues with controller support <https://github."
"com/godotengine/godot/issues?"
"q=is%3Aopen+is%3Aissue+label%3Atopic%3Ainput+gamepad>`__ on GitHub."
msgstr ""
"你可以在 GitHub 上查看\\ `控制器支持的已知问题列表 <https://github.com/"
"godotengine/godot/issues?"
"q=is%3Aopen+is%3Aissue+label%3Atopic%3Ainput+gamepad>`__\\ 。"

msgid "My controller isn't recognized by Godot."
msgstr "Godot 无法识别我的控制器。"

msgid ""
"First, check that your controller is recognized by other applications. You "
"can use the `Gamepad Tester <https://gamepad-tester.com/>`__ website to "
"confirm that your controller is recognized."
msgstr ""
"首先，检查你的控制器是否被其他应用程序识别。你可以使用 `Gamepad Tester "
"<https://gamepad-tester.com/>`__ 网站来确认你的控制器被识别。"

msgid "My controller has incorrectly mapped buttons or axes."
msgstr "我的控制器的按钮或轴映射不正确。"

msgid ""
"If buttons are incorrectly mapped, this may be due to an erroneous mapping "
"from the `SDL game controller database <https://github.com/gabomdq/"
"SDL_GameControllerDB>`__. You can contribute an updated mapping to be "
"included in the next Godot version by opening a pull request on the linked "
"repository."
msgstr ""
"如果按钮存在映射错误，可能是由于来自 `SDL 游戏控制器数据库 <https://github."
"com/gabomdq/SDL_GameControllerDB>`__\\ 的错误的映射。你可以在链接的仓库中提交"
"拉取请求，为下一个 Godot 版本提供映射更新。"

msgid ""
"There are many ways to create mappings. One option is to use the mapping "
"wizard in the `official Joypads demo <https://godotengine.org/asset-library/"
"asset/140>`__. Once you have a working mapping for your controller, you can "
"test it by defining the ``SDL_GAMECONTROLLERCONFIG`` environment variable "
"before running Godot:"
msgstr ""
"有很多方法来创建映射。一个选择是使用 `官方Joypads演示 <https://godotengine."
"org/asset-library/asset/140>`__ 中的映射向导。一旦你有了控制器可工作的映射，"
"你可以在运行Godot之前通过定义 ``SDL_GAMECONTROLLERCONFIG`` 环境变量来测试它:"

msgid ""
"To test mappings on non-desktop platforms or to distribute your project with "
"additional controller mappings, you can add them by calling :ref:`Input."
"add_joy_mapping() <class_Input_method_add_joy_mapping>` as early as possible "
"in a script's ``_ready()`` function."
msgstr ""
"要在非桌面平台上测试映射，或者用额外的控制器映射来分发你的项目，你可以通过调"
"用 :ref:`Input.add_joy_mapping() <class_Input_method_add_joy_mapping>` 尽早在"
"脚本的 ``_ready()`` 函数中添加它们。"

msgid "My controller works on a given platform, but not on another platform."
msgstr "我的控制器在特定的平台上工作，但在另一个平台上却不能。"

msgid "Linux"
msgstr "Linux"

msgid ""
"Prior to Godot 3.3, official Godot binaries were compiled with udev support "
"but self-compiled binaries were compiled *without* udev support unless "
"``udev=yes`` was passed on the SCons command line. This made controller "
"hotplugging support unavailable in self-compiled binaries."
msgstr ""
"在 Godot 3.3 之前，官方的 Godot 可执行文件在编译时支持 udev，但自编译的可执行"
"文件在编译时\\ *不支持* udev，除非在 SCons 命令行中传递 ``udev=yes``\\ 。这使"
"得控制器的热插拔支持在自编译的可执行文件中不可用。"

msgid "HTML5"
msgstr "HTML5"

msgid ""
"HTML5 controller support is often less reliable compared to \"native\" "
"platforms. The quality of controller support tends to vary wildly across "
"browsers. As a result, you may have to instruct your players to use a "
"different browser if they can't get their controller to work."
msgstr ""
"与 \"本地\" 平台相比，HTML5 控制器的支持通常不太可靠。各个浏览器对控制器的支"
"持质量往往相差甚远。因此，如果玩家无法使用他们的控制器，你可能不得不指示他们"
"使用不同的浏览器。"

msgid ""
"Also, note that `controller support was significantly improved <https://"
"github.com/godotengine/godot/pull/45078>`__ in Godot 3.3 and later."
msgstr ""
"另外，请注意，在 Godot 3.3 及以后的版本中，对\\ `控制器的支持得到了很大的改"
"善 <https://github.com/godotengine/godot/pull/45078>`__\\ 。"

msgid "Translation status"
msgstr "翻译状态"
