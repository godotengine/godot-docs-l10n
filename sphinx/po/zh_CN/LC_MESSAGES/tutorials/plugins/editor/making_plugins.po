# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Making plugins"
msgstr "制作插件"

msgid "About plugins"
msgstr "关于插件"

msgid ""
"A plugin is a great way to extend the editor with useful tools. It can be "
"made entirely with GDScript and standard scenes, without even reloading the "
"editor. Unlike modules, you don't need to create C++ code nor recompile the "
"engine. While this makes plugins less powerful, there are still many things "
"you can do with them. Note that a plugin is similar to any scene you can "
"already make, except it is created using a script to add editor "
"functionality."
msgstr ""
"插件是用有用的工具来扩展编辑器的一个好方法. 它可以完全用GDScript和标准场景制"
"作, 甚至不需要重新加载编辑器. 与模块不同, 你不需要创建C++代码也不需要重新编译"
"引擎. 虽然这使得插件的功能不那么强大, 但你仍然可以用它们做很多事情. 请注意, "
"一个插件与你已经可以制作的任何场景相似, 只是它是用脚本创建的, 以增加编辑器功"
"能."

#, fuzzy
msgid ""
"This tutorial will guide you through the creation of two plugins so you can "
"understand how they work and be able to develop your own. The first is a "
"custom node that you can add to any scene in the project, and the other is a "
"custom dock added to the editor."
msgstr ""
"这个教程会教您写两个简单的插件来帮助您理解插件如何运作和如何写插件. 首先是一"
"个可以往任何场景添加的自定义节点, 其次呢, 是个可以往编辑器里添加的自定义面板."

msgid "Creating a plugin"
msgstr "创建插件"

msgid ""
"Before starting, create a new empty project wherever you want. This will "
"serve as a base to develop and test the plugins."
msgstr ""
"在开始前, 先找个地方创建个空项目. 这个空项目是制作和测试我们插件的基础."

msgid ""
"The first thing you need for the editor to identify a new plugin is to "
"create two files: a ``plugin.cfg`` for configuration and a tool script with "
"the functionality. Plugins have a standard path like ``addons/plugin_name`` "
"inside the project folder. Godot provides a dialog for generating those "
"files and placing them where they need to be."
msgstr ""
"编辑器要识别一个新的插件, 首先需要创建两个文件: 一个是 ``plugin.cfg`` 用于配"
"置和具有此功能的工具脚本. 插件在项目文件夹里面有一个标准路径, 比如 ``addons/"
"plugin_name``.Godot提供了一个属性框, 用于生成这些文件并将它们放在需要的位置."

#, fuzzy
msgid ""
"In the main toolbar, click the ``Project`` dropdown. Then click ``Project "
"Settings...``. Go to the ``Plugins`` tab and then click on the ``Create New "
"Plugin`` button in the top-right."
msgstr ""
"在主工具栏中，点击 ``项目`` 下拉菜单，然后点击 ``项目设置...``\\ 。然后转到 "
"``插件`` 选项卡，点击右上角的 ``创建`` 按钮。"

msgid "You will see the dialog appear, like so:"
msgstr "你会看到出现了一个对话框，类似这样："

msgid ""
"The placeholder text in each field describes how it affects the plugin's "
"creation of the files and the config file's values."
msgstr "每个字段中文本属性都描述了它会影响到哪些配置文件的值."

msgid "To continue with the example, use the following values:"
msgstr "如果要继续使用该例子，请使用下列的值："

msgid ""
"Unchecking the ``Activate now?`` option in C# is always required because, "
"like every other C# script, the EditorPlugin script needs to be compiled "
"which requires building the project. After building the project the plugin "
"can be enabled in the ``Plugins`` tab of ``Project Settings``."
msgstr ""
"始终需要在 C# 中去掉对 ``立即激活？`` 选项的勾选，因为和其他 C# 脚本一样，"
"EditorPlugin 脚本是需要编译的，要求构建整个项目。构建项目后，就可以在 ``项目"
"设置`` 的 ``插件`` 选项卡中启用该插件。"

msgid "You should end up with a directory structure like this:"
msgstr "你最终的目录结构应该是这样显示的："

#, fuzzy
msgid ""
"``plugin.cfg`` is an INI file with metadata about your plugin. The name and "
"description help people understand what it does. Your name helps you get "
"properly credited for your work. The version number helps others know if "
"they have an outdated version; if you are unsure on how to come up with the "
"version number, check out `Semantic Versioning <https://semver.org/>`_. The "
"main script file will instruct Godot what your plugin does in the editor "
"once it is active."
msgstr ""
"``plugin.cfg`` 是一个简单的INI文件, 包含关于你的插件的元数据. 名称和描述有助"
"于人们了解它的作用. 你的名字有助于你的工作得到正确的认可. 版本号可以帮助别人"
"知道他们是否有一个过时的版本；如果你不确定如何得出版本号, 请查看 `Semantic "
"Versioning <https://semver.org/>`_ . 主脚本文件将指示Godot, 一旦你的插件被激"
"活后, 它将在编辑器中做什么."

msgid "The script file"
msgstr "脚本文件"

#, fuzzy
msgid ""
"Upon creation of the plugin, the dialog will automatically open the "
"EditorPlugin script for you. The script has two requirements that you cannot "
"change: it must be a ``@tool`` script, or else it will not load properly in "
"the editor, and it must inherit from :ref:`class_EditorPlugin`."
msgstr ""
"创建插件后, 对话框会自动为你打开EditorPlugin脚本. 该脚本有两个要求, 你不能改"
"变: 它必须是一个 ``tool`` 脚本, 否则将无法在编辑器中正常加载；它必须继承 :"
"ref:`class_EditorPlugin`."

#, fuzzy
msgid ""
"In addition to the EditorPlugin script, any other GDScript that your plugin "
"uses must *also* be a tool. Any GDScript without ``@tool`` imported into the "
"editor will act like an empty file!"
msgstr ""
"除了 EditorPlugin 脚本之外，插件用到的其他 GDScript *也*\\ 必须是工具脚"
"本。\\ *没有 ``tool`` 的 GDScript 在导入编辑器后都会像空文件一样！*\\ 构建项"
"目时不会重新加载没有 ``[Tool]`` 的 C# 类，你就只能重新启用插件了！"

#, fuzzy
msgid ""
"It's important to deal with initialization and clean-up of resources. A good "
"practice is to use the virtual function :ref:`_enter_tree() "
"<class_Node_private_method__enter_tree>` to initialize your plugin and :ref:"
"`_exit_tree() <class_Node_private_method__exit_tree>` to clean it up. "
"Thankfully, the dialog generates these callbacks for you. Your script should "
"look something like this:"
msgstr ""
"处理好资源的初始化和清理是很重要的。一个好的做法是使用虚函数 :ref:"
"`_enter_tree() <class_Node_method__enter_tree>` 来初始化你的插件，以及 :ref:"
"`_exit_tree() <class_Node_method__exit_tree>` 来清理它。值得庆幸的是，对话框"
"为你生成了这些回调。你的脚本应该看起来像这样："

msgid "This is a good template to use when creating new plugins."
msgstr "这是创建新插件时使用的好模板."

msgid "A custom node"
msgstr "自定义节点"

msgid ""
"Sometimes you want a certain behavior in many nodes, such as a custom scene "
"or control that can be reused. Instancing is helpful in a lot of cases, but "
"sometimes it can be cumbersome, especially if you're using it in many "
"projects. A good solution to this is to make a plugin that adds a node with "
"a custom behavior."
msgstr ""
"有时你希望在许多节点中存在某种行为, 例如可以重复使用的自定义场景或控件. 实例"
"化在很多情况下都很有用, 但有时它会很麻烦, 特别是如果你在许多项目中使用它. 一"
"个很好的解决方案是创建一个插件, 添加一个具有自定义行为的节点."

msgid ""
"Nodes added via an EditorPlugin are \"CustomType\" nodes. While they work "
"with any scripting language, they have fewer features than :ref:`the Script "
"Class system <doc_gdscript_basics_class_name>`. If you are writing GDScript "
"or NativeScript, we recommend using Script Classes instead."
msgstr ""
"通过 EditorPlugin 添加的节点是“CustomType”（自定义类型）节点。虽然它们可以用"
"于任何脚本语言，但功能比 :ref:`Script 类系统 "
"<doc_gdscript_basics_class_name>`\\ 少。如果你正在编写 GDScript 或 "
"NativeScript，建议使用 Script 类代替。"

#, fuzzy
msgid ""
"To create a new node type, you can use the function :ref:`add_custom_type() "
"<class_EditorPlugin_method_add_custom_type>` from the :ref:"
"`class_EditorPlugin` class. This function can add new types to the editor "
"(nodes or resources). However, before you can create the type, you need a "
"script that will act as the logic for the type. While that script doesn't "
"have to use the ``@tool`` annotation, it can be added so the script runs in "
"the editor."
msgstr ""
"要创建一个新的节点类型, 你可以使用来自 :ref:`class_EditorPlugin` 类的 :ref:"
"`add_custom_type() <class_EditorPlugin_method_add_custom_type>` 这个函数. 这"
"个函数可以向编辑器添加新的类型(节点或资源). 但是, 在你创建类型之前, 需要一个"
"脚本, 作为类型的逻辑. 虽然该脚本不一定要使用 ``tool`` 关键字, 但可以添加它, "
"以便脚本在编辑器中运行."

#, fuzzy
msgid ""
"For this tutorial, we'll create a button that prints a message when clicked. "
"For that, we'll need a script that extends from :ref:`class_Button`. It "
"could also extend :ref:`class_BaseButton` if you prefer:"
msgstr ""
"在本教程中, 我们将创建一个简单的按钮, 在点击时打印出一条信息. 对此, 我们需要"
"一个从 :ref:`class_Button` 扩展的简单脚本. 如果你愿意, 它也可以扩展 :ref:"
"`class_BaseButton` :"

#, fuzzy
msgid ""
"That's it for our basic button. You can save this as ``my_button.gd`` inside "
"the plugin folder. You'll also need a 16×16 icon to show in the scene tree. "
"If you don't have one, you can grab the default one from the engine and save "
"it in your `addons/my_custom_node` folder as `icon.png`, or use the default "
"Godot logo (`preload(\"res://icon.svg\")`)."
msgstr ""
"这就是我们的基本按钮了. 你可以把它保存为插件文件夹中的 ``my_button.gd`` . 你"
"还需要一个16×16的图标来显示在场景树中. 如果你没有, 可以从引擎中抓取默认的, 并"
"保存在你的 ``addons/my_custom_node`` 文件夹中, 作为 ``icon.png`` , 或者使用默"
"认的Godot标志( `preload(\"res://icon.png\")` ). 如果需要, 你也可以使用SVG图"
"标."

msgid ""
"SVG images that are used as custom node icons should have the **Editor > "
"Scale With Editor Scale** and **Editor > Convert Icons With Editor Theme** :"
"ref:`import options <doc_importing_images_editor_import_options>` enabled. "
"This allows icons to follow the editor's scale and theming settings if the "
"icons are designed with the same color palette as Godot's own icons."
msgstr ""

msgid ""
"Now, we need to add it as a custom type so it shows on the **Create New "
"Node** dialog. For that, change the ``custom_node.gd`` script to the "
"following:"
msgstr ""
"现在，我们需要把它作为一个自定义类型添加，以便它显示在\\ **新建 Node** 的对话"
"框中。为此，将 ``custom_node.gd`` 脚本改为以下内容："

msgid ""
"With that done, the plugin should already be available in the plugin list in "
"the **Project Settings**, so activate it as explained in `Checking the "
"results`_."
msgstr ""
"完成后, 插件应该已经在 **项目设置** 的插件列表中可用, 因此请按照 `Checking "
"the results`_ 中的说明激活它."

msgid "Then try it out by adding your new node:"
msgstr "然后通过添加新节点来尝试:"

msgid ""
"When you add the node, you can see that it already has the script you "
"created attached to it. Set a text to the button, save and run the scene. "
"When you click the button, you can see some text in the console:"
msgstr ""
"当你添加节点时, 你可以看到它已经有你创建的脚本附加在上面. 给这个按钮设置一个"
"文本, 保存并运行场景. 当你点击按钮时, 你可以在控制台中看到一些文字:"

msgid "A custom dock"
msgstr "自定义窗口"

msgid ""
"Sometimes, you need to extend the editor and add tools that are always "
"available. An easy way to do it is to add a new dock with a plugin. Docks "
"are just scenes based on Control, so they are created in a way similar to "
"usual GUI scenes."
msgstr ""
"有时, 你需要扩展编辑器并添加始终可用的工具. 一种简单的方法是添加一个带插件的"
"新扩展面板. Docks只是基于Control的场景, 因此它们的创建方式与通常的GUI场景类"
"似."

msgid ""
"Creating a custom dock is done just like a custom node. Create a new "
"``plugin.cfg`` file in the ``addons/my_custom_dock`` folder, then add the "
"following content to it:"
msgstr ""
"创建一个自定义栏好的方法和自定义节点一样. 在 ``addons/my_custom_dock`` 文件夹"
"中创建一个新的 ``plugin.cfg`` 文件, 然后在其中添加以下内容:"

msgid ""
"Then create the script ``custom_dock.gd`` in the same folder. Fill it with "
"the :ref:`template we've seen before <doc_making_plugins_template_code>` to "
"get a good start."
msgstr ""
"然后在同一文件夹中创建脚本 ``custom_dock.gd``\\ 。填写\\ :ref:`之前见过的模"
"板 <doc_making_plugins_template_code>`\\ 以获得良好的开端。"

msgid ""
"Since we're trying to add a new custom dock, we need to create the contents "
"of the dock. This is nothing more than a standard Godot scene: just create a "
"new scene in the editor then edit it."
msgstr ""
"由于我们正在尝试添加新的自定义窗口, 因此我们需要创建窗口的内容. 这只不过是一"
"个标准的Godot场景: 只需在编辑器中创建一个新场景然后编辑它."

msgid ""
"For an editor dock, the root node **must** be a :ref:`Control "
"<class_Control>` or one of its child classes. For this tutorial, you can "
"create a single button. The name of the root node will also be the name that "
"appears on the dock tab, so be sure to give it a short and descriptive name. "
"Also, don't forget to add some text to your button."
msgstr ""
"对于编辑器停靠站, 根节点 **必须是** :ref:`Control <class_Control>` 或其子类之"
"一. 在本教程中, 你可以创建一个按钮. 根节点的名称也将是面板对话框中显示的名"
"称, 因此请务必为其指定一个简短的描述性名称. 另外, 不要忘记在按钮上添加一些文"
"字."

msgid ""
"Save this scene as ``my_dock.tscn``. Now, we need to grab the scene we "
"created then add it as a dock in the editor. For this, you can rely on the "
"function :ref:`add_control_to_dock() "
"<class_EditorPlugin_method_add_control_to_dock>` from the :ref:`EditorPlugin "
"<class_EditorPlugin>` class."
msgstr ""
"把这个场景保存为 ``my_dock.tscn`` . 现在, 我们需要抓取我们创建的场景, 然后在"
"编辑器中把它添加为一个栏目. 为此, 你可以依赖 :ref:`add_control_to_dock() "
"<class_EditorPlugin_method_add_control_to_dock>` 这个函数, 它来自 :ref:"
"`EditorPlugin <class_EditorPlugin>` 类."

msgid ""
"You need to select a dock position and define the control to add (which is "
"the scene you just created). Don't forget to **remove the dock** when the "
"plugin is deactivated. The script could look like this:"
msgstr ""
"你需要选择一个停靠位置并定义要添加的控件, 也就是你刚刚创建的场景. 不要忘了在"
"插件停用时 **remove the dock** . 脚本可以是这样的:"

msgid ""
"Note that, while the dock will initially appear at its specified position, "
"the user can freely change its position and save the resulting layout."
msgstr ""
"请注意, 虽然Dock最初会出现在其指定的位置, 但用户可以自由改变其位置, 并保存所"
"产生的布局."

msgid "Checking the results"
msgstr "检查结果"

#, fuzzy
msgid ""
"It's now time to check the results of your work. Open the **Project "
"Settings** and click on the **Plugins** tab. Your plugin should be the only "
"one on the list."
msgstr ""
"现在是检查工作结果的时候了. 打开 **项目设置** , 然后单击 **插件** 选项卡. 您"
"的插件应该是列表中唯一的插件. 如果未显示, 请单击右上角的 **更新** 按钮."

#, fuzzy
msgid ""
"You can see the plugin is not enabled. Click the **Enable** checkbox to "
"activate the plugin. The dock should become visible before you even close "
"the settings window. You should now have a custom dock:"
msgstr ""
"您可以在 **Status** 列中看到该插件处于非激活状态; 点击状态选择 **Active** . "
"在您关闭设置窗口之前, 该扩展窗口应该可见. 您现在应该看到一个自定义窗口:"

msgid "Going beyond"
msgstr "举一反三"

msgid ""
"Now that you've learned how to make basic plugins, you can extend the editor "
"in several ways. Lots of functionality can be added to the editor with "
"GDScript; it is a powerful way to create specialized editors without having "
"to delve into C++ modules."
msgstr ""
"现在你已经学会了如何制作基本插件, 你可以通过多种方式扩展编辑器. 可以使用"
"GDScript将许多功能添加到编辑器中; 它是一种创建专业编辑器的强大方法, 无需深入"
"研究C++模块."

msgid ""
"You can make your own plugins to help yourself and share them in the `Asset "
"Library <https://godotengine.org/asset-library/>`_ so that people can "
"benefit from your work."
msgstr ""
"你可以制作自己的插件来帮助自己或在 `资产库 <https://godotengine.org/asset-"
"library/>`_ 中分享它们，以便人们可以从你的工作中受益。"

msgid "Registering autoloads/singletons in plugins"
msgstr "在插件中注册自动加载/单例"

msgid ""
"It is possible for editor plugins to automatically register :ref:`autoloads "
"<doc_singletons_autoload>` when the plugin is enabled. This also includes "
"unregistering the autoload when the plugin is disabled."
msgstr ""
"编辑器插件可以在启用时自动注册\\ :ref:`自动加载 "
"<doc_singletons_autoload>`\\ 。同样也包含了在插件禁用时反注册该自动加载。"

msgid ""
"This makes setting up plugins faster for users, as they no longer have to "
"manually add autoloads to their project settings if your editor plugin "
"requires the use of an autoload."
msgstr ""
"这样用户就可以更快速地设置插件了，因为你的编辑器插件要求使用自动加载时，他们"
"不必再手动去项目设置里添加自动加载了。"

msgid "Use the following code to register a singleton from an editor plugin:"
msgstr "在编辑器插件中使用以下代码注册单例："

msgid "Translation status"
msgstr "翻译状态"
