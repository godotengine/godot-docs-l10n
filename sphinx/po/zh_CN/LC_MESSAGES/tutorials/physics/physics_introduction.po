# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Physics introduction"
msgstr "物理介绍"

msgid ""
"In game development, you often need to know when two objects in the game "
"intersect or come into contact. This is known as **collision detection**. "
"When a collision is detected, you typically want something to happen. This "
"is known as **collision response**."
msgstr ""
"在游戏开发中, 你经常需要知道游戏中的两个对象在何时相交或接触. 这被称为 **碰撞"
"检测** . 检测到碰撞时, 你通常希望某些事情发生. 这被称为 **碰撞响应** ."

msgid ""
"Godot offers a number of collision objects in 2D and 3D to provide both "
"collision detection and response. Trying to decide which one to use for your "
"project can be confusing. You can avoid problems and simplify development if "
"you understand how each works and what their pros and cons are."
msgstr ""
"Godot在2D和3D中提供了许多碰撞对象, 以提供碰撞检测和响应. 你可能很难决定哪个适"
"合你的项目. 一旦了解了每种方法的工作原理以及它们的优缺点, 你就可以避免出现问"
"题并简化开发过程."

msgid "In this guide, you will learn:"
msgstr "在本指南中，您将学会："

msgid "Godot's four collision object types"
msgstr "Godot的四种碰撞对象类型"

msgid "How each collision object works"
msgstr "每个碰撞对象的工作原理"

msgid "When and why to choose one type over another"
msgstr "何时以及为何选择这种类型而不是另一种类型"

msgid ""
"This document's examples will use 2D objects. Every 2D physics object and "
"collision shape has a direct equivalent in 3D and in most cases they work in "
"much the same way."
msgstr ""
"本文档的示例将使用2D对象. 每个2D物理对象和碰撞形状在3D中具有直接等价物, 并且"
"在大多数情况下它们以相同的方式工作."

msgid "Collision objects"
msgstr "碰撞物体"

msgid ""
"Godot offers four kinds of physics bodies, extending :ref:`CollisionObject2D "
"<class_CollisionObject2D>`:"
msgstr ""
"Godot提供了四种扩展自 :ref:`CollisionObject2D <class_CollisionObject2D>` 的物"
"体:"

msgid ":ref:`Area2D <class_Area2D>`"
msgstr ":ref:`Area2D <class_Area2D>`"

msgid ""
"``Area2D`` nodes provide **detection** and **influence**. They can detect "
"when objects overlap and can emit signals when bodies enter or exit. An "
"``Area2D`` can also be used to override physics properties, such as gravity "
"or damping, in a defined area."
msgstr ""
"``Area2D`` 节点提供 **检测** 和 **影响** . 它们可以检测物体何时重叠, 并在物体"
"进入或离开时发出信号. ``Area2D`` 也可用于覆盖物理属性, 例如一定区域内的重力或"
"阻尼."

msgid ""
"The other three bodies extend :ref:`PhysicsBody2D <class_PhysicsBody2D>`:"
msgstr "其他三个物体扩展自 :ref:`PhysicsBody2D <class_PhysicsBody2D>` :"

msgid ":ref:`StaticBody2D <class_StaticBody2D>`"
msgstr ":ref:`StaticBody2D <class_StaticBody2D>`"

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. They are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"静态主体是物理引擎不移动的主体. 它参与碰撞检测, 但不会响应碰撞而移动. 它们通"
"常用于属于环境的对象或不需要任何动态行为的对象."

msgid ":ref:`RigidBody2D <class_RigidBody2D>`"
msgstr ":ref:`RigidBody2D <class_RigidBody2D>`"

msgid ""
"This is the node that implements simulated 2D physics. You do not control a "
"``RigidBody2D`` directly, but instead you apply forces to it (gravity, "
"impulses, etc.) and the physics engine calculates the resulting movement. :"
"ref:`Read more about using rigid bodies. <doc_rigid_body>`"
msgstr ""
"这是实现模拟2D物理的节点. 您不直接控制 ``RigidBody2D`` , 而是您对它施加力(重"
"力, 冲动等), 物理引擎计算得到的运动. :ref:`阅读更多关于使用刚体的信息. "
"<doc_rigid_body>`"

msgid ":ref:`KinematicBody2D <class_KinematicBody2D>`"
msgstr ":ref:`KinematicBody2D <class_KinematicBody2D>`"

msgid ""
"A body that provides collision detection, but no physics. All movement and "
"collision response must be implemented in code."
msgstr ""
"提供碰撞检测的物体, 但没有物理特性. 所有移动和碰撞响应必须在代码中实现."

msgid "Physics material"
msgstr "物理材质"

msgid ""
"Static bodies and rigid bodies can be configured to use a :ref:`physics "
"material <class_PhysicsMaterial>`. This allows adjusting the friction and "
"bounce of an object, and set if it's absorbent and/or rough."
msgstr ""
"静态体和刚性体可以被配置为使用\\ :ref:`物理材质 <class_PhysicsMaterial>`\\ 。"
"这允许调整一个物体的摩擦力和反弹力，并设置它是否具有吸收性、粗糙性。"

msgid "Collision shapes"
msgstr "碰撞形状"

msgid ""
"A physics body can hold any number of :ref:`Shape2D <class_Shape2D>` objects "
"as children. These shapes are used to define the object's collision bounds "
"and to detect contact with other objects."
msgstr ""
"物理体可以包含任意数量的 :ref:`Shape2D <class_Shape2D>` 对象作为子对象. 这些"
"形状用于定义对象的碰撞边界并检测与其他对象的接触."

msgid ""
"In order to detect collisions, at least one ``Shape2D`` must be assigned to "
"the object."
msgstr "为了检测碰撞, 必须至少为对象分配一个 ``Shape2D`` ."

msgid ""
"The most common way to assign a shape is by adding a :ref:`CollisionShape2D "
"<class_CollisionShape2D>` or :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>` as a child of the object. These nodes allow you "
"to draw the shape directly in the editor workspace."
msgstr ""
"分配形状的最常用方法是添加 :ref:`CollisionShape2D <class_CollisionShape2D>` "
"或 :ref:`CollisionPolygon2D <class_CollisionPolygon2D>` 作为对象的子项. 这些"
"节点允许您直接在编辑器工作区中绘制形状."

msgid ""
"Be careful to never scale your collision shapes in the editor. The \"Scale\" "
"property in the Inspector should remain ``(1, 1)``. When changing the size "
"of the collision shape, you should always use the size handles, **not** the "
"``Node2D`` scale handles. Scaling a shape can result in unexpected collision "
"behavior."
msgstr ""
"注意，不要在编辑器中缩放碰撞形状。“检查器”中的“Scale”属性应保持为 ``(1, "
"1)``\\ 。改变碰撞形状的大小时，你应该使用尺寸控制柄，而\\ **不是** "
"``Node2D`` 缩放控制柄。缩放形状可能会导致意外的碰撞行为。"

msgid "Physics process callback"
msgstr "物理过程回调"

msgid ""
"The physics engine may spawn multiple threads to improve performance, so it "
"can use up to a full frame to process physics. Because of this, the value of "
"a body's state variables such as ``position`` or ``linear velocity`` may not "
"be accurate for the current frame."
msgstr ""
"物理引擎可能会产生多个线程以提高性能, 所以它能使用最多一个帧来处理物理. 因"
"此, 物体状态的变量的值, 如 ``position`` 或 ``linear velocity`` , 可能在当前帧"
"不完全准确."

msgid ""
"In order to avoid this inaccuracy, any code that needs to access a body's "
"properties should be run in the :ref:`Node._physics_process() "
"<class_Node_method__physics_process>` callback, which is called before each "
"physics step at a constant frame rate (60 times per second by default). This "
"method will be passed a ``delta`` parameter, which is a floating-point "
"number equal to the time passed in *seconds* since the last step. When using "
"the default 60 Hz physics update rate, it will typically be equal to "
"``0.01666...`` (but not always, see below)."
msgstr ""
"为了避免这种不准确性, 任何需要访问物体属性的代码都应该在 :ref:`Node."
"_physics_process() <class_Node_method__physics_process>` 回调中运行, 它在每个"
"物理步骤之前以恒定的帧速率(默认为每秒60次)被调用. 一个 ``delta`` 参数会传递给"
"这个方法, 这个参数是一个浮点数, 等于自上一步以来经过的时间( *秒* ). 当使用默"
"认的60Hz物理更新率时, 它通常等于 ``0.01666...`` (但并非总是如此, 见下文)."

msgid ""
"It's recommended to always use the ``delta`` parameter when relevant in your "
"physics calculations, so that the game behaves correctly if you change the "
"physics update rate or if the player's device can't keep up."
msgstr ""
"建议在物理计算中使用 ``delta`` 参数, 以便当您更改物理更新速率或玩家设备跟不上"
"时, 游戏能够正确运行."

msgid "Collision layers and masks"
msgstr "碰撞层与遮罩"

msgid ""
"One of the most powerful, but frequently misunderstood, collision features "
"is the collision layer system. This system allows you to build up complex "
"interactions between a variety of objects. The key concepts are **layers** "
"and **masks**. Each ``CollisionObject2D`` has 20 different physics layers it "
"can interact with."
msgstr ""
"碰撞层系统是最强大但经常被误解的碰撞功能之一。该系统允许您在各种对象之间建立"
"复杂的交互。关键概念是\\ **层**\\ （Layer）和\\ **遮罩**\\ （Mask）。每个 "
"``CollisionObject2D`` 都有 20 个不同的物理层可以相互作用。"

msgid "Let's look at each of the properties in turn:"
msgstr "让我们依次看看每个属性："

msgid "collision_layer"
msgstr "collision_layer"

msgid ""
"This describes the layers that the object appears **in**. By default, all "
"bodies are on layer ``1``."
msgstr ""
"表示该对象\\ **位于**\\ 哪些层。默认情况下，所有实体都在图层 ``1`` 上。"

msgid "collision_mask"
msgstr "collision_mask"

msgid ""
"This describes what layers the body will **scan** for collisions. If an "
"object isn't in one of the mask layers, the body will ignore it. By default, "
"all bodies scan layer ``1``."
msgstr ""
"表示该对象会对哪些层上的实体进行\\ **扫描**\\ 。如果对象不在任何遮罩层中，则"
"该实体将其忽略。默认情况下，所有实体都会扫描图层 ``1``\\ 。"

msgid ""
"These properties can be configured via code, or by editing them in the "
"Inspector."
msgstr "可以通过代码配置这些属性，也可以在“检查器”中对其进行编辑。"

msgid ""
"Keeping track of what you're using each layer for can be difficult, so you "
"may find it useful to assign names to the layers you're using. Names can be "
"assigned in Project Settings -> Layer Names."
msgstr ""
"跟踪您正在使用每个图层的内容可能很困难，因此您可能会发现为您正在使用的图层指"
"定名称很有用。可以在“项目设置 -> Layer Names”中指定名称。"

msgid "GUI example"
msgstr "图形用户界面示例"

msgid ""
"You have four node types in your game: Walls, Player, Enemy, and Coin. Both "
"Player and Enemy should collide with Walls. The Player node should detect "
"collisions with both Enemy and Coin, but Enemy and Coin should ignore each "
"other."
msgstr ""
"游戏中有四种节点类型：墙（Wall）、玩家（Player）、敌人（Enemy）、金币"
"（Coin）。玩家和敌人都应该与墙碰撞。玩家节点应该检测与敌人和硬币的碰撞，但敌"
"人和硬币应该互相忽略。"

msgid ""
"Start by naming layers 1-4 \"walls\", \"player\", \"enemies\", and \"coins\" "
"and place each node type in its respective layer using the \"Layer\" "
"property. Then set each node's \"Mask\" property by selecting the layers it "
"should interact with. For example, the Player's settings would look like "
"this:"
msgstr ""
"首先将 1 至 4 层分别命名为“walls”（墙）“player”（玩家）“enemies”（敌"
"人）“coins”（金币）并使用“Layer”属性将每个节点类型放在其各自的层中。然后通过"
"选择它应该与之互动的层来设置每个节点的“Mash”属性。例如，玩家的设置将看起来像"
"这样："

msgid "Code example"
msgstr "代码示例"

msgid ""
"In function calls, layers are specified as a bitmask. Where a function "
"enables all layers by default, the layer mask will be given as "
"``0x7fffffff``. Your code can use binary, hexadecimal, or decimal notation "
"for layer masks, depending on your preference."
msgstr ""
"在函数调用中, 为层指定位掩码. 当一个函数默认启用所有图层时, 图层掩码将被指定"
"为 ``0x7fffffff``. 根据你的喜好, 你的代码可以使用二进制, 十六进制或十进制来表"
"示层掩码."

msgid ""
"The code equivalent of the above example where layers 1, 3 and 4 were "
"enabled would be as follows::"
msgstr "如果要用代码来启用第 1、3、4 层： ::"

msgid "Area2D"
msgstr "Area2D"

msgid ""
"Area nodes provide **detection** and **influence**. They can detect when "
"objects overlap and emit signals when bodies enter or exit. Areas can also "
"be used to override physics properties, such as gravity or damping, in a "
"defined area."
msgstr ""
"Area 节点的作用是\\ **检测**\\ 和\\ **影响**\\ 。它们可以检测物体何时重叠，并"
"在物体进入或离开时发出信号。Area 也可用于覆盖物理属性，例如一定区域内的重力或"
"阻尼。"

msgid "There are three main uses for :ref:`Area2D <class_Area2D>`:"
msgstr ":ref:`Area2D <class_Area2D>` 的主要用途有三种："

msgid "Overriding physics parameters (such as gravity) in a given region."
msgstr "覆盖给定区域中的物理参数（例如重力）。"

msgid ""
"Detecting when other bodies enter or exit a region or what bodies are "
"currently in a region."
msgstr "检测其他实体何时进入或退出某个区域或当前哪个实体位于某个区域。"

msgid "Checking other areas for overlap."
msgstr "检查是否与其他区域重叠。"

msgid "By default, areas also receive mouse and touchscreen input."
msgstr "默认情况下,area还会接收鼠标和触摸屏输入."

msgid "StaticBody2D"
msgstr "StaticBody2D"

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. However, it can impart motion or rotation to a colliding body "
"**as if** it were moving, using its ``constant_linear_velocity`` and "
"``constant_angular_velocity`` properties."
msgstr ""
"静态主体是物理引擎不移动的主体. 它参与碰撞检测, 但不会响应碰撞而移动. 然而, "
"它可以使用它的 ``constant_linear_velocity`` 和 ``constant_angular_velocity`` "
"属性将运动或旋转传递给碰撞体, **好像** 它正在移动一样."

msgid ""
"``StaticBody2D`` nodes are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr "``StaticBody2D`` 节点最常用于属于环境的对象或不需要任何动态行为的对象."

msgid "Example uses for ``StaticBody2D``:"
msgstr "``StaticBody2D`` 的示例用法："

msgid "Platforms (including moving platforms)"
msgstr "平台（包括可移动的平台）"

msgid "Conveyor belts"
msgstr "输送带"

msgid "Walls and other obstacles"
msgstr "墙壁和其他障碍"

msgid "RigidBody2D"
msgstr "RigidBody2D"

msgid ""
"This is the node that implements simulated 2D physics. You do not control a :"
"ref:`RigidBody2D <class_RigidBody2D>` directly. Instead, you apply forces to "
"it and the physics engine calculates the resulting movement, including "
"collisions with other bodies, and collision responses, such as bouncing, "
"rotating, etc."
msgstr ""
"这是实现模拟2D物理的节点. 你不能直接控制一个 :ref:`RigidBody2D "
"<class_RigidBody2D>`. 取而代之的是, 对它施加力, 物理引擎会计算由此产生的运"
"动, 包括与其他物体的碰撞, 以及碰撞响应, 如弹跳, 旋转等."

msgid ""
"You can modify a rigid body's behavior via properties such as \"Mass\", "
"\"Friction\", or \"Bounce\", which can be set in the Inspector."
msgstr ""
"你可以通过“Mass”（质量）“Friction”（摩擦）“Bounce”（反弹）等属性修改刚体的行"
"为，这些都可以在检查器中设置。"

msgid ""
"The body's behavior is also affected by the world's properties, as set in "
"`Project Settings -> Physics`, or by entering an :ref:`Area2D "
"<class_Area2D>` that is overriding the global physics properties."
msgstr ""
"物体的行为也受到“项目设置 -> Physics”中设置的世界属性的影响，或者通过输入覆盖"
"全局物理属性的 :ref:`Area2D <class_Area2D>`\\ 。"

msgid ""
"When a rigid body is at rest and hasn't moved for a while, it goes to sleep. "
"A sleeping body acts like a static body, and its forces are not calculated "
"by the physics engine. The body will wake up when forces are applied, either "
"by a collision or via code."
msgstr ""
"当一个刚体处于静止状态, 有一段时间没有移动, 它就会进入睡眠状态. 睡眠的物体就"
"像一个静态的物体, 它的力不会被物理引擎计算. 当力被施加时, 无论是通过碰撞还是"
"通过代码, 该物体都会被唤醒."

msgid "Rigid body modes"
msgstr "刚体模式"

msgid "A rigid body can be set to one of four modes:"
msgstr "刚体可以设置为以下四种模式之一："

msgid ""
"**Rigid** - The body behaves as a physical object. It collides with other "
"bodies and responds to forces applied to it. This is the default mode."
msgstr ""
"**Rigid** - 物体表现为具有物理属性的对象. 它与其他物体发生碰撞, 并对施加于其"
"上的力作出反应. 这是默认模式."

msgid ""
"**Static** - The body behaves like a :ref:`StaticBody2D "
"<class_StaticBody2D>` and does not move."
msgstr ""
"**Static** - 物体表现得像 :ref:`StaticBody2D <class_StaticBody2D>` 并且不会移"
"动."

msgid "**Character** - Similar to \"Rigid\" mode, but the body cannot rotate."
msgstr "**Character** - 类似于“Rigid”模式，但身体不能旋转。"

msgid ""
"**Kinematic** - The body behaves like a :ref:`KinematicBody2D "
"<class_KinematicBody2D>` and must be moved by code."
msgstr ""
"**Kinematic** - 物体的行为类似于 :ref:`KinematicBody2D "
"<class_KinematicBody2D>` 并且必须通过代码移动."

msgid "Using RigidBody2D"
msgstr "使用 RigidBody2D"

msgid ""
"One of the benefits of using a rigid body is that a lot of behavior can be "
"had \"for free\" without writing any code. For example, if you were making "
"an \"Angry Birds\"-style game with falling blocks, you would only need to "
"create RigidBody2Ds and adjust their properties. Stacking, falling, and "
"bouncing would automatically be calculated by the physics engine."
msgstr ""
"使用刚体的一个好处是，可以“免费”获得许多行为而无需编写任何代码。例如，如果您"
"正在制作一个带有下降块的《愤怒的小鸟》式游戏，您只需要创建 RigidBody2D 并调整"
"它们的属性。堆叠、下降、弹跳将由物理引擎自动计算。"

msgid ""
"However, if you do wish to have some control over the body, you should take "
"care - altering the ``position``, ``linear_velocity``, or other physics "
"properties of a rigid body can result in unexpected behavior. If you need to "
"alter any of the physics-related properties, you should use the :ref:"
"`_integrate_forces() <class_RigidBody2D_method__integrate_forces>` callback "
"instead of ``_physics_process()``. In this callback, you have access to the "
"body's :ref:`Physics2DDirectBodyState <class_Physics2DDirectBodyState>`, "
"which allows for safely changing properties and synchronizing them with the "
"physics engine."
msgstr ""
"然而, 如果你确实希望对物体有一些控制, 应该注意改变刚体的 ``position``, "
"``linear_velocity`` 或其他物理属性可能会导致意外的行为. 如果你需要改变任何与"
"物理相关的属性, 应该使用 :ref:`_integrate_forces() "
"<class_RigidBody2D_method__integrate_forces>` 回调来代替 "
"``_physics_process()`` . 在这个回调中, 你可以访问body的 :ref:"
"`Physics2DDirectBodyState <class_Physics2DDirectBodyState>`, 它允许安全地改变"
"属性并与物理引擎同步."

msgid "For example, here is the code for an \"Asteroids\" style spaceship:"
msgstr "例如，以下是《爆破彗星》式宇宙飞船的代码："

msgid ""
"Note that we are not setting the ``linear_velocity`` or ``angular_velocity`` "
"properties directly, but rather applying forces (``thrust`` and ``torque``) "
"to the body and letting the physics engine calculate the resulting movement."
msgstr ""
"请注意, 我们不是直接设置 ``linear_velocity`` 或 ``angular_velocity`` 属性, 而"
"是将力( ``thrust`` 和 ``torque`` )施加到物体上并让物理引擎计算出最终的运动."

msgid ""
"When a rigid body goes to sleep, the ``_integrate_forces()`` function will "
"not be called. To override this behavior, you will need to keep the body "
"awake by creating a collision, applying a force to it, or by disabling the :"
"ref:`can_sleep <class_RigidBody2D_property_can_sleep>` property. Be aware "
"that this can have a negative effect on performance."
msgstr ""
"当一个刚体进入睡眠状态时, ``_integrate_forces()`` 函数将不会被调用. 要重写这"
"一行为, 您需要通过创建碰撞, 对其施加力或禁用 :ref:`can_sleep "
"<class_RigidBody2D_property_can_sleep>` 属性来保持物体的激活. 请注意, 这可能"
"会对性能产生负面影响."

msgid "Contact reporting"
msgstr "接触报告"

msgid ""
"By default, rigid bodies do not keep track of contacts, because this can "
"require a huge amount of memory if many bodies are in the scene. To enable "
"contact reporting, set the :ref:`contacts_reported "
"<class_RigidBody2D_property_contacts_reported>` property to a non-zero "
"value. The contacts can then be obtained via :ref:`Physics2DDirectBodyState."
"get_contact_count() "
"<class_Physics2DDirectBodyState_method_get_contact_count>` and related "
"functions."
msgstr ""
"默认情况下, 刚体不会跟踪接触点, 因为如果场景中存在许多体, 这可能需要大量的内"
"存. 要启用接触报告, 请将 :ref:`contacts_reported "
"<class_RigidBody2D_property_contacts_reported>` 属性设置为非零值. 然后可以通"
"过 :ref:`Physics2DDirectBodyState.get_contact_count() "
"<class_Physics2DDirectBodyState_method_get_contact_count>` 和相关函数获得联"
"系."

msgid ""
"Contact monitoring via signals can be enabled via the :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>` property. See :ref:"
"`RigidBody2D <class_RigidBody2D>` for the list of available signals."
msgstr ""
"通过信号的接触监控, 启用 :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>` 属性. 请参阅 :ref:`RigidBody2D "
"<class_RigidBody2D>` 的可用信号列表."

msgid "KinematicBody2D"
msgstr "KinematicBody2D"

msgid ""
":ref:`KinematicBody2D <class_KinematicBody2D>` bodies detect collisions with "
"other bodies, but are not affected by physics properties like gravity or "
"friction. Instead, they must be controlled by the user via code. The physics "
"engine will not move a kinematic body."
msgstr ""
":ref:`KinematicBody2D <class_KinematicBody2D>` 物体检测与其他物体的碰撞, 但不"
"受重力或摩擦等物理属性的影响. 相反, 它们必须由用户通过代码控制. 物理引擎不会"
"移动运动体."

msgid ""
"When moving a kinematic body, you should not set its ``position`` directly. "
"Instead, you use the ``move_and_collide()`` or ``move_and_slide()`` methods. "
"These methods move the body along a given vector, and it will instantly stop "
"if a collision is detected with another body. After the body has collided, "
"any collision response must be coded manually."
msgstr ""
"移动运动体时, 不应直接设置其 ``position`` . 相反, 您使用 "
"``move_and_collide()`` 或 ``move_and_slide()`` 方法. 这些方法沿着给定的向量移"
"动物体, 如果与另一个物体检测到碰撞, 它将立即停止. 在物体发生碰撞后, 必须手动"
"编码任何碰撞响应."

msgid "Kinematic collision response"
msgstr "运动碰撞响应"

msgid ""
"After a collision, you may want the body to bounce, to slide along a wall, "
"or to alter the properties of the object it hit. The way you handle "
"collision response depends on which method you used to move the "
"KinematicBody2D."
msgstr ""
"碰撞后, 您可能希望物体反弹, 沿着墙壁滑动, 或者改变它所击中的物体的属性. 处理"
"碰撞响应的方式取决于您用于移动KinematicBody2D的方法."

msgid ":ref:`move_and_collide <class_KinematicBody2D_method_move_and_collide>`"
msgstr ""
":ref:`move_and_collide <class_KinematicBody2D_method_move_and_collide>`"

msgid ""
"When using ``move_and_collide()``, the function returns a :ref:"
"`KinematicCollision2D <class_KinematicCollision2D>` object, which contains "
"information about the collision and the colliding body. You can use this "
"information to determine the response."
msgstr ""
"当使用 ``move_and_collide()`` 时, 该函数返回一个 :ref:`KinematicCollision2D "
"<class_KinematicCollision2D>` 对象, 其中包含有关碰撞和碰撞体的信息. 您可以使"
"用此信息来确定响应."

msgid ""
"For example, if you want to find the point in space where the collision "
"occurred:"
msgstr "例如, 如果要查找发生碰撞的空间点:"

msgid "Or to bounce off of the colliding object:"
msgstr "或者从碰撞物体反弹:"

msgid ":ref:`move_and_slide <class_KinematicBody2D_method_move_and_slide>`"
msgstr ":ref:`move_and_slide <class_KinematicBody2D_method_move_and_slide>`"

msgid ""
"Sliding is a common collision response; imagine a player moving along walls "
"in a top-down game or running up and down slopes in a platformer. While it's "
"possible to code this response yourself after using ``move_and_collide()``, "
"``move_and_slide()`` provides a convenient way to implement sliding movement "
"without writing much code."
msgstr ""
"滑动是一种常见的碰撞响应; 想象一个游戏角色在上帝视角的游戏中沿着墙壁移动, 或"
"者在平台游戏中上下坡. 虽然可在使用 ``move_and_collide()`` 之后自己编写这个响"
"应, 但 ``move_and_slide()`` 提供了一种快捷方法来实现滑动且无需编写太多代码."

msgid ""
"``move_and_slide()`` automatically includes the timestep in its calculation, "
"so you should **not** multiply the velocity vector by ``delta``."
msgstr ""
"``move_and_slide()`` 在计算中自动包含时间步长, 因此您 **不** 应将速度向量乘"
"以 ``delta`` ."

msgid ""
"For example, use the following code to make a character that can walk along "
"the ground (including slopes) and jump when standing on the ground:"
msgstr ""
"例如, 使用以下代码制作一个可以沿着地面(包括斜坡)行走的角色, 并在站在地面时跳"
"跃:"

msgid ""
"See :ref:`doc_kinematic_character_2d` for more details on using "
"``move_and_slide()``, including a demo project with detailed code."
msgstr ""
"有关使用 ``move_and_slide()`` 的更多详细信息, 请参阅 :ref:"
"`doc_kinematic_character_2d` , 包括带有详细代码的演示项目."

msgid "Translation status"
msgstr "翻译状态"
