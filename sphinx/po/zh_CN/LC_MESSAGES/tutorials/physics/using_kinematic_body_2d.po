# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2022, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-08 13:53+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using KinematicBody2D"
msgstr "使用 KinematicBody2D"

msgid "Introduction"
msgstr "前言"

msgid ""
"Godot offers several collision objects to provide both collision detection "
"and response. Trying to decide which one to use for your project can be "
"confusing. You can avoid problems and simplify development if you understand "
"how each of them works and what their pros and cons are. In this tutorial, "
"we'll look at the :ref:`KinematicBody2D <class_KinematicBody2D>` node and "
"show some examples of how to use it."
msgstr ""
"Godot提供了几种碰撞对象来提供碰撞检测和响应. 试图决定在你的项目中使用哪一个可"
"能会让你感到困惑. 如果你了解它们中的每一个是如何工作的, 以及它们的优点和缺点"
"是什么, 你就可以避免问题并简化开发. 在本教程中, 我们将查看 :ref:"
"`KinematicBody2D <class_KinematicBody2D>` 节点, 并展示一些如何使用它的例子."

msgid ""
"This document assumes you're familiar with Godot's various physics bodies. "
"Please read :ref:`doc_physics_introduction` first."
msgstr ""
"本文假设您熟悉Godot中的各种物理体. 否则请先阅读 :ref:"
"`doc_physics_introduction` ."

msgid "What is a kinematic body?"
msgstr "什么是运动体？"

msgid ""
"``KinematicBody2D`` is for implementing bodies that are controlled via code. "
"Kinematic bodies detect collisions with other bodies when moving, but are "
"not affected by engine physics properties, like gravity or friction. While "
"this means that you have to write some code to create their behavior, it "
"also means you have more precise control over how they move and react."
msgstr ""
"``KinematicBody2D`` 用于实现通过代码控制的物体. 运动体在移动时可以检测到与其"
"他物体的碰撞, 但不受引擎物理属性的影响, 比如重力或摩擦. 虽然这意味着你必须编"
"写一些代码来创建它们的行为, 但这也意味着你可以更精确地控制它们如何移动和反应."

msgid ""
"A `KinematicBody2D` can be affected by gravity and other forces, but you "
"must calculate the movement in code. The physics engine will not move a "
"`KinematicBody2D`."
msgstr ""
"`KinematicBody2D` 可以受到重力和其他力的影响, 但您必须在代码中计算它的运动. "
"物理引擎不会移动 `KinematicBody2D`."

msgid "Movement and collision"
msgstr "运动与碰撞"

msgid ""
"When moving a ``KinematicBody2D``, you should not set its ``position`` "
"property directly. Instead, you use the ``move_and_collide()`` or "
"``move_and_slide()`` methods. These methods move the body along a given "
"vector and instantly stop if a collision is detected with another body. "
"After a KinematicBody2D has collided, any *collision response* must be coded "
"manually."
msgstr ""
"当移动一个 ``KinematicBody2D`` 时, 你不应该直接设置它的 ``position`` 属性, 而"
"是使用 ``move_and_collide()`` 或 ``move_and_slide()`` 方法. 这些方法沿着给定"
"的向量移动物体, 如果检测到与另一个体发生碰撞, 则立即停止. 在KinematicBody2D发"
"生碰撞后, 任何 *碰撞响应* 必须手动编码."

msgid ""
"You should only do Kinematic body movement in the ``_physics_process()`` "
"callback."
msgstr "你应该只在 ``_physics_process()`` 回调中做Kinematic物体运动."

msgid ""
"The two movement methods serve different purposes, and later in this "
"tutorial, you'll see examples of how they work."
msgstr ""
"这两种运动方法有不同的作用, 在后面的教程中, 你会看到它们如何工作的例子."

msgid "``move_and_collide``"
msgstr "``move_and_collide``"

msgid ""
"This method takes one parameter: a :ref:`Vector2 <class_Vector2>` indicating "
"the body's relative movement. Typically, this is your velocity vector "
"multiplied by the frame timestep (``delta``). If the engine detects a "
"collision anywhere along this vector, the body will immediately stop moving. "
"If this happens, the method will return a :ref:`KinematicCollision2D "
"<class_KinematicCollision2D>` object."
msgstr ""
"这个方法有一个 :ref:`Vector2 <class_Vector2>` 参数以表示物体的相对运动. 通"
"常, 这是您的速度向量乘以帧时间步长( ``delta`` ). 如果在沿着此向量方向的任何位"
"置, 引擎检测到碰撞, 则物体将立即停止移动. 如果发生这种情况, 该方法将返回 :"
"ref:`KinematicCollision2D <class_KinematicCollision2D>` 对象."

msgid ""
"``KinematicCollision2D`` is an object containing data about the collision "
"and the colliding object. Using this data, you can calculate your collision "
"response."
msgstr ""
"``KinematicCollision2D`` 是一个包含碰撞和碰撞对象数据的对象. 使用这些数据, 你"
"可以计算出你的碰撞响应."

msgid "``move_and_slide``"
msgstr "``move_and_slide``"

msgid ""
"The ``move_and_slide()`` method is intended to simplify the collision "
"response in the common case where you want one body to slide along the "
"other. It is especially useful in platformers or top-down games, for example."
msgstr ""
"``move_and_slide()`` 方法旨在简化常见情况下的碰撞响应, 即你希望一个物体沿着另"
"一个物体滑动. 例如, 在平台游戏或自上而下的游戏中, 它特别有用."

msgid ""
"``move_and_slide()`` automatically calculates frame-based movement using "
"``delta``. Do *not* multiply your velocity vector by ``delta`` before "
"passing it to ``move_and_slide()``."
msgstr ""
"``move_and_slide()`` 使用 ``delta`` 自动计算基于帧的运动. 在将速度向量传递给 "
"``move_and_slide()`` 之前, 请 *不要* 将速度向量乘以 ``delta``."

msgid ""
"In addition to the velocity vector, ``move_and_slide()`` takes a number of "
"other parameters allowing you to customize the slide behavior:"
msgstr ""
"除了速度向量之外, ``move_and_slide()`` 还有许多其他参数, 允许您自定义滑动行"
"为:"

msgid "``up_direction`` - *default value:* ``Vector2( 0, 0 )``"
msgstr "``up_direction`` - *默认值:* ``Vector2( 0, 0 )``"

msgid ""
"This parameter allows you to define what surfaces the engine should consider "
"being the floor. Setting this lets you use the ``is_on_floor()``, "
"``is_on_wall()``, and ``is_on_ceiling()`` methods to detect what type of "
"surface the body is in contact with. The default value means that all "
"surfaces are considered walls."
msgstr ""
"这个参数允许你定义哪些表面应该被引擎视为地板. 设置这个参数可以让你使用 "
"``is_on_floor()`` , ``is_on_wall()`` 和 ``is_on_ceiling()`` 方法来检测物体接"
"触的表面类型. 默认值意味着所有的表面都被认为是墙壁."

msgid "``stop_on_slope`` - *default value:* ``false``"
msgstr "``stop_on_slope`` - *默认值:* ``false``"

msgid ""
"This parameter prevents a body from sliding down slopes when standing still."
msgstr "该参数可以防止物体站立不动时从斜坡上滑落."

msgid "``max_slides`` - *default value:* ``4``"
msgstr "``max_slides`` - *默认值:* ``4``"

msgid ""
"This parameter is the maximum number of collisions before the body stops "
"moving. Setting it too low may prevent movement entirely."
msgstr "这个参数是物体停止移动前的最大碰撞次数. 设置太低可能会完全阻止移动."

msgid ""
"``floor_max_angle`` - *default value:* ``0.785398`` (in radians, equivalent "
"to ``45`` degrees)"
msgstr ""
"``floor_max_angle`` - *默认值:* ``0.785398`` (以弧度表示, 相当于 ``45`` 度)"

msgid ""
"This parameter is the maximum angle before a surface is no longer considered "
"a \"floor.\""
msgstr "这是表面不再被视为 \"地板\" 之前的最大角度"

msgid "``infinite_inertia`` - *default value:* ``true``"
msgstr "``infinite_inertia`` - *默认值:* ``true``"

msgid ""
"When this parameter is ``true``, the body can push :ref:`RigidBody2D "
"<class_RigidBody2D>` nodes, ignoring their mass, but won't detect collisions "
"with them. If it's ``false`` the body will collide with rigid bodies and "
"stop."
msgstr ""
"当这个参数为 ``true`` 时, 本体可以推动 :ref:`RigidBody2D "
"<class_RigidBody2D>` 节点, 忽略其质量, 不会检测到与它们的碰撞. 如果是 "
"``false``, 本体会与刚体发生碰撞而停止."

msgid "``move_and_slide_with_snap``"
msgstr "``move_and_slide_with_snap``"

msgid ""
"This method adds some additional functionality to ``move_and_slide()`` by "
"adding the ``snap`` parameter. As long as this vector is in contact with the "
"ground, the body will remain attached to the surface. Note that this means "
"you must disable snapping when jumping, for example. You can do this either "
"by setting ``snap`` to ``Vector2.ZERO`` or by using ``move_and_slide()`` "
"instead."
msgstr ""
"这个方法通过添加 ``sap`` 参数, 给 ``move_and_slide()`` 增加了一些额外的功能. "
"只要这个向量与地面接触, 物体就会保持在表面上. 注意, 这意味着你必须在例如跳跃"
"时禁用捕捉. 你可以将 ``sap`` 设置为 ``Vector2.ZERO`` 或者使用 "
"``move_and_slide()`` 代替."

msgid "Detecting collisions"
msgstr "检测碰撞"

msgid ""
"When using ``move_and_collide()`` the function returns a "
"``KinematicCollision2D`` directly, and you can use this in your code."
msgstr ""
"当使用 ``move_and_collide()`` 时, 函数直接返回一个 "
"``KinematicCollision2D`` , 你可以在代码中使用这个."

msgid ""
"When using ``move_and_slide()`` it's possible to have multiple collisions "
"occur, as the slide response is calculated. To process these collisions, use "
"``get_slide_count()`` and ``get_slide_collision()``:"
msgstr ""
"当使用 ``move_and_slide()`` 时, 有可能发生多次碰撞, 因为滑动响应是计算出来"
"的. 要处理这些碰撞, 使用 ``get_slide_count()`` 和 ``get_slide_collision()``:"

msgid ""
"`get_slide_count()` only counts times the body has collided and changed "
"direction."
msgstr "`get_slide_count()` 只计算物体碰撞和改变方向的次数."

msgid ""
"See :ref:`KinematicCollision2D <class_KinematicCollision2D>` for details on "
"what collision data is returned."
msgstr ""
"关于返回哪些碰撞数据, 请参见 :ref:`KinematicCollision2D "
"<class_KinematicCollision2D>` ."

msgid "Which movement method to use?"
msgstr "使用哪种运动方式？"

msgid ""
"A common question from new Godot users is: \"How do you decide which "
"movement function to use?\" Often, the response is to use "
"``move_and_slide()`` because it's \"simpler,\" but this is not necessarily "
"the case. One way to think of it is that ``move_and_slide()`` is a special "
"case, and ``move_and_collide()`` is more general. For example, the following "
"two code snippets result in the same collision response:"
msgstr ""
"Godot新用户的一个常见问题是:\"你如何决定使用哪个移动函数？\" 通常, 回答是使"
"用 ``move_and_slide()`` , 因为它 \"更简单\" , 但情况不一定如此. 有一种思路"
"是, ``move_and_slide()`` 是一种特殊情况, 而 ``move_and_collide()`` 更通用. 例"
"如, 下面两个代码片段的结果是相同的碰撞响应:"

msgid ""
"Anything you do with ``move_and_slide()`` can also be done with "
"``move_and_collide()``, but it might take a little more code. However, as "
"we'll see in the examples below, there are cases where ``move_and_slide()`` "
"doesn't provide the response you want."
msgstr ""
"您用 ``move_and_slide()`` 做的任何事情都可以用 ``move_and_collide()`` 来完"
"成, 但它可能需要更多的代码. 但是, 正如我们在下面的示例中将看到的, 有些情况下 "
"``move_and_slide()`` 不能提供您想要的响应."

msgid ""
"In the example above, we assign the velocity that ``move_and_slide()`` "
"returns back into the ``velocity`` variable. This is because when the "
"character collides with the environment, the function recalculates the speed "
"internally to reflect the slowdown."
msgstr ""
"在上面的例子中, 我们将 ``move_and_slide()`` 返回的速度赋值给 ``velocity`` 变"
"量. 这是因为当角色与环境发生碰撞时, 函数会在内部重新计算速度, 以反映减速的情"
"况."

msgid ""
"For example, if your character fell on the floor, you don't want it to "
"accumulate vertical speed due to the effect of gravity. Instead, you want "
"its vertical speed to reset to zero."
msgstr ""
"例如, 如果角色倒在地上, 不希望它因为重力的影响而积累垂直速度, 而希望它的垂直"
"速度重置为零."

msgid ""
"``move_and_slide()`` may also recalculate the kinematic body's velocity "
"several times in a loop as, to produce a smooth motion, it moves the "
"character and collides up to five times by default. At the end of the "
"process, the function returns the character's new velocity that we can store "
"in our ``velocity`` variable, and use on the next frame."
msgstr ""
"``move_and_slide()`` 还可以在循环中多次重新计算运动体的速度, 为了产生一个平滑"
"的运动, 它默认会移动角色, 并碰撞5次, 在这个过程结束时, 函数返回角色的新速度, "
"可以将其存储在 ``velocity`` 变量中, 并在下一帧中使用."

msgid "Examples"
msgstr "示例"

msgid ""
"To see these examples in action, download the sample project: :download:"
"`using_kinematic2d.zip <files/using_kinematic2d.zip>`."
msgstr ""
"要查看这些示例, 请下载示例项目: :download:`using_kinematic2d.zip <files/"
"using_kinematic2d.zip>`."

msgid "Movement and walls"
msgstr "移动和墙壁"

msgid ""
"If you've downloaded the sample project, this example is in \"BasicMovement."
"tscn\"."
msgstr "如果你已经下载了示例项目, 这个例子在 \"BasicMovement.tscn\" 中."

msgid ""
"For this example, add a ``KinematicBody2D`` with two children: a ``Sprite`` "
"and a ``CollisionShape2D``. Use the Godot \"icon.png\" as the Sprite's "
"texture (drag it from the Filesystem dock to the *Texture* property of the "
"``Sprite``). In the ``CollisionShape2D``'s *Shape* property, select \"New "
"RectangleShape2D\" and size the rectangle to fit over the sprite image."
msgstr ""
"在这个例子中, 添加一个 ``KinematicBody2D`` , 有两个子级: ``Sprite`` 和 "
"``CollisionShape2D`` . 使用Godot \"icon.png\" 作为Sprite的纹理, 将其从文件系"
"统栏拖到 ``Sprite`` 的 *Texture* 属性. 在 ``CollisionShape2D`` 的 *Shape* 属"
"性中, 选择 \"New RectangleShape2D\" , 并将矩形的大小调整到适合sprite图像的大"
"小."

msgid ""
"See :ref:`doc_2d_movement` for examples of implementing 2D movement schemes."
msgstr "有关实现2D移动方案的示例, 请参阅 :ref:`doc_2d_movement` ."

msgid "Attach a script to the KinematicBody2D and add the following code:"
msgstr "将脚本附加到KinematicBody2D并添加以下代码:"

msgid ""
"Run this scene and you'll see that ``move_and_collide()`` works as expected, "
"moving the body along the velocity vector. Now let's see what happens when "
"you add some obstacles. Add a :ref:`StaticBody2D <class_StaticBody2D>` with "
"a rectangular collision shape. For visibility, you can use a sprite, a "
"Polygon2D, or turn on \"Visible Collision Shapes\" from the \"Debug\" menu."
msgstr ""
"运行这个场景, 您会看到 ``move_and_collide()`` 按预期工作, 沿着速度向量方向移"
"动物体. 现在让我们看看当您添加一些障碍时会发生什么. 添加一个具有矩形碰撞形状"
"的 :ref:`StaticBody2D <class_StaticBody2D>` . 为了可见性, 您可以使用精灵,"
"Polygon2D, 或从 \"调试\" 菜单中打开 \"可见碰撞形状\"."

msgid ""
"Run the scene again and try moving into the obstacle. You'll see that the "
"``KinematicBody2D`` can't penetrate the obstacle. However, try moving into "
"the obstacle at an angle and you'll find that the obstacle acts like glue - "
"it feels like the body gets stuck."
msgstr ""
"再次运行场景并尝试移动到障碍物中. 您会看到 ``KinematicBody2D`` 无法穿透障碍"
"物. 但是, 尝试以某个角度进入障碍物, 您会发现障碍物就像胶水一样 - 感觉物体被卡"
"住了."

msgid ""
"This happens because there is no *collision response*. "
"``move_and_collide()`` stops the body's movement when a collision occurs. We "
"need to code whatever response we want from the collision."
msgstr ""
"发生这种情况是因为没有 *碰撞响应* . ``move_and_collide()`` 在碰撞发生时停止物"
"体的运动. 我们需要编写我们想要的碰撞响应."

msgid ""
"Try changing the function to ``move_and_slide(velocity)`` and running again. "
"Note that we removed ``delta`` from the velocity calculation."
msgstr ""
"尝试将函数更改为 ``move_and_slide(velocity)`` 并再次运行. 请注意, 我们从速度"
"计算中删除了 \"delta\"."

msgid ""
"``move_and_slide()`` provides a default collision response of sliding the "
"body along the collision object. This is useful for a great many game types, "
"and may be all you need to get the behavior you want."
msgstr ""
"``move_and_slide()`` 提供了一个沿碰撞对象滑动物体的默认碰撞响应. 这对于许多游"
"戏类型都很有用, 并且可能是获得所需行为所需的全部内容."

msgid "Bouncing/reflecting"
msgstr "弹跳/反射"

msgid ""
"What if you don't want a sliding collision response? For this example "
"(\"BounceandCollide.tscn\" in the sample project), we have a character "
"shooting bullets and we want the bullets to bounce off the walls."
msgstr ""
"如果您不想要滑动碰撞响应怎么办？ 对于这个示例(示例项目中的 "
"\"BounceandCollide.tscn\"), 我们有一个角色射击子弹, 我们希望子弹从墙上反弹."

msgid ""
"This example uses three scenes. The main scene contains the Player and "
"Walls. The Bullet and Wall are separate scenes so that they can be instanced."
msgstr ""
"此示例使用三个场景. 主场景包含游戏角色和墙壁. 子弹和墙是单独的场景, 以便它们"
"可以实例化."

msgid ""
"The Player is controlled by the `w` and `s` keys for forward and back. "
"Aiming uses the mouse pointer. Here is the code for the Player, using "
"``move_and_slide()``:"
msgstr ""
"游戏角色由 `w` 和 `s` 键控制前进和后退. 瞄准使用鼠标指针. 这是游戏角色的代"
"码, 使用 ``move_and_slide()`` :"

msgid "And the code for the Bullet:"
msgstr "子弹的代码:"

msgid ""
"The action happens in ``_physics_process()``. After using "
"``move_and_collide()``, if a collision occurs, a ``KinematicCollision2D`` "
"object is returned (otherwise, the return is ``Nil``)."
msgstr ""
"动作发生在 ``_physics_process()`` 中. 在使用 ``move_and_collide()`` 后, 如果"
"发生碰撞, 将返回一个 ``KinematicCollision2D`` 对象, 否则, 返回 ``Nil`` ."

msgid ""
"If there is a returned collision, we use the ``normal`` of the collision to "
"reflect the bullet's ``velocity`` with the ``Vector2.bounce()`` method."
msgstr ""
"如果有一个返回的碰撞, 我们使用碰撞的 ``normal`` 来反映子弹的 ``velocity`` 和 "
"``Vector2.bounce()`` 方法."

msgid ""
"If the colliding object (``collider``) has a ``hit`` method, we also call "
"it. In the example project, we've added a flashing color effect to the Wall "
"to demonstrate this."
msgstr ""
"如果碰撞对象( ``collider`` )有一个 ``hit`` 方法, 我们也调用它. 在示例项目中, "
"我们为墙壁添加了一个颜色闪烁效果来演示这一点."

msgid "Platformer movement"
msgstr "平台运动"

msgid ""
"Let's try one more popular example: the 2D platformer. ``move_and_slide()`` "
"is ideal for quickly getting a functional character controller up and "
"running. If you've downloaded the sample project, you can find this in "
"\"Platformer.tscn\"."
msgstr ""
"让我们尝试一个更流行的示例:2D平台游戏. ``move_and_slide()`` 非常适合快速启动"
"和运行功能字符控制器. 如果您已下载示例项目, 可以在 \"Platformer.tscn\" 中找到"
"它."

msgid ""
"For this example, we'll assume you have a level made of ``StaticBody2D`` "
"objects. They can be any shape and size. In the sample project, we're using :"
"ref:`Polygon2D <class_Polygon2D>` to create the platform shapes."
msgstr ""
"对于这个示例, 我们假设您有一个由 ``StaticBody2D`` 对象构成的级别. 它们可以是"
"任何形状和大小. 在示例项目中, 我们使用 :ref:`Polygon2D <class_Polygon2D>` 来"
"创建平台形状."

msgid "Here's the code for the player body:"
msgstr "这是游戏角色物体的代码:"

msgid ""
"When using ``move_and_slide()``, the function returns a vector representing "
"the movement that remained after the slide collision occurred. Setting that "
"value back to the character's ``velocity`` allows us to move up and down "
"slopes smoothly. Try removing ``velocity =`` and see what happens if you "
"don't do this."
msgstr ""
"当使用 ``move_and_slide()`` 时, 该函数返回一个向量, 代表滑动碰撞发生后剩余的"
"运动. 将该值设置返回角色的 ``velocity`` , 我们就可以顺利地在斜坡上和斜坡下移"
"动. 试着去掉 ``velocity =`` , 看看如果不这样做会发生什么."

msgid ""
"Also note that we've added ``Vector2(0, -1)`` as the floor normal. This "
"vector points straight upward. As a result, if the character collides with "
"an object that has this normal, it will be considered a floor."
msgstr ""
"同时注意, 我们已经添加了 ``Vector2(0, -1)`` 作为地板法线. 这是向上指向的向"
"量. 因此, 如果角色与具有该法线的物体相撞, 它将被视为地板."

msgid ""
"Using the floor normal allows us to make jumping work, using "
"``is_on_floor()``. This function will only return ``true`` after a "
"``move_and_slide()`` collision where the colliding body's normal is within "
"45 degrees of the given floor vector. You can control the maximum angle by "
"setting ``floor_max_angle``."
msgstr ""
"使用地板法线, 我们可以使用 ``is_on_floor()`` 来使跳跃工作. 这个函数只有在发"
"生 ``move_and_slide()`` 碰撞后, 碰撞体的法线在给定的地板向量45度以内时才会返"
"回 ``true`` . 你可以通过设置 ``floor_max_angle`` 来控制最大角度."

msgid ""
"This angle also allows you to implement other features like wall jumps using "
"``is_on_wall()``, for example."
msgstr "这个角度也允许你使用 ``is_on_wall()`` 实现其他功能, 比如墙面跳跃."

msgid "Translation status"
msgstr "翻译状态"
