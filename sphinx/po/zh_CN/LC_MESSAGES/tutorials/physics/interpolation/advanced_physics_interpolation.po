# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced physics interpolation"
msgstr "高级物理插值"

msgid ""
"Although the previous instructions will give satisfactory results in a lot "
"of games, in some cases you will want to go a stage further to get the best "
"possible results and the smoothest possible experience."
msgstr ""
"尽管之前的做法可以在大多数游戏中达到令人满意的结果，但在某些情况下，你会想要"
"更进一步，获得最佳结果和最丝滑的体验。"

msgid "Exceptions to automatic physics interpolation"
msgstr "自动物理插值的例外情况"

msgid ""
"Even with physics interpolation active, there may be some local situations "
"where you would benefit from disabling automatic interpolation for a :ref:"
"`Node<class_Node>` (or branch of the :ref:`SceneTree<class_SceneTree>`), and "
"have the finer control of performing interpolation manually."
msgstr ""
"即便启用了物理插值，局部也可能存在一些情况，需要你为某个 :ref:"
"`Node<class_Node>`\\ （或者 :ref:`SceneTree<class_SceneTree>` 的分支）禁用自"
"动插值，去精确控制手动插值。"

msgid ""
"This is possible using the :ref:`Node."
"physics_interpolation_mode<class_Node_property_physics_interpolation_mode>` "
"property which is present in all Nodes. If you for example, turn off "
"interpolation for a Node, the children will recursively also be affected (as "
"they default to inheriting the parent setting). This means you can easily "
"disable interpolation for an entire subscene."
msgstr ""
"这可以通过所有 Node 都有的 :ref:`Node."
"physics_interpolation_mode<class_Node_property_physics_interpolation_mode>` "
"属性实现。假设你关掉了某个 Node 的插值，那么它的所有子节点都会受到影响（因为"
"默认是继承父级设置的）。也就是说，要禁用整个子场景的插值非常简单。"

msgid ""
"The most common situation where you may want to perform your own "
"interpolation is Cameras."
msgstr "最常见的情况就是你可能会想要在 Camera 上执行自己的插值。"

msgid "Cameras"
msgstr "相机"

msgid ""
"In many cases, a :ref:`Camera<class_Camera>` can use automatic interpolation "
"just like any other node. However, for best results, especially at low "
"physics tick rates, it is recommended that you take a manual approach to "
"Camera interpolation."
msgstr ""
"在很多情况下，\\ :ref:`Camera<class_Camera>` 是可以和其他节点一样自动插值的。"
"然而为了达到最佳的效果，尤其是在物理周期率较低的情况下，建议你手动对 Camera "
"进行插值。"

msgid ""
"This is because viewers are very sensitive to Camera movement. For instance, "
"a Camera that realigns slightly every 1/10th of a second (at 10tps tick "
"rate) will often be noticeable. You can get a much smoother result by moving "
"the Camera each frame in ``_process``, and following an interpolated target "
"manually."
msgstr ""
"这是因为观察者对 Camera 的移动是非常敏感的。例如，Camera 每十分之一秒（10 "
"TPS 周期率）做一次略微的重对齐就很容易发现了。通过将 Camera 在 ``_process`` "
"里做每帧的移动，手动跟随插值目标，就可以获得更顺滑的结果。"

msgid "Manual Camera interpolation"
msgstr "手动 Camera 插值"

msgid "**Ensure the Camera is using global coordinate space**"
msgstr "**请确保 Camera 使用的是全局坐标空间**"

msgid ""
"The very first step when performing manual Camera interpolation is to make "
"sure the Camera transform is specified in *global space* rather than "
"inheriting the transform of a moving parent. This is because feedback can "
"occur between the movement of a parent node of a Camera and the movement of "
"the Camera Node itself, which can mess up the interpolation."
msgstr ""
"执行手动 Camera 插值的第一部就是确保 Camera 的变换是用\\ *全局空间*\\ 表达"
"的，而不是继承自可移动的父节点的变换。这是因为 Camera 父节点的运动可能影响到"
"这个 Camera Node 本身的移动，打乱插值。"

msgid "There are two ways of doing this:"
msgstr "有两种实现方法："

msgid ""
"Move the Camera so it is independent on its own branch, rather than being a "
"child of a moving object."
msgstr ""
"调整 Camera 的位置，让它位于自己独立的分支上，不再作为会移动对象的子节点。"

msgid ""
"Call :ref:`Spatial.set_as_toplevel<class_Spatial_method_set_as_toplevel>` "
"and set this to ``true``, which will make the Camera ignore the transform of "
"its parent."
msgstr ""
"调用 :ref:`Spatial.set_as_toplevel<class_Spatial_method_set_as_toplevel>` 并"
"将其设置为 ``true``\\ ，就会让 Camera 忽略父级的变换。"

msgid "Typical example"
msgstr "典型示例"

msgid ""
"A typical example of a custom approach is to use the ``look_at`` function in "
"the Camera every frame in ``_process()`` to look at a target node (such as "
"the player)."
msgstr ""
"自定义方法的典型例子就是每一帧在 ``_process()`` 里使用 Camera 的 ``look_at`` "
"函数让它看向某个目标节点（例如玩家）。"

msgid ""
"But there is a problem. If we use the traditional ``get_global_transform()`` "
"on a Camera \"target\" Node, this transform will only focus the Camera on "
"the target *at the current physics tick*. This is *not* what we want, as the "
"Camera will jump about on each physics tick as the target moves. Even though "
"the Camera may be updated each frame, this does not help give smooth motion "
"if the *target* is only changing each physics tick."
msgstr ""
"但问题来了。如果我们在 Camera 的“目标”Node 节点上使用传统的 "
"``get_global_transform()``\\ ，这个变换只会\\ *在当前物理周期中*\\ 让 Camera "
"在这个目标上聚焦。我们\\ *并不*\\ 希望这样，因为目标是会动的，Camera 在各个物"
"理周期中就会产生跳动。尽管 Camera 可能每帧都在更新，但如果\\ *目标*\\ 只在物"
"理周期内变化，那么相机的运动就不可能变得平滑。"

msgid "get_global_transform_interpolated()"
msgstr "get_global_transform_interpolated()"

msgid ""
"What we really want to focus the Camera on, is not the position of the "
"target on the physics tick, but the *interpolated* position, i.e. the "
"position at which the target will be rendered."
msgstr ""
"我们真正想要让 Camera 聚焦的，并不是物理周期中目标的位置，而是\\ *插值后的"
"*\\ 位置，即目标渲染的位置。"

msgid ""
"We can do this using the :ref:`Spatial."
"get_global_transform_interpolated<class_Spatial_method_get_global_transform_interpolated>` "
"function. This acts exactly like getting :ref:`Spatial."
"global_transform<class_Spatial_property_global_transform>` but it gives you "
"the *interpolated* transform (during a ``_process()`` call)."
msgstr ""
"我们可以使用 :ref:`Spatial."
"get_global_transform_interpolated<class_Spatial_method_get_global_transform_interpolated>` "
"函数来达到目的。这个函数和 :ref:`Spatial."
"global_transform<class_Spatial_property_global_transform>` 是一样的，只不过返"
"回的是（在 ``_process()`` 调用时）\\ *插值后的*\\ 变换。"

msgid ""
"``get_global_transform_interpolated()`` should only be used once or twice "
"for special cases such as Cameras. It should **not** be used all over the "
"place in your code (both for performance reasons, and to give correct "
"gameplay)."
msgstr ""
"只有在类似 Camera 这种特殊的情况下才应该使用一两次 "
"``get_global_transform_interpolated()``\\ ，\\ **不应该**\\ 在代码里到处使用"
"（既影响性能，又影响游戏的正确性）。"

msgid ""
"Aside from exceptions like the Camera, in most cases, your game logic should "
"be in ``_physics_process()``. In game logic you should be calling "
"``get_global_transform()`` or ``get_transform()``, which will give the "
"current physics transform (in global or local space respectively), which is "
"usually what you will want for gameplay code."
msgstr ""
"除了像 Camera 这种例外情况，在大多数时候，你的游戏逻辑都应该放在 "
"``_physics_process()`` 中。游戏逻辑中，你应该调用 ``get_global_transform()`` "
"或者 ``get_transform()`` 获取当前的物理变换（分别对应全局和本地），游戏代码中"
"要用到的一般就是这两个。"

msgid "Example manual Camera script"
msgstr "示例手动 Camera 脚本"

msgid ""
"Here is an example of a simple fixed Camera which follows an interpolated "
"target:"
msgstr "这是一个简单的示例，演示跟随插值对象的固定 Camera："

msgid "Mouse look"
msgstr "鼠标控制视角"

msgid ""
"Mouse look is a very common way of controlling Cameras. But there is a "
"problem. Unlike keyboard input which can be sampled periodically on the "
"physics tick, mouse move events can come in continuously. The Camera will be "
"expected to react and follow these mouse movements on the next frame, rather "
"than waiting until the next physics tick."
msgstr ""
"鼠标控制视角是控制 Camera 的常见方法。但问题来了，和能够在物理周期中反复采样"
"的键盘输入不同，鼠标的移动事件是持续发生的。Camera 应该在下一帧就立马做出反"
"应，跟随鼠标移动，而不是等到下一个物理周期再动。"

msgid ""
"In this situation, it can be better to disable physics interpolation for the "
"Camera node (using :ref:`Node."
"physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`) "
"and directly apply the mouse input to the Camera rotation, rather than apply "
"it in ``_physics_process``."
msgstr ""
"在这种情况下，最好就是禁用 Camera 节点的物理插值（使用 :ref:`Node."
"physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`），"
"直接将鼠标输入应用到 Camera 的旋转中，不要在 ``_physics_process`` 里应用。"

msgid ""
"Sometimes, especially with Cameras, you will want to use a combination of "
"interpolation and non-interpolation:"
msgstr "有些时候，尤其是涉及 Camera 时，你可能会希望同时使用插值和非插值："

msgid ""
"A first person camera may position the camera at a player location (perhaps "
"using :ref:`Spatial."
"get_global_transform_interpolated<class_Spatial_method_get_global_transform_interpolated>`), "
"but control the Camera rotation from mouse look *without* interpolation."
msgstr ""
"第一人称视角可能将相机放置在玩家的位置（使用的可能是 :ref:`Spatial."
"get_global_transform_interpolated<class_Spatial_method_get_global_transform_interpolated>`），"
"但 Camera 的旋转通过鼠标来控制，不进行插值。"

msgid ""
"A third person camera may similarly determine the look at (target location) "
"of the camera using :ref:`Spatial."
"get_global_transform_interpolated<class_Spatial_method_get_global_transform_interpolated>`, "
"but position the camera using mouse look *without* interpolation."
msgstr ""
"第三人称视角可能也用类似的方法使用 :ref:`Spatial."
"get_global_transform_interpolated<class_Spatial_method_get_global_transform_interpolated>` "
"来设置相机的朝向（目标位置），但放置这种使用鼠标控制视角的相机时，是\\ *不能"
"*\\ 使用插值的。"

msgid ""
"There are many permutations and variations of Camera types, but it should be "
"clear that in many cases, disabling automatic physics interpolation and "
"handling this yourself can give a better result."
msgstr ""
"Camera 的类型有多种不同的排列和变种，但应该清楚的是，在大多数情况下，禁用物理"
"插值自己进行处理都能够得到更好的结果。"

msgid "Disabling interpolation on other nodes"
msgstr "在其他节点上禁用插值"

msgid ""
"Although Cameras are the most common example, there are a number of cases "
"when you may wish other nodes to control their own interpolation, or be non-"
"interpolated. Consider for example, a player in a top view game whose "
"rotation is controlled by mouse look. Disabling physics rotation allows the "
"player rotation to match the mouse in real-time."
msgstr ""
"虽然 Camera 是最常见的例子，但其他节点需要控制自己差不插值的例子也还有不少。"
"例如考虑一下俯视角游戏里面的玩家，其旋转就是通过鼠标来控制的。禁用物理旋转可"
"以让玩家的旋转实时地匹配鼠标的位置。"

msgid "MultiMeshes"
msgstr "MultiMesh"

msgid ""
"Although most visual Nodes follow the single Node single visual instance "
"paradigm, MultiMeshes can control several instances from the same Node. "
"Therefore, they have some extra functions for controlling interpolation "
"functionality on a *per-instance* basis. You should explore these functions "
"if you are using interpolated MultiMeshes."
msgstr ""
"尽管大多数可视化 Node 都遵循一个视觉实例一个 Node 的范式，MultiMesh 可以使用"
"单一 Node 控制多个实例。因此，它有一些额外的函数将插值的控制功能精确到\\ *某"
"个实例*\\ 。使用 MultiMesh 进行插值时应当研究一下这些函数。"

msgid ""
":ref:`MultiMesh."
"reset_instance_physics_interpolation<class_MultiMesh_method_reset_instance_physics_interpolation>`"
msgstr ""
":ref:`MultiMesh."
"reset_instance_physics_interpolation<class_MultiMesh_method_reset_instance_physics_interpolation>`"

msgid ""
":ref:`MultiMesh."
"set_as_bulk_array_interpolated<class_MultiMesh_method_set_as_bulk_array_interpolated>`"
msgstr ""
":ref:`MultiMesh."
"set_as_bulk_array_interpolated<class_MultiMesh_method_set_as_bulk_array_interpolated>`"

msgid ""
"Full details are in the :ref:`MultiMesh<class_MultiMesh>` documentation."
msgstr ":ref:`MultiMesh<class_MultiMesh>` 的文档中有详细说明。"

msgid "Translation status"
msgstr "翻译状态"
