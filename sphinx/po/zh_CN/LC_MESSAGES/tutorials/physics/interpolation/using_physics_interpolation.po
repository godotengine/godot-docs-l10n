# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-20 14:58+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using physics interpolation"
msgstr "使用物理插值"

msgid ""
"How do we incorporate physics interpolation into a Godot game? Are there any "
"caveats?"
msgstr "如何在 Godot 游戏中加入物理插值？会有什么问题吗？"

msgid ""
"We have tried to make the system as easy to use as possible, and many "
"existing games will work with few changes. That said there are some "
"situations which require special treatment, and these will be described."
msgstr ""
"我们尝试将该系统做得尽量易用，很多现有的游戏进行少量修改就能够正常工作。即便"
"如此，在有些情况下还是会需要特殊处理，下文会进行讲解。"

msgid "Turn on the physics interpolation setting"
msgstr "开启物理插值设置"

msgid ""
"The first step is to turn on physics interpolation in :ref:`ProjectSettings."
"physics/common/physics_interpolation<class_ProjectSettings_property_physics/"
"common/physics_interpolation>`. You can now run your game."
msgstr ""
"第一步是在 :ref:`ProjectSettings.physics/common/"
"physics_interpolation<class_ProjectSettings_property_physics/common/"
"physics_interpolation>` 中打开物理插值。你现在就可以运行游戏了。"

msgid ""
"It is likely that nothing looks hugely different, particularly if you are "
"running physics at 60 TPS or a multiple of it. However, quite a bit more is "
"happening behind the scenes."
msgstr ""
"很有可能没什么太大的区别，尤其是你的物理周期是 60 TPS 或者是它的倍数的时候。"
"不过，底层实际发生了很多事情。"

msgid ""
"To convert an existing game to use interpolation, it is highly recommended "
"that you temporarily set :ref:`ProjectSettings.physics/common/"
"physics_fps<class_ProjectSettings_property_physics/common/physics_fps>` to a "
"low value such as 10, which will make interpolation problems more obvious."
msgstr ""
"要将现有的游戏转换为使用插值，强烈建议你暂时将 :ref:`ProjectSettings.physics/"
"common/physics_fps<class_ProjectSettings_property_physics/common/"
"physics_fps>` 调低，比如调到 10，这样就会让插值问题更为显著。"

msgid "Move (almost) all game logic from _process to _physics_process"
msgstr "将（几乎）所有游戏逻辑从 _process 移到 _physics_process"

msgid ""
"The most fundamental requirement for physics interpolation (which you may be "
"doing already) is that you should be moving and performing game logic on "
"your objects within ``_physics_process`` (which runs at a physics tick) "
"rather than ``_process`` (which runs on a rendered frame). This means your "
"scripts should typically be doing the bulk of their processing within "
"``_physics_process``, including responding to input and AI."
msgstr ""
"物理插值最基本的要求（你可能已经在执行了）就是应当在（物理周期中执行的）\\ "
"``_physics_process`` 而不是（渲染帧中执行的）\\ ``_process`` 里进行对象的移动"
"和游戏逻辑。这意味着你的脚本应当在 ``_physics_process`` 中执行大段的处理，包"
"括输入和 AI。"

msgid ""
"Setting the transform of objects only within physics ticks allows the "
"automatic interpolation to deal with transforms *between* physics ticks, and "
"ensures the game will run the same whatever machine it is run on. As a "
"bonus, this also reduces CPU usage if the game is rendering at high FPS, "
"since AI logic (for example) will no longer run on every rendered frame."
msgstr ""
"只在物理周期中设置对象的变换，就可以让变换在物理周期\\ *之间*\\ 自动进行插"
"值，确保游戏在任何机器上都能达到一致的运行结果。这样做还能带来额外的好处，会"
"减少高 FPS 时的 CPU 占用，因为（例如）AI 逻辑就不必每个渲染帧都运行了。"

msgid ""
"If you attempt to set the transform of interpolated objects *outside* the "
"physics tick, the calculations for the interpolated position will be "
"incorrect, and you will get jitter. This jitter may not be visible on your "
"machine, but it *will* occur for some players. For this reason, setting the "
"transform of interpolated objects should be avoided outside of the physics "
"tick. Godot will attempt to produce warnings in the editor if this case is "
"detected."
msgstr ""
"如果你尝试在物理周期\\ *之外*\\ 设置插值对象的变换，就会插值出错误的位置，导"
"致颤动。这种颤动可能在你的机器上不可见，但是部分玩家是\\ *会*\\ 观察到的。因"
"此，应当避免在物理周期外设置插值对象的变换。如果检测到这样的情况，Godot 会尝"
"试在编辑器中进行警告。"

msgid ""
"This is only a *soft-rule*. There are some occasions where you might want to "
"teleport objects outside of the physics tick (for instance when starting a "
"level, or respawning objects). Still, in general, you should be applying "
"transforms from the physics tick."
msgstr ""
"这只是个\\ *软性规定*\\ 。是存在想要将对象在物理周期之外进行传送的情况的（例"
"如开始关卡或者重生对象时）。但总的来说，你应该在物理周期中应用变换。"

msgid "Ensure that all indirect movement happens during physics ticks"
msgstr "确保所有间接移动发生在物理周期中"

msgid ""
"Consider that in Godot, Nodes can be moved not just directly in your own "
"scripts, but also by automatic methods such as tweening, animation, and "
"navigation. All these methods should also have their timing set to operate "
"on the physics tick rather than each frame (\"idle\"), **if** you are using "
"them to move objects (*these methods can also be used to control properties "
"that are not interpolated*)."
msgstr ""
"考虑到在 Godot 中，Node 的移动可能不仅是由你自己的脚本造成的，也有可能是补"
"间、动画、导航自动产生的。\\ **如果**\\ 你想要用这些方法来移动对象（\\ *这些"
"方法也能用于控制不进行插值的属性*\\ ），应当将它们都设置为在物理周期执行，而"
"不是每帧执行（“空闲”）。"

msgid ""
"Also consider that nodes can be moved not just by moving themselves, but "
"also by moving parent nodes in the :ref:`SceneTree<class_SceneTree>`. The "
"movement of parents should therefore also only occur during physics ticks."
msgstr ""
"请注意节点也可能不是自行移动的，\\ :ref:`SceneTree<class_SceneTree>` 中的父节"
"点也可能将其移动。因此，父节点的运动也应该只在物理周期中进行。"

msgid "Choose a physics tick rate"
msgstr "选择物理帧率"

msgid ""
"When using physics interpolation, the rendering is decoupled from physics, "
"and you can choose any value that makes sense for your game. You are no "
"longer limited to values that are multiples of the user's monitor refresh "
"rate (for stutter-free gameplay if the target FPS is reached)."
msgstr ""
"使用物理插值时，渲染与物理是脱钩的，你可以选择任何适合你的游戏的值，不再局限"
"于用户显示器刷新率的倍数（达到目标 FPS 时避免游戏中产生卡顿）。"

msgid "As a rough guide:"
msgstr "大体的指南："

msgid "Low tick rates (10-30)"
msgstr "较低的帧率（10-30）"

msgid "Medium tick rates (30-60)"
msgstr "中等的帧率（30-60）"

msgid "High tick rates (60+)"
msgstr "较高的帧率（60+）"

msgid "Better CPU performance"
msgstr "CPU 性能更高"

msgid "Good physics behaviour in complex scenes"
msgstr "复杂场景下物理行为较好"

msgid "Good with fast physics"
msgstr "适合快速物理"

msgid "Add some delay to input"
msgstr "输入存在延迟"

msgid "Good for first person games"
msgstr "适合第一人称游戏"

msgid "Good for racing games"
msgstr "适合赛车游戏"

msgid "Simple physics behaviour"
msgstr "物理行为简单"

msgid ""
"You can always change the tick rate as you develop, it is as simple as "
"changing the project setting."
msgstr "开发时可以随时修改帧率，在项目设置中修改即可。"

msgid "Call reset_physics_interpolation() when teleporting objects"
msgstr "传送对象时调用 reset_physics_interpolation()"

msgid ""
"Most of the time, interpolation is what you want between two physics ticks. "
"However, there is one situation in which it may *not* be what you want. That "
"is when you are initially placing objects, or moving them to a new location. "
"Here, you don't want a smooth motion between the two - you want an "
"instantaneous move."
msgstr ""
"大多数情况下，你都希望在两个物理帧之间进行插值。然而，有一种情况下你可能是\\ "
"*不想要*\\ 的。这就是你最初在放置对象，或者将它们移动到新位置的时候。这里你是"
"不想要在两者之间进行平滑运动的——你想要瞬间移动。"

msgid ""
"The solution to this is to call the :ref:`Node."
"reset_physics_interpolation<class_Node_method_reset_physics_interpolation>` "
"function. You should call this function on a Node *after* setting the "
"position/transform. The rest is done for you automatically."
msgstr ""
"解决方法就是调用 :ref:`Node."
"reset_physics_interpolation<class_Node_method_reset_physics_interpolation>` "
"函数。你应该在设置位置/变换\\ *之后*\\ 在 Node 上去调用这个函数。其余都是自动"
"为你执行的。"

msgid ""
"Even if you forget to call this, it is not usually a problem in most "
"situations (especially at high tick rates). This is something you can easily "
"leave to the polishing phase of your game. The worst that will happen is "
"seeing a streaking motion for a frame or so when you move them - you will "
"know when you need it!"
msgstr ""
"即便你忘记调用，大多数情况下一般也不会有问题（尤其是帧率较高时）。你可以把这"
"些留到打磨游戏的阶段再做。最不济，就是在移动的时候看到几帧连续的移动——看到就"
"知道要做了！"

msgid ""
"You should call ``reset_physics_interpolation()`` *after* setting the new "
"position, rather than before. Otherwise, you will still see the unwanted "
"streaking motion."
msgstr ""
"你应当在设置新位置\\ *之后*\\ 调用 ``reset_physics_interpolation()`` 而不是之"
"前。否则你还是会看到不想看到的连续运动。"

msgid "Testing and debugging tips"
msgstr "测试与调试技巧"

msgid ""
"Even if you intend to run physics at 60 TPS, in order to thoroughly test "
"your interpolation and get the smoothest gameplay, it is highly recommended "
"to temporarily set the physics tick rate to a low value such as 10 TPS."
msgstr ""
"即便你想要以 60 TPS 执行物理，为了彻底测试你的插值，获取最平滑的游戏体验，非"
"常建议临时将物理周期率设为 10 TPS 等较低的值。"

msgid ""
"The gameplay may not work perfectly, but it should enable you to more easily "
"see cases where you should be calling :ref:`Node."
"reset_physics_interpolation<class_Node_method_reset_physics_interpolation>`, "
"or where you should be using your own custom interpolation on e.g. a :ref:"
"`Camera<class_Camera>`. Once you have these cases fixed, you can set the "
"physics tick rate back to the desired setting."
msgstr ""
"游戏体验可能不是非常完美，但是应该能够让你更容易地观察到应当去调用 :ref:"
"`Node."
"reset_physics_interpolation<class_Node_method_reset_physics_interpolation>` "
"的地方，或者是应当使用自定义插值的地方，例如 :ref:`Camera<class_Camera>`。修"
"复了这些情况之后，你就可以将物理周期率设回想要的值了。"

msgid ""
"The other great advantage to testing at a low tick rate is you can often "
"notice other game systems that are synchronized to the physics tick and "
"creating glitches which you may want to work around. Typical examples "
"include setting animation blend values, which you may decide to set in "
"``_process()`` and interpolate manually."
msgstr ""
"使用较低的周期率进行测试的另一大优势在于，你经常可以注意到与物理周期同步的其"
"他游戏系统，造成一些你可能想要避免的跳跃。典型的例子就是设置动画的混合值，你"
"可能会想要在 ``_process()`` 里设置并手动进行插值。"

msgid "Translation status"
msgstr "翻译状态"
