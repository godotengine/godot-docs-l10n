# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Introduction"
msgstr "前言"

msgid "Physics ticks and rendered frames"
msgstr "物理周期与渲染帧"

msgid ""
"One key concept to understand in Godot is the distinction between physics "
"ticks (sometimes referred to as iterations or physics frames), and rendered "
"frames. The physics proceeds at a fixed tick rate (set in :ref:"
"`ProjectSettings.physics/common/"
"physics_fps<class_ProjectSettings_property_physics/common/physics_fps>`), "
"which defaults to 60 ticks per second."
msgstr ""
"Godot 中有一个需要理解的关键概念，那就是物理周期（也叫迭代或者物理帧）和渲染"
"帧的区别。物理处理的周期率是固定的（通过 :ref:`ProjectSettings.physics/"
"common/physics_fps<class_ProjectSettings_property_physics/common/"
"physics_fps>` 设置），默认为每秒 60 次。"

msgid ""
"However, the engine does not necessarily **render** at the same rate. "
"Although many monitors refresh at 60 Hz (cycles per second), many refresh at "
"completely different frequencies (e.g. 75 Hz, 144 Hz, 240 Hz or more). Even "
"though a monitor may be able to show a new frame e.g. 60 times a second, "
"there is no guarantee that the CPU and GPU will be able to *supply* frames "
"at this rate. For instance, when running with V-Sync, the computer may be "
"too slow for 60 and only reach the deadlines for 30 FPS, in which case the "
"frames you see will change at 30 FPS (resulting in stuttering)."
msgstr ""
"然而，引擎不必以相同的频率进行\\ **渲染**\\ 。虽然很多显示器的刷新率是 60 Hz"
"（每秒的循环数），但是也有很多使用的是完全不同的频率（例如 75 Hz、144 Hz、"
"240 Hz 或者更高）。即便显示器可能可以每秒显示 60 个新帧，也无法保证 CPU 和 "
"GPU 能够按照这个频率来\\ *提供*\\ 帧。例如，使用垂直同步运行时，计算机可能太"
"慢了，无法达到 60 FPS，只能达到 30 FPS，那么你能看到的就变化就是 30 FPS 的"
"（造成卡顿）。"

msgid ""
"But there is a problem here. What happens if the physics ticks do not "
"coincide with frames? What happens if the physics tick rate is out of phase "
"with the frame rate? Or worse, what happens if the physics tick rate is "
"*lower* than the rendered frame rate?"
msgstr ""
"但问题来了。物理周期与帧不一致会怎样？物理周期率与帧率不同步会怎样？或者更夸"
"张一点，物理周期率\\ *低于*\\ 渲染帧率会怎样？"

msgid ""
"This problem is easier to understand if we consider an extreme scenario. If "
"you set the physics tick rate to 10 ticks per second, in a simple game with "
"a rendered frame rate of 60 FPS. If we plot a graph of the positions of an "
"object against the rendered frames, you can see that the positions will "
"appear to \"jump\" every 1/10th of a second, rather than giving a smooth "
"motion. When the physics calculates a new position for a new object, it is "
"not rendered in this position for just one frame, but for 6 frames."
msgstr ""
"如果我们考虑比较极端的情况，就能够更方便地理解这个问题。如果你在某个简单的游"
"戏里把物理周期率设为每秒 10 次，而渲染帧率是 60 FPS。如果我们绘制渲染帧与某个"
"对象位置的关系图，你应该可以看到位置是每十分之一秒“跳动”一次的，进行的不是平"
"滑的运动。物理计算出新对象的新位置时，并不是在这个位置渲染一帧，而是要持续 6 "
"帧。"

msgid ""
"This jump can be seen in other combinations of tick / frame rate as "
"glitches, or jitter, caused by this staircasing effect due to the "
"discrepancy between physics tick time and rendered frame time."
msgstr ""
"这种跳动也可以在其他周期/帧率的组合中见到，表现为这种台阶效应所产生的闪烁或者"
"抖动，究其原因还是物理周期的时间与渲染帧的时间的差异。"

msgid "What can we do about frames and ticks being out of sync?"
msgstr "帧和周期不同步，我们能做什么？"

msgid "Lock the tick / frame rate together?"
msgstr "把周期/帧率锁死？"

msgid ""
"The most obvious solution is to get rid of the problem, by ensuring there is "
"a physics tick that coincides with every frame. This used to be the approach "
"on old consoles and fixed hardware computers. If you know that every player "
"will be using the same hardware, you can ensure it is fast enough to "
"calculate ticks and frames at e.g. 50 FPS, and you will be sure it will work "
"great for everybody."
msgstr ""
"最明显的解决方案就是消灭问题本身，方法是保证物理周期与帧一致。一些古早的主机"
"和固定硬件的计算机使用的就是这种做法。如果你知道所有玩家使用的都是相同的硬"
"件，那么你就可以保证周期和帧的计算都能在，例如 50 FPS 里处理掉，这样你就可以"
"确定大家都能够得到很好的体验。"

msgid ""
"However, modern games are often no longer made for fixed hardware. You will "
"often be planning to release on desktop computers, mobiles and more, all of "
"which have huge variations in performance, as well as different monitor "
"refresh rates. We need to come up with a better way of dealing with the "
"problem."
msgstr ""
"然而，现代的游戏通常都不是为固定的硬件开发的。你通常会计划在桌面计算机、移动"
"设备等多处发布，在性能和显示器刷新率上都会有很大差异。我们需要找到更好的解决"
"方法。"

msgid "Adapt the tick rate?"
msgstr "适应周期率？"

msgid ""
"Instead of designing the game at a fixed physics tick rate, we could allow "
"the tick rate to scale according to the end users hardware. We could for "
"example use a fixed tick rate that works for that hardware, or even vary the "
"duration of each physics tick to match a particular frame duration."
msgstr ""
"既然不能按照固定的物理帧率来设计游戏了，那么我们可以根据终端用户的硬件来缩放"
"周期率呀。例如我们可以使用在那种硬件上能够固定达到的周期率，甚至可以改变每一"
"个物理周期的长度来匹配特定的帧长度。"

msgid ""
"This works, but there is a problem. Physics (*and game logic*, which is "
"often also run in the ``_physics_process``) work best and most consistently "
"when run at a **fixed**, predetermined tick rate. If you attempt to run a "
"racing game physics that has been designed for 60 TPS (ticks per second) at "
"e.g. 10 TPS, the physics will behave completely differently. Controls may be "
"less responsive, collisions / trajectories can be completely different. You "
"may test your game thoroughly at 60 TPS, then find it breaks on end users "
"machines when it runs at a different tick rate."
msgstr ""
"确实可行，但还是会有问题。物理（\\ *游戏逻辑*\\ 也一样，通常会在 "
"``_physics_process`` 里执行）只有在以\\ **固定的**\\ 预定义的周期运行时，效果"
"才最佳、最稳定。如果某个赛车游戏的物理系统是按照 60 TPS（每秒周期数）设计的，"
"而你尝试按照 10 TPS 运行，物理系统的行为会大幅改变。控制的响应速度会变慢，碰"
"撞/轨迹会完全不同。你可能在 60 TPS 下完善地测试了你的游戏，但一到终端用户的机"
"器上，用不同的周期率运行就会完蛋。"

msgid ""
"This can make quality assurance difficult with hard to reproduce bugs, "
"especially in AAA games where problems of this sort can be very costly. This "
"can also be problematic for multiplayer games for competitive integrity, as "
"running the game at certain tick rates may be more advantageous than others."
msgstr ""
"这样就会造成品控方面的困难，Bug 难以重现，尤其是 AAA 游戏，这种问题非常费时费"
"力。这也会在多人游戏时造成公平竞争问题，因为在特定帧率下运行游戏可能相对更有"
"优势。"

msgid ""
"Lock the tick rate, but use interpolation to smooth frames in between "
"physics ticks"
msgstr "锁定周期率，但在两个物理周期之间通过插值来平滑帧"

msgid ""
"This has become one of the most popular approaches to dealing with the "
"problem. It is supported by Godot 3.5 and later in 3D (although it is "
"optional and disabled by default)."
msgstr ""
"这是此类问题最受欢迎的解决方案。Godot 从 3.5 其支持在 3D 中使用（虽然是可选"
"的，默认关闭）。"

msgid ""
"We have established that the most desirable physics/game logic arrangement "
"for consistency and predictability is a physics tick rate that is fixed at "
"design-time. The problem is the discrepancy between the physics position "
"recorded, and where we \"want\" a physics object to be shown on a frame to "
"give smooth motion."
msgstr ""
"我们已经认识到，要让物理/游戏逻辑安排达到最理想、稳定、可预知的状态，就需要在"
"设计时使用固定的物理周期率。问题在于这两个位置是不同的：物理对象记录的物理位"
"置，以及我们为了达到平滑的运动而“想要”让它在特定的帧中显示的位置。"

msgid ""
"The answer turns out to be simple, but can be a little hard to get your head "
"around at first."
msgstr "答案非常简单，不过第一次听起来可能会有点难以理解。"

msgid ""
"Instead of keeping track of just the current position of a physics object in "
"the engine, we keep track of *both the current position of the object, and "
"the previous position* on the previous physics tick."
msgstr ""
"除了记录引擎里物理对象的当前位置之外，我们\\ *还要去记录它在上一个物理周期时"
"的位置*\\ 。"

msgid ""
"Why do we need the previous position *(in fact the entire transform, "
"including rotation and scaling)*? By using a little math magic, we can use "
"**interpolation** to calculate what the transform of the object would be "
"between those two points, in our ideal world of smooth continuous movement."
msgstr ""
"为什么需要上一个位置\\ *（实际是完整的变换，还包括旋转和缩放）*\\ ？通过一点"
"神奇的数学知识，我们就可以通过\\ **插值**\\ 来算出，如果在这两个点之间做理想"
"的平滑连续运动的话，这个对象的变换应该是什么。"

msgid "Linear interpolation"
msgstr "线性插值"

msgid ""
"The simplest way to achieve this is linear interpolation, or lerping, which "
"you may have used before."
msgstr "实现起来最简单的方法就是做线性插值，或者叫 lerp，你可能之前用过。"

msgid ""
"Let us consider only the position, and a situation where we know that the "
"previous physics tick X coordinate was 10 units, and the current physics "
"tick X coordinate is 30 units."
msgstr ""
"假设我们只考虑位置，我们知道上一个物理周期 X 坐标为 10 个单位，当前物理周期 "
"X 坐标为 30 个单位。"

msgid ""
"Although the maths is explained here, you do not have to worry about the "
"details, as this step will be performed for you. Under the hood, Godot may "
"use more complex forms of interpolation, but linear interpolation is the "
"easiest in terms of explanation."
msgstr ""
"虽然这里会解释一下数学只是，你不用担心细节，因为你不用自己来做这一步。Godot "
"可能会在底层使用更复杂的插值，但是线性插值是解释起来最简单的。"

msgid "The physics interpolation fraction"
msgstr "物理插值分数"

msgid ""
"If our physics ticks are happening 10 times per second (for this example), "
"what happens if our rendered frame takes place at time 0.12 seconds? We can "
"do some math to figure out where the object would be to obtain a smooth "
"motion between the two ticks."
msgstr ""
"如果我们的物理周期正好是每秒钟 10 次（针对这个例子），如果渲染帧发生在 0.12 "
"秒处会发生什么呢？我们可以通过数学得到，假如该物体在两次物理周期间存在平滑运"
"动，那么它应该位于哪个地方。"

msgid ""
"First of all, we have to calculate how far through the physics tick we want "
"the object to be. If the last physics tick took place at 0.1 seconds, we are "
"0.02 seconds *(0.12 - 0.1)* through a tick that we know will take 0.1 "
"seconds (10 ticks per second). The fraction through the tick is thus:"
msgstr ""
"首先，我们得算出我们希望该物体经过了该物理周期多久。如果上一个物理周期发生在 "
"0.1 秒，那么我们就是经过了一个周期 0.1 秒（每秒 10 个周期）之中的 0.02 秒\\ *"
"（0.12 - 0.1）*\\ 。因此在该周期中的分数就是："

msgid ""
"This is called the **physics interpolation fraction**, and is handily "
"calculated for you by Godot. It can be retrieved on any frame by calling :"
"ref:`Engine."
"get_physics_interpolation_fraction<class_Engine_method_get_physics_interpolation_fraction>`."
msgstr ""
"这就叫做\\ **物理插值分数**\\ ，Godot 会好心地帮你算出来。任何帧中都能通过调"
"用 :ref:`Engine."
"get_physics_interpolation_fraction<class_Engine_method_get_physics_interpolation_fraction>` "
"得到。"

msgid "Calculating the interpolated position"
msgstr "计算插值位置"

msgid ""
"Once we have the interpolation fraction, we can insert it into a standard "
"linear interpolation equation. The X coordinate would thus be:"
msgstr "有了插值分数之后，我们就可以把它带入标准线性插值公式中。X 坐标就是："

msgid "So substituting our ``x_prev`` as 10, and ``x_curr`` as 30:"
msgstr "那么把我们的 ``x_prev`` 替换为 10、\\ ``x_curr`` 替换为 30："

msgid "Let's break that down:"
msgstr "我们来仔细看看："

msgid ""
"We know the X starts from the coordinate on the previous tick (``x_prev``) "
"which is 10 units."
msgstr ""
"我们知道 X 是从上一周期的位置开始的（\\ ``x_prev``\\ ）也就是 10 个单位。"

msgid ""
"We know that after the full tick, the difference between the current tick "
"and the previous tick will have been added (``x_curr - x_prev``) (which is "
"20 units)."
msgstr ""
"我们知道在完整的周期后，会加上当前周期与上一周期的差（\\ ``x_curr - "
"x_prev``\\ ）（也就是 20 个单位）。"

msgid ""
"The only thing we need to vary is the proportion of this difference we add, "
"according to how far we are through the physics tick."
msgstr ""
"我们唯一需要变化的就是根据我们经过了这个物理周期的多少，来加上这个差值的多"
"少。"

msgid ""
"Although this example interpolates the position, the same thing can be done "
"with the rotation and scale of objects. It is not necessary to know the "
"details as Godot will do all this for you."
msgstr ""
"尽管这个例子里我们插值的是位置，对象的旋转和缩放也是可以做插值的。不必了解细"
"节，Godot 会帮你做好这些事情。"

msgid "Smoothed transformations between physics ticks?"
msgstr "在物理周期之间平滑变换？"

msgid ""
"Putting all this together shows that it should be possible to have a nice "
"smooth estimation of the transform of objects between the current and "
"previous physics tick."
msgstr ""
"综上所述，通过对象在当前及上一物理周期时的变换，就应该能够估算得到平滑的变"
"换。"

msgid ""
"But wait, you may have noticed something. If we are interpolating between "
"the current and previous ticks, we are not estimating the position of the "
"object *now*, we are estimating the position of the object in the past. To "
"be exact, we are estimating the position of the object *between 1 and 2 "
"ticks* into the past."
msgstr ""
"但是等一下，你可能注意到了什么。如果我们插值的是当前周期和上一周期，那么我们"
"并不是在估算该对象\\ *现在*\\ 的位置，而是在估算该对象过去的位置。确切地说，"
"我们是在估算该对象过去\\ *1 个周期和 2 个周期之间*\\ 的位置。"

msgid "In the past"
msgstr "过去"

msgid ""
"What does this mean? This scheme does work, but it does mean we are "
"effectively introducing a delay between what we see on the screen, and where "
"the objects *should* be."
msgstr ""
"这是什么意思？这种做法确实是有效的，但是我们本质上确实也是在屏幕上看到的位置"
"和对象\\ *应该*\\ 在的位置之间引入了延迟。"

msgid ""
"In practice, most people won't notice this delay, or rather, it is typically "
"not *objectionable*. There are already significant delays involved in games, "
"we just don't typically notice them. The most significant effect is there "
"can be a slight delay to input, which can be a factor in fast twitch games. "
"In some of these fast input situations, you may wish to turn off physics "
"interpolation and use a different scheme, or use a high tick rate, which "
"mitigates these delays."
msgstr ""
"在实践中，大多数人不会注意到这个延迟，或者说，通常不会\\ *引起反感*\\ 。游戏"
"里本就有显著的延迟，只是我们通常不会注意到。最显著的就是输入会有少量的延迟，"
"快节奏的游戏里就会感觉到。在类似这种快速输入的情况下，你可能会想要关闭物理插"
"值，使用别的反感，或者提高周期率，缓和这种延迟。"

msgid "Why look into the past? Why not predict the future?"
msgstr "为什么要往过去看呢？为什么不预测未来？"

msgid ""
"There is an alternative to this scheme, which is: instead of interpolating "
"between the previous and current tick, we use maths to *extrapolate* into "
"the future. We try to predict where the object *will be*, rather than show "
"it where it was. This can be done and may be offered as an option in future, "
"but there are some significant downsides:"
msgstr ""
"这种方案还有另一种变体，那就是：不在上周期和本周期之间插值，而是利用数学\\ *"
"外插*\\ 出未来的值。我们要尝试预测对象\\ *将会*\\ 在哪里，而不是去显示它曾经"
"在哪个位置。未来可能可以这么做，作为可选项提供，但还是有显著的问题的："

msgid ""
"The prediction may not be correct, especially when an object collides with "
"another object during the physics tick."
msgstr ""
"预测可能是不准确的，尤其是在物理周期中该对象与另一个对象发生碰撞的时候。"

msgid ""
"Where a prediction was incorrect, the object may extrapolate into an "
"\"impossible\" position, like inside a wall."
msgstr "预测错误的时候，该对象就可能外插到“不可能”的位置，类似于墙体的内部。"

msgid ""
"Providing the movement speed is slow, these incorrect predictions may not be "
"too much of a problem."
msgstr "如果运动速度比较慢，这些错误的预测可能不会造成太大的问题。"

msgid ""
"When a prediction was incorrect, the object may have to jump or snap back "
"onto the corrected path. This can be visually jarring."
msgstr ""
"预测错误的时候，该对象可能必须跳跃或者吸附回正确路径。看起来就会非常扎眼。"

msgid "Fixed timestep interpolation"
msgstr "固定步长插值"

msgid ""
"In Godot this whole system is referred to as physics interpolation, but you "
"may also hear it referred to as **\"fixed timestep interpolation\"**, as it "
"is interpolating between objects moved with a fixed timestep (physics ticks "
"per second). In some ways the second term is more accurate, because it can "
"also be used to interpolate objects that are not driven by physics."
msgstr ""
"在 Godot 中，这样的整个系统就叫做物理插值，不过你可能还听说过\\ **“固定步长插"
"值”**\\ 这样的叫法，这是因为在做插值的是在固定时间步长（每秒物理周期数）中移"
"动前后的对象。某种意义上第二种术语更加准确，因为还可以被插值的对象也可以不是"
"由物理驱动移动的。"

msgid ""
"Although physics interpolation is usually a good choice, there are "
"exceptions where you may choose not to use Godot's built-in physics "
"interpolation (or use it in a limited fashion). An example category is "
"internet multiplayer games. Multiplayer games often receive tick or timing "
"based information from other players or a server and these may not coincide "
"with local physics ticks, so a custom interpolation technique can often be a "
"better fit."
msgstr ""
"尽管物理插值通常是不错的选择，但还是存在例外情况的，你可能不会想要使用 Godot "
"内置的物理插值（或者进行有限的使用）。互联网多人游戏就是一种例子。多人游戏经"
"常会从其他玩家或者服务器获取周期和基于时间的信息，这些信息可以与本地物理周期"
"是不同步的，所以做自定义插值可能更加合适。"

msgid "Translation status"
msgstr "翻译状态"
