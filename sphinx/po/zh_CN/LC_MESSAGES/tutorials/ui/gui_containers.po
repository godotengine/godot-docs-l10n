# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Containers"
msgstr "使用容器"

msgid ""
":ref:`Anchors <doc_size_and_anchors>` are an efficient way to handle "
"different aspect ratios for basic multiple resolution handling in GUIs."
msgstr ""
":ref:`Anchors <doc_size_and_anchors>` 是 GUI 中处理基本多分辨率时应对不同纵横"
"比的有效方法。"

msgid "For more complex user interfaces, they can become difficult to use."
msgstr "对于更复杂的用户界面, 它们可能会变得难以使用."

msgid ""
"This is often the case of games, such as RPGs, online chats, tycoons or "
"simulations. Another common case where more advanced layout features may be "
"required is in-game tools (or simply just tools)."
msgstr ""
"这通常是游戏的情况下, 如角色扮演类, 在线聊天, 大富翁类或模拟类游戏. 另一个需"
"要更高级布局功能的常见情况是游戏内工具(或者仅仅是工具)."

msgid ""
"All these situations require a more capable OS-like user interface, with "
"advanced layout and formatting. For that, :ref:`Containers "
"<class_container>` are more useful."
msgstr ""
"这些情况需要一个更强大的类似操作系统的用户界面，具有先进的布局和格式。用 :"
"ref:`Container <class_container>` 会更方便。"

msgid "Container layout"
msgstr "容器布局"

msgid ""
"Containers provide a huge amount of layout power (as an example, the Godot "
"editor user interface is entirely done using them):"
msgstr ""
"容器提供了巨大的布局能力(例如,Godot编辑器的用户界面就是完全使用它们完成的):"

msgid ""
"When a :ref:`Container <class_Container>`-derived node is used, all "
"children :ref:`Control <class_Control>` nodes give up their own positioning "
"ability. This means the *Container* will control their positioning and any "
"attempt to manually alter these nodes will be either ignored or invalidated "
"the next time their parent is resized."
msgstr ""
"当使用 :ref:`Container <class_Container>` 派生的节点时，所有作为子项的 :ref:"
"`Control <class_Control>` 节点都会放弃自我定位能力。这意味着\\ *容器*\\ 将控"
"制它们的位置，任何手动更改这些节点的尝试，都将在它们的父节点下一次调整大小时"
"被忽略或失效。"

msgid ""
"Likewise, when a *Container* derived node is resized, all its children will "
"be re-positioned according to it, with a behavior based on the type of "
"container used:"
msgstr ""
"同样，调整 *Container* 派生节点的大小时，它的所有子节点都将根据它重新定位，其"
"行为基于所用的容器类型："

msgid "Example of *HBoxContainer* resizing children buttons."
msgstr "*HBoxContainer* 调整子按钮大小的例子。"

msgid ""
"The real strength of containers is that they can be nested (as nodes), "
"allowing the creation of very complex layouts that resize effortlessly."
msgstr ""
"容器的真正优势在于它们可以嵌套(作为节点), 允许创建非常复杂的布局, 调整毫不费"
"力."

msgid "Sizing options"
msgstr "大小选项"

#, fuzzy
msgid ""
"When adding a node to a container, the way the container treats each child "
"depends mainly on their *container sizing options*. These options can be "
"found by inspecting the layout of any *Control* that is a child of a "
"*Container*."
msgstr ""
"当向容器添加节点时, 容器对待每个子元素的方式, 主要取决于它们的 *size flags尺"
"寸标记* . 通过检查 *容器* 的子控件, 可以找到这些标记."

#, fuzzy
msgid ""
"Sizing options are independent for vertical and horizontal sizing and not "
"all containers make use of them (but most do):"
msgstr ""
"尺寸标记独立于垂直和水平尺寸, 并不是所有容器都使用它们(但大多数容器都使用):"

msgid ""
"**Fill**: Ensures the control *fills* the designated area within the "
"container. No matter if a control *expands* or not (see below), it will only "
"*fill* the designated area when this is toggled on (it is by default)."
msgstr ""
"**Fill填充** : 确保控件 *fills填充* 容器内指定的区域. 无论控件是否 *expands扩"
"展* (见下面), 当此选项被选中时(默认情况), 只 *填充* 指定区域."

#, fuzzy
msgid ""
"**Expand**: Attempts to use as much space as possible in the parent "
"container (in each axis). Controls that don't expand will be pushed away by "
"those that do. Between expanding controls, the amount of space they take "
"from each other is determined by the *Stretch Ratio* (see below). This "
"option is only available when the parent Container is of the right type, for "
"example the *HBoxContainer* has this option for horizontal sizing."
msgstr ""
"**Expand扩展** : 试图在父容器中尽可能多地使用空间(在每个轴中). 不展开的控件会"
"被展开的控件推开. 在扩展的控件之间, 它们相互占用的空间大小由 *Ratio* 决定(见"
"下文)."

#, fuzzy
msgid ""
"**Shrink Begin** When expanding, try to remain at the left or top of the "
"expanded area."
msgstr ""
"**Shrink Center收缩中心** 当扩展时(如果不填充), 尽量保持在扩展区域的中心(默认"
"情况下, 它仍然位于左侧或顶部)."

#, fuzzy
msgid ""
"**Shrink Center** When expanding, try to remain at the center of the "
"expanded area."
msgstr ""
"**Shrink Center收缩中心** 当扩展时(如果不填充), 尽量保持在扩展区域的中心(默认"
"情况下, 它仍然位于左侧或顶部)."

#, fuzzy
msgid ""
"**Shrink End** When expanding, try to remain at the right or bottom of the "
"expanded area."
msgstr ""
"**Shrink Center收缩中心** 当扩展时(如果不填充), 尽量保持在扩展区域的中心(默认"
"情况下, 它仍然位于左侧或顶部)."

#, fuzzy
msgid ""
"**Stretch Ratio**: The ratio of how much expanded controls take up the "
"available space in relation to each other. A control with \"2\", will take "
"up twice as much available space as one with \"1\"."
msgstr ""
"**Ratio比例** 扩展控件之间, 相互占用可用空间的简单比例. 一个比例为 \"2\" 的控"
"件, 将占用比例为 \"1\" 控件的两倍可用空间."

msgid ""
"Experimenting with these flags and different containers is recommended to "
"get a better grasp on how they work."
msgstr "建议使用这些标记和不同的容器进行试验, 以便更好地了解它们是如何工作的."

msgid "Container types"
msgstr "容器类型"

msgid ""
"Godot provides several container types out of the box as they serve "
"different purposes:"
msgstr "Godot提供了几种开箱即用的容器类型, 因为它们有不同的用途:"

msgid "Box Containers"
msgstr "盒式容器"

msgid ""
"Arranges child controls vertically or horizontally (via :ref:`HBoxContainer "
"<class_HBoxContainer>` and :ref:`VBoxContainer <class_VBoxContainer>`). In "
"the opposite of the designated direction (as in, vertical for an horizontal "
"container), it just expands the children."
msgstr ""
"将子控件垂直或者水平排列（使用 :ref:`HBoxContainer <class_HBoxContainer>` "
"和 :ref:`VBoxContainer <class_VBoxContainer>` ）。而在相对方向上（比如水平容"
"器的垂直方向），子节点会被扩展。"

msgid ""
"These containers make use of the *Ratio* property for children with the "
"*Expand* flag set."
msgstr ""
"这些容器会用到设置了 *Expand（扩展）* 选项的子节点的 *Ratio（比例）* 属性。"

msgid "Grid Container"
msgstr "网格容器"

msgid ""
"Arranges child controls in a grid layout (via :ref:`GridContainer "
"<class_GridContainer>`, amount of columns must be specified). Uses both the "
"vertical and horizontal expand flags."
msgstr ""
"将子控件按照网格排列（使用 :ref:`GridContainer <class_GridContainer>` ，必须"
"指定列数），会同时用到垂直和水平扩展选项。"

msgid "Margin Container"
msgstr "边距容器"

msgid ""
"Child controls are expanded towards the bounds of this control (via :ref:"
"`MarginContainer <class_MarginContainer>`). Padding will be added on the "
"margins depending on the theme configuration."
msgstr ""
"将子节点扩展到该控件的边界（使用 :ref:`MarginContainer "
"<class_MarginContainer>` ），会根据主题的设置来添加不同大小的边距。"

msgid ""
"Again, keep in mind that the margins are a *Theme* value, so they need to be "
"edited from the constants overrides section of each control:"
msgstr ""
"同样, 请记住, 边距是一个 *Theme* 值, 所以它们需要从每个控件的常量重写部分进行"
"编辑:"

msgid "Tab Container"
msgstr "选项卡容器"

msgid ""
"Allows you to place several child controls stacked on top of each other "
"(via :ref:`TabContainer <class_TabContainer>`), with only the *current* one "
"visible."
msgstr ""
"允许你将多个子控件堆叠在一起（使用 :ref:`TabContainer "
"<class_TabContainer>` ），只会显示 *当前* 控件。"

msgid ""
"Changing the *current* one is done via tabs located at the top of the "
"container, via clicking:"
msgstr "点击容器顶部的选项卡可以更改 *当前* 控件："

msgid ""
"The titles are generated from the node names by default (although they can "
"be overridden via *TabContainer* API)."
msgstr ""
"标题默认是根据节点名称生成的（尽管可以通过 *TabContainer* 的 API 重写）。"

msgid ""
"Settings such as tab placement and *StyleBox* can be modified in the "
"*TabContainer* theme overrides."
msgstr ""
"可以在 *TabContainer* 的主题覆盖项中修改类似选项卡位置和 *StyleBox* 等设置。"

msgid "Split Container"
msgstr "拆分容器"

msgid ""
"Accepts only one or two children controls, then places them side to side "
"with a divisor (via :ref:`HSplitContainer <class_HSplitContainer>` and :ref:"
"`VSplitContainer <class_VSplitContainer>`). Respects both horizontal and "
"vertical flags, as well as *Ratio*."
msgstr ""
"只接受单个或者两个子控件，会将它们相邻放置，中间是分隔线（使用 :ref:"
"`HSplitContainer <class_HSplitContainer>` 和 :ref:`VSplitContainer "
"<class_VSplitContainer>` ），会使用到水平和垂直选项以及 *Ratio* 属性。"

msgid ""
"The divisor can be dragged around to change the size relation between both "
"children:"
msgstr "可以通过拖动分隔线来调整两个子节点所占区域的大小："

msgid "PanelContainer"
msgstr "PanelContainer"

#, fuzzy
msgid ""
"A container that draws a *StyleBox*, then expands children to cover its "
"whole area (via :ref:`PanelContainer <class_PanelContainer>`, respecting the "
"*StyleBox* margins). It respects both the horizontal and vertical sizing "
"options."
msgstr ""
"绘制 *StyleBox* 的简单容器，会将子节点扩大到整个区域（使用 :ref:"
"`PanelContainer <class_PanelContainer>`\\ ，会考虑 *StyleBox* 的边距）。它同"
"时考虑水平和垂直尺寸标志。"

msgid ""
"This container is useful as top-level, or just to add custom backgrounds to "
"sections of a layout."
msgstr "这个容器作为顶层非常有用, 或者只是为布局各个部分添加自定义背景."

msgid "ScrollContainer"
msgstr "ScrollContainer"

#, fuzzy
msgid ""
"Accepts a single child node. If this node is bigger than the container, "
"scrollbars will be added to allow panning the node around (via :ref:"
"`ScrollContainer <class_ScrollContainer>`). Both vertical and horizontal "
"size options are respected, and the behavior can be turned on or off per "
"axis in the properties."
msgstr ""
"接受一个单独的子节点. 如果这个节点比容器大, 将添加滚动条以允许移动节点（通"
"过 :ref:`ScrollContainer <class_ScrollContainer>`\\ ）。垂直和水平尺寸标志都"
"会被遵守，该行为可以在属性中的每个轴上打开或关闭."

msgid ""
"Mouse wheel and touch drag (when touch is available) are also valid ways to "
"pan the child control around."
msgstr "鼠标滚轮和触摸拖动(当触摸可用时)也是平移子控件的有效方法."

msgid ""
"As in the example above, one of the most common ways to use this container "
"is together with a *VBoxContainer* as child."
msgstr ""
"正如上面的例子中所展示的，使用此容器最常见的方法之一，是将 *VBoxContainer* 作"
"为子容器一起使用。"

#, fuzzy
msgid "AspectRatioContainer"
msgstr "SplitContainer"

msgid ""
"A container type that arranges its child controls in a way that preserves "
"their proportions automatically when the container is resized. (via :ref:"
"`AspectRatioContainer <class_AspectRatioContainer>`). It has multiple "
"stretch modes, providing options for adjusting the child controls' sizes "
"concerning the container: \"fill,\" \"width control height,\" \"height "
"control width,\" and \"cover.\""
msgstr ""

msgid ""
"useful when you have a container that needs to be dynamic and responsive to "
"different screen sizes, and you want the child elements to scale "
"proportionally without losing their intended shapes."
msgstr ""

#, fuzzy
msgid "FlowContainer"
msgstr "容器"

#, fuzzy
msgid ""
"FlowContainer is a container that arranges its child controls either "
"horizontally or vertically, (via :ref:`HFlowContainer "
"<class_HFlowContainer>` and via :ref:`VFlowContainer "
"<class_VFlowContainer>`). and when the available space runs out, it wraps "
"the children to the next line or column, similar to how text wraps in a book."
msgstr ""
"将子控件垂直或者水平排列（使用 :ref:`HBoxContainer <class_HBoxContainer>` "
"和 :ref:`VBoxContainer <class_VBoxContainer>` ）。而在相对方向上（比如水平容"
"器的垂直方向），子节点会被扩展。"

msgid ""
"useful for creating flexible layouts where the child controls adjust "
"automatically to the available space without overlapping."
msgstr ""

#, fuzzy
msgid "CenterContainer"
msgstr "PanelContainer"

msgid ""
"CenterContainer is a container that automatically keeps all of its child "
"controls centered within it at their minimum size. It ensures that the child "
"controls are always aligned to the center, making it easier to create "
"centered layouts without manual positioning. (via :ref:`CenterContainer "
"<class_CenterContainer>`)."
msgstr ""

msgid "SubViewportContainer"
msgstr "SubViewportContainer"

#, fuzzy
msgid ""
"This is a special control that will only accept a single *Viewport* node as "
"child, and it will display it as if it was an image (via :ref:"
"`SubViewportContainer <class_SubViewportContainer>`)."
msgstr ""
"这是一个特殊的控件，只接受单个 *Viewport* 节点作为子节点，并且会把它作为图片"
"显示（使用 :ref:`ViewportContainer <class_ViewportContainer>`）。"

msgid "Creating custom Containers"
msgstr "创建自定义容器"

#, fuzzy
msgid ""
"It is possible to create a custom container using a script. Here is an "
"example of a container that fits children to its rect size:"
msgstr ""
"可以使用脚本轻松地创建自定义容器。下面是一个简单容器的例子，它会根据自身的矩"
"形尺寸调整子节点："

msgid "Translation status"
msgstr "翻译状态"
