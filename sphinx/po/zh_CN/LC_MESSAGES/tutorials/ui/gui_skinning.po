# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Introduction to GUI skinning"
msgstr "GUI 皮肤简介"

msgid ""
"It is essential for a game to provide clear, informative, and yet visually "
"pleasing user interface to its players. While :ref:`Control <class_Control>` "
"nodes come with a decently functional look out of the box, there is always "
"room for uniqueness and case-specific tuning. For this purpose Godot engine "
"includes a system for GUI skinning (or theming), which allows you to "
"customize the look of every control in your user interface, including your "
"custom controls."
msgstr ""
"游戏必须为其玩家提供清晰、信息丰富且视觉上令人愉悦的用户界面。虽然 :ref:"
"`Control <class_Control>` 节点具有开箱即用的功能外观，但始终有独特性和特定于"
"案例的调整空间。为此，Godot 引擎包括一个用于 GUI 换肤（或主题化）的系统，它允"
"许你自定义用户界面中每个控件的外观，包括你的自定义控件。"

msgid ""
"Here is an example of this system in action — a game with the GUI that is "
"radically different from the default UI theme of the engine:"
msgstr ""
"下面是这个系统的一个例子—— 一个游戏的 GUI 与引擎的默认 UI 主题完全不同："

msgid "A \"Gear Up!\" screen in Tank Kings, courtesy of Winterpixel Games"
msgstr "《坦克王》中的“装备起来！”界面，由 Winterpixel Games 提供"

msgid ""
"Beyond achieving a unique look for your game, this system also enables "
"developers to provide customization options to the end users, including "
"accessibility settings. UI themes are applied in a cascading manner (i.e. "
"they propagate from parent controls to their children), which means that "
"font settings or adjustments for colorblind users can be applied in a single "
"place and affect the entire UI tree. Of course this system can also be used "
"for gameplay purposes: your hero-based game can change its style for the "
"selected player character, or you can give different flavors to the sides in "
"your team-based project."
msgstr ""
"除了为你的游戏实现独特的外观外，该系统还使开发人员能够为最终用户提供自定义选"
"项，包括交互设置。 UI 主题以级联方式应用（即从父控件传播到其子控件），这意味"
"着色盲用户的字体设置或调整，可以在从某处应用并影响整个 UI 树。当然，这个系统"
"也可以用于游戏：基于英雄的游戏可以为选定的玩家角色改变其风格，或者你可以为基"
"于团队的项目中的双方赋予不同的风格。"

msgid "Basics of themes"
msgstr "主题基础知识"

msgid ""
"The skinning system is driven by the :ref:`Theme <class_Theme>` resource. "
"Every Godot project has an inherent default theme that contains the settings "
"used by the built-in control nodes. This is what gives the controls their "
"distinct look out of the box. A theme only describes the configuration, "
"however, and it is still the job of each individual control to use that "
"configuration in the way it requires to display itself. This is important to "
"remember when implementing :ref:`your own custom controls "
"<doc_custom_gui_controls>`."
msgstr ""
"皮肤系统由 :ref:`Theme <class_Theme>` 资源驱动。每个 Godot 项目都有一个固有的"
"默认主题，其中包含内置控制节点使用的设置。这就是使控件具有开箱即用的独特外观"
"的原因。然而，主题仅用于描述配置，并且每个单独控件的工作仍然是按照显示自身所"
"需的方式使用该配置。在实现 :ref:`你自己的自定义控件 "
"<doc_custom_gui_controls>`\\ 时要记住这一点很重要。"

msgid ""
"Even the Godot editor itself relies on the default theme. But it doesn't "
"look the same as a Godot project, because it applies its own heavily "
"customized theme on top of the default one. In principle, this works exactly "
"like it would in your game as explained :ref:`below "
"<doc_gui_theme_in_project>`."
msgstr ""
"甚至 Godot 编辑器本身也依赖于默认主题。但它看起来与 Godot 项目不同，因为它在"
"默认主题之上应用了自己高度定制的主题。原则上，这与在你的游戏中的工作方式完全"
"相同，\\ :ref:`如下所述 <doc_gui_theme_in_project>`\\ 。"

msgid "Theme items"
msgstr "主题项目"

msgid ""
"The configuration that is stored in a theme consists of theme items. Each "
"item has a unique name and must be one of the following data types:"
msgstr ""
"存储在一个主题中的配置由主题项目组成。每个项目都有一个唯一的名称，并且必须是"
"以下数据类型之一："

msgid "**Color**"
msgstr "**Color**"

msgid ""
"A :ref:`color <class_Color>` value, which is often used for fonts and "
"backgrounds. Colors can also be used for modulation of controls and icons."
msgstr ""
":ref:`color <class_Color>` 值，通常用于字体和背景。颜色也可用于控件和图标的调"
"制。"

msgid "**Constant**"
msgstr "**常量**"

msgid ""
"An integer value, which can be used either for numeric properties of "
"controls (such as the item separation in a :ref:`BoxContainer "
"<class_BoxContainer>`), or for boolean flags (such as the drawing of "
"relationship lines in a :ref:`Tree <class_Tree>`)."
msgstr ""
"整型值，可用于控件的数字类型属性（例如 :ref:`BoxContainer "
"<class_BoxContainer>` 的间隙设置）或布尔值标记（例如 :ref:`Tree "
"<class_Tree>` 中是否绘制关系线条）。"

msgid "**Font**"
msgstr "**字体**"

msgid ""
"A :ref:`font <class_Font>` resource, which is used by controls that display "
"text. Fonts contain most text rendering settings, except for its size and "
"color. On top of that, alignment and text direction are controlled by "
"individual controls."
msgstr ""
"一个字体资源（\\ :ref:`font <class_Font>`\\ ），常常被用于显示控件中的文字。"
"字体包含了许多渲染设置，像字体的大小和颜色。之后呢，用另一个单独的控件来控制"
"对齐属性和文字方向。"

#, fuzzy
msgid "**Font size**"
msgstr "**字体**"

msgid ""
"An integer value, which is used alongside a font to determine the size at "
"which the text should be displayed."
msgstr ""

msgid "**Icon**"
msgstr "**图标**"

#, fuzzy
msgid ""
"A :ref:`texture <class_Texture2D>` resource, which is normally used to "
"display an icon (on a :ref:`Button <class_Button>`, for example)."
msgstr ""
"一个材质资源（\\ :ref:`texture <class_Texture>`\\ ），通常用于显示一个图标或"
"者图片（例如在按钮中 :ref:`Button <class_Button>`\\ ）。"

msgid "**StyleBox**"
msgstr "**样式盒**"

msgid ""
"A :ref:`StyleBox <class_StyleBox>` resource, a collection of configuration "
"options which define the way a UI panel should be displayed. This is not "
"limited to the :ref:`Panel <class_Panel>` control, as styleboxes are used by "
"many controls for their backgrounds and overlays."
msgstr ""
"一个样式盒资源（\\ :ref:`StyleBox <class_StyleBox>`\\ ），是一个用来定义一个"
"UI面板怎样展示的配置项集合。不只是用于面板控件（\\ :ref:`Panel "
"<class_Panel>`\\ ），它还常常用于许多控件的背景设置和遮罩设置。"

msgid "Theme types"
msgstr "主题类型"

msgid ""
"To help with the organization of its items each theme is separated into "
"types, and each item must belong to a single type. In other words, each "
"theme item is defined by its name, its data type and its theme type. This "
"combination must be unique within the theme. For example, there cannot be "
"two color items named ``font_color`` in a type called ``Label``, but there "
"can be another ``font_color`` item in a type ``LineEdit``."
msgstr ""
"为了更好地组织一个主题的结构，主题中的项目被划分为多个类型，并且每个项目只能"
"属于单个类型。每个主题项目由其名称、数据类型和主题中的类型这个三元组来定义。"
"这个三元组在主题中必须是唯一的。例如，\\ ``Label`` 类型中不能有两个叫做 "
"``font_color`` 的颜色项目，但是在 ``LineEdit`` 类型中可以有另一个叫做 "
"``font_color`` 的项目。"

msgid ""
"The default Godot theme comes with multiple theme types already defined, one "
"for every built-in control node that uses UI skinning. The example above "
"contains actual theme items present in the default theme. You can refer to "
"the **Theme Properties** section in the class reference for each control to "
"see which items are available to it and its child classes."
msgstr ""
"Godot 的默认主题诞生之初就已经定义了众多的主题类型，它内建于每个使用了 UI 皮"
"肤的控件节点中。在默认主题里上述例子都是目前再用的主题项目。你可以在每个控件"
"的类参考手册中查看\\ **主题属性**\\ 区域看看哪些项目是父类和子类都可用的。"

msgid ""
"Child classes can use theme items defined for their parent class (``Button`` "
"and its derivatives being a good example of that). In fact, every control "
"can use every theme item of any theme type, if it needs to (but for the "
"clarity and predictability we try to avoid that in the engine)."
msgstr ""
"子类可以使用为其父类定义的主题项， ``Button`` 及其派生类型就是很好实例。事实"
"上，如果需要的话，每个控件都可以使用任何主题类型的单个主题项，但为了清晰可"
"控，在引擎中尽量避免这样做。"

msgid ""
"It is important to remember that for child classes that process is "
"automated. Whenever a built-in control requests a theme item from the theme "
"it can omit the theme type, and its class name will be used instead. On top "
"of that, the class names of its parent classes will also be used in turn. "
"This allows changes to the parent class, such as ``Button``, to affect all "
"derived classes without the need to customize every one of them."
msgstr ""
"牢记子类中，哪些过程是自动执行的很重要.不论什么时候内建控件在主题里面请求主题"
"项目时，我们可以忽略主题类型仅通过它的类名知悉。之后呢，下次时我们能根据它的"
"父级类名来使用.可以通过改变父级类，例如 ``Button``\\ ，来影响所有派生类，而不"
"是调整每一个类来实现。"

msgid ""
"You can also define your own theme types, and additionally customize both "
"built-in controls and your own controls. Because built-in controls have no "
"knowledge of your custom theme types, you must utilize scripts to access "
"those items. All control nodes have several methods that allow to fetch "
"theme items from the theme that is applied to them. Those methods accept the "
"theme type as one of the arguments."
msgstr ""
"你当然可以定义你自己的主题类型,并且此外你还可以自定义所有内建控件和自建控件."
"因为内建控件不会有你自定义主题的内容，所以你必须使用脚本把它们加入到这些项目"
"中.所有控件节点都有一系列的方法可以用来把当前应用主题的主题项目都例遍出来.这"
"些方法通常是把主题类型做为一个可输入参数."

msgid ""
"To give more customization opportunities types can also be linked together "
"as type variations. This is another use-case for custom theme types. For "
"example, a theme can contain a type ``Header`` which can be marked as a "
"variation of the base ``Label`` type. An individual ``Label`` control can "
"then be set to use the ``Header`` variation for its type, and every time a "
"theme item is requested from a theme this variation will be used before any "
"other type. This allows to store various presets of theme items for the same "
"class of the control node in the single ``Theme`` resource."
msgstr ""
"为了提供更多的自定义可能性，类型还能够链接在一起成为变种。这是自定义主题类型"
"的另一种使用场景。例如，主题可以包含 ``Header`` 类型，标记为基础 ``Label`` 类"
"型的变种。那么各个 ``Label`` 控件就可以将其类型设为使用 ``Header`` 变种，主题"
"请求主题项目的时候，这个变种都会先于其他类型使用。这样就可以在同一个 "
"``Theme`` 资源里为同样使用某个类的控件节点保存不同主题项目的预设值。"

msgid ""
"Only variations available from the default theme or defined in the custom "
"project theme are shown in the Inspector dock as options. You can still "
"input manually the name of a variation that is defined outside of those two "
"places, but it is recommended to keep all variations to the project theme."
msgstr ""
"只有默认主题或者自定义项目主题中的变种才会在“检查器”中列为可选项。在这两处之"
"外定义的变种名称仍然可以手动输入，但是建议把所有变种都放到项目主题里面。"

msgid ""
"You can learn more about creating and using theme type variations in a :ref:"
"`dedicated article <doc_gui_theme_type_variations>`."
msgstr ""
"你可以通过\\ :ref:`专门的文章 <doc_gui_theme_type_variations>`\\ 了解到更多关"
"于主题类型变种的创建和使用的内容。"

msgid "Customizing a control"
msgstr "自定义控件"

msgid ""
"Each control node can be customized directly without the use of themes. This "
"is called local overrides. Every theme property from the control's class "
"reference can be overridden directly on the control itself, using either the "
"Inspector dock, or scripts. This allows to make granular changes to a "
"particular part of the UI, while not affecting anything else in the project, "
"including this control's children."
msgstr ""
"可以不用主题直接对各个控件节点进行自定义。这种方式称为本地重载。控件的类参考"
"手册中列出的每个主题属性，无论是通过检查器面板还是脚本，都可以在该控件上直接"
"重载。这样就可以针对 UI 中的特定部份进行精细的修改，不影响项目中包括该控件子"
"类在内的其他内容。"

msgid ""
"Local overrides are less useful for the visual flair of your user interface, "
"especially if you aim for consistency. However, for layout nodes these are "
"essential. Nodes such as :ref:`BoxContainer <class_BoxContainer>` and :ref:"
"`GridContainer <class_GridContainer>` use theme constants for defining "
"separation between their children, and :ref:`MarginContainer "
"<class_MarginContainer>` stores its customizable margins in its theme items."
msgstr ""
"本地重载对于提升用户界面的美观程度意义不大，如果你注重一致性的话就更是如此。"
"然而，本地重载对于布局节点而言是不可或缺的。\\ :ref:`BoxContainer "
"<class_BoxContainer>` 和 :ref:`GridContainer <class_GridContainer>` 等节点通"
"过主题常量定义其子节点的间隙大小，\\ :ref:`MarginContainer "
"<class_MarginContainer>` 用主题项目来保存自定义边距。"

msgid ""
"Whenever a control has a local theme item override, this is the value that "
"it uses. Values provided by the theme are ignored."
msgstr ""
"控件存在本地主题项目重载时，会直接使用这个值，主题中所提供的值会被忽略。"

msgid "Customizing a project"
msgstr "自定义项目"

msgid ""
"Out of the box each project adopts the default project theme provided by "
"Godot. The default theme itself is constant and cannot be changed, but its "
"items can be overridden with a custom theme. Custom themes can be applied in "
"two ways: as a project setting, and as a node property throughout the tree "
"of control nodes."
msgstr ""
"所有全新项目使用的都是 Godot 提供的默认项目主题。默认主题本身是常量，无法修"
"改，但可以通过自定义主题进行覆盖。设置自定义主题有两种方法：修改项目设置，或"
"者修改场景树控件节点的节点属性。"

msgid ""
"There are two project settings that can be adjusted to affect your entire "
"project: :ref:`gui/theme/custom<class_ProjectSettings_property_gui/theme/"
"custom>` allows you to set a custom project-wide theme, and :ref:`gui/theme/"
"custom_font<class_ProjectSettings_property_gui/theme/custom_font>` does the "
"same to the default fallback font. When a theme item is requested by a "
"control node the custom project theme, if present, is checked first. Only if "
"it doesn't have the item the default theme is checked."
msgstr ""
"当前有2个计划设定适用于你的整个计划项目 ::ref:`gui/theme/"
"custom<class_ProjectSettings_property_gui/theme/custom>` 允许你设置一种自定义"
"计划项目宽屏主题，并且 :ref:`gui/theme/"
"custom_font<class_ProjectSettings_property_gui/theme/custom_font>` 的功能和默"
"认的字体是一样的。当一个自定义主题的控件节点使用一个主题项目时，如果项目存在"
"它将被当先选中。只有当它不存在项目时，默认主题将被选中。"

msgid ""
"This allows you to configure the default look of every Godot control with a "
"single theme resource, but you can go more granular than that. Every control "
"node also has a :ref:`theme <class_Control_property_theme>` property, which "
"allows you to set a custom theme for the branch of nodes starting with that "
"control. This means that the control and all of its children, and their "
"children in turn, would first check that custom theme resource before "
"falling back on the project and the default themes."
msgstr ""
"在一个单独的主题资源中，你可以设置所有 Godot 控件的默认样式与外观,但是你可以"
"做更多的细节调整.每一个控件节点同样拥有一个\\ :ref:`主题 "
"<class_Control_property_theme>`\\ 属性，通过这个属性你可以为一个控件的所有节"
"点分支设置一个自定义的主题.那意味着那个控件与其所有的子类，和子类的子类，在回"
"滚当前项目和默认主题之前自定义主题的资源将第一个被检查。"

msgid ""
"Instead of changing the project setting you can set the custom theme "
"resource to the root-most control node of your entire UI branch to almost "
"the same effect. While in the running project it will behave as expected, "
"individual scenes will still display using the default theme when previewing "
"or running them directly. To fix that you can set the same theme resource to "
"the root control of each individual scene."
msgstr ""
"计划设定作为一种变化的替代手段，可以让你通过设置自定义主题资源对几乎整个UI分"
"支中的根控件节点做出相同的影响. 然而运行计划项目时可以充当预期效果展示,当单独"
"场景直接预览或者运行时还将使用默认主题展示。为了解决这个问题你可以为每一个单"
"独场景中的根控件设置相同的主题资源."

msgid ""
"For example, you can have a certain style for buttons in your project theme, "
"but want a different look for buttons inside of a popup dialog. You can set "
"a custom theme resource to the root control of your popup and define a "
"different style for buttons within that resource. As long as the chain of "
"control nodes between the root of the popup and the buttons is "
"uninterrupted, those buttons will use the styles defined in the theme "
"resource that is closest to them. All other controls will still be styled "
"using the project-wide theme and the default theme styles."
msgstr ""
"例如，你可以在项目主题中为按钮设置特定的样式，希望在弹出对话框中的按钮又有不"
"同的外观。你可以为弹出窗口的根控件设置自定义主题资源，并在该资源中为按钮定义"
"不同的样式。只要弹出窗口的根控件和按钮之间的节点链不中断，这些按钮就会使用最"
"接近它们的主题资源中定义的样式。所有其他控件仍将使用整个项目的主题和默认的主"
"题样式。"

msgid ""
"To sum it up, for an arbitrary control its theme item lookup would look "
"something like this:"
msgstr "综上所述，对于任意控件，其主题项的查找会是这样的："

msgid "Check for local overrides of the same data type and name."
msgstr "检查相同数据类型和名称的本地重写。"

#, fuzzy
msgid "Using control's type variation, class name and parent class names:"
msgstr "使用控件的类名和父类名："

msgid ""
"Check every control starting from itself and see if it has a theme property "
"set;"
msgstr "从自身开始检查每个控件，看看它是否设置了主题属性；"

msgid ""
"If it does, check that theme for the matching item of the same name, data "
"and theme type;"
msgstr "如果设置了，就在该主题中查找名称、数据、主题类型都相同的项目；"

msgid ""
"If there is no custom theme or it doesn't have the item, move to the parent "
"control;"
msgstr "如果没有自定义主题，或者主题中没有匹配的条目，就前往父控件；"

msgid ""
"Repeat steps a-c. until the root of the tree is reached, or a non-control "
"node is reached."
msgstr "重复步骤 a 至 c，到场景树的根节点或者非控件节点为止。"

#, fuzzy
msgid ""
"Using control's type variation, class name and parent class names check the "
"project-wide theme, if it's present."
msgstr "如果存在项目范围的主题，就在这个主题中查找控件的类名。"

#, fuzzy
msgid ""
"Using control's type variation, class name and parent class names check the "
"default theme."
msgstr "在默认主题中查找控件的类名。"

msgid ""
"Even if the item doesn't exist in any theme, a corresponding default value "
"for that data type will be returned."
msgstr "即便所有主题中都不存在对应的项目，也会返回一个针对该数据类型的默认值。"

msgid "Beyond controls"
msgstr "超越控件"

msgid ""
"Naturally, themes are an ideal type of resource for storing configuration "
"for something visual. While the support for theming is built into control "
"nodes, other nodes can use them as well, just like any other resource."
msgstr ""
"主题是一种用来保存视觉效果配置的理想资源，也非常合理。虽然其他节点并没有像控"
"件节点一样内置针对主题的支持，但还是可以和使用其他资源一样来使用主题。"

msgid ""
"An example of using themes for something beyond controls can be a modulation "
"of sprites for the same units on different teams in a strategy game. A theme "
"resource can define a collection of colors, and sprites (with a help from "
"scripts) can use those colors to draw the texture. The main benefit being "
"that you could make different themes using the same theme items for red, "
"blue, and green teams, and swap them with a single resource change."
msgstr ""
"举个非控件使用主题的例子：在策略游戏中，相同单位需要根据队伍的不同而使用不同"
"颜色的精灵。可以在主题资源中定义颜色的合集，精灵（在脚本的帮助下）就可以使用"
"这些颜色来绘制纹理。这样做的最大好处是可以为红绿蓝队制作不同的主题但使用相同"
"的主题项目，切换队伍只需要替换资源就可以了。"

msgid "Translation status"
msgstr "翻译状态"
