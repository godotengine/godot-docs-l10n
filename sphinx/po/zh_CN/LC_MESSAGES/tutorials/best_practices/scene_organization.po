# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Scene organization"
msgstr "场景组织"

msgid ""
"This article covers topics related to the effective organization of scene "
"content. Which nodes should one use? Where should one place them? How should "
"they interact?"
msgstr ""
"本文讨论与场景内容的有效组织相关的主题。应该使用哪些节点？应该把它们放在哪"
"里？它们应该如何互动？"

msgid "How to build relationships effectively"
msgstr "如何有效地建立关系"

msgid ""
"When Godot users begin crafting their own scenes, they often run into the "
"following problem:"
msgstr "当 Godot 用户开始制作自己的场景时，他们经常遇到以下问题："

msgid ""
"They create their first scene and fill it with content only to eventually "
"end up saving branches of their scene into separate scenes as the nagging "
"feeling that they should split things up starts to accumulate. However, they "
"then notice that the hard references they were able to rely on before are no "
"longer possible. Re-using the scene in multiple places creates issues "
"because the node paths do not find their targets and signal connections "
"established in the editor break."
msgstr ""
"他们创建了自己的第一个场景并填满内容，但随着应该把事情分解的烦人感觉开始积"
"累，他们最终把场景的分支保存为单独的场景。可他们接着就注意到之前能够依赖的硬"
"引用不能用了。在多个地方重用场景会出现问题，因为节点路径找不到目标，在编辑器"
"中建立的信号连接也失效了。"

msgid ""
"To fix these problems, one must instantiate the sub-scenes without them "
"requiring details about their environment. One needs to be able to trust "
"that the sub-scene will create itself without being picky about how one uses "
"it."
msgstr ""
"要解决这些问题，必须实例化子场景，而子场景不能依赖所处环境中的详细信息。子场"
"景应该能够保证自身创建的时候对别人如何用它没有过分的要求。"

msgid ""
"One of the biggest things to consider in OOP is maintaining focused, "
"singular-purpose classes with `loose coupling <https://en.wikipedia.org/wiki/"
"Loose_coupling>`_ to other parts of the codebase. This keeps the size of "
"objects small (for maintainability) and improves their reusability."
msgstr ""
"在 OOP 中需要考虑的最大的事情之一是维护目标明确、单一的类，与代码库的其他部分"
"进行\\ `松散的耦合 <https://en.wikipedia.org/wiki/Loose_coupling>`_\\ 。这样"
"可以使对象的大小保持在较小的范围内（便于维护），提高可重用性。"

msgid ""
"These OOP best practices have *several* implications for best practices in "
"scene structure and script usage."
msgstr "这些 OOP 最佳实践对场景结构和脚本使用的有\\ *很多*\\ 意义。"

msgid ""
"**If at all possible, one should design scenes to have no dependencies.** "
"That is, one should create scenes that keep everything they need within "
"themselves."
msgstr ""
"**应该尽可能设计没有依赖项的场景。**\\ 也就是说，创建的场景应该将所需的一切保"
"留在其内部。"

msgid ""
"If a scene must interact with an external context, experienced developers "
"recommend the use of `Dependency Injection <https://en.wikipedia.org/wiki/"
"Dependency_injection>`_. This technique involves having a high-level API "
"provide the dependencies of the low-level API. Why do this? Because classes "
"which rely on their external environment can inadvertently trigger bugs and "
"unexpected behavior."
msgstr ""
"如果场景必须与外部环境交互，经验丰富的开发人员会建议使用\\ `依赖注入 "
"<https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5>`_\\ 。该"
"技术涉及使高级 API 提供低级 API 的依赖关系。为什么要这样呢？因为依赖于其外部"
"环境的类可能会无意中触发 Bug 和意外行为。"

msgid ""
"To do this, one must expose data and then rely on a parent context to "
"initialize it:"
msgstr "要做到这一点，就必须暴露数据，依靠父级上下文对其进行初始化："

msgid ""
"Connect to a signal. Extremely safe, but should be used only to \"respond\" "
"to behavior, not start it. Note that signal names are usually past-tense "
"verbs like \"entered\", \"skill_activated\", or \"item_collected\"."
msgstr ""
"连接信号。极其安全，但只能用于“响应”行为，而不是启动它。请注意，信号名称通常"
"是过去式动词，如“entered”“skill_activated”“item_collected”（已进入、已激活技"
"能、已收集道具）。"

msgid "Call a method. Used to start behavior."
msgstr "调用方法。用于启动行为。"

msgid ""
"Initialize a :ref:`FuncRef <class_FuncRef>` property. Safer than a method as "
"ownership of the method is unnecessary. Used to start behavior."
msgstr ""
"初始化 :ref:`FuncRef <class_FuncRef>` 属性。比方法更安全，因为方法无须考虑所"
"有权。用于启动行为。"

msgid "Initialize a Node or other Object reference."
msgstr "初始化 Node 或其他 Object 的引用。"

msgid "Initialize a NodePath."
msgstr "初始化 NodePath。"

msgid ""
"These options hide the points of access from the child node. This in turn "
"keeps the child **loosely coupled** to its environment. One can re-use it in "
"another context without any extra changes to its API."
msgstr ""
"这些选项隐藏了子节点的访问点. 这反过来又使子节点与环境保持 **松耦合** . 人们"
"可以在另外一个上下文中重新使用它, 而不需要对API做任何额外的改变."

msgid ""
"Although the examples above illustrate parent-child relationships, the same "
"principles apply towards all object relations. Nodes which are siblings "
"should only be aware of their hierarchies while an ancestor mediates their "
"communications and references."
msgstr ""
"虽然上面的例子说明了父子关系, 但是同样的原则也适用于所有对象之间的关系. 兄弟"
"节点应该只知道它们的层次结构, 而先祖节点则负责协调它们的通信和引用."

msgid ""
"The same principles also apply to non-Node objects that maintain "
"dependencies on other objects. Whichever object actually owns the objects "
"should manage the relationships between them."
msgstr ""
"同样的原则也适用于, 维护对其他对象依赖关系的非节点对象. 无论哪个对象实际拥有"
"这些对象, 都应该管理它们之间的关系."

msgid ""
"One should favor keeping data in-house (internal to a scene) though as "
"placing a dependency on an external context, even a loosely coupled one, "
"still means that the node will expect something in its environment to be "
"true. The project's design philosophies should prevent this from happening. "
"If not, the code's inherent liabilities will force developers to use "
"documentation to keep track of object relations on a microscopic scale; this "
"is otherwise known as development hell. Writing code that relies on external "
"documentation for one to use it safely is error-prone by default."
msgstr ""
"人们应该倾向于将数据保存在内部(场景内部), 尽管它对外部上下文有一个依赖, 即使"
"是一个松散耦合的依赖, 仍然意味着节点, 将期望其环境中的某些内容为真. 项目的设"
"计理念应防止这种情况的发生. 如果不是这样, 代码的继承的责任将迫使开发人员使用"
"文档, 以在微观尺度上跟踪对象关系；这就是所谓的开发地狱. 默认情况下, 编写依赖"
"于外部文档的代码, 让人们安全地使用它, 是很容易出错的."

msgid ""
"To avoid creating and maintaining such documentation, one converts the "
"dependent node (\"child\" above) into a tool script that implements :ref:"
"`_get_configuration_warning() "
"<class_Node_method__get_configuration_warning>`. Returning a non-empty "
"string from it will make the Scene dock generate a warning icon with the "
"string as a tooltip by the node. This is the same icon that appears for "
"nodes such as the :ref:`Area2D <class_Area2D>` node when it has no child :"
"ref:`CollisionShape2D <class_CollisionShape2D>` nodes defined. The editor "
"then self-documents the scene through the script code. No content "
"duplication via documentation is necessary."
msgstr ""
"为了避免创建和维护此类文档, 可以将依赖节点(上面的子级)转换为工具脚本, 该脚本"
"实现 :ref:`_get_configuration_warning() "
"<class_Node_method__get_configuration_warning>`. 从中返回一个非空字符串, 将使"
"场景停靠面板生成警告图标, 该字符串作为节点的工具提示. 当它没有定义 :ref:"
"`CollisionShape2D <class_CollisionShape2D>` 子节点时, 是相同图标, 即显示为节"
"点如 :ref:`Area2D <class_Area2D>` 节点的图标. 然后, 编辑器通过脚本代码自行记"
"录场景. 通过文档, 没有内容复制是必要的."

msgid ""
"A GUI like this can better inform project users of critical information "
"about a Node. Does it have external dependencies? Have those dependencies "
"been satisfied? Other programmers, and especially designers and writers, "
"will need clear instructions in the messages telling them what to do to "
"configure it."
msgstr ""
"这样的GUI可以更好地通知项目用户有关节点的关键信息. 它具有外部依赖性吗？这些依"
"赖性是否得到满足？其他程序员, 尤其是设计师和作家, 将需要消息中的明确指示, 告"
"诉他们如何进行配置."

msgid ""
"So, why do all this complex switcharoo work? Well, because scenes operate "
"best when they operate alone. If unable to work alone, then working with "
"others anonymously (with minimal hard dependencies, i.e. loose coupling) is "
"the next best thing. Inevitably, changes may need to be made to a class and "
"if these changes cause it to interact with other scenes in unforeseen ways, "
"then things will start to break down. The whole point of all this "
"indirection is to avoid ending up in a situation where changing one class "
"results in adversely effecting other classes."
msgstr ""
"那么, 为什么这些复杂的开关都起作用呢？嗯, 因为场景在单独工作时运行得最好. 如"
"果不能单独工作, 那么与别人匿名运行(最小化强依赖, 即松散耦合)是下下之策. 不可"
"避免地, 可能需要对一个类进行更改, 如果这些更改导致它以不可预见的方式与其他场"
"景交互, 那么事情就会开始崩溃. 所有这些间接性的目的就是为了避免最终出现改变一"
"个类导致对其他类产生不利影响的情况."

msgid ""
"Scripts and scenes, as extensions of engine classes, should abide by *all* "
"OOP principles. Examples include..."
msgstr "脚本和场景作为引擎类的扩展, 应该遵守 *所有* 的OOP原则. 例如..."

msgid "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"
msgstr "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"

msgid "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"
msgstr "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"

msgid "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"
msgstr "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"

msgid "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"
msgstr "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"

msgid "Choosing a node tree structure"
msgstr "选择节点树结构"

msgid ""
"So, a developer starts work on a game only to stop at the vast possibilities "
"before them. They might know what they want to do, what systems they want to "
"have, but *where* to put them all? Well, how one goes about making their "
"game is always up to them. One can construct node trees in countless ways. "
"But, for those who are unsure, this helpful guide can give them a sample of "
"a decent structure to start with."
msgstr ""
"从前有个开发者开始开发游戏，却因为海量的可能性而犹豫不前。他可能知道自己想做"
"什么、想要什么样的系统，但是应该把这些东西落实在 *哪里* 呢？好吧，自己做的游"
"戏当然自己说了算。虽然节点树的构造方法有无数种，但对于没把握的人而言，这份指"
"南可以展示一个比较像样的结构作为基础。"

msgid ""
"A game should always have a sort of \"entry point\"; somewhere the developer "
"can definitively track where things begin so that they can follow the logic "
"as it continues elsewhere. This place also serves as a bird's eye view of "
"all of the other data and logic in the program. For traditional "
"applications, this would be the \"main\" function. In this case, it would be "
"a Main node."
msgstr ""
"一个游戏总是应该有一种“入口点”；这是开发者可以明确地追踪到运行的开始位置，以"
"便他们可以在其他地方继续运行逻辑。这个地方也可以作为程序中所有其他数据和逻辑"
"的总览图。对于传统的应用程序，这将是“main”函数。在这种情况下，它将是一个 "
"Main 节点。"

msgid "Node \"Main\" (main.gd)"
msgstr "“Main”节点（main.gd）"

msgid ""
"The ``main.gd`` script would then serve as the primary controller of one's "
"game."
msgstr "``main.gd`` 脚本将作为游戏的主要控制器。"

msgid ""
"Then one has their actual in-game \"World\" (a 2D or 3D one). This can be a "
"child of Main. In addition, one will need a primary GUI for their game that "
"manages the various menus and widgets the project needs."
msgstr ""
"然后你便拥有了真正的游戏“世界”（二维或三维）。这可以是 Main 的子节点。另外，"
"他们的游戏将需要一个主要的 GUI，来管理项目所需的各种菜单和小部件。"

msgid "Node2D/Spatial \"World\" (game_world.gd)"
msgstr "Node2D/Spatial“世界”（game_world.gd）"

msgid "Control \"GUI\" (gui.gd)"
msgstr "Control“GUI”（gui.gd）"

msgid ""
"When changing levels, one can then swap out the children of the \"World\" "
"node. :ref:`Changing scenes manually <doc_change_scenes_manually>` gives "
"users full control over how their game world transitions."
msgstr ""
"当变更关卡时，可以稍后换出“World”节点的子级。\\ :ref:`手动更换场景 "
"<doc_change_scenes_manually>`\\ 让用户完全控制他们的游戏世界如何过渡。"

msgid ""
"The next step is to consider what gameplay systems one's project requires. "
"If one has a system that..."
msgstr "下一步是考虑项目需要什么样的游戏系统。如果有这么一个系统……"

msgid "tracks all of its data internally"
msgstr "跟踪所有的内部数据"

msgid "should be globally accessible"
msgstr "应该是全局可访问的"

msgid "should exist in isolation"
msgstr "应该是独立存在的"

msgid ""
"... then one should create an :ref:`autoload 'singleton' node "
"<doc_singletons_autoload>`."
msgstr ""
"…那么应该创建一个 :ref:`自动加载单例节点 <doc_singletons_autoload>` 节点."

msgid ""
"For smaller games, a simpler alternative with less control would be to have "
"a \"Game\" singleton that simply calls the :ref:`SceneTree.change_scene() "
"<class_SceneTree_method_change_scene>` method to swap out the main scene's "
"content. This structure more or less keeps the \"World\" as the main game "
"node."
msgstr ""
"对于较小的游戏, 一个更简单, 具有更少控制的选择, 是拥有一个游戏单例, 简单地调"
"用 :ref:`SceneTree.change_scene() <class_SceneTree_method_change_scene>` 方法"
"以交换出主场景的内容. 这种结构或多或少保留“World”作为主要游戏节点."

msgid ""
"Any GUI would need to also be a singleton; be a transitory part of the "
"\"World\"; or be manually added as a direct child of the root. Otherwise, "
"the GUI nodes would also delete themselves during scene transitions."
msgstr ""
"任何GUI也需要是一个单例；是 \"世界\" 的一个过渡部分；或者是作为根节点的直接子"
"节点手动添加. 否则,GUI节点也会在场景转换时自行删除."

msgid ""
"If one has systems that modify other systems' data, one should define those "
"as their own scripts or scenes rather than autoloads. For more information "
"on the reasons, please see the :ref:`Autoloads versus regular nodes "
"<doc_autoloads_versus_internal_nodes>` documentation."
msgstr ""
"如果一个系统需要修改另一个系统的数据，那么就应该把它们分别定义成单独的脚本或"
"者场景，不应该使用自动加载。其原因请参考文档\\ :ref:`自动加载与普通节点 "
"<doc_autoloads_versus_internal_nodes>`\\ 。"

msgid ""
"Each subsystem within one's game should have its own section within the "
"SceneTree. One should use parent-child relationships only in cases where "
"nodes are effectively elements of their parents. Does removing the parent "
"reasonably mean that one should also remove the children? If not, then it "
"should have its own place in the hierarchy as a sibling or some other "
"relation."
msgstr ""
"游戏中的每个子系统在 ``SceneTree`` 中应有其自己的部分. 仅在节点是其父级的有效"
"元素的情况下, 才应使用父子关系. 合理地移除父级是否意味着也应删除子级？如果没"
"有, 那么它应在层次结构中有自己的位置, 作为同级关系或其他关系."

msgid ""
"In some cases, one needs these separated nodes to *also* position themselves "
"relative to each other. One can use the :ref:`RemoteTransform "
"<class_RemoteTransform>` / :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>` nodes for this purpose. They will allow a target "
"node to conditionally inherit selected transform elements from the Remote\\* "
"node. To assign the ``target`` :ref:`NodePath <class_NodePath>`, use one of "
"the following:"
msgstr ""
"在某些情况下，我们会需要让这些分离的节点\\ *仍然*\\ 相对彼此进行定位。为此，"
"可以使用 :ref:`RemoteTransform <class_RemoteTransform>` / :ref:"
"`RemoteTransform2D <class_RemoteTransform2D>` 节点。它们将允许目标节点有条件"
"地从 Remote\\* 节点继承选定的变换元素。要分配 ``target`` 的 :ref:`NodePath "
"<class_NodePath>`\\ ，请使用以下方法之一："

msgid ""
"A reliable third party, likely a parent node, to mediate the assignment."
msgstr "一个可靠的第三方, 可能是一个父节点, 来协调分配任务."

msgid ""
"A group, to easily pull a reference to the desired node (assuming there will "
"only ever be one of the targets)."
msgstr "一个编组, 轻松提取对所需节点的引用(假设只有一个目标)."

msgid ""
"When should one do this? Well, this is subjective. The dilemma arises when "
"one must micro-manage when a node must move around the SceneTree to preserve "
"itself. For example..."
msgstr ""
"什么时候应该这样做呢？哎，这是比较主观了。当一个节点必须在 SceneTree 上移动以"
"保护自己时，就会出现两难的局面。例如……"

msgid "Add a \"player\" node to a \"room\"."
msgstr "将“玩家”节点到“房间”。"

msgid "Need to change rooms, so one must delete the current room."
msgstr "要改变房间，那么就必须删除当前房间。"

msgid ""
"Before the room can be deleted, one must preserve and/or move the player."
msgstr "在删除这个房间之前，必须保留并且/或者移动玩家。"

msgid "Is memory a concern?"
msgstr "需要关心内存吗？"

msgid ""
"If not, one can just create the two rooms, move the player and delete the "
"old one. No problem."
msgstr ""
"如果不关心，那么就可以创建两个房间，移动玩家，然后删掉旧房间。没有问题。"

msgid "If so, one will need to..."
msgstr "如果关心，那么就需要……"

msgid "Move the player somewhere else in the tree."
msgstr "将玩家移动到树的其他地方。"

msgid "Delete the room."
msgstr "删除房间。"

msgid "Instantiate and add the new room."
msgstr "实例化并添加房间。"

msgid "Re-add the player."
msgstr "重新添加玩家。"

msgid ""
"The issue is that the player here is a \"special case\"; one where the "
"developers must *know* that they need to handle the player this way for the "
"project. As such, the only way to reliably share this information as a team "
"is to *document* it. Keeping implementation details in documentation however "
"is dangerous. It's a maintenance burden, strains code readability, and "
"bloats the intellectual content of a project unnecessarily."
msgstr ""
"问题在于这里的角色是一种“特殊情况”；开发者必须\\ *知道*\\ 需要以这种方式处理"
"项目中的角色。因此，在团队中可靠地分享这些信息的唯一方法就是\\ *写文档*\\ 。"
"然而，在文档中记录实现细节是很危险的，会成为一种维护负担，使代码可读性下降，"
"不必要地膨胀项目的知识内容。"

msgid ""
"In a more complex game with larger assets, it can be a better idea to simply "
"keep the player somewhere else in the SceneTree entirely. This results in:"
msgstr ""
"在拥有更多的资产的，更复杂的游戏，简单地将玩家完全保留在 SceneTree 中的其他地"
"方会更好。这样的好处是："

msgid "More consistency."
msgstr "一致性更高。"

msgid "No \"special cases\" that must be documented and maintained somewhere."
msgstr "没有“特殊情况”，不必写入文档也不必进行维护。"

msgid ""
"No opportunity for errors to occur because these details are not accounted "
"for."
msgstr "因为不需要考虑这些细节，所以也没有出错的机会。"

msgid ""
"In contrast, if one ever needs to have a child node that does *not* inherit "
"the transform of their parent, one has the following options:"
msgstr "相比之下，如果需要子节点\\ *不*\\ 继承父节点的变换，那么就有以下选项："

msgid ""
"The **declarative** solution: place a :ref:`Node <class_Node>` in between "
"them. As nodes with no transform, Nodes will not pass along such information "
"to their children."
msgstr ""
"**声明式**\\ 解决方案：在它们之间放置一个 :ref:`Node <class_Node>`\\ 。作为没"
"有变换的节点，Node 不会将这些信息传递给其子节点。"

msgid ""
"The **imperative** solution: Use the ``set_as_toplevel`` setter for the :ref:"
"`CanvasItem <class_CanvasItem_method_set_as_toplevel>` or :ref:`Spatial "
"<class_Spatial_method_set_as_toplevel>` node. This will make the node ignore "
"its inherited transform."
msgstr ""
"**命令式**\\ 解决方案：对 :ref:`CanvasItem "
"<class_CanvasItem_method_set_as_toplevel>` 或者 :ref:`Spatial "
"<class_Spatial_method_set_as_toplevel>` 节点使用 ``set_as_toplevel`` 函数。这"
"样就会让该节点忽略其继承的变换。"

msgid ""
"If building a networked game, keep in mind which nodes and gameplay systems "
"are relevant to all players versus those just pertinent to the authoritative "
"server. For example, users do not all need to have a copy of every players' "
"\"PlayerController\" logic. Instead, they need only their own. As such, "
"keeping these in a separate branch from the \"world\" can help simplify the "
"management of game connections and the like."
msgstr ""
"如果构建的是网络游戏，请记住哪些节点和游戏系统与所有玩家相关，而哪些只与权威"
"服务器相关。例如，用户并不需要所有人都拥有每个玩家的“PlayerController”逻辑的"
"副本。相反，他们只需要自己的。这样，将它们保持在从“世界”分离的独立的分支中，"
"可以帮助简化游戏连接等的管理。"

msgid ""
"The key to scene organization is to consider the SceneTree in relational "
"terms rather than spatial terms. Are the nodes dependent on their parent's "
"existence? If not, then they can thrive all by themselves somewhere else. If "
"they are dependent, then it stands to reason that they should be children of "
"that parent (and likely part of that parent's scene if they aren't already)."
msgstr ""
"场景组织的关键是用关系树而不是空间树来考虑 SceneTree。节点是否依赖于其父节点"
"的存在？如果不是，那么它们可以自己在别的地方茁壮成长。如果它们是依赖性的，那"
"么理所当然它们应该是父节点的子节点（如果它们还不是父节点场景的一部分，那么很"
"可能是父节点场景的一部分）。"

msgid ""
"Does this mean nodes themselves are components? Not at all. Godot's node "
"trees form an aggregation relationship, not one of composition. But while "
"one still has the flexibility to move nodes around, it is still best when "
"such moves are unnecessary by default."
msgstr ""
"这是否意味着节点本身就是组件？并不是这样。Godot 的节点树形成的是聚合关系，不"
"是组合关系。虽然依旧可以灵活地移动节点，但在默认情况下是没有进行移动的必要"
"的。"

msgid "Translation status"
msgstr "翻译状态"
