# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Scene organization"
msgstr "场景组织"

msgid ""
"This article covers topics related to the effective organization of scene "
"content. Which nodes should one use? Where should one place them? How should "
"they interact?"
msgstr ""
"本文讨论与场景内容的有效组织相关的主题。应该使用哪些节点？应该把它们放在哪"
"里？它们应该如何互动？"

msgid "How to build relationships effectively"
msgstr "如何有效地建立关系"

msgid ""
"When Godot users begin crafting their own scenes, they often run into the "
"following problem:"
msgstr "当 Godot 用户开始制作自己的场景时，他们经常遇到以下问题："

msgid ""
"They create their first scene and fill it with content only to eventually "
"end up saving branches of their scene into separate scenes as the nagging "
"feeling that they should split things up starts to accumulate. However, they "
"then notice that the hard references they were able to rely on before are no "
"longer possible. Re-using the scene in multiple places creates issues "
"because the node paths do not find their targets and signal connections "
"established in the editor break."
msgstr ""
"他们创建了自己的第一个场景并填满内容，但随着应该把事情分解的烦人感觉开始积"
"累，他们最终把场景的分支保存为单独的场景。可他们接着就注意到之前能够依赖的硬"
"引用不能用了。在多个地方重用场景会出现问题，因为节点路径找不到目标，在编辑器"
"中建立的信号连接也失效了。"

msgid ""
"To fix these problems, one must instantiate the sub-scenes without them "
"requiring details about their environment. One needs to be able to trust "
"that the sub-scene will create itself without being picky about how one uses "
"it."
msgstr ""
"要解决这些问题，必须实例化子场景，而子场景不能依赖所处环境中的详细信息。子场"
"景应该能够保证自身创建的时候对别人如何用它没有过分的要求。"

msgid ""
"One of the biggest things to consider in OOP is maintaining focused, "
"singular-purpose classes with `loose coupling <https://en.wikipedia.org/wiki/"
"Loose_coupling>`_ to other parts of the codebase. This keeps the size of "
"objects small (for maintainability) and improves their reusability."
msgstr ""
"在 OOP 中需要考虑的最大的事情之一是维护目标明确、单一的类，与代码库的其他部分"
"进行\\ `松散的耦合 <https://en.wikipedia.org/wiki/Loose_coupling>`_\\ 。这样"
"可以使对象的大小保持在较小的范围内（便于维护），提高可重用性。"

msgid ""
"These OOP best practices have *several* implications for best practices in "
"scene structure and script usage."
msgstr "这些 OOP 最佳实践对场景结构和脚本使用的有\\ *很多*\\ 意义。"

msgid ""
"**If at all possible, one should design scenes to have no dependencies.** "
"That is, one should create scenes that keep everything they need within "
"themselves."
msgstr ""
"**应该尽可能设计没有依赖项的场景。**\\ 也就是说，创建的场景应该将所需的一切保"
"留在其内部。"

msgid ""
"If a scene must interact with an external context, experienced developers "
"recommend the use of `Dependency Injection <https://en.wikipedia.org/wiki/"
"Dependency_injection>`_. This technique involves having a high-level API "
"provide the dependencies of the low-level API. Why do this? Because classes "
"which rely on their external environment can inadvertently trigger bugs and "
"unexpected behavior."
msgstr ""
"如果场景必须与外部环境交互，经验丰富的开发人员会建议使用\\ `依赖注入 "
"<https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5>`_\\ 。该"
"技术涉及使高级 API 提供低级 API 的依赖关系。为什么要这样呢？因为依赖于其外部"
"环境的类可能会无意中触发 Bug 和意外行为。"

msgid ""
"To do this, one must expose data and then rely on a parent context to "
"initialize it:"
msgstr "要做到这一点，就必须暴露数据，依靠父级上下文对其进行初始化："

msgid ""
"Connect to a signal. Extremely safe, but should be used only to \"respond\" "
"to behavior, not start it. By convention, signal names are usually past-"
"tense verbs like \"entered\", \"skill_activated\", or \"item_collected\"."
msgstr ""
"连接信号。这样做极其安全，但只能用于“响应”行为，而不是启动行为。按照惯例，信"
"号名称通常是过去式动词，如“entered”“skill_activated”“item_collected”（已进"
"入、已激活技能、已收集道具）。"

msgid "Call a method. Used to start behavior."
msgstr "调用方法。用于启动行为。"

msgid ""
"Initialize a :ref:`Callable <class_Callable>` property. Safer than a method "
"as ownership of the method is unnecessary. Used to start behavior."
msgstr ""
"初始化 :ref:`Callable <class_Callable>` 属性。比调用方法更安全，因为不需要拥"
"有这个方法的所有权。用于启动行为。"

msgid "Initialize a Node or other Object reference."
msgstr "初始化 Node 或其他 Object 的引用。"

msgid "Initialize a NodePath."
msgstr "初始化 NodePath。"

msgid ""
"These options hide the points of access from the child node. This in turn "
"keeps the child **loosely coupled** to its environment. One can reuse it in "
"another context without any extra changes to its API."
msgstr ""
"这些选项隐藏了子节点的访问点。这反过来又使子节点与环境保持 **松耦合** "
"（loosely coupled）。人们可以在另外一个上下文中重新使用它，而不需要对API做任"
"何额外的改变。"

msgid ""
"Although the examples above illustrate parent-child relationships, the same "
"principles apply towards all object relations. Nodes which are siblings "
"should only be aware of their hierarchies while an ancestor mediates their "
"communications and references."
msgstr ""
"虽然上面的例子说明了父子关系, 但是同样的原则也适用于所有对象之间的关系. 兄弟"
"节点应该只知道它们的层次结构, 而先祖节点则负责协调它们的通信和引用."

msgid ""
"The same principles also apply to non-Node objects that maintain "
"dependencies on other objects. Whichever object actually owns the objects "
"should manage the relationships between them."
msgstr ""
"同样的原则也适用于, 维护对其他对象依赖关系的非节点对象. 无论哪个对象实际拥有"
"这些对象, 都应该管理它们之间的关系."

msgid ""
"One should favor keeping data in-house (internal to a scene) though as "
"placing a dependency on an external context, even a loosely coupled one, "
"still means that the node will expect something in its environment to be "
"true. The project's design philosophies should prevent this from happening. "
"If not, the code's inherent liabilities will force developers to use "
"documentation to keep track of object relations on a microscopic scale; this "
"is otherwise known as development hell. Writing code that relies on external "
"documentation for one to use it safely is error-prone by default."
msgstr ""
"人们应该倾向于将数据保存在内部(场景内部), 尽管它对外部上下文有一个依赖, 即使"
"是一个松散耦合的依赖, 仍然意味着节点, 将期望其环境中的某些内容为真. 项目的设"
"计理念应防止这种情况的发生. 如果不是这样, 代码的继承的责任将迫使开发人员使用"
"文档, 以在微观尺度上跟踪对象关系；这就是所谓的开发地狱. 默认情况下, 编写依赖"
"于外部文档的代码, 让人们安全地使用它, 是很容易出错的."

msgid ""
"To avoid creating and maintaining such documentation, one converts the "
"dependent node (\"child\" above) into a tool script that implements "
"``_get_configuration_warnings()``. Returning a non-empty PackedStringArray "
"from it will make the Scene dock generate a warning icon with the string(s) "
"as a tooltip by the node. This is the same icon that appears for nodes such "
"as the :ref:`Area2D <class_Area2D>` node when it has no child :ref:"
"`CollisionShape2D <class_CollisionShape2D>` nodes defined. The editor then "
"self-documents the scene through the script code. No content duplication via "
"documentation is necessary."
msgstr ""
"为了避免创建和维护此类文档，可以将依赖节点（上面的子级）转换为工具脚本，该脚"
"本实现 ``_get_configuration_warnings()`` 。从中返回的一个非空字符串紧缩数组"
"（PackedStringArray）将使场景停靠面板生成警告图标，其中包含上述字符串作为节点"
"的工具提示。这个警告图标和没有定义 :ref:`CollisionShape2D "
"<class_CollisionShape2D>` 子节点时 :ref:`Area2D <class_Area2D>` 节点旁出现的"
"图标是一样的。这样，编辑器通过脚本代码自记录（self-document）场景，也就不需要"
"在文档里记录一些与之重复的内容了。"

msgid ""
"A GUI like this can better inform project users of critical information "
"about a Node. Does it have external dependencies? Have those dependencies "
"been satisfied? Other programmers, and especially designers and writers, "
"will need clear instructions in the messages telling them what to do to "
"configure it."
msgstr ""
"这样的GUI可以更好地通知项目用户有关节点的关键信息. 它具有外部依赖性吗？这些依"
"赖性是否得到满足？其他程序员, 尤其是设计师和作家, 将需要消息中的明确指示, 告"
"诉他们如何进行配置."

msgid ""
"So, why does all this complex switcharoo work? Well, because scenes operate "
"best when they operate alone. If unable to work alone, then working with "
"others anonymously (with minimal hard dependencies, i.e. loose coupling) is "
"the next best thing. Inevitably, changes may need to be made to a class and "
"if these changes cause it to interact with other scenes in unforeseen ways, "
"then things will start to break down. The whole point of all this "
"indirection is to avoid ending up in a situation where changing one class "
"results in adversely effecting other classes dependent on it."
msgstr ""
"那么，为什么所有这些复杂的开关都能起作用呢？嗯，因为场景单独运行时效果最好。"
"如果无法单独工作，那么与其他人匿名合作（具有最小的硬依赖性，即松散耦合）是第"
"二好的。然而不可避免地，可能需要对类进行更改，如果这些更改导致它以不可预见的"
"方式与其他场景交互，那么就会开始出现故障。所有这些间接实现的目的是避免最终出"
"现这样的情况：更改一个类会对依赖它的其他类产生不利影响。"

msgid ""
"Scripts and scenes, as extensions of engine classes, should abide by *all* "
"OOP principles. Examples include..."
msgstr "脚本和场景作为引擎类的扩展, 应该遵守 *所有* 的OOP原则. 例如..."

msgid "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"
msgstr "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"

msgid "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"
msgstr "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"

msgid "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"
msgstr "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"

msgid "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"
msgstr "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"

msgid "Choosing a node tree structure"
msgstr "选择节点树结构"

msgid ""
"So, a developer starts work on a game only to stop at the vast possibilities "
"before them. They might know what they want to do, what systems they want to "
"have, but *where* to put them all? Well, how one goes about making their "
"game is always up to them. One can construct node trees in countless ways. "
"But, for those who are unsure, this helpful guide can give them a sample of "
"a decent structure to start with."
msgstr ""
"于是，一个开发者开始着手做游戏，却在广阔的可能性面前停了下来。他可能知道自己"
"想做什么，想要什么样的系统，但是该把这些东西安置在 *哪里* 呢？好吧，自己做的"
"游戏当然自己说了算。构造节点树的方法有无数种。但对于没把握的人而言，这份有用"
"的指南可以给他们一个不错的结构样本作为开始。"

msgid ""
"A game should always have a sort of \"entry point\"; somewhere the developer "
"can definitively track where things begin so that they can follow the logic "
"as it continues elsewhere. This place also serves as a bird's eye view of "
"all of the other data and logic in the program. For traditional "
"applications, this would be the \"main\" function. In this case, it would be "
"a Main node."
msgstr ""
"一个游戏总是应该具有某种“入口点”，即某个地方，开发者能明确地追踪各种东西从哪"
"里开始，进而能随着逻辑延伸至其他地方。该处也充当着程序中所有其他数据和逻辑的"
"鸟瞰点。对于传统的应用程序而言，这即是“main”函数。而在这个案例中，它是一个 "
"Main 节点。"

msgid "Node \"Main\" (main.gd)"
msgstr "“Main”节点（main.gd）"

msgid ""
"The ``main.gd`` script would then serve as the primary controller of one's "
"game."
msgstr "``main.gd`` 脚本将作为游戏的主要控制器。"

msgid ""
"Then one has their actual in-game \"World\" (a 2D or 3D one). This can be a "
"child of Main. In addition, one will need a primary GUI for their game that "
"manages the various menus and widgets the project needs."
msgstr ""
"然后你便拥有了真正的游戏“世界”（二维或三维）。这可以是 Main 的子节点。另外，"
"他们的游戏将需要一个主要的 GUI，来管理项目所需的各种菜单和小部件。"

msgid "Node2D/Node3D \"World\" (game_world.gd)"
msgstr "Node2D/Node3D “世界”（game_world.gd）"

msgid "Control \"GUI\" (gui.gd)"
msgstr "Control“GUI”（gui.gd）"

msgid ""
"When changing levels, one can then swap out the children of the \"World\" "
"node. :ref:`Changing scenes manually <doc_change_scenes_manually>` gives "
"users full control over how their game world transitions."
msgstr ""
"当变更关卡时，可以稍后换出“World”节点的子级。\\ :ref:`手动更换场景 "
"<doc_change_scenes_manually>`\\ 让用户完全控制他们的游戏世界如何过渡。"

msgid ""
"The next step is to consider what gameplay systems one's project requires. "
"If one has a system that..."
msgstr "下一步是考虑项目需要什么样的游戏系统。如果有这么一个系统……"

msgid "tracks all of its data internally"
msgstr "跟踪所有的内部数据"

msgid "should be globally accessible"
msgstr "应该是全局可访问的"

msgid "should exist in isolation"
msgstr "应该是独立存在的"

msgid ""
"... then one should create an :ref:`autoload 'singleton' node "
"<doc_singletons_autoload>`."
msgstr ""
"…接下来他该创建一个 :ref:`自动加载“单例”节点 <doc_singletons_autoload>` 了。"

msgid ""
"For smaller games, a simpler alternative with less control would be to have "
"a \"Game\" singleton that simply calls the :ref:`SceneTree."
"change_scene_to_file() <class_SceneTree_method_change_scene_to_file>` method "
"to swap out the main scene's content. This structure more or less keeps the "
"\"World\" as the main game node."
msgstr ""
"对于较小的游戏，一个更简单且更少控制的做法是使用一个“Game”单例，简单地调用 :"
"ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` 方法，用于置换出主场景的内容。"
"这种结构多少保留了“World”作为主要游戏节点。"

msgid ""
"Any GUI would need to also be a singleton; be a transitory part of the "
"\"World\"; or be manually added as a direct child of the root. Otherwise, "
"the GUI nodes would also delete themselves during scene transitions."
msgstr ""
"任一GUI也需要是一个单例，或作为 \"World\" 的过渡部分，或被手动添加到根节点作"
"为其直接子节点。否则GUI节点也会在场景转换时自行删除。"

msgid ""
"If one has systems that modify other systems' data, one should define those "
"as their own scripts or scenes rather than autoloads. For more information "
"on the reasons, please see the :ref:`Autoloads versus regular nodes "
"<doc_autoloads_versus_internal_nodes>` documentation."
msgstr ""
"如果一个系统需要修改另一个系统的数据，那么就应该把它们分别定义成单独的脚本或"
"者场景，不应该使用自动加载。其原因请参考文档\\ :ref:`自动加载与普通节点 "
"<doc_autoloads_versus_internal_nodes>`\\ 。"

msgid ""
"Each subsystem within one's game should have its own section within the "
"SceneTree. One should use parent-child relationships only in cases where "
"nodes are effectively elements of their parents. Does removing the parent "
"reasonably mean that one should also remove the children? If not, then it "
"should have its own place in the hierarchy as a sibling or some other "
"relation."
msgstr ""
"游戏中的每个子系统在 ``SceneTree`` 中应有其自己的部分. 仅在节点是其父级的有效"
"元素的情况下, 才应使用父子关系. 合理地移除父级是否意味着也应删除子级？如果没"
"有, 那么它应在层次结构中有自己的位置, 作为同级关系或其他关系."

msgid ""
"In some cases, one needs these separated nodes to *also* position themselves "
"relative to each other. One can use the :ref:`RemoteTransform "
"<class_RemoteTransform3D>` / :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>` nodes for this purpose. They will allow a target "
"node to conditionally inherit selected transform elements from the Remote\\* "
"node. To assign the ``target`` :ref:`NodePath <class_NodePath>`, use one of "
"the following:"
msgstr ""
"在某些情况下，我们会需要让这些分离的节点\\ *仍然*\\ 进行相对定位。为此，可以"
"使用 :ref:`RemoteTransform <class_RemoteTransform3D>` / :ref:"
"`RemoteTransform2D <class_RemoteTransform2D>` 节点。它们允许目标节点有条件地"
"从 Remote\\* 节点继承选定的变换元素。要分配 ``target`` 的 :ref:`NodePath "
"<class_NodePath>`\\ ，请使用以下方法之一："

msgid ""
"A reliable third party, likely a parent node, to mediate the assignment."
msgstr "一个可靠的第三方, 可能是一个父节点, 来协调分配任务."

msgid ""
"A group, to easily pull a reference to the desired node (assuming there will "
"only ever be one of the targets)."
msgstr "一个编组, 轻松提取对所需节点的引用(假设只有一个目标)."

msgid ""
"When should one do this? Well, this is subjective. The dilemma arises when "
"one must micro-manage when a node must move around the SceneTree to preserve "
"itself. For example..."
msgstr ""
"什么时候他该这样做呢？嗯，这就比较主观了。当他必须精细管理，且一个节点必须在"
"场景树上来回移动以保留自己时，就会出现两难的局面。例如……"

msgid "Add a \"player\" node to a \"room\"."
msgstr "添加一个“玩家”节点到一个“房间”节点。"

msgid "Need to change rooms, so one must delete the current room."
msgstr "需要改变房间了，所以他必须删除当前房间节点。"

msgid ""
"Before the room can be deleted, one must preserve and/or move the player."
msgstr "在房间能被删除前，他必须保留玩家并/或将其移走。"

msgid "Is memory a concern?"
msgstr "需要关心内存吗？"

msgid ""
"If not, one can just create the two rooms, move the player and delete the "
"old one. No problem."
msgstr ""
"如果不需要，他就可以直接创建两个房间，移动玩家到新房间，并且删掉旧房间。没有"
"任何问题。"

msgid "If so, one will need to..."
msgstr "如果比较关注内存情况，那么就需要这样……"

msgid "Move the player somewhere else in the tree."
msgstr "将玩家节点(player)移动到节点树的其他地方。"

msgid "Delete the room."
msgstr "删除房间节点\"room\"。"

msgid "Instantiate and add the new room."
msgstr "实例化并添加新的房间room节点。"

msgid "Re-add the player."
msgstr "重新添加玩家节点\"player\"到新的room节点中。"

msgid ""
"The issue is that the player here is a \"special case\"; one where the "
"developers must *know* that they need to handle the player this way for the "
"project. As such, the only way to reliably share this information as a team "
"is to *document* it. Keeping implementation details in documentation however "
"is dangerous. It's a maintenance burden, strains code readability, and "
"bloats the intellectual content of a project unnecessarily."
msgstr ""
"问题在于这里的角色是一种“特殊情况”；开发者必须\\ *知道*\\ 需要以这种方式处理"
"项目中的角色。因此，在团队中可靠地分享这些信息的唯一方法就是\\ *写文档*\\ 。"
"然而，在文档中记录实现细节是很危险的，会成为一种维护负担，使代码可读性下降，"
"不必要地膨胀项目的知识内容。"

msgid ""
"In a more complex game with larger assets, it can be a better idea to simply "
"keep the player somewhere else in the SceneTree entirely. This results in:"
msgstr ""
"在拥有更多的资产的，更复杂的游戏，简单地将玩家完全保留在 SceneTree 中的其他地"
"方会更好。这样的好处是："

msgid "More consistency."
msgstr "一致性更高。"

msgid "No \"special cases\" that must be documented and maintained somewhere."
msgstr "没有“特殊情况”，不必写入文档也不必进行维护。"

msgid ""
"No opportunity for errors to occur because these details are not accounted "
"for."
msgstr "因为不需要考虑这些细节，所以也没有出错的机会。"

msgid ""
"In contrast, if one ever needs to have a child node that does *not* inherit "
"the transform of their parent, one has the following options:"
msgstr "相比之下，如果需要子节点\\ *不*\\ 继承父节点的变换，那么就有以下选项："

msgid ""
"The **declarative** solution: place a :ref:`Node <class_Node>` in between "
"them. As nodes with no transform, Nodes will not pass along such information "
"to their children."
msgstr ""
"**声明式**\\ 解决方案：在它们之间放置一个 :ref:`Node <class_Node>`\\ 。作为没"
"有变换的节点，Node 不会将这些信息传递给其子节点。"

msgid ""
"The **imperative** solution: Use the ``top_level`` property for the :ref:"
"`CanvasItem <class_CanvasItem_property_top_level>` or :ref:`Node3D "
"<class_Node3D_property_top_level>` node. This will make the node ignore its "
"inherited transform."
msgstr ""
"**命令式**\\ 解决方案：对 :ref:`CanvasItem "
"<class_CanvasItem_property_top_level>` 或者 :ref:`Node3D "
"<class_Node3D_property_top_level>` 节点使用 ``top_level`` 属性。这样就会让该"
"节点忽略其继承的变换（transform）。"

msgid ""
"If building a networked game, keep in mind which nodes and gameplay systems "
"are relevant to all players versus those just pertinent to the authoritative "
"server. For example, users do not all need to have a copy of every players' "
"\"PlayerController\" logic. Instead, they need only their own. As such, "
"keeping these in a separate branch from the \"world\" can help simplify the "
"management of game connections and the like."
msgstr ""
"如果构建的是网络游戏，请记住哪些节点和游戏系统与所有玩家相关，而哪些只与权威"
"服务器相关。例如，用户并不需要所有人都拥有每个玩家的“PlayerController”逻辑的"
"副本。相反，他们只需要自己的。这样，将它们保持在从“世界”分离的独立的分支中，"
"可以帮助简化游戏连接等的管理。"

msgid ""
"The key to scene organization is to consider the SceneTree in relational "
"terms rather than spatial terms. Are the nodes dependent on their parent's "
"existence? If not, then they can thrive all by themselves somewhere else. If "
"they are dependent, then it stands to reason that they should be children of "
"that parent (and likely part of that parent's scene if they aren't already)."
msgstr ""
"场景组织的关键是用关系树而不是空间树来考虑 SceneTree。节点是否依赖于其父节点"
"的存在？如果不是，那么它们可以自己在别的地方茁壮成长。如果它们是依赖性的，那"
"么理所当然它们应该是父节点的子节点（如果它们还不是父节点场景的一部分，那么很"
"可能是父节点场景的一部分）。"

msgid ""
"Does this mean nodes themselves are components? Not at all. Godot's node "
"trees form an aggregation relationship, not one of composition. But while "
"one still has the flexibility to move nodes around, it is still best when "
"such moves are unnecessary by default."
msgstr ""
"这是否意味着节点本身就是组件？并不是这样。Godot 的节点树形成的是聚合关系，不"
"是组合关系。虽然依旧可以灵活地移动节点，但在默认情况下是没有进行移动的必要"
"的。"

msgid "Translation status"
msgstr "翻译状态"
