# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Data preferences"
msgstr "数据偏好"

msgid ""
"Ever wondered whether one should approach problem X with data structure Y or "
"Z? This article covers a variety of topics related to these dilemmas."
msgstr ""
"在面对问题 X 的时候，你有没有对应该使用数据结构 Y 还是 Z 产生过困惑？本文会涉"
"及到与这些困境有关的各种主题。"

msgid ""
"This article makes references to \"[something]-time\" operations. This "
"terminology comes from algorithm analysis' `Big O Notation <https://rob-bell."
"net/2009/06/a-beginners-guide-to-big-o-notation/>`_."
msgstr ""
"本文会提及“[某某]时间”的操作。这个术语来自于算法分析中的\\ `大 O 表示法 "
"<https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/>`_\\ 。"

msgid ""
"Long-story short, it describes the worst-case scenario of runtime length. In "
"laymen's terms:"
msgstr "简而言之，它描述了最坏情况下的运行时长。用外行的话来说："

msgid ""
"\"As the size of a problem domain increases, the runtime length of the "
"algorithm...\""
msgstr "“随着问题域的大小增加，算法的运行时长……”"

msgid "Constant-time, ``O(1)``: \"...does not increase.\""
msgstr "常量时间，\\ ``O(1)``\\ ：“……不会增加。”"

msgid "Logarithmic-time, ``O(log n)``: \"...increases at a slow rate.\""
msgstr "对数时间，\\ ``O(log n)``\\ ：“……会以较慢的速度增长。”"

msgid "Linear-time, ``O(n)``: \"...increases at the same rate.\""
msgstr "线性时间，\\ ``O(n)``\\ ：“……会以相同的速度增长。”"

msgid "Etc."
msgstr "等等。"

msgid ""
"Imagine if one had to process 3 million data points within a single frame. "
"It would be impossible to craft the feature with a linear-time algorithm "
"since the sheer size of the data would increase the runtime far beyond the "
"time allotted. In comparison, using a constant-time algorithm could handle "
"the operation without issue."
msgstr ""
"想象一下, 如果必须在一帧内处理300万个数据点. 不可能使用线性时间算法来设计这个"
"特性, 因为数据的绝对大小, 将使运行时间大大超出分配的时间. 相比之下, 使用常量"
"时间算法可以毫无问题地处理该操作."

msgid ""
"By and large, developers want to avoid engaging in linear-time operations as "
"much as possible. But, if one keeps the scale of a linear-time operation "
"small, and if one does not need to perform the operation often, then it may "
"be acceptable. Balancing these requirements and choosing the right "
"algorithm / data structure for the job is part of what makes programmers' "
"skills valuable."
msgstr ""
"总的来说, 开发人员希望尽可能避免进行线性时间操作. 但是, 如果保持线性时间运算"
"的规模很小, 并且如果不需要经常执行操作, 则这是能够接受的. 平衡这些需求, 并为"
"工作选择正确的算法/数据结构, 是使程序员的技能有价值的一部分."

msgid "Array vs. Dictionary vs. Object"
msgstr "数组、字典、对象"

msgid ""
"Godot stores all variables in the scripting API in the :ref:`Variant "
"<doc_variant_class>` class. Variants can store Variant-compatible data "
"structures such as :ref:`Array <class_Array>` and :ref:`Dictionary "
"<class_Dictionary>` as well as :ref:`Objects <class_Object>`."
msgstr ""
"Godot 把脚本 API 中的所有变量都存储在 :ref:`Variant <doc_variant_class>` 中。"
"Variant 可以存储兼容数据结构，例如 :ref:`Array <class_Array>` （数组）、 :"
"ref:`Dictionary <class_Dictionary>` （字典）、 :ref:`Object <class_Object>` "
"（对象）。"

msgid ""
"Godot implements Array as a ``Vector<Variant>``. The engine stores the Array "
"contents in a contiguous section of memory, i.e. they are in a row adjacent "
"to each other."
msgstr ""
"Godot 使用 ``Vector<Variant>`` 实现数组。引擎会将数组内容存储在一段连续的内存"
"之中，也就是说，元素与元素之间是相邻的。"

msgid ""
"For those unfamiliar with C++, a Vector is the name of the array object in "
"traditional C++ libraries. It is a \"templated\" type, meaning that its "
"records can only contain a particular type (denoted by angled brackets). So, "
"for example, a :ref:`PackedStringArray <class_PackedStringArray>` would be "
"something like a ``Vector<String>``."
msgstr ""
"这里的 Vector 是传统 C++ STL 库中数组对象的名称，是个“模板”类型，即它只能存储"
"特定类型的数据（用尖括号表示）。例如，\\ :ref:`PackedStringArray "
"<class_PackedStringArray>` 其实就类似于 ``Vector<String>``\\ 。"

msgid "Contiguous memory stores imply the following operation performance:"
msgstr "因为是在内存中连续存储，所以执行各种操作的性能如下："

msgid "**Iterate:** Fastest. Great for loops."
msgstr "**迭代：**\\ 最快，非常适合循环。"

msgid "Op: All it does is increment a counter to get to the next record."
msgstr "操作：把计数器加一即可获取下一个元素。"

msgid "**Insert, Erase, Move:** Position-dependent. Generally slow."
msgstr "**插入、删除、移动：**\\ 与位置相关，一般较慢。"

msgid ""
"Op: Adding/removing/moving content involves moving the adjacent records over "
"(to make room / fill space)."
msgstr ""
"操作：元素的添加、删除、移动需要移动与之相邻的元素（腾出地方或者填充空缺）。"

msgid "Fast add/remove *from the end*."
msgstr "在\\ *末尾*\\ 添加、删除很快。"

msgid "Slow add/remove *from an arbitrary position*."
msgstr "在\\ *任意位置*\\ 添加、删除较慢。"

msgid "Slowest add/remove *from the front*."
msgstr "在\\ *开头*\\ 添加、删除最慢。"

msgid "If doing many inserts/removals *from the front*, then..."
msgstr "如果需要在\\ *开头*\\ 执行多次插入、删除操作，那么……"

msgid "invert the array."
msgstr "反转数组。"

msgid "do a loop which executes the Array changes *at the end*."
msgstr "通过循环在\\ *末尾*\\ 执行数组更改。"

msgid "re-invert the array."
msgstr "再把数组反转回来。"

msgid ""
"This makes only 2 copies of the array (still constant time, but slow) versus "
"copying roughly 1/2 of the array, on average, N times (linear time)."
msgstr ""
"这样就只复制了两次数组（虽然比较慢，但还是常数时间），否则就得把平均大概一半"
"的数组复制 N 遍（线性时间）。"

msgid ""
"**Get, Set:** Fastest *by position*. E.g. can request 0th, 2nd, 10th record, "
"etc. but cannot specify which record you want."
msgstr ""
"**取值、设值：**\\ 因为是\\ *按位置*\\ 存取的，所以最快。例如你可以请求第 0 "
"个、第 2 个、第 10 个等等的元素，但不能按照元素的值来请求。"

msgid "Op: 1 addition operation from array start position up to desired index."
msgstr "操作：把起始位置做一次加法，得到所需的索引。"

msgid "**Find:** Slowest. Identifies the index/position of a value."
msgstr "**查找：**\\ 最慢。根据值获取索引，也就是位置。"

msgid ""
"Op: Must iterate through array and compare values until one finds a match."
msgstr "操作：必须遍历数组，一个个元素做比较，直到找到匹配的为止。"

msgid ""
"Performance is also dependent on whether one needs an exhaustive search."
msgstr "性能同时也取决于是否需要查遍整个数组才能找到目标。"

msgid ""
"If kept ordered, custom search operations can bring it to logarithmic time "
"(relatively fast). Laymen users won't be comfortable with this though. Done "
"by re-sorting the Array after every edit and writing an ordered-aware search "
"algorithm."
msgstr ""
"如果保持有序, 自定义搜索操作, 可以使其达到对数时间(相对较快). 不过, 外行用户"
"对此会感到不舒服. 通过在每次编辑之后, 重新排序数组, 并编写一个感知顺序的搜索"
"算法来完成."

msgid ""
"Godot implements Dictionary as an ``OrderedHashMap<Variant, Variant>``. The "
"engine stores a small array (initialized to 2^3 or 8 records) of key-value "
"pairs. When one attempts to access a value, they provide it a key. It then "
"*hashes* the key, i.e. converts it into a number. The \"hash\" is used to "
"calculate the index into the array. As an array, the OHM then has a quick "
"lookup within the \"table\" of keys mapped to values. When the HashMap "
"becomes too full, it increases to the next power of 2 (so, 16 records, then "
"32, etc.) and rebuilds the structure."
msgstr ""
"Godot 使用 ``OrderedHashMap<Variant, Variant>`` 实现 Dictionary。引擎存储一个"
"键值对的小数组（初始化为 2^3 即 8 条记录）。当试图访问一个值时，它提供一个"
"键。然后，对键进行\\ *哈希*\\ 处理，即转换成一个数字。“哈希”值用来计算进入数"
"组的索引。作为一个数组，OHM 就可以在键映射到值的“表”中快速查找。当 HashMap 变"
"得过满时，它会增加到2的下一个幂值（即 16 条记录，然后是 32 条，以此类推），并"
"重新构建结构。"

msgid ""
"Hashes are to reduce the chance of a key collision. If one occurs, the table "
"must recalculate another index for the value that takes the previous "
"position into account. In all, this results in constant-time access to all "
"records at the expense of memory and some minor operational efficiency."
msgstr ""
"散列是为了减少键碰撞的机会. 如果发生了, 列表必须为考虑前一个位置的值, 重新计"
"算另一个索引. 总之, 这导致以牺牲内存和一些较小的操作效率为代价, 对所有记录的"
"常量时间访问."

msgid "Hashing every key an arbitrary number of times."
msgstr "散列每个键任意次数."

msgid ""
"Hash operations are constant-time, so even if an algorithm must do more than "
"one, as long as the number of hash calculations doesn't become too dependent "
"on the density of the table, things will stay fast. Which leads to..."
msgstr ""
"散列操作是常量时间的, 因此即使一个算法必须执行多于一个, 只要散列计算的数量不"
"太依赖于列表的密度, 一切都会保持快速. 这导致了……"

msgid "Maintaining an ever-growing size for the table."
msgstr "保持不断增长的表规模."

msgid ""
"HashMaps maintain gaps of unused memory interspersed in the table on purpose "
"to reduce hash collisions and maintain the speed of accesses. This is why it "
"constantly increases in size quadratically by powers of 2."
msgstr ""
"HashMaps为了减少哈希冲突, 并保持访问速度, 在表中保留了未使用的内存的间隙. 这"
"也是为什么它的大小不断地以2的幂次增加的原因."

msgid ""
"As one might be able to tell, Dictionaries specialize in tasks that Arrays "
"do not. An overview of their operational details is as follows:"
msgstr "如大家所知，字典擅长的任务是数组所不擅长的。其操作细节概述如下："

msgid "**Iterate:** Fast."
msgstr "**迭代** : 快速."

msgid ""
"Op: Iterate over the map's internal vector of hashes. Return each key. "
"Afterwards, users then use the key to jump to and return the desired value."
msgstr ""
"操作: 遍历映射的内部散列向量. 返回每个键. 之后, 用户使用该键跳转到并返回所需"
"的值."

msgid "**Insert, Erase, Move:** Fastest."
msgstr "**插入, 删除, 移动** : 最快."

msgid ""
"Op: Hash the given key. Do 1 addition operation to look up the appropriate "
"value (array start + offset). Move is two of these (one insert, one erase). "
"The map must do some maintenance to preserve its capabilities:"
msgstr ""
"操作: 散列给定的键. 执行1个加法操作来查找适当的值(数组开始+偏移量). 移动其中"
"的两个(一个插入, 一个擦除). 映射必须进行一些维护, 以保留其功能:"

msgid "update ordered List of records."
msgstr "更新记录的有序列表."

msgid "determine if table density mandates a need to expand table capacity."
msgstr "确定列表密度, 是否需要扩展列表容量."

msgid ""
"The Dictionary remembers in what order users inserted its keys. This enables "
"it to execute reliable iterations."
msgstr "字典会记住用户插入键的顺序. 这使它能够执行可靠的迭代."

msgid "**Get, Set:** Fastest. Same as a lookup *by key*."
msgstr "**取值, 设值** : 最快. 和 *根据键* 查找相同."

msgid "Op: Same as insert/erase/move."
msgstr "操作: 和插入/删除/移动类似."

msgid "**Find:** Slowest. Identifies the key of a value."
msgstr "**查找** : 最慢. 标识值的键."

msgid ""
"Op: Must iterate through records and compare the value until a match is "
"found."
msgstr "操作: 必须遍历记录并比较该值, 直到找到匹配的为止."

msgid ""
"Note that Godot does not provide this feature out-of-the-box (because they "
"aren't meant for this task)."
msgstr "请注意,Godot并未开箱即用地提供此功能(因为它们并非用于此任务)."

msgid ""
"Godot implements Objects as stupid, but dynamic containers of data content. "
"Objects query data sources when posed questions. For example, to answer the "
"question, \"do you have a property called, 'position'?\", it might ask its :"
"ref:`script <class_Script>` or the :ref:`ClassDB <class_ClassDB>`. One can "
"find more information about what objects are and how they work in the :ref:"
"`doc_what_are_godot_classes` article."
msgstr ""
"Godot用愚蠢, 但动态的方式容纳数据容器实现对象. 提出问题时, 对象将查询数据源. "
"例如, 要回答\"你是否有一个名为 ``position`` 的属性？\"的问题, 它可能会询问"
"其 :ref:`script <class_Script>` 或 :ref:`ClassDB <class_ClassDB>`. 你可以在 :"
"ref:`doc_what_are_godot_classes` 文章中, 找到有关什么是对象以及它们如何工作的"
"更多信息."

msgid ""
"The important detail here is the complexity of the Object's task. Every time "
"it performs one of these multi-source queries, it runs through *several* "
"iteration loops and HashMap lookups. What's more, the queries are linear-"
"time operations dependent on the Object's inheritance hierarchy size. If the "
"class the Object queries (its current class) doesn't find anything, the "
"request defers to the next base class, all the way up until the original "
"Object class. While these are each fast operations in isolation, the fact "
"that it must make so many checks is what makes them slower than both of the "
"alternatives for looking up data."
msgstr ""
"这里重要的细节是对象任务的复杂性. 每次执行这些多源查询时, 它运行 *几个* 迭代"
"循环和哈希表查找. 此外, 查询是线性时间操作, 依赖于对象的继承层次结构大小. 如"
"果 ``Object`` 查询的类(当前类)什么都没有找到, 则该请求将一直推迟到下一个基"
"类, 一直到原始 ``Object`` 类为止. 虽然这些都是单独的快速操作, 但它必须进行如"
"此多的检查, 于是这一事实使得它们比查找数据的两种方法都要慢."

msgid ""
"When developers mention how slow the scripting API is, it is this chain of "
"queries they refer to. Compared to compiled C++ code where the application "
"knows exactly where to go to find anything, it is inevitable that scripting "
"API operations will take much longer. They must locate the source of any "
"relevant data before they can attempt to access it."
msgstr ""
"当开发人员提到脚本API有多慢时, 所引用的正是这一系列查询. 与编译后的, 应用程序"
"知道在哪里可以找到任何东西的,C++代码相比, 不可避免的是, 脚本API操作将花费更长"
"的时间. 他们必须定位任何相关数据的来源, 然后才能尝试访问它."

msgid ""
"The reason GDScript is slow is because every operation it performs passes "
"through this system."
msgstr "GDScript很慢的原因是, 它执行的每个操作都要经过这个系统."

msgid ""
"C# can process some content at higher speeds via more optimized bytecode. "
"But, if the C# script calls into an engine class' content or if the script "
"tries to access something external to it, it will go through this pipeline."
msgstr ""
"C#可以通过更优化的字节码, 以更快的速度处理一些内容. 但是, 如果C#脚本调用引擎"
"类的内容, 或者脚本试图访问它的外部内容, 它会通过这个管道."

msgid ""
"NativeScript C++ goes even further and keeps everything internal by default. "
"Calls into external structures will go through the scripting API. In "
"NativeScript C++, registering methods to expose them to the scripting API is "
"a manual task. It is at this point that external, non-C++ classes will use "
"the API to locate them."
msgstr ""
"NativeScript C++甚至更进一步, 默认将所有内容都保持在内部. 对外部结构的调用将"
"通过脚本API进行. 在NativeScript C++中, 注册方法以将其公开给脚本API是一项手动"
"任务. 至此, 外部非C++类将使用API来查找它们."

msgid ""
"So, assuming one extends from Reference to create a data structure, like an "
"Array or Dictionary, why choose an Object over the other two options?"
msgstr ""
"因此, 假设从引用扩展到创建数据结构, 比如一个 ``Array`` 或 ``Dictionary``, 为"
"什么选择一个 ``Object`` 而不是其他两个选项？"

msgid ""
"**Control:** With objects comes the ability to create more sophisticated "
"structures. One can layer abstractions over the data to ensure the external "
"API doesn't change in response to internal data structure changes. What's "
"more, Objects can have signals, allowing for reactive behavior."
msgstr ""
"**控件** : 对象能够创建更复杂的结构. 可以在数据上分层抽象, 以确保外部API不会"
"响应内部数据结构的更改. 更重要的是, 对象可以有信号, 允许响应式行为. 对象带来"
"了创建更复杂结构的能力."

msgid ""
"**Clarity:** Objects are a reliable data source when it comes to the data "
"that scripts and engine classes define for them. Properties may not hold the "
"values one expects, but one doesn't need to worry about whether the property "
"exists in the first place."
msgstr ""
"**清晰** : 当涉及到脚本和引擎类为对象定义的数据时, 对象是一个可靠的数据源. 属"
"性可能不包含期望的值, 但是无需担心这个属性是否首先存在."

msgid ""
"**Convenience:** If one already has a similar data structure in mind, then "
"extending from an existing class makes the task of building the data "
"structure much easier. In comparison, Arrays and Dictionaries don't fulfill "
"all use cases one might have."
msgstr ""
"**便利** : 如果已经有了类似的数据结构, 之后从现有类扩展, 可以使构建数据结构的"
"任务变得容易得多. 相比之下, 数组和字典不能满足所有的用例."

msgid ""
"Objects also give users the opportunity to create even more specialized data "
"structures. With it, one can design their own List, Binary Search Tree, "
"Heap, Splay Tree, Graph, Disjoint Set, and any host of other options."
msgstr ""
"对象还让用户有机会创建更专门化的数据结构。有了它，一个人可以设计自己的列表、"
"二叉搜索树、堆、散列树、图、不相交集，以及其他选择。"

msgid ""
"\"Why not use Node for tree structures?\" one might ask. Well, the Node "
"class contains things that won't be relevant to one's custom data structure. "
"As such, it can be helpful to construct one's own node type when building "
"tree structures."
msgstr ""
"\"为什么不在树结构中使用节点？\" 有人可能会问. 节点类包含与自定义数据结构无关"
"的内容. 因此在构建树结构时, 构造自己的节点类型是很有帮助的."

msgid ""
"From here, one can then create their own structures with specific features, "
"limited only by their imagination."
msgstr ""
"从这里开始, 然后就可以创建具有特定功能的结构, 只会受到他们想象力的限制."

msgid "Enumerations: int vs. string"
msgstr "枚举：整数 VS 字符串"

msgid ""
"Most languages offer an enumeration type option. GDScript is no different, "
"but unlike most other languages, it allows one to use either integers or "
"strings for the enum values (the latter only when using the ``export`` "
"keyword in GDScript). The question then arises, \"which should one use?\""
msgstr ""
"大多数语言都提供了一个枚举类型选项.GDScript也不例外, 但与大多数其他语言不同的"
"是, 它允许人们使用整数或字符串作为枚举值(只有在GDScript中使用 ``export`` 关键"
"字时才可使用后者). 那么问题就来了,\"应该使用哪一种？\""

msgid ""
"The short answer is, \"whichever you are more comfortable with.\" This is a "
"feature specific to GDScript and not Godot scripting in general; The "
"languages prioritizes usability over performance."
msgstr ""
"简而言之,\"你觉得哪个更舒服就选哪个.\" 这是GDScript特有的特性, 而并非一般的"
"Godot脚本；该语言将可用性置于性能之上."

msgid ""
"On a technical level, integer comparisons (constant-time) will happen faster "
"than string comparisons (linear-time). If one wants to keep up other "
"languages' conventions though, then one should use integers."
msgstr ""
"在技术层面上, 整数比较(常量时间)比字符串比较(线性时间)更快. 如果你想保持其他"
"语言的习惯, 那么应该使用整数."

msgid ""
"The primary issue with using integers comes up when one wants to *print* an "
"enum value. As integers, attempting to print ``MY_ENUM`` will print ``5`` or "
"what-have-you, rather than something like ``\"MyEnum\"``. To print an "
"integer enum, one would have to write a Dictionary that maps the "
"corresponding string value for each enum."
msgstr ""
"当你想要 *打印* 枚举值时，使用整数的主要问题就出现了。尝试直接打印以 `int` 型"
"保存的枚举 ``MY_ENUM`` ，将会打印 ``5`` 之类的东西，而不是像 ``MyEnum`` 这样"
"的词。要打印以 `int` 型保存的枚举。必须编写一个字典来映射每个枚举对应的字符串"
"值。"

msgid ""
"If the primary purpose of using an enum is for printing values and one "
"wishes to group them together as related concepts, then it makes sense to "
"use them as strings. That way, a separate data structure to execute on the "
"printing is unnecessary."
msgstr ""
"如果使用枚举的主要目的是打印值, 并且希望将它们作为相关概念组合在一起, 那么使"
"用它们作为字符串是有意义的. 这样, 就不需要在打印上执行单独的数据结构."

msgid ""
"AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree"
msgstr ""
"AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree"

msgid ""
"Under what circumstances should one use each of Godot's animation classes? "
"The answer may not be immediately clear to new Godot users."
msgstr ""
"在什么情况下应该使用Godot的各种动画类？对于Godot的新用户来说, 可能不是马上清"
"楚答案."

msgid ""
":ref:`AnimatedTexture <class_AnimatedTexture>` is a texture that the engine "
"draws as an animated loop rather than a static image. Users can manipulate..."
msgstr ""
":ref:`AnimatedTexture <class_AnimatedTexture>` 是引擎绘制一个动画循环, 而不是"
"一个静态图像的纹理. 用户可以进行如下操作…"

msgid "the rate at which it moves across each section of the texture (FPS)."
msgstr "它在纹理的每个部分移动的速率（FPS）。"

msgid "the number of regions contained within the texture (frames)."
msgstr "纹理中包含的区域数(帧)."

msgid ""
"Godot's :ref:`RenderingServer <class_RenderingServer>` then draws the "
"regions in sequence at the prescribed rate. The good news is that this "
"involves no extra logic on the part of the engine. The bad news is that "
"users have very little control."
msgstr ""
"Godot 的 :ref:`RenderingServer <class_RenderingServer>` 会按照规定的速度依次"
"绘制区块。好处是不涉及引擎部分额外的逻辑。坏处是用户几乎没有控制权。"

msgid ""
"Also note that AnimatedTexture is a :ref:`Resource <class_Resource>` unlike "
"the other :ref:`Node <class_Node>` objects discussed here. One might create "
"a :ref:`Sprite2D <class_Sprite2D>` node that uses AnimatedTexture as its "
"texture. Or (something the others can't do) one could add AnimatedTextures "
"as tiles in a :ref:`TileSet <class_TileSet>` and integrate it with a :ref:"
"`TileMap <class_TileMap>` for many auto-animating backgrounds that all "
"render in a single batched draw call."
msgstr ""
"另外请注意，AnimatedTexture 是一种 :ref:`Resource <class_Resource>`\\ ，与此"
"处讨论的其他 :ref:`Node <class_Node>` 对象不同。可以创建 :ref:`Sprite2D "
"<class_Sprite2D>` 节点，使用 AnimatedTexture 作为其纹理。或者（仅在其他方法无"
"法满足要求时）可以将 AnimatedTexture 作为图块添加到 :ref:`TileSet "
"<class_TileSet>` 中并将其与 :ref:`TileMap <class_TileMap>` 集成到一起，从而获"
"得自动动画化的背景。使用此方法时所有的渲染将在单个批处理内绘制调用。"

msgid ""
"The AnimatedSprite2D node, in combination with the :ref:`SpriteFrames "
"<class_SpriteFrames>` resource, allows one to create a variety of animation "
"sequences through spritesheets, flip between animations, and control their "
"speed, regional offset, and orientation. This makes them well-suited to "
"controlling 2D frame-based animations."
msgstr ""
"``AnimatedSprite`` 节点可以与 :ref:`SpriteFrames <class_SpriteFrames>` 资源结"
"合使用，使用户可以通过精灵表创建各种动画序列、在动画之间切换并控制它们的速"
"度、区域偏移量和方向。这使得它们非常适合控制基于二维的帧动画。"

msgid ""
"If one needs trigger other effects in relation to animation changes (for "
"example, create particle effects, call functions, or manipulate other "
"peripheral elements besides the frame-based animation), then will need to "
"use an :ref:`AnimationPlayer <class_AnimationPlayer>` node in conjunction "
"with the AnimatedSprite2D."
msgstr ""
"触发与动画更改相关的其他效果，例如创建粒子效果、调用函数或操作除基于帧的动画"
"外的其他外围元素需要将一个 :ref:`AnimationPlayer <class_AnimationPlayer>` 节"
"点与 ``AnimatedSprite`` 关联。"

msgid ""
"AnimationPlayers are also the tool one will need to use if they wish to "
"design more complex 2D animation systems, such as..."
msgstr ""
"如果你想设计更复杂的二维动画系统，AnimationPlayer 也是你的必备工具，例如……"

msgid "**Cut-out animations:** editing sprites' transforms at runtime."
msgstr "**剪纸动画：**\\ 在运行时编辑精灵的变换。"

msgid ""
"**2D Mesh animations:** defining a region for the sprite's texture and "
"rigging a skeleton to it. Then one animates the bones which stretch and bend "
"the texture in proportion to the bones' relationships to each other."
msgstr ""
"**二维网格动画**\\ ：为精灵的纹理划分一个区域，并将骨架绑定在上面。然后动画化"
"其中的骨骼，使骨骼按照彼此之间的关系，成比例地拉伸和弯曲纹理。"

msgid "A mix of the above."
msgstr "综上所述."

msgid ""
"While one needs an AnimationPlayer to design each of the individual "
"animation sequences for a game, it can also be useful to combine animations "
"for blending, i.e. enabling smooth transitions between these animations. "
"There may also be a hierarchical structure between animations that one plans "
"out for their object. These are the cases where the :ref:`AnimationTree "
"<class_AnimationTree>` shines. One can find an in-depth guide on using the "
"AnimationTree :ref:`here <doc_animation_tree>`."
msgstr ""
"虽然我们需要一个 AnimationPlayer, 来为游戏设计每个独立的动画序列, 它也可以用"
"来混合复合动画, 也就是说, 在这些动画之间实现平滑的转换. 在为对象规划的动画之"
"间, 也可能存在一个层次结构. 在这些情况下使用 :ref:`AnimationTree "
"<class_AnimationTree>` 效果很出色. 可以在 :ref:`这里 <doc_animation_tree>` 找"
"到关于使用 AnimationTree 的深入指南."

msgid "Translation status"
msgstr "翻译状态"
