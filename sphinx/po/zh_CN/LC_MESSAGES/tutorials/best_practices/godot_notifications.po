# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Godot notifications"
msgstr "Godot 通知"

msgid ""
"Every Object in Godot implements a :ref:`_notification "
"<class_Object_method__notification>` method. Its purpose is to allow the "
"Object to respond to a variety of engine-level callbacks that may relate to "
"it. For example, if the engine tells a :ref:`CanvasItem <class_CanvasItem>` "
"to \"draw\", it will call ``_notification(NOTIFICATION_DRAW)``."
msgstr ""
"Godot 中的每个对象都实现了 :ref:`_notification "
"<class_Object_method__notification>` 方法。其目的是允许对象响应可能与之相关的"
"各种引擎级回调。例如，如果引擎想让某个 :ref:`CanvasItem <class_CanvasItem>` "
"去执行“绘制”（draw）操作，它就会去调用 "
"``_notification(NOTIFICATION_DRAW)``\\ 。"

msgid ""
"Some of these notifications, like draw, are useful to override in scripts. "
"So much so that Godot exposes many of them with dedicated functions:"
msgstr ""
"在所有这些通知之中，有很多类似“绘制”这样经常需要在脚本中去覆盖的通知，多到 "
"Godot 要提供专用函数的地步："

msgid "``_ready()`` : NOTIFICATION_READY"
msgstr "``_ready()`` : NOTIFICATION_READY"

msgid "``_enter_tree()`` : NOTIFICATION_ENTER_TREE"
msgstr "``_enter_tree()`` : NOTIFICATION_ENTER_TREE"

msgid "``_exit_tree()`` : NOTIFICATION_EXIT_TREE"
msgstr "``_exit_tree()`` : NOTIFICATION_EXIT_TREE"

msgid "``_process(delta)`` : NOTIFICATION_PROCESS"
msgstr "``_process(delta)`` : NOTIFICATION_PROCESS"

msgid "``_physics_process(delta)`` : NOTIFICATION_PHYSICS_PROCESS"
msgstr "``_physics_process(delta)`` : NOTIFICATION_PHYSICS_PROCESS"

msgid "``_draw()`` : NOTIFICATION_DRAW"
msgstr "``_draw()`` : NOTIFICATION_DRAW"

msgid ""
"What users might *not* realize is that notifications exist for types other "
"than Node alone:"
msgstr "用户可能\\ *不会*\\ 意识到 Node 之外的类型也有通知："

msgid ""
":ref:`Object::NOTIFICATION_POSTINITIALIZE "
"<class_Object_constant_NOTIFICATION_POSTINITIALIZE>`: a callback that "
"triggers during object initialization. Not accessible to scripts."
msgstr ""
":ref:`Object::NOTIFICATION_POSTINITIALIZE "
"<class_Object_constant_NOTIFICATION_POSTINITIALIZE>`\\ ：在对象初始化期间触发"
"的回调。脚本无法访问。"

msgid ""
":ref:`Object::NOTIFICATION_PREDELETE "
"<class_Object_constant_NOTIFICATION_PREDELETE>`: a callback that triggers "
"before the engine deletes an Object, i.e. a 'destructor'."
msgstr ""
":ref:`Object::NOTIFICATION_PREDELETE "
"<class_Object_constant_NOTIFICATION_PREDELETE>`\\ ：在引擎删除一个 Object"
"（即“destructor”析构函数）之前触发的回调。"

msgid ""
":ref:`MainLoop::NOTIFICATION_WM_MOUSE_ENTER "
"<class_MainLoop_constant_NOTIFICATION_WM_MOUSE_ENTER>`: a callback that "
"triggers when the mouse enters the window in the operating system that "
"displays the game content."
msgstr ""
":ref:`MainLoop::NOTIFICATION_WM_MOUSE_ENTER "
"<class_MainLoop_constant_NOTIFICATION_WM_MOUSE_ENTER>`\\ ：当鼠标进入显示游戏"
"内容的操作系统窗口时，触发的回调。"

msgid ""
"And many of the callbacks that *do* exist in Nodes don't have any dedicated "
"methods, but are still quite useful."
msgstr ""
"而且, 在节点中 *确实* 存在许多回调, 都没有任何专用方法, 但是它们仍然非常有用."

msgid ""
":ref:`Node::NOTIFICATION_PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>`: a callback that triggers "
"anytime one adds a child node to another node."
msgstr ""
":ref:`Node::NOTIFICATION_PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>`: 任何时候将一个子节点添加到另一"
"个节点时, 都会触发的回调."

msgid ""
":ref:`Node::NOTIFICATION_UNPARENTED "
"<class_Node_constant_NOTIFICATION_UNPARENTED>`: a callback that triggers "
"anytime one removes a child node from another node."
msgstr ""
":ref:`Node::NOTIFICATION_UNPARENTED "
"<class_Node_constant_NOTIFICATION_UNPARENTED>`: 任何时候从另一个节点删除一个"
"子节点时, 都会触发的回调."

msgid ""
":ref:`Popup::NOTIFICATION_POST_POPUP "
"<class_Popup_constant_NOTIFICATION_POST_POPUP>`: a callback that triggers "
"after a Popup node completes any ``popup*`` method. Note the difference from "
"its ``about_to_show`` signal which triggers *before* its appearance."
msgstr ""
":ref:`Popup::NOTIFICATION_POST_POPUP "
"<class_Popup_constant_NOTIFICATION_POST_POPUP>`: 一个回调, 在Popup节点完成任"
"何 ``popup*`` 方法后触发. 注意与它的 ``about_to_show`` 信号的区别, 后者在 *出"
"现之前* 触发."

msgid ""
"One can access all these custom notifications from the universal "
"``_notification`` method."
msgstr "您可以从通用的 ``_notification`` 方法, 访问所有这些自定义通知."

msgid ""
"Methods in the documentation labeled as \"virtual\" are also intended to be "
"overridden by scripts."
msgstr "文档中被标记为“virtual”的方法（虚方法）是为使用脚本覆盖准备的。"

msgid ""
"A classic example is the :ref:`_init <class_Object_method__init>` method in "
"Object. While it has no ``NOTIFICATION_*`` equivalent, the engine still "
"calls the method. Most languages (except C#) rely on it as a constructor."
msgstr ""
"一个经典的例子是 ``Object`` 中的 :ref:`_init <class_Object_method__init>` 方"
"法. 虽然它没有等效的 ``NOTIFICATION_*``, 但是引擎仍然调用该方法. 大多数语言"
"(C#除外)都将其用作构造函数."

msgid ""
"So, in which situation should one use each of these notifications or virtual "
"functions?"
msgstr "那么, 在哪种情况下应该使用这些通知或虚函数呢？"

msgid "_process vs. _physics_process vs. \\*_input"
msgstr "_process vs. _physics_process vs. \\*_input"

msgid ""
"Use ``_process`` when one needs a framerate-dependent deltatime between "
"frames. If code that updates object data needs to update as often as "
"possible, this is the right place. Recurring logic checks and data caching "
"often execute here, but it comes down to the frequency at which one needs "
"the evaluations to update. If they don't need to execute every frame, then "
"implementing a Timer-yield-timeout loop is another option."
msgstr ""
"当需要帧之间依赖于帧速率的 ``deltatime`` 时, 请使用 ``_process``. 如果更新对"
"象数据的代码, 需要尽可能频繁地更新, 那么这是正确放置这些代码的地方. 经常在这"
"里执行循环逻辑检查和数据缓存, 但它取决于需要更新估算的频率. 如果他们不需要执"
"行每一帧, 那么执行一个 ``Timer-yield-timeout`` 循环是另一种选择."

msgid ""
"Use ``_physics_process`` when one needs a framerate-independent deltatime "
"between frames. If code needs consistent updates over time, regardless of "
"how fast or slow time advances, this is the right place. Recurring kinematic "
"and object transform operations should execute here."
msgstr ""
"当一个帧之间需要独立于帧速率的 ``deltatime`` 时, 请使用 "
"``_physics_process``. 如果不管时间是快还是慢, 代码需要随着时间的推移进行一致"
"的更新, 那么这是正确的放置这些代码的地方. 重复的运动学和对象变换操作, 应在此"
"处执行."

msgid ""
"While it is possible, to achieve the best performance, one should avoid "
"making input checks during these callbacks. ``_process`` and "
"``_physics_process`` will trigger at every opportunity (they do not \"rest\" "
"by default). In contrast, ``*_input`` callbacks will trigger only on frames "
"in which the engine has actually detected the input."
msgstr ""
"为了获得最佳性能, 应尽可能避免在这些回调期间, 进行输入检查. ``_process`` 和 "
"``_physics_process`` 将在每个机会触发(默认情况下它们不会 ``休息``). 相反, "
"``*_input`` 回调仅在, 引擎实际检测到输入的帧上触发."

msgid ""
"One can check for input actions within the input callbacks just the same. If "
"one wants to use delta time, one can fetch it from the related deltatime "
"methods as needed."
msgstr ""
"可以同样检查输入回调中的输入动作. 如果要使用增量时间, 则可以根据需要从相关的"
"增量时间方法中获取它."

msgid "_init vs. initialization vs. export"
msgstr "_init vs. 初始化 vs. export"

msgid ""
"If the script initializes its own node subtree, without a scene, that code "
"should execute here. Other property or SceneTree-independent initializations "
"should also run here. This triggers before ``_ready`` or ``_enter_tree``, "
"but after a script creates and initializes its properties."
msgstr ""
"如果脚本初始化它自己的节点子树, 没有场景, 代码应该在这里执行. 其他属性或独立"
"于 ``SceneTree`` 的 ``initialization`` 也应在此处运行. 这会在 ``_ready`` 或 "
"``_enter_tree`` 之前触发, 但是会在脚本创建并初始化其属性之后触发."

msgid ""
"Scripts have three types of property assignments that can occur during "
"instantiation:"
msgstr "脚本具有三种可能在实例化过程中发生的属性分配方法："

msgid ""
"When instantiating a scene, property values will set up according to the "
"following sequence:"
msgstr "当实例化一个场景时, 将根据以下顺序设置属性值:"

msgid ""
"**Initial value assignment:** instantiation will assign either the "
"initialization value or the init assignment value. Init assignments take "
"priority over initialization values."
msgstr ""
"**初始值分配：**\\ 实例化将先赋初值 initialization 或在 _init 方法中赋值。"
"_init 赋值优先级高于 initialization 初值。"

msgid ""
"**Exported value assignment:** If instancing from a scene rather than a "
"script, Godot will assign the exported value to replace the initial value "
"defined in the script."
msgstr ""
"**导出值赋值：**\\ 如果从一个场景而不是脚本中实例化，Godot 将用导出的值替换脚"
"本中定义的初始值。"

msgid ""
"As a result, instantiating a script versus a scene will affect both the "
"initialization *and* the number of times the engine calls the setter."
msgstr "因此，实例化脚本和场景，将影响初始化 *和* 引擎调用 ``setter`` 的次数."

msgid "_ready vs. _enter_tree vs. NOTIFICATION_PARENTED"
msgstr "_ready vs. _enter_tree vs. NOTIFICATION_PARENTED"

msgid ""
"When instantiating a scene connected to the first executed scene, Godot will "
"instantiate nodes down the tree (making ``_init`` calls) and build the tree "
"going downwards from the root. This causes ``_enter_tree`` calls to cascade "
"down the tree. Once the tree is complete, leaf nodes call ``_ready``. A node "
"will call this method once all child nodes have finished calling theirs. "
"This then causes a reverse cascade going up back to the tree's root."
msgstr ""
"当实例化连接到第一个执行场景的场景时，Godot将实例化树下的节点(进行 ``_init`` "
"调用)，并构建从根向下的树。这导致 ``_enter_tree`` 调用, 向下级联树。当树构建"
"完成, 叶子节点调用 ``_ready``. 一旦所有子节点都完成了对它们的子节点的调用，一"
"个节点就会调用这个方法。然后, 这将导致反向级联回到树的根部."

msgid ""
"When instantiating a script or a standalone scene, nodes are not added to "
"the SceneTree upon creation, so no ``_enter_tree`` callbacks trigger. "
"Instead, only the ``_init`` call occurs. When the scene is added to the "
"SceneTree, the ``_enter_tree`` and ``_ready`` calls occur."
msgstr ""
"当实例化脚本或独立的场景时，节点不会在创建时被添加到SceneTree中，所以未触发 "
"``_enter_tree`` 回调。而只有 ``_init`` 调用发生。当场景被添加到SceneTree时， "
"``_enter_tree`` 和 ``_ready`` 调用会发生。"

msgid ""
"If one needs to trigger behavior that occurs as nodes parent to another, "
"regardless of whether it occurs as part of the main/active scene or not, one "
"can use the :ref:`PARENTED <class_Node_constant_NOTIFICATION_PARENTED>` "
"notification. For example, here is a snippet that connects a node's method "
"to a custom signal on the parent node without failing. Useful on data-"
"centric nodes that one might create at runtime."
msgstr ""
"如果需要触发作为节点设置父级到另一个节点而发生的行为, 无论它是否作为在主要/活"
"动场景中的部分发生, 都可以使用 :ref:`PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>` 通知. 例如, 这有一个将节点方法连"
"接到其父节点上自定义信号, 而不会失败的代码段。对可能在运行时创建并以数据为中"
"心的节点很有用。"

msgid "Translation status"
msgstr "翻译状态"
