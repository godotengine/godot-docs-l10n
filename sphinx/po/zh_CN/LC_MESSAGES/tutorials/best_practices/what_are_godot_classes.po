# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Applying object-oriented principles in Godot"
msgstr "在 Godot 中应用面向对象原则"

msgid ""
"The engine offers two main ways to create reusable objects: scripts and "
"scenes. Neither of these technically define classes under the hood."
msgstr ""
"引擎提供了两种创建可重用对象的主要方式: 脚本和场景. 这两种方式在技术上都没有"
"在引擎下定义类."

msgid ""
"Still, many best practices using Godot involve applying object-oriented "
"programming principles to the scripts and scenes that compose your game. "
"That is why it's useful to understand how we can think of them as classes."
msgstr ""
"尽管如此, 使用Godot的许多最佳实践涉及到将面向对象的编程原则应用到组成你的游戏"
"的脚本和场景中. 这就是为什么了解我们如何将它们视为类是很有用的."

msgid ""
"This guide briefly explains how scripts and scenes work in the engine's core "
"to help you understand how they work under the hood."
msgstr ""
"本指南简要介绍了脚本和场景在引擎核心中的工作方式, 以帮助您了解它们在引擎中的"
"工作方式."

msgid "How scripts work in the engine"
msgstr "脚本在引擎中的工作原理"

msgid ""
"The engine provides built-in classes like :ref:`Node <class_Node>`. You can "
"extend those to create derived types using a script."
msgstr ""
"引擎提供了内置的类, 如 :ref:`Node <class_Node>` . 你可以使用脚本扩展这些类来"
"创建派生类型."

msgid ""
"These scripts are not technically classes. Instead, they are resources that "
"tell the engine a sequence of initializations to perform on one of the "
"engine's built-in classes."
msgstr ""
"这些脚本在技术上不是类. 相反, 它们是告诉引擎在内置类中执行一系列初始化的资源."

msgid ""
"Godot's internal classes have methods that register a class's data with a :"
"ref:`ClassDB <class_ClassDB>`. This database provides runtime access to "
"class information. ``ClassDB`` contains information about classes like:"
msgstr ""
"Godot的内部类具有使用一个 :ref:`ClassDB <class_ClassDB>` 注册一个类数据的方"
"法. 该数据库提供对类信息的运行时访问. ``ClassDB`` 包含有关类的信息, 例如:"

msgid "Properties."
msgstr "属性。"

msgid "Methods."
msgstr "方法。"

msgid "Constants."
msgstr "常量。"

msgid "Signals."
msgstr "信号。"

msgid ""
"This ``ClassDB`` is what objects check against when performing an operation "
"like accessing a property or calling a method. It checks the database's "
"records and the object's base types' records to see if the object supports "
"the operation."
msgstr ""
"这个 ``ClassDB`` 是对象在执行访问属性或调用方法等操作时的检查对象. 它检查数据"
"库的记录和对象的基本类型记录, 以确定对象是否支持该操作."

msgid ""
"Attaching a :ref:`Script <class_Script>` to your object extends the methods, "
"properties, and signals available from the ``ClassDB``."
msgstr ""
"将 :ref:`Script <class_Script>` 附加到你的对象中, 可以扩展 ``ClassDB`` 中的方"
"法, 属性和信号."

msgid ""
"Even scripts that don't use the ``extends`` keyword implicitly inherit from "
"the engine's base :ref:`Reference <class_Reference>` class. As a result, you "
"can instantiate scripts without the ``extends`` keyword from code. Since "
"they extend ``Reference`` though, you cannot attach them to a :ref:`Node "
"<class_Node>`."
msgstr ""
"脚本即使没有使用 ``extends`` 关键字，也会隐式地继承引擎的基础 :ref:"
"`Reference <class_Reference>` 类。因此，你可以从代码中实例化不使用 "
"``extends`` 关键字的脚本。不过由于扩展的是 ``Reference``\\ ，你是无法把它们附"
"加到 :ref:`Node <class_Node>` 上的。"

msgid "Scenes"
msgstr "场景"

msgid ""
"The behavior of scenes has many similarities to classes, so it can make "
"sense to think of a scene as a class. Scenes are reusable, instantiable, and "
"inheritable groups of nodes. Creating a scene is similar to having a script "
"that creates nodes and adds them as children using ``add_child()``."
msgstr ""
"场景的行为与类有很多相似之处, 所以把场景看成一个类是有意义的. 场景是可重用, "
"可实例化, 可继承的节点组. 创建场景类似于有一个脚本, 创建节点并使用 "
"``add_child()`` 将其添加为子节点."

msgid ""
"We often pair a scene with a scripted root node that makes use of the "
"scene's nodes. As such, the scene is often an extension of the script's "
"declarative code."
msgstr ""
"我们经常将场景与使用场景节点的脚本根节点配对. 因此, 场景通常是脚本声明性代码"
"的扩展."

msgid "The content of a scene helps to define:"
msgstr "场景的内容有助于定义："

msgid "What nodes are available to the script"
msgstr "脚本可使用哪些节点"

msgid "How they are organized"
msgstr "它们是如何组织的"

msgid "How they are initialized"
msgstr "它们是如何初始化的"

msgid "What signal connections they have with each other"
msgstr "它们彼此之间有什么信号连接"

msgid ""
"Why is any of this important to scene organization? Because instances of "
"scenes *are* objects. As a result, many object-oriented principles that "
"apply to written code also apply to scenes: single responsibility, "
"encapsulation, and others."
msgstr ""
"为什么这些对组织场景很重要？因为场景的实例\\ *都是*\\ 对象。因此，许多适用于"
"书面代码的面向对象原则也适用于场景：单一职责、封装等。"

msgid ""
"The scene is *always an extension of the script attached to its root node*, "
"so you can interpret it as part of a class."
msgstr ""
"场景\\ *就是对附着在根节点上的脚本的扩展*\\ ，所以你可以将其解释为类的一部"
"分。"

msgid ""
"Most of the techniques explained in this best practices series build on this "
"point."
msgstr "此系列最佳实践中所解释的大部分技术都建立在这一点上。"

msgid "Translation status"
msgstr "翻译状态"
