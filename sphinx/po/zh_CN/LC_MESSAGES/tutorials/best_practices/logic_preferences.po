# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Logic preferences"
msgstr "逻辑偏好"

msgid ""
"Ever wondered whether one should approach problem X with strategy Y or Z? "
"This article covers a variety of topics related to these dilemmas."
msgstr ""
"有没有想过应该用数据结构Y还是Z, 来处理问题X ？本文涵盖了与这些困境有关的各种"
"主题."

msgid "Adding nodes and changing properties: which first?"
msgstr "先添加节点还是先修改属性？"

msgid ""
"When initializing nodes from a script at runtime, you may need to change "
"properties such as the node's name or position. A common dilemma is, when "
"should you change those values?"
msgstr ""
"运行时使用脚本初始化节点时，你可能需要对节点的名称、位置等属性进行修改。常见"
"的纠结点在于，你应该什么时候去修改？"

msgid ""
"It is the best practice to change values on a node before adding it to the "
"scene tree. Some property's setters have code to update other corresponding "
"values, and that code can be slow! For most cases, this code has no impact "
"on your game's performance, but in heavy use cases such as procedural "
"generation, it can bring your game to a crawl."
msgstr ""
"最佳实践是在节点加入场景树之前修改取值。部分属性的 setter 代码会更新其他对应"
"的值，可能会比较慢！大多数情况下，这样的代码不会对游戏的性能产生影响，但对于"
"程序式生成之类的重型使用场景，就可能让游戏卡成 PPT。"

msgid ""
"For these reasons, it is always a best practice to set the initial values of "
"a node before adding it to the scene tree."
msgstr "综上，最佳的做法就是先为节点设置初始值，然后再把它添加到场景树中。"

msgid "Loading vs. preloading"
msgstr "加载 VS 预加载"

msgid ""
"In GDScript, there exists the global :ref:`preload "
"<class_@GDScript_method_preload>` method. It loads resources as early as "
"possible to front-load the \"loading\" operations and avoid loading "
"resources while in the middle of performance-sensitive code."
msgstr ""
"在 GDScript 中，存在全局 :ref:`preload <class_@GDScript_method_preload>` 方"
"法。它尽可能早地加载资源，以便提前进行“加载”操作，并避免在执行性能敏感的代码"
"时加载资源。"

msgid ""
"Its counterpart, the :ref:`load <class_@GDScript_method_load>` method, loads "
"a resource only when it reaches the load statement. That is, it will load a "
"resource in-place which can cause slowdowns when it occurs in the middle of "
"sensitive processes. The ``load()`` function is also an alias for :ref:"
"`ResourceLoader.load(path) <class_ResourceLoader_method_load>` which is "
"accessible to *all* scripting languages."
msgstr ""
"其对应的 :ref:`load <class_@GDScript_method_load>` 方法只有在执行 load 语句时"
"才会加载资源。也就是说，它将立即加载资源。所以，在敏感进程中加载资源会造成速"
"度减慢。 ``load()`` 函数是可以被 *所有* 脚本语言访问的 :ref:`ResourceLoader."
"load(path) <class_ResourceLoader_method_load>` 的别名。"

msgid ""
"So, when exactly does preloading occur versus loading, and when should one "
"use either? Let's see an example:"
msgstr ""
"那么, 预加载和加载到底在什么时候发生, 又应该什么时候使用这两种方法呢？我们来"
"看一个例子:"

msgid ""
"Preloading allows the script to handle all the loading the moment one loads "
"the script. Preloading is useful, but there are also times when one doesn't "
"wish for it. To distinguish these situations, there are a few things one can "
"consider:"
msgstr ""
"预加载允许脚本在加载脚本时处理所有加载. 预加载是有用的, 但也有一些时候, 人们"
"并不希望这样. 为了区分这些情况, 我们可以考虑以下几点:"

msgid ""
"If one cannot determine when the script might load, then preloading a "
"resource, especially a scene or script, could result in further loads one "
"does not expect. This could lead to unintentional, variable-length load "
"times on top of the original script's load operations."
msgstr ""
"如果无法确定何时可以加载脚本, 则预加载资源, 尤其是场景或脚本, 可能会导致进一"
"步加载, 这是人们所不希望的. 这可能会导致无意中, 在原始脚本的加载操作之上的可"
"变长度加载时间. 在原始脚本的加载操作之上, 这可能导致意外的, 可变长度的加载时"
"间."

msgid ""
"If something else could replace the value (like a scene's exported "
"initialization), then preloading the value has no meaning. This point isn't "
"a significant factor if one intends to always create the script on its own."
msgstr ""
"如果其他东西可以代替该值(例如场景导出的初始化), 则预加载该值没有任何意义. 如"
"果打算总是自己创建脚本, 那么这一点并不是重要因素."

msgid ""
"If one wishes only to 'import' another class resource (script or scene), "
"then using a preloaded constant is often the best course of action. However, "
"in exceptional cases, one may wish not to do this:"
msgstr ""
"如果只希望“导入”另一个类资源（脚本或者场景），那么最好的解决方法就是使用预加"
"载常量（Preloaded Constant）。不过也有例外的情况："

msgid ""
"If the 'imported' class is liable to change, then it should be a property "
"instead, initialized either using an ``export`` or a ``load()`` (and perhaps "
"not even initialized until later)."
msgstr ""
"如果已被导入的类有可能发生变化，那么它应该是一个使用 ``export`` 、 ``load`` "
"或之后进行初始化的属性。"

msgid ""
"If the script requires a great many dependencies, and one does not wish to "
"consume so much memory, then one may wish to, load and unload various "
"dependencies at runtime as circumstances change. If one preloads resources "
"into constants, then the only way to unload these resources would be to "
"unload the entire script. If they are instead loaded properties, then one "
"can set them to ``null`` and remove all references to the resource entirely "
"(which, as a :ref:`RefCounted <class_RefCounted>`-extending type, will cause "
"the resources to delete themselves from memory)."
msgstr ""
"如果脚本需要大量依赖关系，又不想消耗太多内存，则可以在环境变化时动态地加载或"
"卸载各种依赖关系。如果将资源预加载为常量，则卸载这些资源的唯一方法是卸载整个"
"脚本。如果改为加载属性，则可以将它们设置为 ``null`` 并完全删除对资源的所有引"
"用（扩展自 :ref:`RefCounted <class_RefCounted>` 的类型会在指向其的所有引用均"
"已消失时自动释放内存）。"

msgid "Large levels: static vs. dynamic"
msgstr "大型关卡：静态 VS 动态"

msgid ""
"If one is creating a large level, which circumstances are most appropriate? "
"Should they create the level as one static space? Or should they load the "
"level in pieces and shift the world's content as needed?"
msgstr ""
"如果正在创建一个大型关卡, 哪种情况是最合适的？他们应该将关卡创建为一个静态空"
"间吗？还是他们应该分阶段加载关卡, 并根据需要改变世界的内容？"

msgid ""
"Well, the simple answer is, \"when the performance requires it.\" The "
"dilemma associated with the two options is one of the age-old programming "
"choices: does one optimize memory over speed, or vice versa?"
msgstr ""
"答案很简单，“当性能需要的时候”。与这两种选择有关的困境是一种古老的编程选择："
"优化内存还是速度？"

msgid ""
"The naive answer is to use a static level that loads everything at once. "
"But, depending on the project, this could consume a large amount of memory. "
"Wasting users' RAM leads to programs running slow or outright crashing from "
"everything else the computer tries to do at the same time."
msgstr ""
"最简单的方法是使用静态关卡, 它可以一次加载所有内容. 但是, 这取决于项目, 这可"
"能会消耗大量内存. 浪费用户的运行内存会导致程序运行缓慢, 或者计算机在同一时间"
"尝试做的所有其他事情都会崩溃."

msgid ""
"No matter what, one should break larger scenes into smaller ones (to aid in "
"reusability of assets). Developers can then design a node that manages the "
"creation/loading and deletion/unloading of resources and nodes in real-time. "
"Games with large and varied environments or procedurally generated elements "
"often implement these strategies to avoid wasting memory."
msgstr ""
"无论如何，应该将较大的场景分解为较小的场景（以利于资产重用）。然后，开发人员"
"可以设计一个节点，该节点实时管理资源和节点的创建/加载和删除/卸载。具有大型多"
"样环境或程序生成的元素的游戏，通常会实行这些策略，以避免浪费内存。"

msgid ""
"On the flip side, coding a dynamic system is more complex, i.e. uses more "
"programmed logic, which results in opportunities for errors and bugs. If one "
"isn't careful, they can develop a system that bloats the technical debt of "
"the application."
msgstr ""
"另一方面, 对动态系统进行编码更复杂, 即, 使用更多的编程逻辑, 这会导致出现错误"
"和bug的机会. 如果不小心的话, 开发的系统, 会增加应用程序的技术成本."

msgid "As such, the best options would be..."
msgstr "因此, 最好的选择是…"

msgid "To use a static level for smaller games."
msgstr "在小型游戏中使用静态关卡."

msgid ""
"If one has the time/resources on a medium/large game, create a library or "
"plugin that can code the management of nodes and resources. If refined over "
"time, so as to improve usability and stability, then it could evolve into a "
"reliable tool across projects."
msgstr ""
"在开发中型/大型游戏时, 如果有时间/资源, 可以去创建一个可以对节点和资源的管理"
"进行编码的库或插件. 如果随着时间的流逝而改进, 以提高可用性和稳定性, 那么它可"
"能会演变成跨项目的可靠工具."

msgid ""
"Code the dynamic logic for a medium/large game because one has the coding "
"skills, but not the time or resources to refine the code (game's gotta get "
"done). Could potentially refactor later to outsource the code into a plugin."
msgstr ""
"为一款中/大型游戏编写动态逻辑代码, 因为你拥有编程技能, 但却没有时间或资源去完"
"善代码(必须要完成游戏). 以后可能会进行重构, 将代码外包到插件中."

msgid ""
"For an example of the various ways one can swap scenes around at runtime, "
"please see the :ref:`\"Change scenes manually\" "
"<doc_change_scenes_manually>` documentation."
msgstr ""
"有关在运行时中, 可以交换场景的各种方式的示例, 请参见文档 :ref:`手动更改场景 "
"<doc_change_scenes_manually>` ."

msgid "Translation status"
msgstr "翻译状态"
