# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Kinematic character (2D)"
msgstr "Personagem cinemático (2D)"

msgid "Introduction"
msgstr "Introdução"

msgid ""
"Yes, the name sounds strange. \"Kinematic Character\". What is that? The "
"reason for the name is that, when physics engines came out, they were called "
"\"Dynamics\" engines (because they dealt mainly with collision responses). "
"Many attempts were made to create a character controller using the dynamics "
"engines, but it wasn't as easy as it seemed. Godot has one of the best "
"implementations of dynamic character controller you can find (as it can be "
"seen in the 2d/platformer demo), but using it requires a considerable level "
"of skill and understanding of physics engines (or a lot of patience with "
"trial and error)."
msgstr ""
"Sim, o nome soa estranho. \"Personagem cinemático\". O que é aquilo? A razão "
"para o nome é que, quando os motores de física surgiram, eles eram chamados "
"de motores \"Dinâmicos\" (porque lidavam principalmente com respostas de "
"colisão). Muitas tentativas foram feitas para criar um controlador de "
"personagem usando os motores de dinâmica, mas não foi tão fácil quanto "
"parecia. Godot tem uma das melhores implementações de controlador de "
"personagem dinâmico que você pode encontrar (como pode ser visto na demo 2d/"
"platformer), mas usá-lo requer um nível considerável de habilidade e "
"compreensão dos motores de física (ou muita paciência com testes e erro)."

msgid ""
"Some physics engines, such as Havok seem to swear by dynamic character "
"controllers as the best option, while others (PhysX) would rather promote "
"the kinematic one."
msgstr ""
"Alguns motores de física, como o Havok, parecem defender os controladores de "
"personagens dinâmicos como a melhor opção, enquanto outros (PhysX) preferem "
"promover o cinemático."

msgid "So, what is the difference?:"
msgstr "Então, qual é a diferença?:"

msgid ""
"A **dynamic character controller** uses a rigid body with an infinite "
"inertia tensor. It's a rigid body that can't rotate. Physics engines always "
"let objects move and collide, then solve their collisions all together. This "
"makes dynamic character controllers able to interact with other physics "
"objects seamlessly, as seen in the platformer demo. However, these "
"interactions are not always predictable. Collisions can take more than one "
"frame to be solved, so a few collisions may seem to displace a tiny bit. "
"Those problems can be fixed, but require a certain amount of skill."
msgstr ""
"Um **controlador dinâmico de personagem** usa um corpo rígido com um tensor "
"de inércia infinito. É um corpo rígido que não pode girar. Os motores de "
"física sempre permitem que os objetos se movam e colidam, então resolvem "
"suas colisões todas juntas. Isso torna os controladores de personagem "
"dinâmicos capazes de interagir perfeitamente com outros objetos físicos, "
"como visto na demonstração do jogo de plataforma. No entanto, essas "
"interações nem sempre são previsíveis. As colisões podem levar mais de um "
"quadro para serem resolvidas, então algumas colisões podem parecer deslocar "
"um pouquinho. Esses problemas podem ser corrigidos, mas requerem uma certa "
"habilidade."

msgid ""
"A **kinematic character controller** is assumed to always begin in a non-"
"colliding state, and will always move to a non-colliding state. If it starts "
"in a colliding state, it will try to free itself like rigid bodies do, but "
"this is the exception, not the rule. This makes their control and motion a "
"lot more predictable and easier to program. However, as a downside, they "
"can't directly interact with other physics objects, unless done by hand in "
"code."
msgstr ""
"Presume-se que um **controlador de caractere cinemático** comece sempre em "
"um estado sem colisão e sempre se moverá para um estado sem colisão. Se "
"começar em estado de colisão, tentará se libertar como fazem os corpos "
"rígidos, mas esta é a exceção, não a regra. Isso torna seu controle e "
"movimento muito mais previsível e fácil de programar. No entanto, como "
"desvantagem, eles não podem interagir diretamente com outros objetos "
"físicos, a menos que sejam feitos à mão em código."

#, fuzzy
msgid ""
"This short tutorial focuses on the kinematic character controller. It uses "
"the old-school way of handling collisions, which is not necessarily simpler "
"under the hood, but well hidden and presented as an API."
msgstr ""
"Este breve tutorial se concentrará no controlador de personagem cinemático. "
"Basicamente, a maneira antiga de lidar com colisões (que não é "
"necessariamente mais simples por baixo dos panos, mas bem escondida e "
"apresentada como uma API simples e agradável)."

msgid "Physics process"
msgstr "Processo físico"

msgid ""
"To manage the logic of a kinematic body or character, it is always advised "
"to use physics process, because it's called before physics step and its "
"execution is in sync with physics server, also it is called the same amount "
"of times per second, always. This makes physics and motion calculation work "
"in a more predictable way than using regular process, which might have "
"spikes or lose precision if the frame rate is too high or too low."
msgstr ""
"Para gerenciar a lógica de um corpo ou personagem cinemático, é sempre "
"aconselhável usar o processo de física, pois é chamado antes da simulação de "
"física e sua execução está em sincronia com o servidor de física, também é "
"chamado a mesma quantidade de vezes por segundo, sempre. Isso faz com que a "
"física e o cálculo de movimento funcionem de maneira mais previsível do que "
"usando o processo regular, que pode ter picos ou perder a precisão se a taxa "
"de quadros for muito alta ou muito baixa."

msgid "Scene setup"
msgstr "Configuração da cena"

#, fuzzy
msgid ""
"To have something to test, here's the scene (from the tilemap tutorial): "
"`kinematic_character_2d_starter.zip <https://github.com/godotengine/godot-"
"docs-project-starters/releases/download/latest-4.x/"
"kinematic_character_2d_starter.zip>`_. We'll be creating a new scene for the "
"character. Use the robot sprite and create a scene like this:"
msgstr ""
"Para ter algo para testar, aqui está a cena (do tutorial do tilemap): :"
"download:`kbscene.zip <files/kbscene.zip>`. Estaremos criando uma nova cena "
"para o personagem. Use o sprite do robô e crie uma cena como esta:"

msgid ""
"You'll notice that there's a warning icon next to our CollisionShape2D node; "
"that's because we haven't defined a shape for it. Create a new CircleShape2D "
"in the shape property of CollisionShape2D. Click on <CircleShape2D> to go to "
"the options for it, and set the radius to 30:"
msgstr ""
"Você notará que há um ícone de aviso próximo ao nosso nó CollisionShape2D; "
"isso porque não definimos uma forma para ele. Crie um novo CircleShape2D na "
"propriedade de forma de CollisionShape2D. Clique em <CircleShape2D> para "
"acessar as opções e defina o raio como 30:"

msgid ""
"**Note: As mentioned before in the physics tutorial, the physics engine "
"can't handle scale on most types of shapes (only collision polygons, planes "
"and segments work), so always change the parameters (such as radius) of the "
"shape instead of scaling it. The same is also true for the kinematic/rigid/"
"static bodies themselves, as their scale affects the shape scale.**"
msgstr ""
"**Observação: como mencionado anteriormente no tutorial de física, o engine "
"de física não pode lidar com a escala na maioria dos tipos de formas "
"(somente polígonos de colisão, planos e segmentos funcionam), portanto, "
"sempre altere os parâmetros (como o raio) da forma em vez de dimensioná-la. "
"O mesmo também é verdade para os próprios corpos cinemáticos/rígidos/"
"estáticos, pois sua escala afeta a escala da forma.**"

msgid ""
"Now, create a script for the character, the one used as an example above "
"should work as a base."
msgstr ""
"Agora, crie um script para o personagem, o usado como exemplo acima deve "
"servir de base."

msgid ""
"Finally, instance that character scene in the tilemap, and make the map "
"scene the main one, so it runs when pressing play."
msgstr ""
"Por fim, crie uma instância dessa cena de personagem no tilemap e torne a "
"cena do mapa a principal, para que seja executada ao pressionar o play."

msgid "Moving the kinematic character"
msgstr "Movendo o personagem cinemático"

#, fuzzy
msgid ""
"Go back to the character scene, and open the script, the magic begins now! "
"Kinematic body will do nothing by default, but it has a useful function "
"called ``CharacterBody2D.move_and_collide()``. This function takes a :ref:"
"`Vector2 <class_Vector2>` as an argument, and tries to apply that motion to "
"the kinematic body. If a collision happens, it stops right at the moment of "
"the collision."
msgstr ""
"Volte para a cena do personagem e abra o script, a mágica começa agora! O "
"corpo cinemático não fará nada por padrão, mas tem uma função útil chamada :"
"ref:`KinematicBody2D.move_and_collide() "
"<class_KinematicBody2D_method_move_and_collide>`. Esta função recebe um :ref:"
"`Vector2 <class_Vector2>` como argumento e tenta aplicar esse movimento ao "
"corpo cinemático. Se ocorrer uma colisão, ele para no momento da colisão."

msgid "So, let's move our sprite downwards until it hits the floor:"
msgstr "Então, vamos mover nosso sprite para baixo até atingir o chão:"

msgid ""
"The result is that the character will move, but stop right when hitting the "
"floor. Pretty cool, huh?"
msgstr ""
"O resultado é que o personagem vai se mover, mas parar ao bater no chão. Bem "
"legal, né?"

msgid ""
"The next step will be adding gravity to the mix, this way it behaves a "
"little more like a regular game character:"
msgstr ""
"O próximo passo será adicionar gravidade à mistura, de forma que ela se "
"comporte um pouco mais como um personagem normal do jogo:"

msgid ""
"Now the character falls smoothly. Let's make it walk to the sides, left and "
"right when touching the directional keys. Remember that the values being "
"used (for speed at least) are pixels/second."
msgstr ""
"Agora o personagem cai sem problemas. Vamos fazê-lo andar para os lados, "
"esquerda e direita ao tocar nas teclas direcionais. Lembre-se de que os "
"valores usados (pelo menos para velocidade) são pixels/segundo."

#, fuzzy
msgid "This adds basic support for walking when pressing left and right:"
msgstr ""
"Isso adiciona um suporte simples para andar pressionando esquerda e direita:"

msgid "And give it a try."
msgstr "E experimente."

msgid ""
"This is a good starting point for a platformer. A more complete demo can be "
"found in the demo zip distributed with the engine, or in the https://github."
"com/godotengine/godot-demo-projects/tree/master/2d/kinematic_character."
msgstr ""
"Este é um bom ponto de partida para um jogo de plataforma. Uma demonstração "
"mais completa pode ser encontrada no zip de demonstração distribuído com o "
"mecanismo ou no https://github.com/godotengine/godot-demo-projects/tree/"
"master/2d/kinematic_character."

msgid "Translation status"
msgstr "Progresso da Tradução"
