# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Viewports"
msgstr "Usando Viewports"

msgid "Introduction"
msgstr "Introdução"

msgid ""
"Think of a :ref:`Viewport <class_Viewport>` as a screen onto which the game "
"is projected. In order to see the game, we need to have a surface on which "
"to draw it; that surface is the Root :ref:`Viewport <class_Viewport>`."
msgstr ""

msgid ""
":ref:`Viewports <class_Viewport>` can also be added to the scene so that "
"there are multiple surfaces to draw on. When we are drawing to a :ref:"
"`Viewport <class_Viewport>` that is not the Root, we call it a render "
"target. We can access the contents of a render target by accessing its "
"corresponding :ref:`texture <class_ViewportTexture>`. By using a :ref:"
"`Viewport <class_Viewport>` as a render target, we can either render "
"multiple scenes simultaneously or we can render to a :ref:`texture "
"<class_ViewportTexture>` which is applied to an object in the scene, for "
"example a dynamic skybox."
msgstr ""

msgid ""
":ref:`Viewports <class_Viewport>` have a variety of use cases, including:"
msgstr ""
":ref:`Viewports <class_Viewport>` tem uma variedade de casos de uso, "
"incluindo:"

msgid "Rendering 3D objects within a 2D game"
msgstr "Renderização de objetos 3D em um jogo 2D"

msgid "Rendering 2D elements in a 3D game"
msgstr "Renderização de elementos 2D em um jogo 3D"

msgid "Rendering dynamic textures"
msgstr "Renderização de texturas dinâmicas"

msgid "Generating procedural textures at runtime"
msgstr "Geração de texturas procedurais durante a execução"

msgid "Rendering multiple cameras in the same scene"
msgstr "Renderização de várias câmeras na mesma cena"

msgid ""
"What all these use cases have in common is that you are given the ability to "
"draw objects to a texture as if it were another screen and can then choose "
"what to do with the resulting texture."
msgstr ""
"O que todos esses casos de uso têm em comum é que você tem a capacidade de "
"desenhar objetos em uma textura como se fosse outra tela e pode então "
"escolher o que fazer com a textura resultante."

msgid "Input"
msgstr "Entrada"

msgid ""
":ref:`Viewports <class_Viewport>` are also responsible for delivering "
"properly adjusted and scaled input events to all their children nodes. "
"Typically, input is received by the nearest :ref:`Viewport <class_Viewport>` "
"in the tree, but you can set :ref:`Viewports <class_Viewport>` not to "
"receive input by checking 'Disable Input' to 'on'; this will allow the next "
"nearest :ref:`Viewport <class_Viewport>` in the tree to capture the input."
msgstr ""
":ref:`Viewports <class_Viewport>` também são responsáveis por fornecer "
"eventos de entrada devidamente ajustados e dimensionados para todos os seus "
"nós filhos. Normalmente, a entrada é recebida pelo :ref:`Viewport "
"<class_Viewport>` mais próximo na árvore, mas você pode definir :ref:"
"`Viewports <class_Viewport>` para não receber entrada marcando 'Disable "
"Input' para 'on'; isso permitirá que o próximo :ref:`Viewport "
"<class_Viewport>` na árvore capture a entrada."

msgid ""
"For more information on how Godot handles input, please read the :ref:`Input "
"Event Tutorial<doc_inputevent>`."
msgstr ""
"Para obter mais informações sobre como o Godot lida com as entradas, leia o :"
"ref:`Tutorial de evento de entrada<doc_inputevent>`."

msgid "Listener"
msgstr "Ouvinte (Listener)"

msgid ""
"Godot supports 3D sound (in both 2D and 3D nodes); more on this can be found "
"in the :ref:`Audio Streams Tutorial<doc_audio_streams>`. For this type of "
"sound to be audible, the :ref:`Viewport <class_Viewport>` needs to be "
"enabled as a listener (for 2D or 3D). If you are using a custom :ref:"
"`Viewport <class_Viewport>` to display your :ref:`World <class_World>`, "
"don't forget to enable this!"
msgstr ""
"Godot suporta som 3D (nos nós 2D e 3D); mais sobre isso pode ser encontrado "
"no :ref:`Audio Streams Tutorial<doc_audio_streams>`. Para que este tipo de "
"som seja audível, o :ref:`Viewport <class_Viewport>` precisa estar "
"habilitado como ouvinte (para 2D ou 3D). Se você estiver usando um :ref:"
"`Viewport <class_Viewport>` personalizado para exibir seu :ref:`World "
"<class_World>`, não se esqueça de habilitá-lo!"

msgid "Cameras (2D & 3D)"
msgstr "Câmeras (2D e 3D)"

msgid ""
"When using a :ref:`Camera <class_Camera>` / :ref:`Camera2D "
"<class_Camera2D>`, cameras will always display on the closest parent :ref:"
"`Viewport <class_Viewport>` (going towards the root). For example, in the "
"following hierarchy:"
msgstr ""
"Ao usar uma :ref:`Camera <class_Camera>` / :ref:`Camera2D <class_Camera2D>`, "
"as câmeras sempre serão exibidas no pai mais próximo :ref:`Viewport "
"<class_Viewport>` (indo em direção à raiz). Por exemplo, na seguinte "
"hierarquia:"

msgid ""
"CameraA will display on the Root :ref:`Viewport <class_Viewport>` and it "
"will draw MeshA. CameraB will be captured by the :ref:`Viewport "
"<class_Viewport>` Node along with MeshB. Even though MeshB is in the scene "
"hierarchy, it will still not be drawn to the Root :ref:`Viewport "
"<class_Viewport>`. Similarly MeshA will not be visible from the :ref:"
"`Viewport <class_Viewport>` node because :ref:`Viewport <class_Viewport>` "
"nodes only capture nodes below them in the hierarchy."
msgstr ""
"CameraA será exibida na raiz :ref:`Viewport <class_Viewport>` e desenhará "
"MeshA. CameraB será capturado pelo nó :ref:`Viewport <class_Viewport>` "
"juntamente com MeshB. Mesmo que MeshB esteja na hierarquia da cena, ele "
"ainda não será desenhado para o Raiz :ref:`Viewport <class_Viewport>`. Da "
"mesma forma, MeshA não será visível a partir do nó :ref:`Viewport "
"<class_Viewport>` porque os nós :ref:`Viewport <class_Viewport>` capturam "
"apenas os nós abaixo deles na hierarquia."

msgid ""
"There can only be one active camera per :ref:`Viewport <class_Viewport>`, so "
"if there is more than one, make sure that the desired one has the "
"\"current\" property set, or make it the current camera by calling:"
msgstr ""
"Só pode haver uma câmera ativa por :ref:`Viewport <class_Viewport>`, "
"portanto, se houver mais de uma, certifique-se de que a desejada tenha a "
"propriedade \"current\" definida ou torne-a a câmera atual chamando:"

msgid ""
"By default, cameras will render all objects in their world. In 3D, cameras "
"can use their :ref:`cull_mask <class_Camera_property_cull_mask>` property "
"combined with the :ref:`VisualInstance's <class_VisualInstance>` :ref:`layer "
"<class_VisualInstance_property_layers>` property to restrict which objects "
"are rendered."
msgstr ""
"Por padrão, as câmeras renderizarão todos os objetos em seu mundo. Em 3D, as "
"câmeras podem usar sua propriedade :ref:`cull_mask "
"<class_Camera_property_cull_mask>` combinada com a propriedade :ref:"
"`VisualInstance <class_VisualInstance>` :ref:`layer "
"<class_VisualInstance_property_layers>` para restringir quais objetos são "
"renderizados."

msgid "Scale & stretching"
msgstr "Escala e alongamento"

msgid ""
":ref:`Viewports <class_Viewport>` have a \"size\" property, which represents "
"the size of the :ref:`Viewport <class_Viewport>` in pixels. For :ref:"
"`Viewports <class_Viewport>` which are children of :ref:`ViewportContainers "
"<class_viewportcontainer>`, these values are overridden, but for all others, "
"this sets their resolution."
msgstr ""
":ref:`Viewports <class_Viewport>` tem uma propriedade \"size\", que "
"representa o tamanho do :ref:`Viewport <class_Viewport>` em pixels. Para :"
"ref:`Viewports <class_Viewport>` que são filhos de :ref:`ViewportContainers "
"<class_viewportcontainer>`, esses valores são substituídos, mas para todos "
"os outros, isso define sua resolução."

msgid ""
"It is also possible to scale the 2D content and make the :ref:`Viewport "
"<class_Viewport>` resolution different from the one specified in size, by "
"calling:"
msgstr ""
"Também é possível dimensionar o conteúdo 2D e tornar a resolução :ref:"
"`Viewport <class_Viewport>` diferente da especificada em tamanho, chamando:"

#, fuzzy
msgid ""
"The root :ref:`Viewport <class_Viewport>` uses this for the stretch options "
"in the project settings. For more information on scaling and stretching "
"visit the :ref:`Multiple Resolutions Tutorial <doc_multiple_resolutions>`"
msgstr ""
"A raiz :ref:`Viewport <class_Viewport>` usa isso para as opções de "
"alongamento nas configurações do projeto. Para obter mais informações sobre "
"dimensionamento e alongamento, visite o :ref:`Tutorial de múltiplas "
"resoluções <doc_multiple_resolutions>`"

msgid "Worlds"
msgstr "Mundos"

msgid ""
"For 3D, a :ref:`Viewport <class_Viewport>` will contain a :ref:`World "
"<class_World>`. This is basically the universe that links physics and "
"rendering together. Spatial-based nodes will register using the :ref:`World "
"<class_World>` of the closest :ref:`Viewport <class_Viewport>`. By default, "
"newly created :ref:`Viewports <class_Viewport>` do not contain a :ref:`World "
"<class_World>` but use the same as their parent :ref:`Viewport "
"<class_Viewport>` (the root :ref:`Viewport <class_Viewport>` always contains "
"a :ref:`World <class_World>`, which is the one objects are rendered to by "
"default). A :ref:`World <class_World>` can be set in a :ref:`Viewport "
"<class_Viewport>` using the \"world\" property, and that will separate all "
"children nodes of that :ref:`Viewport <class_Viewport>` from interacting "
"with the parent :ref:`Viewport's <class_Viewport>` :ref:`World "
"<class_World>`. This is especially useful in scenarios where, for example, "
"you might want to show a separate character in 3D imposed over the game "
"(like in StarCraft)."
msgstr ""
"Para 3D, uma :ref:`Viewport <class_Viewport>` conterá um :ref:`World "
"<class_World>`. Este é basicamente o universo que une a física e a "
"renderização. Nós baseados em espaço serão registrados usando o :ref:`World "
"<class_World>` da :ref:`Viewport <class_Viewport>` mais próxima. Por padrão, "
"as novas :ref:`Viewports <class_Viewport>` não contêm um :ref:`World "
"<class_World>`, mas usam o mesmo que seu pai :ref:`Viewport "
"<class_Viewport>` (a raiz :ref:` Viewport <class_Viewport>`sempre contém um :"
"ref:`World <class_World>`, que é para onde os objetos são renderizados por "
"padrão). A :ref:`World <class_World>` pode ser definido em uma :ref:"
"`Viewport <class_Viewport>` usando a propriedade \"world\", e isso irá "
"separar todos os nós filhos dessa :ref:`Viewport <class_Viewport>` "
"interagindo com o pai :ref:`World <class_World>` :ref:`<class_Viewport> da "
"viewport`. Isso é especialmente útil em cenários onde, por exemplo, você "
"pode querer mostrar um personagem separado em 3D imposto sobre o jogo (como "
"em StarCraft)."

msgid ""
"As a helper for situations where you want to create :ref:`Viewports "
"<class_Viewport>` that display single objects and don't want to create a :"
"ref:`World <class_World>`, :ref:`Viewport <class_Viewport>` has the option "
"to use its own :ref:`World <class_World>`. This is useful when you want to "
"instance 3D characters or objects in a 2D :ref:`World <class_World2D>`."
msgstr ""

msgid ""
"For 2D, each :ref:`Viewport <class_Viewport>` always contains its own :ref:"
"`World2D <class_World2D>`. This suffices in most cases, but in case sharing "
"them may be desired, it is possible to do so by setting the :ref:`Viewport's "
"<class_Viewport>` :ref:`World2D <class_World2D>` manually."
msgstr ""

msgid ""
"For an example of how this works, see the demo projects `3D in 2D <https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ "
"and `2D in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/2d_in_3d>`_ respectively."
msgstr ""

msgid "Capture"
msgstr "Captura"

msgid ""
"It is possible to query a capture of the :ref:`Viewport <class_Viewport>` "
"contents. For the root :ref:`Viewport <class_Viewport>`, this is effectively "
"a screen capture. This is done with the following code:"
msgstr ""

msgid ""
"But if you use this in ``_ready()`` or from the first frame of the :ref:"
"`Viewport's <class_Viewport>` initialization, you will get an empty texture "
"because there is nothing to get as texture. You can deal with it using (for "
"example):"
msgstr ""

msgid "Viewport Container"
msgstr "Viewport Container"

msgid ""
"If the :ref:`Viewport <class_Viewport>` is a child of a :ref:"
"`ViewportContainer <class_viewportcontainer>`, it will become active and "
"display anything it has inside. The layout looks like this:"
msgstr ""

msgid ""
"The :ref:`Viewport <class_Viewport>` will cover the area of its parent :ref:"
"`ViewportContainer <class_viewportcontainer>` completely if :ref:"
"`Stretch<class_viewportcontainer_property_stretch>` is set to ``true`` in :"
"ref:`ViewportContainer <class_viewportcontainer>`. Note: The size of the :"
"ref:`ViewportContainer <class_viewportcontainer>` cannot be smaller than the "
"size of the :ref:`Viewport <class_Viewport>`."
msgstr ""

msgid "Rendering"
msgstr "Renderizando"

msgid ""
"Due to the fact that the :ref:`Viewport <class_Viewport>` is an entryway "
"into another rendering surface, it exposes a few rendering properties that "
"can be different from the project settings. The first is MSAA; you can "
"choose to use a different level of MSAA for each :ref:`Viewport "
"<class_Viewport>`; the default behavior is DISABLED. You can also set the :"
"ref:`Viewport <class_Viewport>` to use HDR, HDR is very useful for when you "
"want to store values in the texture that are outside the range 0.0 - 1.0."
msgstr ""

msgid ""
"If you know how the :ref:`Viewport <class_Viewport>` is going to be used, "
"you can set its Usage to either 3D or 2D. Godot will then restrict how the :"
"ref:`Viewport <class_Viewport>` is drawn to in accordance with your choice; "
"default is 3D. The 2D usage mode is slightly faster and uses less memory "
"compared to the 3D one. It's a good idea to set the :ref:`Viewport "
"<class_Viewport>`'s Usage property to 2D if your viewport doesn't render "
"anything in 3D."
msgstr ""

msgid ""
"If you need to render 3D shadows in the viewport, make sure to set the "
"viewport's *Shadow Atlas Size* property to a value higher than 0. Otherwise, "
"shadows won't be rendered. For reference, the Project Settings define it to "
"4096 by default."
msgstr ""

msgid ""
"Godot also provides a way of customizing how everything is drawn inside :ref:"
"`Viewports <class_Viewport>` using “Debug Draw”. Debug Draw allows you to "
"specify one of four options for how the :ref:`Viewport <class_Viewport>` "
"will display things drawn inside it. Debug Draw is disabled by default."
msgstr ""

msgid "*A scene drawn with Debug Draw disabled*"
msgstr ""

msgid ""
"The other three options are Unshaded, Overdraw, and Wireframe. Unshaded "
"draws the scene without using lighting information so all the objects appear "
"flatly colored the color of their albedo."
msgstr ""

msgid "*The same scene with Debug Draw set to Unshaded*"
msgstr ""

msgid ""
"Overdraw draws the meshes semi-transparent with an additive blend so you can "
"see how the meshes overlap."
msgstr ""

msgid "*The same scene with Debug Draw set to Overdraw*"
msgstr ""

msgid ""
"Lastly, Wireframe draws the scene using only the edges of triangles in the "
"meshes."
msgstr ""

msgid ""
"The effects of the Wireframe mode are only visible in the editor, not while "
"the project is running."
msgstr ""

msgid "Render target"
msgstr "Destino da renderização"

msgid ""
"When rendering to a :ref:`Viewport <class_Viewport>`, whatever is inside "
"will not be visible in the scene editor. To display the contents, you have "
"to draw the :ref:`Viewport's <class_Viewport>` :ref:`ViewportTexture "
"<class_ViewportTexture>` somewhere. This can be requested via code using "
"(for example):"
msgstr ""

msgid ""
"Or it can be assigned in the editor by selecting \"New ViewportTexture\""
msgstr ""

msgid ""
"and then selecting the :ref:`Viewport <class_Viewport>` you want to use."
msgstr ""

msgid ""
"Every frame, the :ref:`Viewport <class_Viewport>`'s texture is cleared away "
"with the default clear color (or a transparent color if :ref:`Transparent "
"Bg<class_Viewport_property_transparent_bg>` is set to ``true``). This can be "
"changed by setting :ref:`Clear "
"Mode<class_Viewport_property_render_target_clear_mode>` to Never or Next "
"Frame. As the name implies, Never means the texture will never be cleared, "
"while next frame will clear the texture on the next frame and then set "
"itself to Never."
msgstr ""

msgid ""
"By default, re-rendering of the :ref:`Viewport <class_Viewport>` happens "
"when the :ref:`Viewport <class_Viewport>`'s :ref:`ViewportTexture "
"<class_ViewportTexture>` has been drawn in a frame. If visible, it will be "
"rendered; otherwise, it will not. This behavior can be changed to manual "
"rendering (once), or always render, no matter if visible or not. This "
"flexibility allows users to render an image once and then use the texture "
"without incurring the cost of rendering every frame."
msgstr ""

msgid ""
"Make sure to check the Viewport demos! Viewport folder in the demos archive "
"available to download, or https://github.com/godotengine/godot-demo-projects/"
"tree/master/viewport"
msgstr ""

msgid "Translation status"
msgstr "Progresso da Tradução"
