# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Autoloads versus regular nodes"
msgstr "Autoloads versus nós normais"

msgid ""
"Godot offers a feature to automatically load nodes at the root of your "
"project, allowing you to access them globally, that can fulfill the role of "
"a Singleton: :ref:`doc_singletons_autoload`. These auto-loaded nodes are not "
"freed when you change the scene from code with :ref:`SceneTree.change_scene "
"<class_SceneTree_method_change_scene>`."
msgstr ""
"O Godot oferece um recurso para carregar automaticamente nós na raiz do seu "
"projeto, permitindo que você os acesse globalmente, que pode cumprir o papel "
"de um Singleton: :ref:`doc_singletons_autoload`. Estes nós auto-carregados "
"não são liberados quando você muda a cena pelo código com :ref:`SceneTree."
"change_scene <class_SceneTree_method_change_scene>`."

msgid ""
"In this guide, you will learn when to use the Autoload feature, and "
"techniques you can use to avoid it."
msgstr ""
"Neste guia, você aprenderá quando usar a funcionalidade Autoload e as "
"técnicas que você pode usar para evitá-lo."

msgid "The cutting audio issue"
msgstr "O problema do corte de áudio"

msgid ""
"Other engines can encourage the use of creating manager classes, singletons "
"that organize a lot of functionality into a globally accessible object. "
"Godot offers many ways to avoid global state thanks to the node tree and "
"signals."
msgstr ""
"Outros motores podem encorajar o uso da criação de classes de gerenciador, "
"singletons que organizam muita funcionalidade em um objeto globalmente "
"acessível. O Godot oferece muitas maneiras de evitar o estado global graças "
"à árvore de nós e aos sinais."

msgid ""
"For example, let's say we are building a platformer and want to collect "
"coins that play a sound effect. There's a node for that: the :ref:"
"`AudioStreamPlayer <class_AudioStreamPlayer>`. But if we call the "
"``AudioStreamPlayer`` while it is already playing a sound, the new sound "
"interrupts the first."
msgstr ""
"Por exemplo, digamos que estamos construindo um jogo de plataforma e "
"queremos coletar moedas que reproduzam um efeito sonoro. Há um nó para isso: "
"o :ref:`AudioStreamPlayer <class_AudioStreamPlayer>`. Mas se chamarmos o "
"``AudioStreamPlayer`` enquanto ele já está tocando um som, o novo som "
"interrompe o primeiro."

msgid ""
"A solution is to code a global, auto-loaded sound manager class. It "
"generates a pool of ``AudioStreamPlayer`` nodes that cycle through as each "
"new request for sound effects comes in. Say we call that class ``Sound``, "
"you can use it from anywhere in your project by calling ``Sound."
"play(\"coin_pickup.ogg\")``. This solves the problem in the short term but "
"causes more problems:"
msgstr ""
"Uma solução é codificar uma classe de gestão de som global e auto-carregada. "
"Ele gera um conjunto de nós ``AudioStreamPlayer`` que se movimentam à medida "
"que cada nova solicitação de efeitos sonoros chega. Digamos que chamamos "
"essa classe ``Sound``, você pode utilizá-la de qualquer lugar do seu projeto "
"chamando ``Sound.play(\"coin_pickup.ogg\")``. Isto resolve o problema a "
"curto prazo, mas causa mais problemas:"

msgid ""
"**Global state**: one object is now responsible for all objects' data. If "
"the ``Sound`` class has errors or doesn't have an AudioStreamPlayer "
"available, all the nodes calling it can break."
msgstr ""
"**Estado global**: um objeto agora é responsável pelos dados de todos os "
"objetos. Se a classe ``Sound`` tem erros ou não tem um AudioStreamPlayer "
"disponível, todos os nós que o chamam podem quebrar."

msgid ""
"**Global access**: now that any object can call ``Sound.play(sound_path)`` "
"from anywhere, there's no longer an easy way to find the source of a bug."
msgstr ""
"**Acesso global**: agora que qualquer objeto pode chamar ``Sound."
"play(sound_path)`` de qualquer lugar, não há mais uma maneira fácil de "
"encontrar a origem de um bug."

msgid ""
"**Global resource allocation**: with a pool of ``AudioStreamPlayer`` nodes "
"stored from the start, you can either have too few and face bugs, or too "
"many and use more memory than you need."
msgstr ""
"**Alocação global de recursos***: com um conjunto de nós "
"``AudioStreamPlayer`` armazenados desde o início, você pode ou ter muito "
"poucos e enfrentar bugs, ou muitos e utilizar mais memória do que você "
"precisa."

msgid ""
"About global access, the problem is that Any code anywhere could pass wrong "
"data to the ``Sound`` autoload in our example. As a result, the domain to "
"explore to fix the bug spans the entire project."
msgstr ""
"Sobre o acesso global, o problema é que qualquer código em qualquer lugar "
"pode passar dados errados para o autoload ``Sound`` no nosso exemplo. Como "
"resultado, o domínio a explorar para corrigir o bug abrange todo o projeto."

msgid ""
"When you keep code inside a scene, only one or two scripts may be involved "
"in audio."
msgstr ""
"Quando você mantém o código dentro de uma cena, apenas um ou dois scripts "
"podem estar envolvidos no áudio."

msgid ""
"Contrast this with each scene keeping as many ``AudioStreamPlayer`` nodes as "
"it needs within itself and all these problems go away:"
msgstr ""
"Contraste isto com cada cena mantendo tantos nós ``AudioStreamPlayer`` "
"quantos forem necessários dentro de si e todos estes problemas desaparecem:"

msgid ""
"Each scene manages its own state information. If there is a problem with the "
"data, it will only cause issues in that one scene."
msgstr ""
"Cada cena gerencia suas próprias informações de estado. Se houver um "
"problema com os dados, isso causará problemas apenas naquela cena."

msgid ""
"Each scene accesses only its own nodes. Now, if there is a bug, it's easy to "
"find which node is at fault."
msgstr ""
"Cada cena acessa apenas seus próprios nós. Agora, se houver um bug, é fácil "
"descobrir qual nó é o culpado."

msgid "Each scene allocates exactly the amount of resources it needs."
msgstr "Cada cena aloca exatamente a quantidade de recursos de que precisa."

msgid "Managing shared functionality or data"
msgstr "Gestão de funcionalidades ou dados compartilhados"

msgid ""
"Another reason to use an Autoload can be that you want to reuse the same "
"method or data across many scenes."
msgstr ""
"Outra razão para usar um Autoload pode ser que você queira reutilizar o "
"mesmo método ou dados em muitas cenas."

msgid ""
"In the case of functions, you can create a new type of ``Node`` that "
"provides that feature for an individual scene using the :ref:`class_name "
"<doc_gdscript_basics_class_name>` keyword in GDScript."
msgstr ""
"No caso de funções, você pode criar um novo tipo de ``Node`` que fornece "
"esse recurso para uma cena individual utilizando a palavra-chave :ref:"
"`class_name <doc_scripting_continued_class_name>` em GDScript."

msgid "When it comes to data, you can either:"
msgstr "Quando se trata de dados, você pode:"

msgid ""
"Create a new type of :ref:`Resource <class_Resource>` to share the data."
msgstr ""
"Cria um novo tipo de :ref:`Resource <class_Resource>` para compartilhar os "
"dados."

msgid ""
"Store the data in an object to which each node has access, for example using "
"the ``owner`` property to access the scene's root node."
msgstr ""
"Armazenar os dados em um objeto ao qual cada nó tem acesso, por exemplo "
"utilizando a propriedade ``owner`` para acessar o nó raiz da cena."

msgid "When you should use an Autoload"
msgstr "Quando você deve usar um Autoload"

msgid "Auto-loaded nodes can simplify your code in some cases:"
msgstr ""
"Nós carregados automaticamente podem simplificar seu código em alguns casos:"

msgid ""
"**Static Data**: if you need data that is exclusive to one class, like a "
"database, then an autoload can be a good tool. There is no scripting API in "
"Godot to create and manage static data otherwise."
msgstr ""
"**Dados estáticos**: se você precisa de dados exclusivos de uma classe, como "
"um banco de dados, então um auto-carregamento pode ser uma boa ferramenta. "
"Não há API de scripting no Godot para criar e gerenciar dados estáticos de "
"outra forma."

msgid ""
"**Static functions**: creating a library of functions that only return "
"values."
msgstr ""
"**Funções estáticas**: criar uma biblioteca de funções que só retornam "
"valores."

msgid ""
"**Systems with a wide scope**: If the singleton is managing its own "
"information and not invading the data of other objects, then it's a great "
"way to create systems that handle broad-scoped tasks. For example, a quest "
"or a dialogue system."
msgstr ""
"**Sistemas com amplo escopo**: se o singleton está gerenciando suas próprias "
"informações e não invadindo os dados de outros objetos, então é uma ótima "
"maneira de criar sistemas que lidam com tarefas de amplo escopo. Por "
"exemplo, uma quest ou um sistema de diálogo."

msgid ""
"Until Godot 3.1, another use was just for convenience: autoloads have a "
"global variable for their name generated in GDScript, allowing you to call "
"them from any script file in your project. But now, you can use the "
"``class_name`` keyword instead to get auto-completion for a type in your "
"entire project."
msgstr ""
"Até o Godot 3.1, outro uso era apenas por conveniência: os autoloads têm uma "
"variável global para seu nome gerada no GDScript, permitindo que você os "
"chame a partir de qualquer arquivo de script em seu projeto. Mas agora, você "
"pode usar a palavra-chave ``class_name`` para obter o preenchimento "
"automático de um tipo em todo o seu projeto."

msgid ""
"Autoload is not exactly a Singleton. Nothing prevents you from instantiating "
"copies of an auto-loaded node. It is only a tool that makes a node load "
"automatically as a child of the root of your scene tree, regardless of your "
"game's node structure or which scene you run, e.g. by pressing :kbd:`F6` key."
msgstr ""
"Autoload não é exatamente um Singleton. Nada o impede de instanciar cópias "
"de um nó carregado automaticamente. É apenas uma ferramenta que faz um nó "
"carregar automaticamente como um filho da raiz da sua árvore de cenas, "
"independentemente da estrutura do seu jogo ou da cena que você executar, por "
"exemplo, pressionando a tecla :kbd:`F6`."

msgid ""
"As a result, you can get the auto-loaded node, for example an autoload "
"called ``Sound``, by calling ``get_node(\"/root/Sound\")``."
msgstr ""
"Como resultado, você pode obter o nó carregado automaticamente, por exemplo, "
"um autoload chamado ``Sound``, chamando ``get_node(\"/root/Sound\")``."

msgid "Translation status"
msgstr "Progresso da Tradução"
