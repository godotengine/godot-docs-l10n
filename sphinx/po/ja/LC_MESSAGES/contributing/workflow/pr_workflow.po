# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Pull request workflow"
msgstr "プルリクエスト・ワークフロー"

msgid ""
"The so-called \"PR workflow\" used by Godot is common to many projects using "
"Git, and should be familiar to veteran free software contributors. The idea "
"is that only a small number (if any) commit directly to the *master* branch. "
"Instead, contributors *fork* the project (i.e. create a copy of it, which "
"they can modify as they wish), and then use the GitHub interface to request "
"a *pull* from one of their fork's branches to one branch of the original "
"(often named *upstream*) repository."
msgstr ""
"Godotが使用するいわゆる「PRワークフロー」は、Gitを使用する多くのプロジェクト"
"に共通しており、ベテランのフリーソフトウェア貢献者には馴染み深いはずです。ア"
"イデアは、少数(もしある場合)だけが\\ *master*\\ ブランチに直接コミットするこ"
"とです。代わりに、寄稿者\\ *フォーク*\\ プロジェクト(つまり、必要に応じて変更"
"できるコピーを作成する)を使用し、GitHubインターフェイスを使用して、フォークの"
"分岐の1つから元のブランチ (多くの場合は\\ *upstream*\\ ) リポジトリの1つのブ"
"ランチに\\ *プル*\\ をリクエストします。"

msgid ""
"The resulting *pull request* (PR) can then be reviewed by other "
"contributors, which might approve it, reject it, or most often request that "
"modifications be done. Once approved, the PR can then be merged by one of "
"the core developers, and its commit(s) will become part of the target branch "
"(usually the *master* branch)."
msgstr ""
"結果の\\ *プルリクエスト*\\ (PR) は、他の貢献者によって確認され、承認、拒否、"
"またはほとんどの場合、変更の実行を要求できます。承認されると、PRはコア開発者"
"の1人によってマージされ、そのコミットはターゲットブランチ (通常は\\ "
"*master*\\ ブランチ) の一部になります。"

#, fuzzy
msgid ""
"We will go together through an example to show the typical workflow and "
"associated Git commands. But first, let's have a quick look at the "
"organization of Godot's Git repository."
msgstr ""
"一般的なワークフローと関連するGit コマンドを示す例をまとめます。しかし、ま"
"ず、GodotのGitリポジトリの組織を簡単に見てみましょう。"

msgid "Git source repository"
msgstr "Gitソースリポジトリ"

msgid ""
"The `repository on GitHub <https://github.com/godotengine/godot>`_ is a `Git "
"<https://git-scm.com>`_ code repository together with an embedded issue "
"tracker and PR system."
msgstr ""
"`GitHubのリポジトリ <https://github.com/godotengine/godot>`_\\ は、組み込みの"
"問題追跡システムとPRシステムを備えた\\ `Git <https://git-scm.com>`_\\ コード"
"リポジトリです。"

msgid ""
"If you are contributing to the documentation, its repository can be found "
"`here <https://github.com/godotengine/godot-docs>`_."
msgstr ""
"ドキュメントに貢献する場合は、そのリポジトリは `こちら <https://github.com/"
"godotengine/godot-docs>`_ にあります。"

msgid ""
"The Git version control system is the tool used to keep track of successive "
"edits to the source code - to contribute efficiently to Godot, learning the "
"basics of the Git command line is *highly* recommended. There exist some "
"graphical interfaces for Git, but they usually encourage users to take bad "
"habits regarding the Git and PR workflow, and we therefore recommend not to "
"use them. In particular, we advise not to use GitHub's online editor for "
"code contributions (although it's tolerated for small fixes or documentation "
"changes) as it enforces one commit per file and per modification, which "
"quickly leads to PRs with an unreadable Git history (especially after peer "
"review)."
msgstr ""
"Gitバージョン管理システムは、ソースコードへの連続した編集を追跡するために使用"
"されるツールです - Godotに効率的に貢献するために、Gitコマンドラインの基本を学"
"ぶことは\\ *強く*\\ 推奨されます。Gitにはグラフィカルインターフェイスがいくつ"
"かありますが、通常はGitとPRワークフローに関する悪い習慣をユーザーに奨励するた"
"め、使用しないことをお勧めします。特に、GitHubのオンラインエディタをコードの"
"投稿に使用しないことをお勧めします (ただし、小さな修正やドキュメントの変更に"
"は許容されます)、ファイルごとに1つのコミットが適用され、変更ごとに1つのコミッ"
"トが適用され、読み取り不能なGit履歴を持つPRがすぐに発生します(特にピアレ"
"ビューの後)。"

#, fuzzy
msgid ""
"The first sections of Git's \"Book\" are a good introduction to the tool's "
"philosophy and the various commands you need to master in your daily "
"workflow. You can read them online on the `Git SCM <https://git-scm.com/book/"
"en/v2>`_ website. You can also try out `GitHub's interactive guide <https://"
"try.github.io/>`__."
msgstr ""
"Gitの「ブック」の最初のセクションは、ツールの哲学と、毎日のワークフローで習得"
"する必要があるさまざまなコマンドの優れた紹介です。\\ `Git SCM <https://git-"
"scm.com/book/en/v2>`_\\ Webサイトでオンラインで読むことができます。"

msgid "The branches on the Git repository are organized as follows:"
msgstr "Gitリポジトリ上のブランチは、次のように編成されています:"

msgid ""
"The ``master`` branch is where the development of the next major version "
"occurs. As a development branch, it can be unstable and is not meant for use "
"in production. This is where PRs should be done in priority."
msgstr ""
"``master`` ブランチは、次のメジャーバージョンの開発が行われる場所です。開発ブ"
"ランチとして、それは不安定であり、生産で使用するためのものではありません。こ"
"こでPRを優先して行う必要があります。"

#, fuzzy
msgid ""
"The stable branches are named after their version, e.g. ``3.1`` and ``2.1``. "
"They are used to backport bugfixes and enhancements from the ``master`` "
"branch to the currently maintained stable release (e.g. 3.1.2 or 2.1.6). As "
"a rule of thumb, the last stable branch is maintained until the next minor "
"version (e.g. the ``3.0`` branch was maintained until the release of Godot "
"3.1). If you want to make PRs against a maintained stable branch, please "
"check first if your changes are also relevant for the ``master`` branch, and "
"if so make the PR for the ``master`` branch in priority. Release managers "
"can then cherry-pick the fix to a stable branch if relevant."
msgstr ""
"安定したブランチは、バージョンにちなんで名前が付けられます(例:``3.1`` と "
"``2.1``)。これらは、\\ ``master`` ブランチから現在維持されている安定したリ"
"リース (3.1.2 や 2.1.6 など) にバグ修正と機能強化をバックポートするために使用"
"されます。経験則として、最後の安定したブランチは次のメジャー バージョンまで維"
"持されます (例: ``3.0`` ブランチは Godot 3.1 のリリースまで維持されていまし"
"た)。維持されている安定したブランチに対してPRを行いたい場合、変更が "
"``master`` ブランチにも関連しているかどうかを確認する必要があります。"

#, fuzzy
msgid ""
"There might occasionally be feature branches, usually meant to be merged "
"into the ``master`` branch at some time."
msgstr ""
"機能ブランチが存在する場合がありますが、通常はいつか ``master`` ブランチに"
"マージされることを意図しています。"

msgid "Forking and cloning"
msgstr "フォークとクローン作成"

msgid ""
"The first step is to *fork* the `godotengine/godot <https://github.com/"
"godotengine/godot>`_ repository on GitHub. To do so, you will need to have a "
"GitHub account and to be logged in. In the top right corner of the "
"repository's GitHub page, you should see the \"Fork\" button as shown below:"
msgstr ""
"最初のステップは、GitHubで\\ `godotengine / godot <https://github.com/"
"godotengine/godot>`_\\ リポジトリを\\ *フォーク*\\ することです。 そのために"
"は、GitHubアカウントが必要であり、ログインする必要があります。リポジトリの"
"GitHubページの右上隅に、以下に示すように「フォーク」ボタンが表示されます:"

msgid ""
"Click it, and after a while you should be redirected to your own fork of the "
"Godot repo, with your GitHub username as namespace:"
msgstr ""
"これをクリックすると、しばらくするとGitHubのユーザ名を名前空間として、Godot "
"repoの自分のフォークにリダイレクトされるはずです:"

msgid ""
"You can then *clone* your fork, i.e. create a local copy of the online "
"repository (in Git speak, the *origin remote*). If you haven't already, "
"download Git from `its website <https://git-scm.com>`_ if you're using "
"Windows or macOS, or install it through your package manager if you're using "
"Linux."
msgstr ""
"次に、forkの\\ *クローン*\\ を作成します。つまり、オンラインリポジトリのロー"
"カルコピーを作成します(Gitの言葉を使えば、\\ *元のリモート*\\ )。まだGitをダ"
"ウンロードしていない場合は、WindowsまたはmacOSを使用している場合はその\\ `Web"
"サイト <https://git-scm.com>`_\\ からダウンロードし、Linuxを使用している場合"
"はパッケージマネージャからインストールします。"

msgid ""
"If you are on Windows, open Git Bash to type commands. macOS and Linux users "
"can use their respective terminals."
msgstr ""
"Windowsを使用している場合は、Git Bashを開いてコマンドを入力します。macOSと"
"Linuxユーザーはそれぞれの端末を使用できます。"

msgid "To clone your fork from GitHub, use the following command:"
msgstr "GitHubからフォークのクローンを作成するには、次のコマンドを使用します:"

msgid ""
"In our examples, the \"$\" character denotes the command line prompt on "
"typical UNIX shells. It is not part of the command and should not be typed."
msgstr ""
"この例では、「$」文字は、一般的なUNIXシェルのコマンドラインプロンプトを示しま"
"す。これはコマンドの一部ではないため、入力しないでください。"

msgid ""
"After a little while, you should have a ``godot`` directory in your current "
"working directory. Move into it using the ``cd`` command:"
msgstr ""
"しばらくすると、現在の作業ディレクトリに ``godot`` ディレクトリが表示されま"
"す。 ``cd`` コマンドを使用して移動します:"

msgid ""
"We will start by setting up a reference to the original repository that we "
"forked:"
msgstr "まず、フォークした元のリポジトリへの参照を設定します:"

#, fuzzy
msgid ""
"This will create a reference named ``upstream`` pointing to the original "
"``godotengine/godot`` repository. This will be useful when you want to pull "
"new commits from its ``master`` branch to update your fork. You have another "
"remote reference named ``origin``, which points to your fork (``USERNAME/"
"godot``)."
msgstr ""
"これにより、元の godotengine/godot リポジトリを指す ``upstream`` という名前の"
"参照が作成されます。これは、フォークを更新するために ``master`` ブランチから"
"新しいコミットをプルする場合に便利です。フォークを指す ``origin`` という名前"
"の別の ``remote`` 参照があります。"

msgid ""
"You only need to do the above steps once, as long as you keep that local "
"``godot`` folder (which you can move around if you want, the relevant "
"metadata is hidden in its ``.git`` subfolder)."
msgstr ""
"ローカルの ``godot`` フォルダを保持している限り、上記の手順を実行する必要があ"
"るのは1回だけです(必要に応じて移動できますが、関連するメタデータは ``.git`` "
"サブフォルダに隠されています)。"

msgid ""
"*Branch it, pull it, code it, stage it, commit, push it, rebase it... "
"technologic.*"
msgstr ""
"*ブランチ、プル、コーディング、ステージング、コミット、プッシュ、リベース..."
"テクノロジー。*"

msgid ""
"This bad take on Daft Punk's *Technologic* shows the general conception Git "
"beginners have of its workflow: lots of strange commands to learn by copy "
"and paste, hoping they will work as expected. And that's actually not a bad "
"way to learn, as long as you're curious and don't hesitate to question your "
"search engine when lost, so we will give you the basic commands to know when "
"working in Git."
msgstr ""
"Daft Punkの\\ *Technologic*\\ に対するこの悪い見方は、Git初心者がワークフロー"
"について持っている一般的な概念を示しています。コピーアンドペーストで学ぶ多く"
"の奇妙なコマンドは、期待どおりに機能することを望んでいます。 そして、あなたが"
"好奇心が強く、迷ったときに検索エンジンに質問することを躊躇しない限り、それは"
"実際に学ぶための悪い方法ではないので、Gitで作業するときに知る基本的なコマンド"
"を提供します。"

#, fuzzy
msgid ""
"In the following, we will assume as an example that you want to implement a "
"feature in Godot's Project Manager, which is coded in the ``editor/"
"project_manager.cpp`` file."
msgstr ""
"以下では、 ``editor/project_manager.cpp`` ファイルにコーディングされている機"
"能をGodotのプロジェクトマネージャーに実装することを想定しています。"

msgid "Branching"
msgstr "ブランチ"

msgid ""
"By default, the ``git clone`` should have put you on the ``master`` branch "
"of your fork (``origin``). To start your own feature development, we will "
"create a feature branch:"
msgstr ""
"デフォルトでは、 `` git clone`` はフォークの ``master`` ブランチ( `` "
"origin`` )に置かれているはずです。 独自の機能開発を開始するために、機能ブラン"
"チを作成します:"

msgid "This command is equivalent:"
msgstr "このコマンドは、次のコマンドと同等です:"

msgid "If you want to go back to the ``master`` branch, you'd use:"
msgstr "``master`` ブランチに戻す場合は、次の方法を使用します:"

msgid ""
"You can see which branch you are currently on with the ``git branch`` "
"command:"
msgstr ""
"``git branch`` コマンドを使用して現在どのブランチに入っているかを確認できま"
"す:"

msgid ""
"Be sure to always go back to the ``master`` branch before creating a new "
"branch, as your current branch will be used as the base for the new one. "
"Alternatively, you can specify a custom base branch after the new branch's "
"name:"
msgstr ""

msgid "Updating your branch"
msgstr "ブランチの更新"

msgid ""
"This would not be needed the first time (just after you forked the upstream "
"repository). However, the next time you want to work on something, you will "
"notice that your fork's ``master`` is several commits behind the upstream "
"``master`` branch: pull requests from other contributors would have been "
"merged in the meantime."
msgstr ""
"これは最初は必要ありません(アップストリームリポジトリをフォークした直後)。し"
"かし、次に何かをしたいときには、あなたのフォークの ``master`` が上流の "
"``master`` ブランチの後ろにいくつかのコミットがあることに気づくでしょう。その"
"間に他の貢献者からのプルリクエストがマージされているでしょう。"

msgid ""
"To ensure there won't be conflicts between the feature you develop and the "
"current upstream ``master`` branch, you will have to update your branch by "
"*pulling* the upstream branch."
msgstr ""
"開発する機能と現在のアップストリーム ``master`` ブランチとの間に競合が生じな"
"いようにするには、アップストリームブランチを\\ *プル*\\ によってブランチを更"
"新する必要があります。"

msgid ""
"The ``--rebase`` argument will ensure that any local changes that you "
"committed will be re-applied *on top* of the pulled branch, which is usually "
"what we want in our PR workflow. This way, when you open a pull request, "
"your own commits will be the only difference with the upstream ``master`` "
"branch."
msgstr ""

msgid ""
"While rebasing, conflicts may arise if your commits modified code that has "
"been changed in the upstream branch in the meantime. If that happens, Git "
"will stop at the conflicting commit and will ask you to resolve the "
"conflicts. You can do so with any text editor, then stage the changes (more "
"on that later), and proceed with ``git rebase --continue``. Repeat the "
"operation if later commits have conflicts too, until the rebase operation "
"completes."
msgstr ""

msgid ""
"If you're unsure about what is going on during a rebase and you panic (no "
"worry, we all do the first few times), you can abort the rebase with ``git "
"rebase --abort``. You will then be back to the original state of your branch "
"before calling ``git pull --rebase``."
msgstr ""

msgid ""
"If you omit the ``--rebase`` argument, you will instead create a merge "
"commit which tells Git what to make of the two distinct branches. If any "
"conflicts arise, they would be resolved all at once via this merge commit."
msgstr ""

msgid ""
"While this is a valid workflow and the default behavior of ``git pull``, "
"merge commits within PRs are frowned upon in our PR workflow. We only use "
"them when merging PRs into the upstream branch."
msgstr ""

msgid ""
"The philosophy is that a PR should represent the final stage of the changes "
"made to the codebase, and we are not interested in mistakes and fixes that "
"would have been done in intermediate stages before merging. Git gives us "
"great tools to \"rewrite the history\" and make it as if we got things right "
"the first time, and we're happy to use it to ensure that changes are easy to "
"review and understand long after they have been merged."
msgstr ""

msgid ""
"If you have already created a merge commit without using ``rebase``, or have "
"made any other changes that have resulted in undesired history, the best "
"option is to use an *interactive rebase* on the upstream branch. See the :"
"ref:`dedicated section <doc_pr_workflow_rebase>` for instructions."
msgstr ""
"もし ``rebase`` を使わずにすでにマージコミットを作成していたり、他の変更をし"
"た結果、望ましくない履歴が残っている場合は、上流ブランチで *interactive "
"rebase* を使うのが最善の方法です。説明は :ref:`専用セクション "
"<doc_pr_workflow_rebase>` を参照してください。"

msgid ""
"If at any time you want to *reset* a local branch to a given commit or "
"branch, you can do so with ``git reset --hard <commit ID>`` or ``git reset --"
"hard <remote>/<branch>`` (e.g. ``git reset --hard upstream/master``)."
msgstr ""

msgid ""
"Be warned that this will remove any changes that you might have committed in "
"this branch. If you ever lose commits by mistake, use the ``git reflog`` "
"command to find the commit ID of the previous state that you would like to "
"restore, and use it as argument of ``git reset --hard`` to go back to that "
"state."
msgstr ""

msgid "Making changes"
msgstr "変更を行う"

msgid ""
"You would then do your changes to our example's ``editor/project_manager."
"cpp`` file with your usual development environment (text editor, IDE, etc.)."
msgstr ""
"次に、通常の開発環境(テキストエディタ、IDEなど) を使用して、例の ``editor/"
"project_manager.cpp`` ファイルに変更を加えます。"

#, fuzzy
msgid ""
"By default, those changes are *unstaged*. The staging area is a layer "
"between your working directory (where you make your modifications) and the "
"local Git repository (the commits and all the metadata in the ``.git`` "
"folder). To bring changes from the working directory to the Git repository, "
"you need to *stage* them with the ``git add`` command, and then to commit "
"them with the ``git commit`` command."
msgstr ""
"デフォルトでは、これらの変更は\\ *ステージングされていません*\\ 。 ステージン"
"グ領域は、作業ディレクトリ(変更を行う場所)とローカルgitリポジトリ(コミットお"
"よび ``.git`` フォルダ内のすべてのメタデータ)の間のレイヤーです。 作業ディレ"
"クトリからGitリポジトリに変更を反映するには、 ``git add`` コマンドで変更を\\ "
"*ステージングし*\\ 、次に ``git commit`` コマンドでコミットする必要がありま"
"す。"

msgid ""
"There are various commands you should know to review your current work, "
"before staging it, while it is staged, and after it has been committed."
msgstr ""
"現在の作業を確認するために、ステージングする前、ステージング中、コミット後に"
"確認するために知っておくべきさまざまなコマンドがあります。"

msgid ""
"``git diff`` will show you the current unstaged changes, i.e. the "
"differences between your working directory and the staging area."
msgstr ""
"``git diff`` には、現在のステージングされていない変更、つまり作業ディレクトリ"
"とステージング領域の違いが表示されます。"

msgid ""
"``git checkout -- <files>`` will undo the unstaged changes to the given "
"files."
msgstr ""
"``git checkout -- <files>`` は、指定されたファイルに対するステージングされて"
"いない変更を取り消します。"

msgid "``git add <files>`` will *stage* the changes on the listed files."
msgstr ""
"``git add <files>`` は、リストされたファイルの変更を\\ *ステージング*\\ しま"
"す。"

msgid ""
"``git diff --staged`` will show the current staged changes, i.e. the "
"differences between the staging area and the last commit."
msgstr ""
"``git diff --staged`` は、現在のステージングされた変更、すなわちステージング"
"領域と最後のコミットの違いが表示されます。"

msgid "``git reset HEAD <files>`` will *unstage* changes to the listed files."
msgstr ""
"``git reset HEAD <files>`` は、リストされたファイルを\\ *ステージ解除*\\ しま"
"す。"

msgid ""
"``git status`` will show you what are the currently staged and unstaged "
"modifications."
msgstr ""
"``git status`` は、現在ステージングされ、ステージングされていない変更が何であ"
"るかを示します。"

msgid ""
"``git commit`` will commit the staged files. It will open a text editor (you "
"can define the one you want to use with the ``GIT_EDITOR`` environment "
"variable or the ``core.editor`` setting in your Git configuration) to let "
"you write a commit log. You can use ``git commit -m \"Cool commit log\"`` to "
"write the log directly."
msgstr ""
"``git commit`` はステージングされたファイルをコミットします。 テキストエディ"
"タが開き(Gitの ``GIT_EDITOR`` 環境変数または ``core.editor`` 設定で使用するエ"
"ディタを定義できます)、コミットログを書き込むことができます。 ``git commit -"
"m \"Cool commit log\"`` を使用して、ログを直接書き込むことができます。"

msgid ""
"``git commit --amend`` lets you amend the last commit with your currently "
"staged changes (added with ``git add``). This is the best option if you want "
"to fix a mistake in the last commit (bug, typo, style issue, etc.)."
msgstr ""

msgid ""
"``git log`` will show you the last commits of your current branch. If you "
"did local commits, they should be shown at the top."
msgstr ""
"``git log`` には、現在のブランチの最後のコミットが表示されます。ローカルコ"
"ミットを行った場合は、上部に表示する必要があります。"

msgid ""
"``git show`` will show you the changes of the last commit. You can also "
"specify a commit hash to see the changes for that commit."
msgstr ""
"``git show`` は、最後のコミットの変更を表示します。コミットハッシュを指定し"
"て、そのコミットの変更を確認することもできます。"

msgid ""
"That's a lot to memorize! Don't worry, just check this cheat sheet when you "
"need to make changes, and learn by doing."
msgstr ""
"覚えておくべきことがたくさんあります！心配する必要はありません。変更が必要な"
"場合はこのチートシートを確認し、実行して学習してください。"

msgid "Here's how the shell history could look like on our example:"
msgstr "この例では、シェルの履歴がどのように見えるかを次に示します:"

msgid ""
"With this, we should have two new commits in our ``better-project-manager`` "
"branch which were not in the ``master`` branch. They are still only local "
"though, the remote fork does not know about them, nor does the upstream repo."
msgstr ""
"これにより、 ``better-project-manager`` ブランチに ``master`` ブランチにはな"
"い2つの新しいコミットが必要になります。 ただし、それらはまだローカルのみであ"
"り、リモートフォークはそれらを認識せず、アップストリームリポジトリも認識しま"
"せん。"

msgid "Pushing changes to a remote"
msgstr "変更をリモートにプッシュする"

msgid ""
"That's where ``git push`` will come into play. In Git, a commit is always "
"done in the local repository (unlike Subversion where a commit will modify "
"the remote repository directly). You need to *push* the new commits to a "
"remote branch to share them with the world. The syntax for this is:"
msgstr ""
"そこで ``git push`` を使用します。Gitでは、コミットは常にローカルリポジトリで"
"行われます(コミットがリモートリポジトリを直接変更するSubversionとは異なりま"
"す)。 新しいコミットをリモートブランチに\\ *プッシュ*\\ して、それらを世界と"
"共有する必要があります。 この構文は次のとおりです:"

msgid ""
"The part about the remote branch can be omitted if you want it to have the "
"same name as the local branch, which is our case in this example, so we will "
"do:"
msgstr ""
"この例では、ローカル ブランチと同じ名前を付ける場合は、リモート ブランチに関"
"する部分を省略できます:"

msgid ""
"Git will ask you for your username and password. For your password, enter "
"your GitHub Personal Access Token (PAT). If you do not have a GitHub "
"Personal Access Token, or do not have one with the correct permissions for "
"your newly forked repository, you will need to create one. Follow this link "
"to create your Personal Access Token: `Creating a personal access token "
"<https://docs.github.com/en/authentication/keeping-your-account-and-data-"
"secure/creating-a-personal-access-token>`_."
msgstr ""

#, fuzzy
msgid ""
"After you have successfully verified your account using your PAT, the "
"changes will be sent to your remote repository. If you check the fork's page "
"on GitHub, you should see a new branch with your added commits."
msgstr ""
"Gitはユーザー名とパスワードを尋ね、変更内容はリモートに送信されます。GitHubで"
"フォークのページを確認すると、コミットが追加された新しいブランチが表示されま"
"す。"

msgid "Issuing a pull request"
msgstr "プルリクエストの発行"

#, fuzzy
msgid ""
"When you load your fork's branch on GitHub, you should see a line saying "
"*\"This branch is 2 commits ahead of godotengine:master.\"* (and potentially "
"some commits behind, if your ``master`` branch was out of sync with the "
"upstream ``master`` branch)."
msgstr ""
"フォークのブランチをGitHubにロードすると、 *「このブランチはgodotengine:"
"masterより2コミット先です」* という行が表示されます( ``master`` ブランチが"
"アップストリーム ``master`` ブランチと同期していない場合、潜在的にいくつかの"
"コミットが遅れます)。"

#, fuzzy
msgid ""
"On that line, there is a \"Pull request\" link. Clicking it will open a form "
"that will let you issue a pull request on the ``godotengine/godot`` upstream "
"repository. It should show you your two commits, and state \"Able to "
"merge\". If not (e.g. it has way more commits, or says there are merge "
"conflicts), don't create the PR yet, something went wrong. Go to our `Godot "
"Contributors Chat <https://chat.godotengine.org/>`_ and ask for support :)"
msgstr ""
"その行には、「プルリクエスト」リンクがあります。クリックすると、godotengine/"
"godotアップストリームリポジトリでプルリクエストを発行できるフォームが開きま"
"す。2つのコミットを表示し、「マージ可能」を示す必要があります。そうでない場合"
"(例えば、より多くのコミットがある場合、またはマージの競合があると言う)、PRを"
"作成しないでください。IRCに移動し、サポートを依頼しましょう"

msgid ""
"Use an explicit title for the PR and put the necessary details in the "
"comment area. You can drag and drop screenshots, GIFs or zipped projects if "
"relevant, to showcase what your work implements. Click \"Create a pull "
"request\", and tadaa!"
msgstr ""
"PRに明示的なタイトルを使用し、必要な詳細をコメント領域に配置します。スクリー"
"ンショット、GIF、またはzipプロジェクトをドラッグアンドドロップして、作業内容"
"を示すことができます。「プルリクエストを作成」をクリックし、じゃじゃーん!"

msgid "Modifying a pull request"
msgstr "プルリクエストの変更"

msgid ""
"While it is reviewed by other contributors, you will often need to make "
"changes to your yet-unmerged PR, either because contributors requested them, "
"or because you found issues yourself while testing."
msgstr ""
"他の貢献者によってレビューされていますが、貢献者が要求したか、テスト中に自分"
"で問題を発見したため、まだマージされていないPRを変更する必要があります。"

msgid ""
"The good news is that you can modify a pull request simply by acting on the "
"branch you made the pull request from. You can e.g. make a new commit on "
"that branch, push it to your fork, and the PR will be updated automatically:"
msgstr ""
"良いニュースは、プルリクエストを行ったブランチに基づいて操作するだけでプルリ"
"クエストを変更できることです。たとえば、そのブランチで新しいコミットを行い、"
"フォークにプッシュすると、PRが自動的に更新されます:"

msgid ""
"However, be aware that in our PR workflow, we favor commits that bring the "
"codebase from one functional state to another functional state, without "
"having intermediate commits fixing up bugs in your own code or style issues. "
"Most of the time, we will prefer a single commit in a given PR (unless "
"there's a good reason to keep the changes separate). Instead of authoring a "
"new commit, consider using ``git commit --amend`` to amend the previous "
"commit with your fixes. The above example would then become:"
msgstr ""

msgid "The interactive rebase"
msgstr ""

msgid ""
"If you didn't follow the above steps closely to *amend* changes into a "
"commit instead of creating fixup commits, or if you authored your changes "
"without being aware of our workflow and Git usage tips, reviewers might "
"request you to *rebase* your branch to *squash* some or all of the commits "
"into one."
msgstr ""

msgid ""
"Indeed, if some commits have been made following reviews to fix bugs, typos, "
"etc. in the original commit, they are not relevant to a future changelog "
"reader who would want to know what happened in the Godot codebase, or when "
"and how a given file was last modified."
msgstr ""

#, fuzzy
msgid ""
"To squash those extraneous commits into the main one, we will have to "
"*rewrite history*. Right, we have that power. You may read that it's a bad "
"practice, and it's true when it comes to branches of the upstream repo. But "
"in your fork, you can do whatever you want, and everything is allowed to get "
"neat PRs :)"
msgstr ""
"これら2つのコミットをまとめてつぶすには、\\ *履歴を書き換える*\\ 必要がありま"
"す。 私たちにはその力があります。 あなたはそれが悪い習慣であると読むかもしれ"
"ません、そしてそれはアップストリームレポのブランチに関しては本当です。 しか"
"し、あなたのフォークでは、あなたがやりたいことが何でもでき、すべてがきちんと"
"したPRを得ることができます:)"

msgid ""
"We will use the *interactive rebase* ``git rebase -i`` to do this. This "
"command takes a commit ID or a branch name as argument, and will let you "
"modify all commits between that commit/branch and the last one in your "
"working branch, the so-called ``HEAD``."
msgstr ""
"これには *interactive rebase* ``git rebase -i`` を使います。このコマンドはコ"
"ミットIDかブランチ名を引数にとり、そのコミット/ブランチと作業ブランチの最後の"
"コミット、いわゆる ``HEAD``との間のすべてのコミットを修正することができます。"

msgid ""
"While you can give any commit ID to ``git rebase -i`` and review everything "
"in between, the most common and convenient workflow involves rebasing on the "
"upstream ``master`` branch, which you can do with:"
msgstr ""

msgid ""
"Referencing branches in Git is a bit tricky due to the distinction between "
"remote and local branches. Here, ``upstream/master`` (with a `/`) is a local "
"branch which has been pulled from the ``upstream`` remote's ``master`` "
"branch."
msgstr ""

msgid ""
"Interactive rebases can only be done on local branches, so the `/` is "
"important here. As the upstream remote changes frequently, your local "
"``upstream/master`` branch may become outdated, so you can update it with "
"``git fetch upstream master``. Contrarily to ``git pull --rebase upstream "
"master`` which would update your currently checked out branch, ``fetch`` "
"will only update the ``upstream/master`` reference (which is distinct from "
"your local ``master`` branch... yes it's confusing, but you'll become "
"familiar with this little by little)."
msgstr ""

msgid ""
"This will open a text editor (``vi`` by default, see `Git docs <https://git-"
"scm.com/book/en/v2/Customizing-Git-Git-Configuration#_core_editor>`_ to "
"configure your favorite one) with something which may look like this:"
msgstr ""

msgid ""
"The editor will also show instructions regarding how you can act on those "
"commits. In particular, it should tell you that \"pick\" means to use that "
"commit (do nothing), and that \"squash\" and \"fixup\" can be used to *meld* "
"the commit in its parent commit. The difference between \"squash\" and "
"\"fixup\" is that \"fixup\" will discard the commit log from the squashed "
"commit. In our example, we are not interested in keeping the log of the "
"\"Fix a typo\" commit, so we use:"
msgstr ""
"エディタには、これらのコミットを実行する方法についての指示も表示されます。特"
"に、「pick」とはそのコミットを使用すること(何もしない)を意味し、「squash」と"
"「fixup」を使用してコミットを親コミットに\\ *マージ*\\ できることを示します。"
"「squash」と「fixup」の違いは、「fixup」はコミットログを圧縮されたコミットか"
"ら破棄する点です。この例では、「Fix a typo(誤字を修正する)」コミットのログを"
"保持することには関心がないので、以下を使用します:"

msgid ""
"Upon saving and quitting the editor, the rebase will occur. The second "
"commit will be melded into the first one, and ``git log`` and ``git show`` "
"should now confirm that you have only one commit with the changes from both "
"previous commits."
msgstr ""
"エディタを保存して終了すると、リベースが発生します。2番目のコミットが1番目の"
"コミットにマージされ、 ``git log`` と ``git show`` によって、前の2つのコミッ"
"トから変更されたコミットが1つだけであることが確認されます。"

msgid ""
"But! You rewrote the history, and now your local and remote branches have "
"diverged. Indeed, commit 1b4aad7 in the above example will have changed, and "
"therefore got a new commit hash. If you try to push to your remote branch, "
"it will raise an error:"
msgstr ""
"だがしかし!履歴を書き直した結果、ローカルブランチとリモートブランチが分岐しま"
"した。実際に、上記の例のコミット:1b4aad7は変更され、新しいコミットハッシュを"
"取得します。リモートブランチにプッシュしようとすると、エラーが発生します:"

#, fuzzy
msgid ""
"This is reasonable behavior, Git will not let you push changes that would "
"override remote content. But that's actually what we want to do here, so we "
"will have to *force* it:"
msgstr ""
"これは正常な動作です。Gitでは、リモートコンテンツをオーバーライドする変更を"
"プッシュできません。 しかし、実際にはここでやりたいことなので、\\ *強制する* "
"\\必要があります:"

msgid ""
"And tadaa! Git will happily *replace* your remote branch with what you had "
"locally (so make sure that's what you wanted, using ``git log``). This will "
"also update the PR accordingly."
msgstr ""
"じゃじゃーん！Gitは、リモートブランチをローカルで持っていたもので喜んで\\ *置"
"換*\\ します(したがって、 ``git log`` を使用して、それが目的のものであること"
"を確認してください) これにより、それに応じてPRも更新されます。"

msgid "Rebasing onto another branch"
msgstr ""

msgid ""
"If you have accidentally opened your PR on the wrong branch, or need to "
"target another branch for some reason, you might need to filter out a lot of "
"commits that differ between the old branch (for example ``4.2``) and the new "
"branch (for example ``master``). This can make rebasing difficult and "
"tedious. Fortunately ``git`` has a command just for this situation, ``git "
"rebase --onto``."
msgstr ""

msgid ""
"If your PR was created from the ``4.2`` branch and you want to update it to "
"instead start at ``master`` the following steps *should* fix this in one "
"step:"
msgstr ""

msgid ""
"This will take all the commits on your branch *after* the ``4.2`` branch, "
"and then splice them on top of ``master``, ignoring any commits from the "
"``4.2`` branch not on the ``master`` branch. You may still need to do some "
"fixing, but this command should save you a lot of tedious work removing "
"commits."
msgstr ""

msgid ""
"Just like above for the interactive rebase you need to force push your "
"branch to handle the different changes:"
msgstr ""

msgid "Deleting a Git branch"
msgstr "Gitブランチの削除"

msgid ""
"After your pull request gets merged, there's one last thing you should do: "
"delete your Git branch for the PR. There won't be issues if you don't delete "
"your branch, but it's good practice to do so. You'll need to do this twice, "
"once for the local branch and another for the remote branch on GitHub."
msgstr ""
"プルリクエストがマージされた後、最後にやることが1つあります。PRのGitブランチ"
"を削除します。 ブランチを削除しなくても問題はありませんが、削除することをお勧"
"めします。 これを2回行う必要があります。1回はローカルブランチ用、もう1回は"
"GitHub上のリモートブランチ用です。"

#, fuzzy
msgid "To delete our better Project Manager branch locally, use this command:"
msgstr ""
"プロジェクトマネージャブランチをローカルで削除するベターな方法では、次のコマ"
"ンドを使用します:"

msgid ""
"Alternatively, if the branch hadn't been merged yet and we wanted to delete "
"it anyway, instead of ``-d`` you would use ``-D``."
msgstr ""
"あるいは、ブランチがまだマージされておらず、とにかく削除したい場合は、 ``-"
"d`` の代わりに ``-D`` を使用します。"

msgid "Next, to delete the remote branch on GitHub use this command:"
msgstr ""
"次に、GitHub のリモートブランチを削除するには、次のコマンドを使用します:"

msgid ""
"You can also delete the remote branch from the GitHub PR itself, a button "
"should appear once it has been merged or closed."
msgstr ""

msgid "Translation status"
msgstr "翻訳ステータス"
