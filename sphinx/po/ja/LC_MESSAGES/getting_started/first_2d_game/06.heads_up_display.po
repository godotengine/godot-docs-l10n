# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2022, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-24 15:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Heads up display"
msgstr ""

msgid ""
"The final piece our game needs is a User Interface (UI) to display things "
"like score, a \"game over\" message, and a restart button."
msgstr ""

#, fuzzy
msgid ""
"Create a new scene, and add a :ref:`CanvasLayer <class_CanvasLayer>` node "
"named ``HUD``. \"HUD\" stands for \"heads-up display\", an informational "
"display that appears as an overlay on top of the game view."
msgstr ""
"ゲームに必要な最後の部分は、スコア、「ゲームオーバー」メッセージ、再起動ボタ"
"ンなどを表示するインターフェイスです。新しいシーンを作成し、 ``HUD`` という名"
"前の\\ :ref:`CanvasLayer <class_CanvasLayer>`\\ ノードを追加します。「HUD」"
"は、ゲームビューの上にオーバーレイとして表示される情報表示である「ヘッドアッ"
"プディスプレイ」の略です。"

msgid ""
"The :ref:`CanvasLayer <class_CanvasLayer>` node lets us draw our UI elements "
"on a layer above the rest of the game, so that the information it displays "
"isn't covered up by any game elements like the player or mobs."
msgstr ""
":ref:`CanvasLayer <class_CanvasLayer>`\\ ノードを使用すると、ゲームの他の部分"
"よりも上のレイヤにUI要素を描画することができるため、表示される情報がプレイ"
"ヤーやモブなどのゲーム要素によって隠されることがなくなります。"

msgid "The HUD needs to display the following information:"
msgstr "HUDには、次の情報を表示する必要があります:"

msgid "Score, changed by ``ScoreTimer``."
msgstr "``ScoreTimer`` によって変更されるスコア。"

msgid "A message, such as \"Game Over\" or \"Get Ready!\""
msgstr "「Game Over」や「Get Ready! (よーい！)」 などのメッセージ"

msgid "A \"Start\" button to begin the game."
msgstr "ゲームを開始する「スタート」ボタン。"

msgid ""
"The basic node for UI elements is :ref:`Control <class_Control>`. To create "
"our UI, we'll use two types of :ref:`Control <class_Control>` nodes: :ref:"
"`Label <class_Label>` and :ref:`Button <class_Button>`."
msgstr ""
"UI要素の基本ノードは\\ :ref:`コントロール <class_Control>`\\ です。UIを作成す"
"るには、\\ :ref:`ラベル <class_Label>`\\ と\\ :ref:`ボタン <class_Button>`\\ "
"の2種類の\\ :ref:`コントロール <class_Control>`\\ ノードを使用します。"

msgid "Create the following as children of the ``HUD`` node:"
msgstr "``HUD`` ノードの子として次を作成します:"

msgid ":ref:`Label <class_Label>` named ``ScoreLabel``."
msgstr "``ScoreLabel`` という名前の\\ :ref:`ラベル <class_Label>`\\ 。"

msgid ":ref:`Label <class_Label>` named ``Message``."
msgstr "``Message`` という名前の\\ :ref:`Label <class_Label>`\\ 。"

msgid ":ref:`Button <class_Button>` named ``StartButton``."
msgstr "``StartButton`` という名前の\\ :ref:`ボタン <class_Button>`\\ 。"

msgid ":ref:`Timer <class_Timer>` named ``MessageTimer``."
msgstr "``MessageTimer`` という名前の\\ :ref:`Timer <class_Timer>`\\ 。"

msgid ""
"Click on the ``ScoreLabel`` and type a number into the ``Text`` field in the "
"Inspector. The default font for ``Control`` nodes is small and doesn't scale "
"well. There is a font file included in the game assets called \"Xolonium-"
"Regular.ttf\". To use this font, do the following:"
msgstr ""
"``ScoreLabel`` をクリックし、インスペクタの\\ *Text*\\ フィールドに数字を入力"
"します。 ``Control`` ノードのデフォルトのフォントは小さく、うまくスケールしま"
"せん。そこで、ゲームアセットに含まれる 「Xolonium-Regular.ttf」というフォント"
"ファイルがあります。 このフォントを使用するには、次のようにしてください:"

#, fuzzy
msgid "Under \"Theme Overrides/Fonts/Font\", choose \"New DynamicFont\""
msgstr "「カスタムフォント」で 「新しい動的フォント」を選択します"

#, fuzzy
msgid ""
"Click on the \"DynamicFont\" you added, and under \"Font/Font Data\", choose "
"\"Load\" and select the \"Xolonium-Regular.ttf\" file."
msgstr ""
"\"Font/Data/0\" の下の、追加した \"Font\" をクリックし、 [読み込み] を選択"
"し、\"Xolonium-Regular.ttf\" ファイルを選択します。"

#, fuzzy
msgid ""
"Once you've done this on the ``ScoreLabel``, you can click the down arrow "
"next to the Font property and choose \"Copy\", then \"Paste\" it in the same "
"place on the other two Control nodes. Set \"Size\" property of the "
"\"DynamicFont\" under \"Settings/Size\". A setting of ``64`` works well."
msgstr ""
"これを ``ScoreLabel`` で行ったら、DynamicFont プロパティの横にある下向き矢印"
"をクリックして「コピー」を選択し、他の２つのコントロールノードの同じ場所に"
"「ペースト」してください。また、フォントの ``Size`` も設定する必要がありま"
"す。 ``64`` の設定はうまく機能します。"

#, fuzzy
msgid ""
"**Anchors and Margins:** ``Control`` nodes have a position and size, but "
"they also have anchors and margins. Anchors define the origin - the "
"reference point for the edges of the node. Margins update automatically when "
"you move or resize a control node. They represent the distance from the "
"control node's edges to its anchor."
msgstr ""
"**アンカーとマージン**\\ : ``Control`` ノードには、位置とサイズがありますが、"
"アンカーとマージンもあります。アンカーによって、原点 (節点のエッジの参照点) "
"が定義されます。余白は、コントロールノードを移動またはサイズ変更すると自動的"
"に更新されます。コントロールノードのエッジからアンカーまでの距離を表します。"
"詳細は\\ :ref:`doc_design_interfaces_with_the_control_nodes`\\ を参照してくだ"
"さい。"

msgid ""
"Arrange the nodes as shown below. Click the \"Layout\" button to set a "
"Control node's layout:"
msgstr ""
"以下に示すようにノードを配置します。「レイアウト」ボタンをクリックして、コン"
"トロールノードのレイアウトを設定します:"

msgid ""
"You can drag the nodes to place them manually, or for more precise "
"placement, use the following settings:"
msgstr ""
"ノードをドラッグして手動で配置したり、より正確な配置を行うには、次の設定を使"
"用します:"

msgid "ScoreLabel"
msgstr "\\ ScoreLabel"

msgid "*Layout* : \"Top Wide\""
msgstr "\\ *Layout* : \"Top Wide\""

msgid "*Text* : ``0``"
msgstr "\\ *Text* : ``0``"

msgid "*Align* : \"Center\""
msgstr "\\ *Align* : \"Center\""

msgid "Message"
msgstr "Message"

msgid "*Layout* : \"HCenter Wide\""
msgstr "\\ *Layout* : \"HCenter Wide\""

msgid "*Text* : ``Dodge the Creeps!``"
msgstr "\\ *Text* : ``Dodge the Creeps!``"

msgid "*Autowrap* : \"On\""
msgstr "\\ *Autowrap* : \"On\""

msgid "StartButton"
msgstr "\\ StartButton"

msgid "*Text* : ``Start``"
msgstr "\\ *Text* : ``Start``"

msgid "*Layout* : \"Center Bottom\""
msgstr "\\ *Layout* : \"Center Bottom\""

msgid "*Margin* :"
msgstr "\\ *Margin* :"

msgid "Top: ``-200``"
msgstr "\\ Top: ``-200``"

msgid "Bottom: ``-100``"
msgstr "\\ Bottom: ``-100``"

msgid ""
"On the ``MessageTimer``, set the ``Wait Time`` to ``2`` and set the ``One "
"Shot`` property to \"On\"."
msgstr ""
"``MessageTimer`` 上で、\\ ``Wait Time`` を ``2`` に設定し、\\ ``One Shot`` プ"
"ロパティを「On」に設定してください。"

msgid "Now add this script to ``HUD``:"
msgstr "次に、このスクリプトを ``HUD`` に追加します:"

msgid ""
"The ``start_game`` signal tells the ``Main`` node that the button has been "
"pressed."
msgstr ""
"``start_game`` シグナルは、ボタンが押されたことを ``Main`` ノードに通知しま"
"す。"

msgid ""
"This function is called when we want to display a message temporarily, such "
"as \"Get Ready\"."
msgstr ""
"この関数は、「Get Ready」などのメッセージを一時的に表示させたい場合に呼び出さ"
"れます。"

msgid ""
"This function is called when the player loses. It will show \"Game Over\" "
"for 2 seconds, then return to the title screen and, after a brief pause, "
"show the \"Start\" button."
msgstr ""
"この関数は、プレイヤーが負けたときに呼び出されます。 2秒間「Game Over」と表示"
"され、タイトル画面に戻り、少し間を置いて「Start」ボタンが表示されます。"

msgid ""
"When you need to pause for a brief time, an alternative to using a Timer "
"node is to use the SceneTree's ``create_timer()`` function. This can be very "
"useful to add delays such as in the above code, where we want to wait some "
"time before showing the \"Start\" button."
msgstr ""
"短い間、一時停止する必要がある場合は、Timerノードを使用する代わりに、"
"SceneTreeの ``create_timer()`` 関数を使用します。 これは、上記のコードのよう"
"に、\"Start\" ボタンを表示する前に少し時間を置きたい場合など、遅延させるのに"
"非常に役立ちます。"

msgid "This function is called by ``Main`` whenever the score changes."
msgstr "この関数はスコアが変わるたびに ``Main`` によって呼び出されます。"

msgid ""
"Connect the ``timeout()`` signal of ``MessageTimer`` and the ``pressed()`` "
"signal of ``StartButton`` and add the following code to the new functions:"
msgstr ""
"``MessageTimer`` の ``timeout()`` シグナルと ``StartButton`` の "
"``pressed()`` シグナルを接続してから、下記のコードを新しい関数に加えます:"

msgid "Connecting HUD to Main"
msgstr "HUDをメインに接続する"

msgid ""
"Now that we're done creating the ``HUD`` scene, go back to ``Main``. "
"Instance the ``HUD`` scene in ``Main`` like you did the ``Player`` scene. "
"The scene tree should look like this, so make sure you didn't miss anything:"
msgstr ""
"``HUD`` シーンの作成が完了したら、 ``Main`` に戻ります。 ``Player`` のシーン"
"と同じように ``HUD`` シーンを ``Main`` にインスタンス化し、ツリーの一番下に配"
"置します。ツリー全体は次のようになるはずです。何も見落としていないか確認して"
"ください:"

msgid ""
"Now we need to connect the ``HUD`` functionality to our ``Main`` script. "
"This requires a few additions to the ``Main`` scene:"
msgstr ""
"次に、 ``HUD`` 機能を ``Main`` のスクリプトに接続します。これには、 ``Main`` "
"シーンにいくつかの追加が必要です:"

msgid ""
"In the Node tab, connect the HUD's ``start_game`` signal to the "
"``new_game()`` function of the Main node by typing \"new_game\" in the "
"\"Receiver Method\" in the \"Connect a Signal\" window. Verify that the "
"green connection icon now appears next to ``func new_game()`` in the script."
msgstr ""
"ノードタブで、「シグナルを接続」ウィンドウの 「受信側メソッド」に "
"\"new_game\" と入力して、HUDの ``start_game`` のシグナルをメインノードの "
"``new_game()`` 関数に接続します。スクリプトの ``func new_game()`` の横に緑色"
"の接続アイコンが表示されていることを確認してください。"

msgid ""
"In ``new_game()``, update the score display and show the \"Get Ready\" "
"message:"
msgstr ""
"``new_game()`` で、スコア表示を更新し、「Get Ready」メッセージを表示します:"

msgid "In ``game_over()`` we need to call the corresponding ``HUD`` function:"
msgstr "``game_over()`` では、対応する ``HUD`` 関数を呼び出す必要があります:"

msgid ""
"Finally, add this to ``_on_ScoreTimer_timeout()`` to keep the display in "
"sync with the changing score:"
msgstr ""
"最後に、これを ``_on_ScoreTimer_timeout()`` に追加して、変更されたスコアと同"
"期して表示を維持します:"

msgid ""
"Now you're ready to play! Click the \"Play the Project\" button. You will be "
"asked to select a main scene, so choose ``Main.tscn``."
msgstr ""
"これでプレイの準備が整いました！ [プロジェクトを実行] ボタンをクリックしま"
"す。メインシーンを選択するように求められますので、 ``Main.tscn`` を選択しま"
"す。"

msgid "Removing old creeps"
msgstr "古い「クリープ」を削除する"

msgid ""
"If you play until \"Game Over\" and then start a new game right away, the "
"creeps from the previous game may still be on the screen. It would be better "
"if they all disappeared at the start of a new game. We just need a way to "
"tell *all* the mobs to remove themselves. We can do this with the \"group\" "
"feature."
msgstr ""
"「ゲームオーバー」までプレイしてから新しいゲームを開始すると、前のゲームの"
"「クリープ」が画面に表示されたままになっています。 それらすべて、新しいゲーム"
"の開始時には消したほうがいいでしょう。それには、\\ *すべて*\\ のモブたちに自"
"身の削除を指示する方法が必要です。これは「グループ」機能を使えば可能です。"

msgid ""
"In the ``Mob`` scene, select the root node and click the \"Node\" tab next "
"to the Inspector (the same place where you find the node's signals). Next to "
"\"Signals\", click \"Groups\" and you can type a new group name and click "
"\"Add\"."
msgstr ""
"``Mob`` シーンでルートノードを選択し、インスペクタの隣にある「ノード」タブを"
"クリックしてください (ノードのシグナルを見つけるのと同じ場所です)。「シグナ"
"ル」の横にある「グループ」をクリックして、新しいグループ名を入力して「追加」"
"をクリックします。"

#, fuzzy
msgid ""
"Now all mobs will be in the \"mobs\" group. We can then add the following "
"line to the ``new_game()`` function in ``Main``:"
msgstr ""
"これですべてのモブが 「mobs」グループに入るようになります。あとは、 ``Main`` "
"内の ``game_over()`` 関数に次の行を追加します。"

msgid ""
"The ``call_group()`` function calls the named function on every node in a "
"group - in this case we are telling every mob to delete itself."
msgstr ""
"``call_group()`` 関数はグループ内の全てのノードに対して名前付きの関数を呼び出"
"します - この場合は全てのモブに自分自身を削除するように指示しています。"

msgid ""
"The game's mostly done at this point. In the next and last part, we'll "
"polish it a bit by adding a background, looping music, and some keyboard "
"shortcuts."
msgstr ""

#, fuzzy
msgid "Translation status"
msgstr "翻訳形式"
