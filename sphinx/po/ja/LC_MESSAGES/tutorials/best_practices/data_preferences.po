# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Data preferences"
msgstr "データ設定"

msgid ""
"Ever wondered whether one should approach problem X with data structure Y or "
"Z? This article covers a variety of topics related to these dilemmas."
msgstr ""
"問題Xにアプローチするときに、データ構造をYにするかZするかについて悩んだことは"
"ありませんか？この記事では、これらのジレンマに関連するさまざまなトピックにつ"
"いて説明します。"

msgid ""
"This article makes references to \"[something]-time\" operations. This "
"terminology comes from algorithm analysis' `Big O Notation <https://rob-bell."
"net/2009/06/a-beginners-guide-to-big-o-notation/>`_."
msgstr ""
"この記事では、「何らかの-時間」操作への言及を行います。この用語はアルゴリズム"
"分析の `ビッグ・オー記法 <https://rob-bell.net/2009/06/a-beginners-guide-to-"
"big-o-notation/>`_ に由来します。"

msgid ""
"Long-story short, it describes the worst-case scenario of runtime length. In "
"laymen's terms:"
msgstr "手短に言えば、実行時間の最悪のシナリオを説明しています。素人の言葉で:"

msgid ""
"\"As the size of a problem domain increases, the runtime length of the "
"algorithm...\""
msgstr ""
"「問題領域のサイズが大きくなるにつれて、アルゴリズムの実行時間の長さが...」"

msgid "Constant-time, ``O(1)``: \"...does not increase.\""
msgstr "定数時間、\\ ``O(1)``: 「...は増加しません」"

msgid "Logarithmic-time, ``O(log n)``: \"...increases at a slow rate.\""
msgstr "対数時間、\\ ``O(log n)``: 「...はゆっくりと増加します」"

msgid "Linear-time, ``O(n)``: \"...increases at the same rate.\""
msgstr "線形時間、\\ ``O(n)``: 「\"...は同じ割合で増加します」"

msgid "Etc."
msgstr "等。"

msgid ""
"Imagine if one had to process 3 million data points within a single frame. "
"It would be impossible to craft the feature with a linear-time algorithm "
"since the sheer size of the data would increase the runtime far beyond the "
"time allotted. In comparison, using a constant-time algorithm could handle "
"the operation without issue."
msgstr ""
"1つのフレーム内で300万個のデータ ポイントを処理する必要がある場合を想像してく"
"ださい。データのサイズが割り当てられた時間をはるかに超えてランタイムを増加さ"
"せるので、線形時間アルゴリズムを使用して機能を作成することは不可能です。対照"
"的に、定数時間アルゴリズムを使用すると、問題なく操作を処理できます。"

msgid ""
"By and large, developers want to avoid engaging in linear-time operations as "
"much as possible. But, if one keeps the scale of a linear-time operation "
"small, and if one does not need to perform the operation often, then it may "
"be acceptable. Balancing these requirements and choosing the right "
"algorithm / data structure for the job is part of what makes programmers' "
"skills valuable."
msgstr ""
"概して、開発者は線形時間操作に可能な限り関与することを避けたいと考えていま"
"す。ただし、線形時間操作の規模を小さく保ち、操作を頻繁に実行する必要がない場"
"合は、許容できる場合があります。これらの要件のバランスを取り、ジョブに適した"
"アルゴリズム/データ構造を選択することは、プログラマーのスキルを価値あるものに"
"します。"

msgid "Array vs. Dictionary vs. Object"
msgstr "Array(配列) 対 Dictionary(辞書) 対 Object(オブジェクト)"

#, fuzzy
msgid ""
"Godot stores all variables in the scripting API in the :ref:`Variant "
"<doc_variant_class>` class. Variants can store Variant-compatible data "
"structures such as :ref:`Array <class_Array>` and :ref:`Dictionary "
"<class_Dictionary>` as well as :ref:`Objects <class_Object>`."
msgstr ""
"Godotは、スクリプトAPI内のすべての変数を `バリアント型 <https://docs."
"godotengine.org/en/latest/development/cpp/variant_class.html>`_ クラスに格納"
"します。バリアントには、\\ :ref:`Array(配列) <class_Array>` や :ref:"
"`Dictionary(辞書) <class_Dictionary>` などのバリアント互換データ構造と :ref:"
"`Object(オブジェクト) <class_Object>` を格納できます。"

msgid ""
"Godot implements Array as a ``Vector<Variant>``. The engine stores the Array "
"contents in a contiguous section of memory, i.e. they are in a row adjacent "
"to each other."
msgstr ""
"GodotはArrayを ``Vector <Variant>``として実装します。エンジンは、配列の内容を"
"メモリの連続したセクションに保存します。つまり、それらは互いに隣接する行にあ"
"ります。"

#, fuzzy
msgid ""
"For those unfamiliar with C++, a Vector is the name of the array object in "
"traditional C++ libraries. It is a \"templated\" type, meaning that its "
"records can only contain a particular type (denoted by angled brackets). So, "
"for example, a :ref:`PackedStringArray <class_PackedStringArray>` would be "
"something like a ``Vector<String>``."
msgstr ""
"C++に慣れていない人にとって、ベクターは従来のC++ライブラリの配列オブジェクト"
"の名前です。これは「テンプレート化された」タイプです。つまり、そのレコードに"
"は特定のタイプ(山括弧で示される)のみを含めることができます。したがって、たと"
"えば、\\ :ref:`PoolStringArray <class_PoolStringArray>` は ``Vector "
"<String>`` のようなものになります。"

msgid "Contiguous memory stores imply the following operation performance:"
msgstr "連続したメモリ ストアは、次の操作パフォーマンスを意味します:"

msgid "**Iterate:** Fastest. Great for loops."
msgstr "**Iterate(反復):** 最速。ループに最適です。"

msgid "Op: All it does is increment a counter to get to the next record."
msgstr "処理: カウンタをインクリメントして次のレコードに行くだけです。"

msgid "**Insert, Erase, Move:** Position-dependent. Generally slow."
msgstr "**Insert(挿入)、Erase(消去)、Move(移動):** 位置に依存。一般的に遅い。"

msgid ""
"Op: Adding/removing/moving content involves moving the adjacent records over "
"(to make room / fill space)."
msgstr ""
"処理: コンテンツを追加/削除/移動するには、隣接するレコードを移動する必要があ"
"ります(スペースを空ける/スペースを塗りつぶす作業)。"

msgid "Fast add/remove *from the end*."
msgstr "*末尾からは*\\ 追加/削除が速い。"

msgid "Slow add/remove *from an arbitrary position*."
msgstr "*任意の位置からは*\\ 追加/削除が遅い。"

msgid "Slowest add/remove *from the front*."
msgstr "*先頭からは*\\ 追加/削除が最も遅い。"

msgid "If doing many inserts/removals *from the front*, then..."
msgstr "*先頭から*\\ 複数の挿入/削除を行う場合には..."

msgid "invert the array."
msgstr "配列の並びを反転します。"

msgid "do a loop which executes the Array changes *at the end*."
msgstr "*末尾から*\\ 配列の変更をするループ処理を実行します。"

msgid "re-invert the array."
msgstr "配列の並びを再反転します。"

msgid ""
"This makes only 2 copies of the array (still constant time, but slow) versus "
"copying roughly 1/2 of the array, on average, N times (linear time)."
msgstr ""
"この方法なら、操作の最中に配列の約1/2を平均してN回(線形時間)コピーをする代わ"
"りに、配列全体の2回のコピーだけで済みます(依然として一定の時間がかかり、遅い"
"ですが)。"

#, fuzzy
msgid ""
"**Get, Set:** Fastest *by position*. E.g. can request 0th, 2nd, 10th record, "
"etc. but cannot specify which record you want."
msgstr ""
"**取得、設定:** 位置で指定するので\\ *最速*\\ 。例: 0番目、2番目、10番目のレ"
"コードなどを要求できますが、必要なレコードを指定することはできません。"

msgid "Op: 1 addition operation from array start position up to desired index."
msgstr "処理: 配列の開始位置から目的のインデックスまでの1回の追加操作。"

msgid "**Find:** Slowest. Identifies the index/position of a value."
msgstr "**検索:** 最も遅い。値のインデックス/位置を識別します。"

msgid ""
"Op: Must iterate through array and compare values until one finds a match."
msgstr ""
"処理: 配列を反復処理し、一致するものが見つかるまで値を比較する必要がありま"
"す。"

msgid ""
"Performance is also dependent on whether one needs an exhaustive search."
msgstr "パフォーマンスは、徹底的な検索が必要かどうかによっても異なります。"

msgid ""
"If kept ordered, custom search operations can bring it to logarithmic time "
"(relatively fast). Laymen users won't be comfortable with this though. Done "
"by re-sorting the Array after every edit and writing an ordered-aware search "
"algorithm."
msgstr ""
"値が順序付けされている場合、カスタム検索操作によって対数時間 (比較的高速) に"
"なります。しかし、素人のユーザーはこれに不慣れです。編集のたびに配列を再ソー"
"トし、順序に対応した検索アルゴリズムを作成することで完了します。"

#, fuzzy
msgid ""
"Godot implements Dictionary as an ``OrderedHashMap<Variant, Variant>``. The "
"engine stores a small array (initialized to 2^3 or 8 records) of key-value "
"pairs. When one attempts to access a value, they provide it a key. It then "
"*hashes* the key, i.e. converts it into a number. The \"hash\" is used to "
"calculate the index into the array. As an array, the OHM then has a quick "
"lookup within the \"table\" of keys mapped to values. When the HashMap "
"becomes too full, it increases to the next power of 2 (so, 16 records, then "
"32, etc.) and rebuilds the structure."
msgstr ""
"Godotは、Dictionaryを ``OrderedHashMap<Variant, Variant>``として実装します。"
"エンジンは、キーと値のペアの巨大な配列(1000レコードに初期化された)を保存しま"
"す。値にアクセスしようとすると、まず値がキーになります。次に、キーを\\ *ハッ"
"シュ*\\ します。つまり、キーを数値に変換します。 「ハッシュ」は配列へのイン"
"デックスになり、OHM(訳注:オブジェクト・ハンドル・マネージャー？)は値にマップ"
"されたキーの概念的な「テーブル」内の値をすばやく検索できます。"

msgid ""
"Hashes are to reduce the chance of a key collision. If one occurs, the table "
"must recalculate another index for the value that takes the previous "
"position into account. In all, this results in constant-time access to all "
"records at the expense of memory and some minor operational efficiency."
msgstr ""
"ハッシュは、キーの衝突の可能性を減らすためのものです。発生した場合、テーブル"
"は以前の位置を考慮した値の別のインデックスを再計算する必要があります。これに"
"より、メモリと若干の運用効率が犠牲になりますが、全体として、すべてのレコード"
"に定数時間でアクセスできます。"

msgid "Hashing every key an arbitrary number of times."
msgstr "すべてのキーを任意の回数ハッシュします。"

msgid ""
"Hash operations are constant-time, so even if an algorithm must do more than "
"one, as long as the number of hash calculations doesn't become too dependent "
"on the density of the table, things will stay fast. Which leads to..."
msgstr ""
"ハッシュ操作は定数時間であるため、ハッシュ計算の数がテーブルの密度に依存しす"
"ぎない限り、アルゴリズムで複数の処理を行う必要がある場合でも、処理は高速にな"
"ります。話は続きます..."

#, fuzzy
msgid "Maintaining an ever-growing size for the table."
msgstr "巨大なサイズのテーブルを保持します。"

msgid ""
"HashMaps maintain gaps of unused memory interspersed in the table on purpose "
"to reduce hash collisions and maintain the speed of accesses. This is why it "
"constantly increases in size quadratically by powers of 2."
msgstr ""

#, fuzzy
msgid ""
"As one might be able to tell, Dictionaries specialize in tasks that Arrays "
"do not. An overview of their operational details is as follows:"
msgstr ""
"おわかりになると思いますが、Dictionaryは配列ではないタスクに特化しています。"
"運用の詳細の概要は次のとおりです。"

msgid "**Iterate:** Fast."
msgstr "**反復処理:** 高速。"

msgid ""
"Op: Iterate over the map's internal vector of hashes. Return each key. "
"Afterwards, users then use the key to jump to and return the desired value."
msgstr ""
"処理: マップのハッシュの内部ベクトルを反復処理し、各キーを返します。その後、"
"ユーザーはキーを使用して目的の値にジャンプしてリターンします。"

msgid "**Insert, Erase, Move:** Fastest."
msgstr "**挿入、消去、移動:** 最速。"

msgid ""
"Op: Hash the given key. Do 1 addition operation to look up the appropriate "
"value (array start + offset). Move is two of these (one insert, one erase). "
"The map must do some maintenance to preserve its capabilities:"
msgstr ""
"処理: 指定されたキーをハッシュします。 1回の追加操作を実行して、適切な値(配列"
"の開始+オフセット)を検索します。移動はこれらの2つです(1つは挿入、1つは消去)。"
"マップは、その機能を維持するためにいくつかのメンテナンスを行う必要があります:"

msgid "update ordered List of records."
msgstr "レコードの順序付きリストを更新します。"

msgid "determine if table density mandates a need to expand table capacity."
msgstr ""
"テーブルの密度により、テーブルの容量を拡張する必要があるかどうかを判断しま"
"す。"

msgid ""
"The Dictionary remembers in what order users inserted its keys. This enables "
"it to execute reliable iterations."
msgstr ""
"Dictionaryは、ユーザーがキーを挿入した順序を記憶しています。これにより、信頼"
"性の高い反復処理を実行できます。"

msgid "**Get, Set:** Fastest. Same as a lookup *by key*."
msgstr "**取得、設定:** 最速。\\ *キーによる検索*\\ と同じです。"

msgid "Op: Same as insert/erase/move."
msgstr "処理: 挿入/消去/移動と同じです。"

msgid "**Find:** Slowest. Identifies the key of a value."
msgstr "**検索:** 最も遅い。値のキーを識別します。"

msgid ""
"Op: Must iterate through records and compare the value until a match is "
"found."
msgstr ""
"処理: レコードを反復処理し、一致が見つかるまで値を比較する必要があります。"

msgid ""
"Note that Godot does not provide this feature out-of-the-box (because they "
"aren't meant for this task)."
msgstr ""
"Godotはすぐにはこの機能を提供しないことに注意してください(これらの機能はこの"
"タスク用ではないため)。"

msgid ""
"Godot implements Objects as stupid, but dynamic containers of data content. "
"Objects query data sources when posed questions. For example, to answer the "
"question, \"do you have a property called, 'position'?\", it might ask its :"
"ref:`script <class_Script>` or the :ref:`ClassDB <class_ClassDB>`. One can "
"find more information about what objects are and how they work in the :ref:"
"`doc_what_are_godot_classes` article."
msgstr ""
"Godotは、Objectをあまり賢くはありませんが、データ コンテンツの動的なコンテ"
"ナーとして実装します。Objectは、質問が行われるとデータソースに対してクエリを"
"実行します。たとえば、「 'position'というプロパティがありますか？」という質問"
"に答えるために、その :ref:`script <class_Script>` または :ref:`ClassDB "
"<class_ClassDB>`を要求します。\\ :ref:`doc_what_are_godot_classes` の記事で、"
"オブジェクトとは何か、そしてそれらがどのように機能するかについての詳細を見つ"
"けることができます。"

msgid ""
"The important detail here is the complexity of the Object's task. Every time "
"it performs one of these multi-source queries, it runs through *several* "
"iteration loops and HashMap lookups. What's more, the queries are linear-"
"time operations dependent on the Object's inheritance hierarchy size. If the "
"class the Object queries (its current class) doesn't find anything, the "
"request defers to the next base class, all the way up until the original "
"Object class. While these are each fast operations in isolation, the fact "
"that it must make so many checks is what makes them slower than both of the "
"alternatives for looking up data."
msgstr ""
"ここで重要な点は、オブジェクトのタスクの複雑さです。これらのマルチソースクエ"
"リの1つを実行するたびに、\\ *複数* の反復ループとHashMapのルックアップを実行"
"します。さらに、クエリはオブジェクトの継承階層サイズに依存する線形時間操作で"
"す。 Objectクエリを実行するクラス(現在のクラス)で何も見つからない場合、リクエ"
"ストはObjectの継承元の基本クラスへと次々に受け渡されます。これらはそれぞれ単"
"独では高速な操作ですが、非常に多くのチェックを行う必要があるという事実が、"
"データを検索するための Array/Dictionary 両方の代替手段よりも遅くなる理由で"
"す。"

msgid ""
"When developers mention how slow the scripting API is, it is this chain of "
"queries they refer to. Compared to compiled C++ code where the application "
"knows exactly where to go to find anything, it is inevitable that scripting "
"API operations will take much longer. They must locate the source of any "
"relevant data before they can attempt to access it."
msgstr ""
"開発者がスクリプトAPIの速度が遅いと言及するのは、この一連のクエリの参照につい"
"てです。アプリケーションが何かを見つける場所を正確に知っているコンパイル済み"
"のC++コードと比較すると、スクリプトAPIでは操作にかかる時間が大幅に長くなるこ"
"とは避けられません。アクセスを行う前に、関連するデータのソースを見つける必要"
"があるからです。"

msgid ""
"The reason GDScript is slow is because every operation it performs passes "
"through this system."
msgstr ""
"GDScriptが遅いのは、実行するすべての操作がこのシステムを通過するためです。"

msgid ""
"C# can process some content at higher speeds via more optimized bytecode. "
"But, if the C# script calls into an engine class' content or if the script "
"tries to access something external to it, it will go through this pipeline."
msgstr ""
"C#は、より最適化されたバイトコードにより、一部のコンテンツをより高速に処理で"
"きます。ただし、C#スクリプトがエンジンクラスのコンテンツを呼び出す場合、また"
"はスクリプトが外部の何かにアクセスしようとする場合、このパイプラインを通過し"
"ます。"

msgid ""
"NativeScript C++ goes even further and keeps everything internal by default. "
"Calls into external structures will go through the scripting API. In "
"NativeScript C++, registering methods to expose them to the scripting API is "
"a manual task. It is at this point that external, non-C++ classes will use "
"the API to locate them."
msgstr ""
"NativeScript C++はさらに進んで、デフォルトですべてを内部に保持します。外部構"
"造への呼び出しは、スクリプトAPIを経由します。 NativeScript C++では、スクリプ"
"トAPIに公開するメソッドを登録するのは手動のタスクです。この時点で、外部の非C+"
"+クラスがAPIを使用してそれらを見つけます。"

msgid ""
"So, assuming one extends from Reference to create a data structure, like an "
"Array or Dictionary, why choose an Object over the other two options?"
msgstr ""
"では、Array や Dictionary などのデータ構造を作成するために Reference から拡張"
"すると仮定すると、なぜ他の2つのオプションよりも Object を選択するのでしょう"
"か？"

msgid ""
"**Control:** With objects comes the ability to create more sophisticated "
"structures. One can layer abstractions over the data to ensure the external "
"API doesn't change in response to internal data structure changes. What's "
"more, Objects can have signals, allowing for reactive behavior."
msgstr ""
"**コントロール:** Object を使用すると、より洗練された構造を作成する機能が提供"
"されます。データを抽象化して、内部データ構造の変更に応じて外部APIが変更されな"
"いようにすることができます。さらに、Object はシグナルを持ち、反応的な動作を可"
"能にします。"

msgid ""
"**Clarity:** Objects are a reliable data source when it comes to the data "
"that scripts and engine classes define for them. Properties may not hold the "
"values one expects, but one doesn't need to worry about whether the property "
"exists in the first place."
msgstr ""
"**明快さ:** Object は、スクリプトとエンジンクラスが定義するデータに関しては信"
"頼できるデータソースです。プロパティは期待する値を保持していない場合がありま"
"すが、プロパティがそもそも存在するかどうかを心配する必要はありません。"

msgid ""
"**Convenience:** If one already has a similar data structure in mind, then "
"extending from an existing class makes the task of building the data "
"structure much easier. In comparison, Arrays and Dictionaries don't fulfill "
"all use cases one might have."
msgstr ""
"**利便性:** 同様のデータ構造をすでに念頭に置いている場合、既存のクラスから拡"
"張すると、データ構造を構築するタスクがはるかに簡単になります。それに比べて、"
"Array と Dictionary はすべてのユースケースを満たしているわけではありません。"

msgid ""
"Objects also give users the opportunity to create even more specialized data "
"structures. With it, one can design their own List, Binary Search Tree, "
"Heap, Splay Tree, Graph, Disjoint Set, and any host of other options."
msgstr ""
"また、Object を使用すると、ユーザーはさらに特殊なデータ構造を作成することもで"
"きます。これを使用して、独自のリスト、バイナリ検索ツリー、ヒープ、スプレー"
"木、グラフ、素集合、およびその他のオプションのホストを設計できます。"

msgid ""
"\"Why not use Node for tree structures?\" one might ask. Well, the Node "
"class contains things that won't be relevant to one's custom data structure. "
"As such, it can be helpful to construct one's own node type when building "
"tree structures."
msgstr ""
"「ツリー構造にNodeを使用しないのはなぜですか？」と尋ねるかもしれません。 Node"
"クラスには、カスタムデータ構造に関係のないものが含まれています。そのため、ツ"
"リー構造を構築するときに、独自のノードタイプを構築すると役立ちます。"

msgid ""
"From here, one can then create their own structures with specific features, "
"limited only by their imagination."
msgstr ""
"ここから、想像力によってのみ制限される特定の機能を備えた独自の構造を作成でき"
"ます。"

msgid "Enumerations: int vs. string"
msgstr "列挙型: int 対 string"

#, fuzzy
msgid ""
"Most languages offer an enumeration type option. GDScript is no different, "
"but unlike most other languages, it allows one to use either integers or "
"strings for the enum values (the latter only when using the ``export`` "
"keyword in GDScript). The question then arises, \"which should one use?\""
msgstr ""
"ほとんどの言語には、列挙型オプションがあります。 GDScriptでも同様ですが、他の"
"ほとんどの言語とは異なり、整数値または文字列を列挙値に使用できます。 そのた"
"め、このように思うはずです「どちらを使うべきか？」"

msgid ""
"The short answer is, \"whichever you are more comfortable with.\" This is a "
"feature specific to GDScript and not Godot scripting in general; The "
"languages prioritizes usability over performance."
msgstr ""
"簡単な答えは、「どちらが快適か」です。これは、(C++、C#等の)一般的なGodotスク"
"リプトにはない、GDScript固有の機能です。この言語はパフォーマンスよりも使いや"
"すさを優先しています。"

msgid ""
"On a technical level, integer comparisons (constant-time) will happen faster "
"than string comparisons (linear-time). If one wants to keep up other "
"languages' conventions though, then one should use integers."
msgstr ""
"技術的なレベルでは、整数の比較 (定数時間) は文字列の比較 (線形時間) よりも高"
"速に行われます。しかし、他の言語の規則を維持したい場合は、整数を使用する必要"
"があります。"

#, fuzzy
msgid ""
"The primary issue with using integers comes up when one wants to *print* an "
"enum value. As integers, attempting to print ``MY_ENUM`` will print ``5`` or "
"what-have-you, rather than something like ``\"MyEnum\"``. To print an "
"integer enum, one would have to write a Dictionary that maps the "
"corresponding string value for each enum."
msgstr ""
"整数値の使用に関する主な問題は、列挙値を\\ *印刷*\\ したいときに発生します。"
"整数として、MY_ENUMを印刷しようとすると、\\ ``\"MyEnum\"`` のようなものではな"
"く、``5`` などが出力されます。整数の列挙型を出力するには、各列挙型に対応する"
"文字列値をマップする辞書(Dictionary)を作成する必要があります。"

msgid ""
"If the primary purpose of using an enum is for printing values and one "
"wishes to group them together as related concepts, then it makes sense to "
"use them as strings. That way, a separate data structure to execute on the "
"printing is unnecessary."
msgstr ""
"列挙型を使用する主な目的が値を出力することであり、それらを関連する概念として"
"グループ化する場合、それらを文字列として使用することは理にかなっています。そ"
"うすれば、印刷で実行するための別個のデータ構造は不要です。"

#, fuzzy
msgid ""
"AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree"
msgstr "AnimatedTexture 対 AnimatedSprite 対 AnimationPlayer 対 AnimationTree"

msgid ""
"Under what circumstances should one use each of Godot's animation classes? "
"The answer may not be immediately clear to new Godot users."
msgstr ""
"どのような状況でGodotの各アニメーションクラスを使用する必要がありますか？ 答"
"えは、新しいGodotユーザーにはすぐにはわからないかもしれません。"

msgid ""
":ref:`AnimatedTexture <class_AnimatedTexture>` is a texture that the engine "
"draws as an animated loop rather than a static image. Users can manipulate..."
msgstr ""
":ref:`AnimatedTexture <class_AnimatedTexture>` は、エンジンが静的イメージでは"
"なくアニメーション ループとして描画するテクスチャです。ユーザーは次の操作がで"
"きます..."

#, fuzzy
msgid "the rate at which it moves across each section of the texture (FPS)."
msgstr "テクスチャの各セクションを移行する速度(fps)。"

msgid "the number of regions contained within the texture (frames)."
msgstr "テクスチャに含まれる領域の数(フレーム数)。"

#, fuzzy
msgid ""
"Godot's :ref:`RenderingServer <class_RenderingServer>` then draws the "
"regions in sequence at the prescribed rate. The good news is that this "
"involves no extra logic on the part of the engine. The bad news is that "
"users have very little control."
msgstr ""
"Godotの :ref:`VisualServer <class_VisualServer>` は、指定されたレートで領域を"
"順番に描画します。良いニュースは、これはエンジンの部分に余分なロジックを含み"
"ないことです。悪いニュースは、ユーザーがほとんど制御できないことです。"

#, fuzzy
msgid ""
"Also note that AnimatedTexture is a :ref:`Resource <class_Resource>` unlike "
"the other :ref:`Node <class_Node>` objects discussed here. One might create "
"a :ref:`Sprite2D <class_Sprite2D>` node that uses AnimatedTexture as its "
"texture. Or (something the others can't do) one could add AnimatedTextures "
"as tiles in a :ref:`TileSet <class_TileSet>` and integrate it with a :ref:"
"`TileMap <class_TileMap>` for many auto-animating backgrounds that all "
"render in a single batched draw call."
msgstr ""
"また、AnimatedTextureは :ref:`Resource <class_Resource>` であり、ここで説明し"
"た他の :ref:`Node <class_Node>` オブジェクトとは異なります。テクスチャとして"
"AnimatedTextureを使用する :ref:`Sprite <class_Sprite>` ノードを作成できます。"
"ほかにも(他ではできません)AnimatedTextureを :ref:`TileSet <class_TileSet>` の"
"タイルとして追加して :ref:`TileMap <class_TileMap>` と統合することで、単一の"
"バッチ描画呼び出しですべてをレンダリングできる、多くの自動アニメーション背景"
"を作成できます。"

#, fuzzy
msgid ""
"The AnimatedSprite2D node, in combination with the :ref:`SpriteFrames "
"<class_SpriteFrames>` resource, allows one to create a variety of animation "
"sequences through spritesheets, flip between animations, and control their "
"speed, regional offset, and orientation. This makes them well-suited to "
"controlling 2D frame-based animations."
msgstr ""
"AnimatedSprite ノードは、:ref:`SpriteFrames <class_SpriteFrames>` リソースと"
"組み合わせて、スプライトシートを通じてさまざまなアニメーション シーケンスを作"
"成し、アニメーションの反復、速度、領域のオフセット、および方向を制御できま"
"す。これにより、2Dフレームベースのアニメーションの制御に適しています。"

#, fuzzy
msgid ""
"If one needs trigger other effects in relation to animation changes (for "
"example, create particle effects, call functions, or manipulate other "
"peripheral elements besides the frame-based animation), then will need to "
"use an :ref:`AnimationPlayer <class_AnimationPlayer>` node in conjunction "
"with the AnimatedSprite2D."
msgstr ""
"アニメーションの変更に関連して他の効果をトリガーする必要がある場合 (たとえ"
"ば、パーティクル エフェクトの作成、関数の呼び出し、フレーム ベースのアニメー"
"ション以外の他の周辺要素の操作など)、AnimatedSprite と組み合わせて :ref:"
"`AnimationPlayer <class_AnimationPlayer>` ノードを使用する必要があります。"

msgid ""
"AnimationPlayers are also the tool one will need to use if they wish to "
"design more complex 2D animation systems, such as..."
msgstr ""
"AnimationPlayer は、次のようなより複雑な2Dアニメーションシステムを設計する場"
"合に使用する必要があるツールでもあります。"

#, fuzzy
msgid "**Cut-out animations:** editing sprites' transforms at runtime."
msgstr ""
"**カットアウトアニメーション:** 実行時にスプライトの幾何学変換を編集します。"

msgid ""
"**2D Mesh animations:** defining a region for the sprite's texture and "
"rigging a skeleton to it. Then one animates the bones which stretch and bend "
"the texture in proportion to the bones' relationships to each other."
msgstr ""
"**2Dメッシュアニメーション:** スプライトのテクスチャの領域を定義し、スケルト"
"ンをリギングします。次に、ボーンのアニメーション化を行い、ボーンの相互関係に"
"応じてテクスチャを伸縮させます。"

msgid "A mix of the above."
msgstr "上記のミックス。"

msgid ""
"While one needs an AnimationPlayer to design each of the individual "
"animation sequences for a game, it can also be useful to combine animations "
"for blending, i.e. enabling smooth transitions between these animations. "
"There may also be a hierarchical structure between animations that one plans "
"out for their object. These are the cases where the :ref:`AnimationTree "
"<class_AnimationTree>` shines. One can find an in-depth guide on using the "
"AnimationTree :ref:`here <doc_animation_tree>`."
msgstr ""
"ゲームの個々のアニメーションシーケンスをそれぞれ設計するには AnimationPlayer "
"が必要ですが、アニメーションを組み合わせてブレンドすること、つまり、これらの"
"アニメーション間のスムーズな移行を可能にすることにも役立ちます。アニメーショ"
"ン間には、オブジェクトに対して計画している階層構造もあります。これらは :ref:"
"`AnimationTree <class_AnimationTree>` が脚光を浴びるケースです。 "
"AnimationTree の使用に関する詳細なガイドは :ref:`ここ <doc_animation_tree>` "
"で見つけることができます。"

msgid "Translation status"
msgstr "翻訳ステータス"
