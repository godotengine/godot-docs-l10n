# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Godot interfaces"
msgstr "Godotインターフェース"

msgid ""
"Often one needs scripts that rely on other objects for features. There are 2 "
"parts to this process:"
msgstr ""
"多くの場合、機能を他のオブジェクトに依存するスクリプトが必要です。このプロセ"
"スには2つの部分があります:"

msgid "Acquiring a reference to the object that presumably has the features."
msgstr "機能を持つ可能性のあるオブジェクトへの参照を取得します。"

msgid "Accessing the data or logic from the object."
msgstr "オブジェクトからデータまたはロジックにアクセスします。"

msgid "The rest of this tutorial outlines the various ways of doing all this."
msgstr ""
"このチュートリアルの残りの部分では、これを行うさまざまな方法の概要を説明しま"
"す。"

msgid "Acquiring object references"
msgstr "オブジェクト参照の取得"

msgid ""
"For all :ref:`Object <class_Object>`\\s, the most basic way of referencing "
"them is to get a reference to an existing object from another acquired "
"instance."
msgstr ""
"すべての :ref:`Object <class_Object>` について、それらを参照する最も基本的な"
"方法は、取得した別のインスタンスから既存のオブジェクトへの参照を取得すること"
"です。"

#, fuzzy
msgid ""
"The same principle applies for :ref:`RefCounted <class_RefCounted>` objects. "
"While users often access :ref:`Node <class_Node>` and :ref:`Resource "
"<class_Resource>` this way, alternative measures are available."
msgstr ""
"同じ原則が :ref:`Reference <class_Reference>` オブジェクトにも適用されます。"
"ユーザーはこの方法で :ref:`Node <class_Node>` と :ref:`Resource "
"<class_Resource>` に頻繁にアクセスしますが、代替手段も利用できます。"

msgid ""
"Instead of property or method access, one can get Resources by load access."
msgstr ""
"プロパティまたはメソッドアクセスの代わりに、ロードアクセスによってリソースを"
"取得できます。"

msgid "Note the following:"
msgstr "次の点に注意してください:"

msgid "There are many ways in which a language can load such resources."
msgstr "言語がそのようなリソースをロードできる方法はたくさんあります。"

msgid ""
"When designing how objects will access data, don't forget that one can pass "
"resources around as references as well."
msgstr ""
"オブジェクトがデータにアクセスする方法を設計するとき、リソースを参照としても"
"渡すことができることを忘れないでください。"

msgid ""
"Keep in mind that loading a resource fetches the cached resource instance "
"maintained by the engine. To get a new object, one must :ref:`duplicate "
"<class_Resource_method_duplicate>` an existing reference or instantiate one "
"from scratch with ``new()``."
msgstr ""
"リソースをロードすると、エンジンによって維持されているキャッシュされたリソー"
"スインスタンスがフェッチされることに注意してください。新しいオブジェクトを取"
"得するには、既存の参照を :ref:`duplicate <class_Resource_method_duplicate>` "
"するか、\\ ``new()`` でゼロからインスタンス化する必要があります。"

msgid "Nodes likewise have an alternative access point: the SceneTree."
msgstr "ノードにも同様に、代替アクセス ポイントがあります: SceneTreeです。"

msgid "Accessing data or logic from an object"
msgstr "オブジェクトからのデータまたはロジックへのアクセス"

msgid ""
"Godot's scripting API is duck-typed. This means that if a script executes an "
"operation, Godot doesn't validate that it supports the operation by "
"**type**. It instead checks that the object **implements** the individual "
"method."
msgstr ""
"GodotのスクリプトAPIはダック・タイプです。つまり、スクリプトが操作を実行する"
"場合、Godotは **型(type)** による操作をサポートしているかどうかを検証しませ"
"ん。代わりに、オブジェクトが個々のメソッドを **実装** していることをチェック"
"します。"

msgid ""
"For example, the :ref:`CanvasItem <class_CanvasItem>` class has a "
"``visible`` property. All properties exposed to the scripting API are in "
"fact a setter and getter pair bound to a name. If one tried to access :ref:"
"`CanvasItem.visible <class_CanvasItem_property_visible>`, then Godot would "
"do the following checks, in order:"
msgstr ""
"たとえば、\\ :ref:`CanvasItem <class_CanvasItem>` クラスには ``visible`` プロ"
"パティがあります。スクリプトAPIに公開されるすべてのプロパティは、実際には名前"
"にバインドされたセッターとゲッターのペアです。\\ :ref:`CanvasItem.visible "
"<class_CanvasItem_property_visible>` にアクセスしようとすると、Godot は次の"
"チェックを順番に実行します:"

msgid ""
"If the object has a script attached, it will attempt to set the property "
"through the script. This leaves open the opportunity for scripts to override "
"a property defined on a base object by overriding the setter method for the "
"property."
msgstr ""
"オブジェクトにスクリプトがアタッチされている場合、まずスクリプトを介してプロ"
"パティを設定しようとします。このプロパティのセッターメソッドをスクリプトで"
"オーバーライドする手段によって、基本オブジェクトで定義されたプロパティをスク"
"リプトから変更することができます。"

msgid ""
"If the script does not have the property, it performs a HashMap lookup in "
"the ClassDB for the \"visible\" property against the CanvasItem class and "
"all of its inherited types. If found, it will call the bound setter or "
"getter. For more information about HashMaps, see the :ref:`data preferences "
"<doc_data_preferences>` docs."
msgstr ""
"スクリプトにプロパティがない場合は、CanvasItemクラスとその継承されたすべての"
"型に対して、\"visible\"プロパティの ClassDBでハッシュマップルックアップが実行"
"されます。見つかった場合は、バインドされたセッターまたはゲッターを呼び出しま"
"す。ハッシュマップの詳細については、\\ :ref:`データ設定"
"<doc_data_preferences>` ドキュメントを参照してください。"

msgid ""
"If not found, it does an explicit check to see if the user wants to access "
"the \"script\" or \"meta\" properties."
msgstr ""
"見つからない場合は、ユーザーが\"script\"プロパティまたは\"meta\"プロパティに"
"アクセスするかどうかを明示的に確認します。"

msgid ""
"If not, it checks for a ``_set``/``_get`` implementation (depending on type "
"of access) in the CanvasItem and its inherited types. These methods can "
"execute logic that gives the impression that the Object has a property. This "
"is also the case with the ``_get_property_list`` method."
msgstr ""
"そうでない場合は、CanvasItemおよびその継承されたタイプで(アクセスのタイプに応"
"じて) ``_set``/``_get`` の実装をチェックします。これらのメソッドは、オブジェ"
"クトにプロパティがあることを示すロジックを実行できます。これは "
"``_get_property_list`` メソッドでも同様です。"

msgid ""
"Note that this happens even for non-legal symbol names, such as names "
"starting with a digit or containing a slash."
msgstr ""

msgid ""
"As a result, this duck-typed system can locate a property either in the "
"script, the object's class, or any class that object inherits, but only for "
"things which extend Object."
msgstr ""
"その結果、このダック・タイプのシステムは、スクリプト、オブジェクトのクラス、"
"またはオブジェクトが継承する任意のクラスのいずれかでプロパティを見つけること"
"ができますが、これは Object を拡張するものについてのみです。"

msgid ""
"Godot provides a variety of options for performing runtime checks on these "
"accesses:"
msgstr ""
"Godotは、これらのアクセスでランタイムチェックを実行するためのさまざまなオプ"
"ションを提供します:"

#, fuzzy
msgid ""
"A duck-typed property access. These will be property checks (as described "
"above). If the operation isn't supported by the object, execution will halt."
msgstr ""
"ダック・タイプのプロパティアクセス。これらはプロパティチェックを行います(上記"
"を参照)。操作がオブジェクトによってサポートされていない場合、実行は停止しま"
"す。"

msgid ""
"A method check. In the case of :ref:`CanvasItem.visible "
"<class_CanvasItem_property_visible>`, one can access the methods, "
"``set_visible`` and ``is_visible`` like any other method."
msgstr ""
"メソッドチェック。\\ :ref:`CanvasItem.visible "
"<class_CanvasItem_property_visible>` の場合、他のメソッドと同様に "
"``set_visible`` と ``is_visible`` のメソッドにアクセスできます。"

#, fuzzy
msgid ""
"Outsource the access to a :ref:`Callable <class_Callable>`. These may be "
"useful in cases where one needs the max level of freedom from dependencies. "
"In this case, one relies on an external context to setup the method."
msgstr ""
":ref:`FuncRef <class_FuncRef>` へのアクセスを外部委託します。これらは、依存関"
"係から最大限の自由度が必要な場合に役立ちます。この場合、メソッドの設定は外部"
"コンテキストに依存します。"

msgid ""
"These strategies contribute to Godot's flexible design. Between them, users "
"have a breadth of tools to meet their specific needs."
msgstr ""
"これらの戦略は、Godotの柔軟なデザインに貢献します。それらの間から、ユーザーは"
"特定のニーズを満たすための幅広いツールを手にできます。"

msgid "Translation status"
msgstr "翻訳ステータス"
