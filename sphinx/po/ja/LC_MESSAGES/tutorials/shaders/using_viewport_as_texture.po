# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using a Viewport as a texture"
msgstr "ビューポートをテクスチャとして使用する"

msgid "Introduction"
msgstr "はじめに"

msgid ""
"This tutorial will introduce you to using the :ref:`Viewport "
"<class_Viewport>` as a texture that can be applied to 3D objects. In order "
"to do so, it will walk you through the process of making a procedural planet "
"like the one below:"
msgstr ""
"このチュートリアルでは、3Dオブジェクトに適用できるテクスチャとして :ref:"
"`Viewport <class_Viewport>` を使用する方法を紹介します。 そのためには、以下の"
"ような手続き型惑星を作成するプロセスを順を追って説明します:"

msgid ""
"This tutorial does not cover how to code a dynamic atmosphere like the one "
"this planet has."
msgstr ""
"このチュートリアルでは、この惑星のような動的な大気をコーディングする方法につ"
"いては説明しません。"

#, fuzzy
msgid ""
"This tutorial assumes you are familiar with how to set up a basic scene "
"including: a :ref:`Camera3D <class_Camera3D>`, a :ref:`light source "
"<class_OmniLight3D>`, a :ref:`MeshInstance3D <class_MeshInstance3D>` with a :"
"ref:`Primitive Mesh <class_PrimitiveMesh>`, and applying a :ref:"
"`StandardMaterial3D <class_StandardMaterial3D>` to the mesh. The focus will "
"be on using the :ref:`Viewport <class_Viewport>` to dynamically create "
"textures that can be applied to the mesh."
msgstr ""
"このチュートリアルでは、\\ :ref:`Camera <class_Camera>`、\\ :ref:`light "
"source <class_OmniLight>`\\ 、:ref:`Mesh Instance <class_MeshInstance>` など"
"の基本的なシーンの設定方法に慣れていることを前提としています。\\ :ref:"
"`Primitive Mesh <class_PrimitiveMesh>` を使用し、\\ :ref:`Spatial Material "
"<class_SpatialMaterial>` をメッシュに適用します。\\ :ref:`Viewport "
"<class_Viewport>` を使用して、メッシュに適用できるテクスチャを動的に作成する"
"ことに焦点が置かれます。"

#, fuzzy
msgid "In this tutorial, we'll cover the following topics:"
msgstr "このチュートリアルでは、次のトピックについて説明します:"

msgid "How to use a :ref:`Viewport <class_Viewport>` as a render texture"
msgstr ""
":ref:`Viewport <class_Viewport>` をレンダーテクスチャとして使用する方法"

msgid "Mapping a texture to a sphere with equirectangular mapping"
msgstr "正距円筒図法でテクスチャを球にマッピングする"

msgid "Fragment shader techniques for procedural planets"
msgstr "手続き型惑星のフラグメントシェーダーテクニック"

msgid ""
"Setting a Roughness map from a :ref:`Viewport Texture "
"<class_ViewportTexture>`"
msgstr ""
":ref:`ビューポートテクスチャ<class_ViewportTexture>` から粗さマップを設定する"

msgid "Setting up the Viewport"
msgstr "ビューポートを設定する"

msgid "First, add a :ref:`Viewport <class_Viewport>` to the scene."
msgstr "最初に、シーンに :ref:`Viewport <class_Viewport>` を追加します。"

msgid ""
"Next, set the size of the :ref:`Viewport <class_Viewport>` to ``(1024, "
"512)``. The :ref:`Viewport <class_Viewport>` can actually be any size so "
"long as the width is double the height. The width needs to be double the "
"height so that the image will accurately map onto the sphere, as we will be "
"using equirectangular projection, but more on that later."
msgstr ""
"次に、\\ :ref:`Viewport <class_Viewport>` のサイズを ``(1024, 512)`` に設定し"
"ます。\\ :ref:`Viewport <class_Viewport>` は、幅が高さの2倍である限り、実際に"
"は任意のサイズにできます。正距円筒図法を使用するため、画像は球体に正確にマッ"
"ピングされるように、幅は高さの2倍にする必要がありますが、これについては後で詳"
"しく説明します。"

msgid ""
"Next, disable HDR and disable 3D. We don't need HDR because our planet's "
"surface will not be especially bright, so values between ``0`` and ``1`` "
"will be fine. And we will be using a :ref:`ColorRect <class_ColorRect>` to "
"render the surface, so we don't need 3D either."
msgstr ""
"次に、HDRを無効にし、3Dを無効にします。惑星の表面はそれほど明るくないため、"
"HDRは必要ありません。そのため、\\ ``0`` と ``1`` の間の値で問題ありません。そ"
"して　:ref:`ColorRect <class_ColorRect>` を使用してサーフェスをレンダリングす"
"るため、3Dも必要ありません。"

msgid ""
"Select the Viewport and add a :ref:`ColorRect <class_ColorRect>` as a child."
msgstr ""
"ビューポートを選択し、\\ :ref:`ColorRect <class_ColorRect>` を子として追加し"
"ます。"

msgid ""
"Set the anchors \"Right\" and \"Bottom\" to ``1``, then make sure all the "
"margins are set to ``0``. This will ensure that the :ref:`ColorRect "
"<class_ColorRect>` takes up the entire :ref:`Viewport <class_Viewport>`."
msgstr ""
"アンカー(anchors)の「右」と「下」を ``1`` に設定し、すべてのマージンが ``0`` "
"に設定されていることを確認します。これにより、\\ :ref:`ColorRect "
"<class_ColorRect>` が :ref:`Viewport <class_Viewport>` 全体を使用するようにな"
"ります。"

msgid ""
"Next, we add a :ref:`Shader Material <class_ShaderMaterial>` to the :ref:"
"`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > Material "
"> ``New ShaderMaterial``)."
msgstr ""
"次に、\\ :ref:`Shader Material <class_ShaderMaterial>` を :ref:`ColorRect "
"<class_ColorRect>` に追加します(ColorRect → CanvasItem → Material → Material "
"→ ``New ShaderMaterial``)。"

msgid ""
"Basic familiarity with shading is recommended for this tutorial. However, "
"even if you are new to shaders, all the code will be provided, so you should "
"have no problem following along."
msgstr ""
"このチュートリアルでは、シェーディングに関する基本的な知識があることが推奨さ"
"れます。ただし、シェーダーを初めて使用する場合でも、すべてのコードが提供され"
"るため、順を追っていけば問題が発生することはありません。"

msgid ""
"ColorRect > CanvasItem > Material > Material > click / Edit > ShaderMaterial "
"> Shader > ``New Shader`` > click / Edit:"
msgstr ""
"ColorRect → CanvasItem → Material → Material →クリック/編集 → ShaderMaterial "
"→ Shader → ``New Shader`` → クリック/編集:"

msgid "The above code renders a gradient like the one below."
msgstr "上記のコードは、以下のようなグラデーションをレンダリングします。"

msgid ""
"Now we have the basics of a :ref:`Viewport <class_Viewport>` that we render "
"to and we have a unique image that we can apply to the sphere."
msgstr ""
"これで、レンダリングする :ref:`Viewport <class_Viewport>` の基本ができ、球体"
"に適用できる一意の画像ができました。"

msgid "Applying the texture"
msgstr "テクスチャを適用する"

#, fuzzy
msgid ""
"MeshInstance3D > GeometryInstance > Geometry > Material Override > ``New "
"StandardMaterial3D``:"
msgstr ""
"MeshInstance → GeometryInstance → Geometry → Material Override → ``New "
"SpatialMaterial``:"

#, fuzzy
msgid ""
"Now we go into the :ref:`MeshInstance3D <class_MeshInstance3D>` and add a :"
"ref:`StandardMaterial3D <class_StandardMaterial3D>` to it. No need for a "
"special :ref:`Shader Material <class_ShaderMaterial>` (although that would "
"be a good idea for more advanced effects, like the atmosphere in the example "
"above)."
msgstr ""
"ここで :ref:`Mesh Instance <class_MeshInstance>` に進み、それに :ref:"
"`Spatial Material <class_SpatialMaterial>` を追加します。特別な :ref:`Shader "
"Material <class_ShaderMaterial>` は必要ありません(ただし、上記の例の雰囲気の"
"ような、より高度な効果を得るには良い考えです)。"

#, fuzzy
msgid ""
"MeshInstance3D > GeometryInstance > Geometry > Material Override > "
"``click`` / ``Edit``:"
msgstr ""
"MeshInstance → GeometryInstance → Geometry → Material Override → ``クリック"
"`` / ``編集``:"

#, fuzzy
msgid ""
"Open the newly created :ref:`StandardMaterial3D <class_StandardMaterial3D>` "
"and scroll down to the \"Albedo\" section and click beside the \"Texture\" "
"property to add an Albedo Texture. Here we will apply the texture we made. "
"Choose \"New ViewportTexture\""
msgstr ""
"新しく作成された :ref:`Spatial Material <class_SpatialMaterial>` を開"
"き、\"Albedo\"セクションまでスクロールダウンし、\"Texture\"プロパティの横をク"
"リックして、Albedo Textureを追加します。ここで、作成したテクスチャを適用しま"
"す。選択 - \"New ViewportTexture\""

msgid ""
"Then, from the menu that pops up, select the Viewport that we rendered to "
"earlier."
msgstr ""
"次に、ポップアップするメニューから、以前にレンダリングしたビューポートを選択"
"します。"

msgid ""
"Your sphere should now be colored in with the colors we rendered to the "
"Viewport."
msgstr "これで、ビューポートにレンダリングした色で球体が色付けされるはずです。"

msgid ""
"Notice the ugly seam that forms where the texture wraps around? This is "
"because we are picking a color based on UV coordinates and UV coordinates do "
"not wrap around the texture. This is a classic problem in 2D map projection. "
"Game developers often have a 2-dimensional map they want to project onto a "
"sphere, but when it wraps around, it has large seams. There is an elegant "
"workaround for this problem that we will illustrate in the next section."
msgstr ""
"テクスチャが回り込む場所に形成されるい縫い目に注目してください。これは、UV座"
"標に基づいて色を選択しており、UV座標がテクスチャをラップしていないためです。"
"これは、2Dマップ投影の古典的な問題です。ゲーム開発者は多くの場合、球体に投影"
"したい2次元のマップを持っていますが、それをラップすると大きな継ぎ目ができま"
"す。次のセクションで説明するこの問題に対するエレガントな回避策があります。"

msgid "Making the planet texture"
msgstr "惑星のテクスチャを作る"

msgid ""
"So now, when we render to our :ref:`Viewport <class_Viewport>`, it appears "
"magically on the sphere. But there is an ugly seam created by our texture "
"coordinates. So how do we get a range of coordinates that wrap around the "
"sphere in a nice way? One solution is to use a function that repeats on the "
"domain of our texture. ``sin`` and ``cos`` are two such functions. Let's "
"apply them to the texture and see what happens."
msgstr ""
"したがって、\\ :ref:`Viewport <class_Viewport>` にレンダリングすると、魔法の"
"ように球体に表示されます。しかし、テクスチャ座標によって作成されたい縫い目が"
"あります。それでは、どのようにすれば、球体を適切に包み込む座標範囲を取得でき"
"ますか？ 1つの解決策は、テクスチャのドメインで繰り返される関数を使用すること"
"です。\\ ``sin`` と ``cos`` はそのような関数です。それらをテクスチャに適用し"
"て、何が起こるか見てみましょう。"

#, fuzzy
msgid ""
"Not too bad. If you look around, you can see that the seam has now "
"disappeared, but in its place, we have pinching at the poles. This pinching "
"is due to the way Godot maps textures to spheres in its :ref:"
"`StandardMaterial3D <class_StandardMaterial3D>`. It uses a projection "
"technique called equirectangular projection, which translates a spherical "
"map onto a 2D plane."
msgstr ""
"悪くありません。周りを見ると、縫い目が消えていることがわかりますが、その代わ"
"りに極をつまんでいます。このピンチは、Godotが :ref:`Spatial Material "
"<class_SpatialMaterial>` でテクスチャを球体にマップする方法によるものです。こ"
"れは、正距円筒図法と呼ばれる投影手法を使用します。これは、球面地図を2D平面に"
"変換します。"

msgid ""
"If you are interested in a little extra information on the technique, we "
"will be converting from spherical coordinates into Cartesian coordinates. "
"Spherical coordinates map the longitude and latitude of the sphere, while "
"Cartesian coordinates are, for all intents and purposes, a vector from the "
"center of the sphere to the point."
msgstr ""
"もしも、テクニック関して興味がある方へのちょっとした追加情報ですが、座標は球"
"面座標からデカルト座標(直交座標)に変換して処理をします。 球体座標は球体の経度"
"と緯度をマッピングしますが、変換後のデカルト座標は等距離で全方位に向いた球体"
"の中心から点までのベクトルです。"

msgid ""
"For each pixel, we will calculate its 3D position on the sphere. From that, "
"we will use 3D noise to determine a color value. By calculating the noise in "
"3D, we solve the problem of the pinching at the poles. To understand why, "
"picture the noise being calculated across the surface of the sphere instead "
"of across the 2D plane. When you calculate across the surface of the sphere, "
"you never hit an edge, and hence you never create a seam or a pinch point on "
"the pole. The following code converts the ``UVs`` into Cartesian coordinates."
msgstr ""
"各ピクセルについて、球上の3D位置を計算します。それから、3Dノイズを使用して色"
"の値を決定します。 3Dでノイズを計算することにより、極での挟み込みの問題を解決"
"します。理由を理解するために、2D平面ではなく球の表面全体で計算されるノイズを"
"想像してください。球の表面を横切って計算すると、エッジにヒットすることはない"
"ため、極に継ぎ目やピンチポイントを作成することはありません。次のコードは、\\ "
"``UV`` をデカルト座標に変換します。"

msgid "And if we use ``unit`` as an output ``COLOR`` value, we get:"
msgstr ""
"そして、出力する ``COLOR`` 値として ``unit`` を使用すると、次のようになりま"
"す:"

msgid ""
"Now that we can calculate the 3D position of the surface of the sphere, we "
"can use 3D noise to make the planet. We will be using this noise function "
"directly from a `Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_:"
msgstr ""
"球の表面の3D位置を計算できるようになったので、3Dノイズを使用して惑星を作成で"
"きます。\\ `Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_ のノイズ関数"
"をそのまま使用します。"

msgid ""
"All credit goes to the author, Inigo Quilez. It is published under the "
"``MIT`` licence."
msgstr ""
"すべての功績は著者であるInigo Quilezに帰属します。\\ ``MIT`` ライセンスの下で"
"公開されています。"

msgid ""
"Now to use ``noise``, add the following to the    ``fragment`` function:"
msgstr "``noise`` を使用するには、以下を ``fragment`` 関数に追加します:"

msgid "In order to highlight the texture, we set the material to unshaded."
msgstr ""
"テクスチャを強調表示するために、マテリアルをシェーディングなしに設定します。"

msgid ""
"You can see now that the noise indeed wraps seamlessly around the sphere. "
"Although this looks nothing like the planet you were promised. So let's move "
"onto something more colorful."
msgstr ""
"ノイズが実際に球の周りにシームレスに巻き付いていることがわかります。これはあ"
"なたに約束された惑星のようには見えませんが。それでは、もっとカラフルなものに"
"移りましょう。"

msgid "Coloring the planet"
msgstr "惑星を彩る"

msgid ""
"Now to make the planet colors. While there are many ways to do this, for "
"now, we will stick with a gradient between water and land."
msgstr ""
"今から惑星の色を作ります。これを行うには多くの方法がありますが、今のところ、"
"水と土地の間の勾配にこだわります。"

msgid ""
"To make a gradient in GLSL, we use the ``mix`` function. ``mix`` takes two "
"values to interpolate between and a third argument to choose how much to "
"interpolate between them; in essence, it *mixes* the two values together. In "
"other APIs, this function is often called ``lerp``. However, ``lerp`` is "
"typically reserved for mixing two floats together; ``mix`` can take any "
"values whether it be floats or vector types."
msgstr ""
"GLSLでグラデーションを作成するには、\\ ``mix`` 関数を使用します。\\ ``mix`` "
"は、2つの値の間を補間し、3番目の引数はそれらの間を補間する量を選択します。本"
"質的には、2つの値を\\ *混合*\\ します。他のAPIでは、この関数はしばしば "
"``lerp`` と呼ばれます。ただし、\\ ``lerp`` は通常、2つの浮動小数点を混合する"
"ために予約されています。 \\ ``mix``は、浮動小数点型であろうとベクトル型であろ"
"うと、任意の値を取ることができます。"

msgid ""
"The first color is blue for the ocean. The second color is a kind of reddish "
"color (because all alien planets need red terrain). And finally, they are "
"mixed together by ``n * 0.5 + 0.5``. ``n`` smoothly varies between ``-1`` "
"and ``1``. So we map it into the ``0-1`` range that ``mix`` expects. Now you "
"can see that the colors change between blue and red."
msgstr ""
"海の最初の色は青です。 2番目の色は一種の赤みがかった色です(すべてのエイリアン"
"の惑星には赤い地形が必要なため)。そして最後に、それらは ``n * 0.5 + 0.5`` で"
"混合されます。\\ ``n`` は ``-1`` と ``1`` の間で滑らかに変化します。したがっ"
"て、\\ ``mix`` が期待する ``0-1`` の範囲にマッピングします。これで、色が青と"
"赤の間で変化することがわかります。"

msgid ""
"That is a little more blurry than we want. Planets typically have a "
"relatively clear separation between land and sea. In order to do that, we "
"will change the last term to ``smoothstep(-0.1, 0.0, n)``. And thus the "
"whole line becomes:"
msgstr ""
"それは私たちが望むよりも少しぼやけています。惑星は通常、陸と海の間の比較的明"
"確な分離を持っています。そのためには、最後の用語を ``smoothstep(-0.1,0.0,"
"n)`` に変更します。したがって、行全体は次のようになります:"

msgid ""
"What ``smoothstep`` does is return ``0`` if the third argument is below the "
"first and ``1`` if the third argument is larger than the second and smoothly "
"blends between ``0`` and ``1`` if the third number is between the first and "
"the second. So in this line, ``smoothstep`` returns ``0`` whenever ``n`` is "
"less than ``-0.1`` and it returns ``1`` whenever ``n`` is above ``0``."
msgstr ""
"``smoothstep`` が行うことは、3番目の引数が最初の引数よりも小さい場合は ``0`` "
"を返し、3番目の引数が2番目よりも大きい場合は``1`` を返し、3番目の数値が1番目"
"と2番目の間にある場合は ``0`` と ``1`` の間をスムーズにブレンドします 。した"
"がって、この行では、\\ ``n`` が ``-0.1`` 未満の場合は常に ``smoothstep`` が "
"``0`` を返し、\\ ``n`` が ``0`` を超える場合は ``1`` を返します。"

msgid ""
"One more thing to make this a little more planet-y. The land shouldn't be so "
"blobby; let's make the edges a little rougher. A trick that is often used in "
"shaders to make rough looking terrain with noise is to layer levels of noise "
"over one another at various frequencies. We use one layer to make the "
"overall blobby structure of the continents. Then another layer breaks up the "
"edges a bit, and then another, and so on. What we will do is calculate ``n`` "
"with four lines of shader code instead of just one. ``n`` becomes:"
msgstr ""
"これをもう少し惑星らしくするもう一つの作業を行います。このままでは地形がぼん"
"やりとしているはずです。なので、エッジを少し粗くしましょう。シェーダーでノイ"
"ズの多い荒い地形を作るためによく使用されるトリックは、さまざまな周波数とレベ"
"ルのノイズを相互に重ねることです。 1つのレイヤーを使用して、大陸全体の大雑把"
"な構造を作成します。次に、別のレイヤーが少しエッジを分割し、次に別のレイヤー"
"が続きます。ここでは、1行ではなく4行のシェーダーコードで ``n`` を計算しま"
"す。\\ ``n`` は次のようになります:"

msgid "And now the planet looks like:"
msgstr "新たに、惑星は次のようになります:"

msgid "And with shading turned back on, it looks like:"
msgstr "シェーディングをオンに戻すと、次のようになります:"

msgid "Making an ocean"
msgstr "海を作る"

msgid ""
"One final thing to make this look more like a planet. The ocean and the land "
"reflect light differently. So we want the ocean to shine a little more than "
"the land. We can do this by passing a fourth value into the ``alpha`` "
"channel of our output ``COLOR`` and using it as a Roughness map."
msgstr ""
"これを惑星のように見せるための最後の1つです。海と陸では光の反射が異なります。"
"そのため、海は陸地よりも少しだけ輝かせたいです。これを行うには、4番目の値を出"
"力 ``COLOR``の ``alpha`` チャンネルに渡し、それを粗さマップとして使用します。"

msgid ""
"This line returns ``0.3`` for water and ``1.0`` for land. This means that "
"the land is going to be quite rough, while the water will be quite smooth."
msgstr ""
"この行は、水に対して ``0.3`` を返し、土地に対して ``1.0`` を返します。これ"
"は、水が非常に滑らかになる一方で、土地が非常に荒くなることを意味します。"

msgid ""
"And then, in the material, under the \"Metallic\" section, make sure "
"``Metallic`` is set to ``0`` and ``Specular`` is set to ``1``. The reason "
"for this is the water reflects light really well, but isn't metallic. These "
"values are not physically accurate, but they are good enough for this demo."
msgstr ""
"そして、マテリアルの ``Metallic`` セクションで、\\ ``Metallic`` が ``0`` に設"
"定され、\\ ``Specular`` が ``1`` に設定されていることを確認します。これは、水"
"が光を非常によく反射するが、金属ではないためです。これらの値は物理的に正確で"
"はありませんが、このデモには十分です。"

msgid ""
"Next, under the \"Roughness\" section, set ``Roughness`` to ``1`` and set "
"the roughness texture to a :ref:`Viewport Texture <class_ViewportTexture>` "
"pointing to our planet texture :ref:`Viewport <class_Viewport>`. Finally, "
"set the ``Texture Channel`` to ``Alpha``. This instructs the renderer to use "
"the ``alpha`` channel of our output ``COLOR`` as the ``Roughness`` value."
msgstr ""
"次に、\"Roughness\" セクションで、\\ ``Roughness`` を ``1`` に設定し、粗さテ"
"クスチャを、惑星テクスチャ :ref:`Viewport <class_Viewport>` を指し示す :ref:"
"`Viewport Texture <class_ViewportTexture>` に設定します。 最後に、\\ "
"``Texture Channel`` を ``Alpha`` に設定します。これは、出力 ``COLOR`` の "
"``alpha`` チャンネルを ``Roughness`` 値として使用するようにレンダラーに指示し"
"ます。"

#, fuzzy
msgid ""
"You'll notice that very little changes except that the planet is no longer "
"reflecting the sky. This is happening because, by default, when something is "
"rendered with an alpha value, it gets drawn as a transparent object over the "
"background. And since the default background of the :ref:`Viewport "
"<class_Viewport>` is opaque, the ``alpha`` channel of the :ref:`Viewport "
"Texture <class_ViewportTexture>` is ``1``, resulting in the planet texture "
"being drawn with slightly fainter colors and a ``Roughness`` value of ``1`` "
"everywhere. To correct this, we go into the :ref:`Viewport <class_Viewport>` "
"and enable the \"Transparent Bg\" property. Since we are now rendering one "
"transparent object on top of another, we want to enable "
"``blend_premul_alpha``:"
msgstr ""
"惑星が空を反射しなくなったことを除いて、ほとんど変化がないことに気付くでしょ"
"う。これは、デフォルトでは、何かがアルファ値でレンダリングされると、背景上の"
"透明なオブジェクトとして描画されるために発生します。そして、\\ :ref:"
"`Viewport <class_Viewport>` のデフォルトの背景は不透明であるため、\\ :ref:"
"`Viewport Texture <class_ViewportTexture>` の ``alpha`` チャンネルは ``1`` で"
"あり、惑星テクスチャはわずかに薄い色で描画され、\\ ``Roughness`` の値はどこで"
"も ``1`` になります。これを修正するために、\\ :ref:`Viewport "
"<class_Viewport>` に入り、 \"Transparent Bg\" をonに設定します。ある透明なオ"
"ブジェクトを別の透明なオブジェクトの上にレンダリングしているので、\\ "
"``blend_premul_alpha`` を有効にします:"

msgid ""
"This pre-multiplies the colors by the ``alpha`` value and then blends them "
"correctly together. Typically, when blending one transparent color on top of "
"another, even if the background has an ``alpha`` of ``0`` (as it does in "
"this case), you end up with weird color bleed issues. Setting "
"``blend_premul_alpha`` fixes that."
msgstr ""
"これにより、色に ``alpha`` 値が事前に乗算され、それらが正しくブレンドされま"
"す。通常、ある透明色を別の透明色の上にブレンドすると、背景の ``alpha`` が "
"``0`` であっても(この場合のように)、奇妙な色にじみの問題が発生します。これは "
"``blend_premul_alpha`` を設定すると修正されます。"

#, fuzzy
msgid ""
"Now the planet should look like it is reflecting light on the ocean but not "
"the land. If you haven't done so already, add an :ref:`OmniLight3D "
"<class_OmniLight3D>` to the scene so you can move it around and see the "
"effect of the reflections on the ocean."
msgstr ""
"これで、惑星は、海ではなく陸で光を反射しているように見えるはずです。まだ行っ"
"ていない場合は、シーンに :ref:`OmniLight <class_OmniLight>` を追加し、それを"
"移動させて、海の反射の効果を確認できるようにします。"

msgid ""
"And there you have it. A procedural planet generated using a :ref:`Viewport "
"<class_Viewport>`."
msgstr ""
"そして、あなたは手に入れました。\\ :ref:`Viewport <class_Viewport>`を使用して"
"生成された手続き型惑星を。"

msgid "Translation status"
msgstr "翻訳ステータス"
