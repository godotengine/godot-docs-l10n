# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-20 14:58+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Screen-reading shaders"
msgstr "スクリーン読み取りシェーダー"

msgid "Introduction"
msgstr "はじめに"

#, fuzzy
msgid ""
"It is often desired to make a shader that reads from the same screen to "
"which it's writing. 3D APIs, such as OpenGL or DirectX, make this very "
"difficult because of internal hardware limitations. GPUs are extremely "
"parallel, so reading and writing causes all sorts of cache and coherency "
"problems. As a result, not even the most modern hardware supports this "
"properly."
msgstr ""
"非常に多くの場合、書き込み先と同じ画面から読み取るシェーダーを作成することが"
"望まれます。 OpenGLやDirectXなどの3D APIは、内部ハードウェアの制限により、こ"
"れを非常に困難にします。 GPUは非常に並列であるため、読み取りと書き込みはあら"
"ゆる種類のキャッシュと一貫性の問題を引き起こします。その結果、最新のハード"
"ウェアでさえこれを適切にサポートしていません。"

msgid ""
"The workaround is to make a copy of the screen, or a part of the screen, to "
"a back-buffer and then read from it while drawing. Godot provides a few "
"tools that make this process easy."
msgstr ""
"回避策は、画面または画面の一部をバックバッファにコピーし、描画中にそこから読"
"み取ることです。 Godotには、このプロセスを簡単にするツールがいくつか用意され"
"ています。"

msgid "SCREEN_TEXTURE built-in texture"
msgstr "SCREEN_TEXTURE ビルトインテクスチャ"

#, fuzzy
msgid ""
"Godot :ref:`doc_shading_language` has a special texture, ``SCREEN_TEXTURE`` "
"(and ``DEPTH_TEXTURE`` for depth, in the case of 3D). It takes as argument "
"the UV of the screen and returns a vec3 RGB with the color. A special built-"
"in varying: SCREEN_UV can be used to obtain the UV for the current fragment. "
"As a result, this simple canvas_item fragment shader:"
msgstr ""
"Godot :ref`doc_shading_language` には、\"SCREEN_TEXTURE\" (および3Dの場合は深"
"さの \"DEPTH_TEXTURE\")という特別なテクスチャがあります。引数として画面のUVを"
"取り、色付きのvec3 RGBを返します。特別なビルトインvarying: SCREEN_UVを使用し"
"て、現在のフラグメントのUVを取得できます。その結果、この単純な2Dフラグメント"
"シェーダーは次のようになります:"

msgid "results in an invisible object, because it just shows what lies behind."
msgstr "背後にあるものを表示するだけなので、不可視のオブジェクトになります。"

msgid ""
"The reason why textureLod must be used is because, when Godot copies back a "
"chunk of the screen, it also does an efficient separatable gaussian blur to "
"its mipmaps."
msgstr ""
"textureLodを使用する必要がある理由は、Godotが画面のチャンクをコピーバックする"
"ときに、ミップマップに対して効率的な分離可能なガウスぼかしも行うためです。"

msgid ""
"This allows for not only reading from the screen, but reading from it with "
"different amounts of blur at no cost."
msgstr ""
"これにより、画面から読み取るだけでなく、異なる量のブラーを使用して読み取るこ"
"とができます。"

msgid ""
"Mipmaps are not generated in GLES2 due to poor performance and compatibility "
"with older devices."
msgstr ""

msgid "SCREEN_TEXTURE example"
msgstr "SCREEN_TEXTUREの例"

#, fuzzy
msgid ""
"``SCREEN_TEXTURE`` can be used for many things. There is a special demo for "
"*Screen Space Shaders*, that you can download to see and learn. One example "
"is a simple shader to adjust brightness, contrast and saturation:"
msgstr ""
"SCREEN_TEXTUREは、多くのことに使用できます。\\ *Screen Space Shaders* の特別"
"なデモがあり、ダウンロードして確認および学習できます。 1つの例は、明るさ、コ"
"ントラスト、彩度を調整するシンプルなシェーダーです:"

msgid "Behind the scenes"
msgstr "舞台裏"

#, fuzzy
msgid ""
"While this seems magical, it's not. In 2D, the ``SCREEN_TEXTURE`` built-in, "
"when first found in a node that is about to be drawn, does a full-screen "
"copy to a back-buffer. Subsequent nodes that use it in shaders will not have "
"the screen copied for them, because this ends up being inefficient. In 3D, "
"the screen is copied after the opaque geometry pass, but before the "
"transparent geometry pass, so transparent objects will not be captured in "
"the ``SCREEN_TEXTURE``."
msgstr ""
"これは魔法のように見えますが、そうではありません。 SCREEN_TEXTUREビルトイン"
"は、描画しようとしているノードで最初に見つかったときに、バックバッファへのフ"
"ルスクリーンコピーを実行します。シェーダーでそれを使用する後続のノードでは、"
"画面がコピーされません。これは、非効率的であるためです。"

#, fuzzy
msgid ""
"As a result, in 2D, if shaders that use ``SCREEN_TEXTURE`` overlap, the "
"second one will not use the result of the first one, resulting in unexpected "
"visuals:"
msgstr ""
"その結果、SCREEN_TEXTUREを使用するシェーダーがオーバーラップする場合、2番目の"
"シェーダーは最初のシェーダーの結果を使用せず、予期しないビジュアルになります:"

#, fuzzy
msgid ""
"In the above image, the second sphere (top right) is using the same source "
"for ``SCREEN_TEXTURE`` as the first one below, so the first one "
"\"disappears\", or is not visible."
msgstr ""
"上の画像では、2番目の球体(右上)がSCREEN_TEXTUREに同じソースを使用しているた"
"め、最初の球体は「消える」か、表示されません。"

msgid ""
"In 2D, this can be corrected via the :ref:`BackBufferCopy "
"<class_BackBufferCopy>` node, which can be instantiated between both "
"spheres. BackBufferCopy can work by either specifying a screen region or the "
"whole screen:"
msgstr ""
"2Dでは、これは :ref:`BackBufferCopy <class_BackBufferCopy>` ノードを介して修"
"正できます。これは両方の球の間でインスタンス化できます。 BackBufferCopyは、画"
"面領域または画面全体を指定することで機能します:"

msgid "With correct back-buffer copying, the two spheres blend correctly:"
msgstr "バックバッファを正しくコピーすると、2つの球体が正しくブレンドされます:"

msgid ""
"In 3D, there is less flexibility to solve this particular issue because the "
"``SCREEN_TEXTURE`` is only captured once. Be careful when using "
"``SCREEN_TEXTURE`` in 3D as it won't capture transparent objects and may "
"capture some opaque objects that are in front of the object."
msgstr ""

msgid ""
"You can reproduce the back-buffer logic in 3D by creating a :ref:`Viewport "
"<class_Viewport>` with a camera in the same position as your object, and "
"then use the :ref:`Viewport's <class_Viewport>` texture instead of "
"``SCREEN_TEXTURE``."
msgstr ""

msgid "Back-buffer logic"
msgstr "バックバッファロジック"

msgid ""
"So, to make it clearer, here's how the backbuffer copying logic works in "
"Godot:"
msgstr ""
"したがって、わかりやすくするために、Godotでのバックバッファーコピーロジックの"
"動作を次に示します:"

#, fuzzy
msgid ""
"If a node uses the ``SCREEN_TEXTURE``, the entire screen is copied to the "
"back buffer before drawing that node. This only happens the first time; "
"subsequent nodes do not trigger this."
msgstr ""
"ノードがSCREEN_TEXTUREを使用する場合、そのノードを描画する前に画面全体がバッ"
"クバッファーにコピーされます。これは最初にのみ発生します。後続のノードはこれ"
"をトリガーしません。"

#, fuzzy
msgid ""
"If a BackBufferCopy node was processed before the situation in the point "
"above (even if ``SCREEN_TEXTURE`` was not used), the behavior described in "
"the point above does not happen. In other words, automatic copying of the "
"entire screen only happens if ``SCREEN_TEXTURE`` is used in a node for the "
"first time and no BackBufferCopy node (not disabled) was found before in "
"tree-order."
msgstr ""
"上記の状況の前にBackBufferCopyノードが処理された場合(SCREEN_TEXTUREが使用され"
"なかった場合でも)、上記の状況で説明した動作は発生しません。言い換えると、"
"SCREEN_TEXTUREがノードで初めて使用され、BackBufferCopyノード(無効ではない)が"
"ツリー順で以前に見つからなかった場合にのみ、画面全体の自動コピーが発生しま"
"す。"

#, fuzzy
msgid ""
"BackBufferCopy can copy either the entire screen or a region. If set to only "
"a region (not the whole screen) and your shader uses pixels not in the "
"region copied, the result of that read is undefined (most likely garbage "
"from previous frames). In other words, it's possible to use BackBufferCopy "
"to copy back a region of the screen and then use ``SCREEN_TEXTURE`` on a "
"different region. Avoid this behavior!"
msgstr ""
"BackBufferCopyは、画面全体または領域のいずれかをコピーできます。(画面全体では"
"なく)領域のみに設定され、シェーダーがコピーされた領域にないピクセルを使用する"
"場合、その読み取りの結果は未定義です(ほとんどの場合、前のフレームからのゴ"
"ミ)。つまり、BackBufferCopyを使用して画面の領域をコピーバックし、別の領域で"
"SCREEN_TEXTUREを使用することができてしまいます。この動作は避けてください！"

msgid "DEPTH_TEXTURE"
msgstr "\\ DEPTH_TEXTURE"

#, fuzzy
msgid ""
"For 3D shaders, it's also possible to access the screen depth buffer. For "
"this, the ``DEPTH_TEXTURE`` built-in is used. This texture is not linear; it "
"must be converted via the inverse projection matrix."
msgstr ""
"3Dシェーダーの場合、画面深度バッファーにアクセスすることもできます。このため"
"に、DEPTH_TEXTUREビルトインが使用されます。このテクスチャは線形ではありませ"
"ん。逆射影行列を介して変換する必要があります。"

msgid ""
"The following code retrieves the 3D position below the pixel being drawn:"
msgstr "次のコードは、描画中のピクセルの下の3D位置を取得します:"

msgid "Translation status"
msgstr "翻訳ステータス"
