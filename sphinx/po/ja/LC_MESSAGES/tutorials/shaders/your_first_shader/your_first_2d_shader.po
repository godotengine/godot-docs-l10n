# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#, fuzzy
msgid "Your first 2D shader"
msgstr "最初のシェーダー"

msgid "Introduction"
msgstr "はじめに"

#, fuzzy
msgid ""
"Shaders are special programs that execute on the GPU and are used for "
"rendering graphics. All modern rendering is done with shaders. For a more "
"detailed description of what shaders are please see :ref:`What are shaders "
"<doc_introduction_to_shaders>`."
msgstr ""
"シェーダーは、GPUで実行される特別なプログラムで、グラフィックのレンダリングに"
"使用されます。 最新のレンダリングはすべてシェーダーで行われます。 シェーダー"
"の詳細については、\\ :ref:`シェーダーとは <doc_what_are_shaders>` を参照して"
"ください。"

msgid ""
"This tutorial will focus on the practical aspects of writing shader programs "
"by walking you through the process of writing a shader with both vertex and "
"fragment functions. This tutorial targets absolute beginners to shaders."
msgstr ""
"このチュートリアルでは、頂点関数とフラグメント関数の両方を使用してシェーダー"
"を作成するプロセスを順を追って説明し、シェーダープログラムを作成する実用的な"
"側面に焦点を当てます。 このチュートリアルは、シェーダーの初心者を対象にしてい"
"ます。"

msgid ""
"If you have experience writing shaders and are just looking for an overview "
"of how shaders work in Godot, see the :ref:`Shading Reference <toc-shading-"
"reference>`."
msgstr ""
"シェーダーの作成経験があり、Godotでのシェーダーの動作の概要を探しているだけの"
"場合は、\\ :ref:`シェーディングリファレンス <toc-shading-reference>` を参照し"
"てください。"

msgid "Setup"
msgstr "セットアップ"

#, fuzzy
msgid ""
":ref:`CanvasItem shaders <doc_canvas_item_shader>` are used to draw all 2D "
"objects in Godot, while :ref:`Spatial <doc_spatial_shader>` shaders are used "
"to draw all 3D objects."
msgstr ""
":ref:`CanvasItem <doc_canvas_item_shader>` シェーダーはGodotのすべての2Dオブ"
"ジェクトを描画するために使用され、\\ :ref:`Spatial <doc_spatial_shader>` "
"シェーダーはすべての3Dオブジェクトを描画するために使用されます。"

#, fuzzy
msgid ""
"In order to use a shader it must be attached inside a :ref:`Material "
"<class_Material>` which must be attached to an object. Materials are a type "
"of :ref:`Resource <doc_resources>`. To draw multiple objects with the same "
"material, the material must be attached to each object."
msgstr ""
"シェーダーを使用するには、オブジェクトにアタッチする必要がある :ref:"
"`Material <class_material>` 内にアタッチする必要があります。 マテリアルは :"
"ref:`Resource <doc_resources>` の一種です。 同じマテリアルで複数のオブジェク"
"トを描画するには、マテリアルを各オブジェクトにアタッチする必要があります。"

#, fuzzy
msgid ""
"All objects derived from a :ref:`CanvasItem <class_CanvasItem>` have a "
"material property. This includes all :ref:`GUI elements <class_Control>`, :"
"ref:`Sprite2Ds <class_Sprite2D>`, :ref:`TileMaps <class_Tilemap>`, :ref:"
"`MeshInstance2Ds <class_MeshInstance2D>` etc. They also have an option to "
"inherit their parent's material. This can be useful if you have a large "
"number of nodes that you want to use the same material."
msgstr ""
":ref:`CanvasItem <class_canvasitem>` から派生したすべてのオブジェクトには、マ"
"テリアルプロパティがあります。 これには、すべての :ref:`GUI要素 "
"<class_Control>`\\ 、\\ :ref:`スプライト <class_sprite>`\\ 、\\ :ref:`タイル"
"マップ <class_tilemap>`\\ 、\\ :ref:`MeshInstance2D <class_meshinstance2d>` "
"などがあります。オプションもあります。 親のマテリアルを継承します。 これは、"
"同じマテリアルを使用するノードが多数ある場合に役立ちます。"

msgid ""
"To begin, create a Sprite2D node. :ref:`You can use any CanvasItem "
"<doc_custom_drawing_in_2d>`, so long as it is drawing to the canvas, so for "
"this tutorial we will use a Sprite2D, as it is the easiest CanvasItem to "
"start drawing with."
msgstr ""

#, fuzzy
msgid ""
"In the Inspector, click beside \"Texture\" where it says \"[empty]\" and "
"select \"Load\", then select \"icon.svg\". For new projects, this is the "
"Godot icon. You should now see the icon in the viewport."
msgstr ""
"インスペクタで、\"Texture\"の横にある[空]をクリックして[読込み]を選択"
"し、”Icon.png\"を選択します。 新しいプロジェクトの場合、これはGodotアイコンで"
"す。 ビューポートにアイコンが表示されます。"

msgid ""
"Next, look down in the Inspector, under the CanvasItem section, click beside "
"\"Material\" and select \"New ShaderMaterial\". This creates a new Material "
"resource. Click on the sphere that appears. Godot currently doesn't know "
"whether you are writing a CanvasItem Shader or a Spatial Shader and it "
"previews the output of spatial shaders. So what you are seeing is the output "
"of the default Spatial Shader."
msgstr ""
"次に、インスペクタのCanvasItemセクションの下を見て、「Material」の横をクリッ"
"クし、「新規 ShaderMaterial」を選択します。 これにより、新しいマテリアルリ"
"ソースが作成されます。 表示される球をクリックします。 Godotは現在、CanvasItem"
"シェーダーとSpatialシェーダーのどちらを記述しているかを認識せず、Spatial"
"シェーダーの出力をプレビューします。 したがって、表示されているのは、デフォル"
"トのSpatialシェーダーの出力です。"

#, fuzzy
msgid ""
"Click beside \"Shader\" and select \"New Shader\". Finally, click on the "
"shader you just created and the shader editor will open. You are now ready "
"to begin writing your first shader."
msgstr ""
"\"Shader\"の横をクリックし、「新規 Shader」を選択します。 最後に、新しい"
"シェーダーリソースをクリックすると、シェーダーエディタが開きます。 これで、最"
"初のシェーダーを書き始める準備ができました。"

msgid "Your first CanvasItem shader"
msgstr "最初のキャンバスアイテム(CanvasItem)シェーダー"

msgid ""
"In Godot, all shaders start with a line specifying what type of shader they "
"are. It uses the following format:"
msgstr ""
"Godotでは、すべてのシェーダーは、シェーダーのタイプを指定する行で始まりま"
"す。 次の形式を使用します:"

msgid ""
"Because we are writing a CanvasItem shader, we specify ``canvas_item`` in "
"the first line. All our code will go beneath this declaration."
msgstr ""
"CanvasItemシェーダーを記述しているため、最初の行で ``canvas_item`` を指定しま"
"す。 すべてのコードは、この宣言の下に配置されます。"

msgid ""
"This line tells the engine which built-in variables and functionality to "
"supply you with."
msgstr "この行は、どの組み込み変数と関数を提供するかをエンジンに伝えます。"

msgid ""
"In Godot you can override three functions to control how the shader "
"operates; ``vertex``, ``fragment``, and ``light``. This tutorial will walk "
"you through writing a shader with both vertex and fragment functions. Light "
"functions are significantly more complex than vertex and fragment functions "
"and so will not be covered here."
msgstr ""
"Godotでは、3つの関数をオーバーライドして、シェーダーの動作を制御できます。\\ "
"``vertex``\\ 、\\ ``fragment``\\ 、および ``light``\\ 。 このチュートリアルで"
"は、頂点(vertex)関数とフラグメント(fragment)関数の両方を使用してシェーダーを"
"作成する方法を説明します。 ライト(light)関数は、頂点関数やフラグメント関数よ"
"りもかなり複雑なので、ここでは説明しません。"

msgid "Your first fragment function"
msgstr "最初のフラグメント関数"

#, fuzzy
msgid ""
"The fragment function runs for every pixel in a Sprite2D and determines what "
"color that pixel should be."
msgstr ""
"フラグメント関数は、Sprite内のすべてのピクセルに対して実行され、そのピクセル"
"の色を決定します。"

#, fuzzy
msgid ""
"They are restricted to the pixels covered by the Sprite2D, that means you "
"cannot use one to, for example, create an outline around a Sprite2D."
msgstr ""
"これらはSpriteでカバーされるピクセルに制限されているため、Spriteの周囲にアウ"
"トラインを作成する場合などは使用できません。"

msgid ""
"The most basic fragment function does nothing except assign a single color "
"to every pixel."
msgstr ""
"最も基本的なフラグメント関数は、すべてのピクセルに単一の色を割り当てること以"
"外は何もしません。"

#, fuzzy
msgid ""
"We do so by writing a ``vec4`` to the built-in variable ``COLOR``. ``vec4`` "
"is shorthand for constructing a vector with 4 numbers. For more information "
"about vectors see the :ref:`Vector math tutorial <doc_vector_math>`. "
"``COLOR`` is both an input variable to the fragment function and the final "
"output from it."
msgstr ""
"そのためには、組み込み変数 ``COLOR`` に ``vec4`` を書き込みます。\\ ``vec4`` "
"は、4つの数値でベクトルを構築するための省略表現です。 ベクトルの詳細について"
"は、\\ :ref:`ベクトル演算チュートリアル <doc_vector_math>`を参照してくださ"
"い。\\ ``COLOR`` はフラグメント関数への入力変数であり、フラグメント関数からの"
"最終出力です。"

msgid ""
"Congratulations! You're done. You have successfully written your first "
"shader in Godot."
msgstr ""
"おめでとう！ できました。 Godotで最初のシェーダーの作成に成功しました。"

msgid "Now let's make things more complex."
msgstr "それでは、もっと複雑にしましょう。"

#, fuzzy
msgid ""
"There are many inputs to the fragment function that you can use for "
"calculating ``COLOR``. ``UV`` is one of them. UV coordinates are specified "
"in your Sprite2D (without you knowing it!) and they tell the shader where to "
"read from textures for each part of the mesh."
msgstr ""
"``COLOR`` の計算に使用できるフラグメント関数には多くの入力があります。\\ "
"``UV`` もその1つです。 UV座標は(知らないうちに)スプライトで指定され、メッシュ"
"の各部分のテクスチャから読み取る場所をシェーダーに伝えます。"

msgid ""
"In the fragment function you can only read from ``UV``, but you can use it "
"in other functions or to assign values to ``COLOR`` directly."
msgstr ""
"フラグメント関数では ``UV`` からしか読み取ることができませんが、他の関数で使"
"用したり、値を ``COLOR`` に直接割り当てることができます。"

msgid "``UV`` varies between 0-1 from left-right and from top-bottom."
msgstr "``UV`` は、左から右、上から下で0～1の間で変化します。"

msgid "Using ``TEXTURE`` built-in"
msgstr "``TEXTURE`` ビルトインを使用する"

msgid ""
"The default fragment function reads from the set Sprite2D texture and "
"displays it."
msgstr ""

#, fuzzy
msgid ""
"When you want to adjust a color in a Sprite2D you can adjust the color from "
"the texture manually like in the code below."
msgstr ""
"スプライトの色を調整する場合、以下のコードのようにテクスチャの色を手動で調整"
"することはできません。"

msgid ""
"Certain nodes, like Sprite2Ds, have a dedicated texture variable that can be "
"accessed in the shader using ``TEXTURE``. If you want to use the Sprite2D "
"texture to combine with other colors, you can use the ``UV`` with the "
"``texture`` function to access this variable. Use them to redraw the "
"Sprite2D with the texture."
msgstr ""

msgid "Uniform input"
msgstr "Uniform入力"

msgid ""
"Uniform input is used to pass data into a shader that will be the same "
"across the entire shader."
msgstr ""
"Uniform入力は、シェーダー全体で同一のデータを、シェーダーに渡すために使用され"
"ます。"

msgid ""
"You can use uniforms by defining them at the top of your shader like so:"
msgstr "Uniformを使用するには、シェーダーの上部で次のように定義します:"

msgid ""
"For more information about usage see the :ref:`Shading Language doc "
"<doc_shading_language>`."
msgstr ""
"使用法の詳細については、\\ :ref:`シェーディング言語ドキュメント "
"<doc_shading_language>` を参照してください。"

#, fuzzy
msgid "Add a uniform to change the amount of blue in our Sprite2D."
msgstr "uniformを追加して、スプライトの青の量を変更します。"

#, fuzzy
msgid ""
"Now you can change the amount of blue in the Sprite2D from the editor. Look "
"back at the Inspector under where you created your shader. You should see a "
"section called \"Shader Param\". Unfold that section and you will see the "
"uniform you just declared. If you change the value in the editor, it will "
"overwrite the default value you provided in the shader."
msgstr ""
"これで、エディタからスプライトの青の量を変更できます。シェーダーを作成した場"
"所のインスペクタを再確認すると、\\ ``Shader Param`` というセクションが表示さ"
"れるはずです。そのセクションを展開すると、宣言したuniformが表示されます。エ"
"ディタで値を変更すると、シェーダーで指定したデフォルト値が上書きされます。"

msgid "Interacting with shaders from code"
msgstr "コードからシェーダーを操作する"

#, fuzzy
msgid ""
"You can change uniforms from code using the function "
"``set_shader_parameter()`` which is called on the node's material resource. "
"With a Sprite2D node, the following code can be used to set the ``blue`` "
"uniform."
msgstr ""
"ノードのマテリアルリソースで呼び出される ``set_shader_param()`` 関数を使用し"
"て、コードからuniformを変更できます。 Spriteノードでは、次のコードを使用して "
"``blue`` uniformを設定できます。"

msgid ""
"Note that the name of the uniform is a string. The string must match exactly "
"with how it is written in the shader, including spelling and case."
msgstr ""
"uniformの名前は文字列であることに注意してください。文字列は、スペルや大文字小"
"文字を含め、シェーダーでの記述方法と正確に一致する必要があります。"

msgid "Your first vertex function"
msgstr "最初の頂点関数"

msgid "Now that we have a fragment function, let's write a vertex function."
msgstr "フラグメント関数ができたので、頂点関数を書きましょう。"

msgid ""
"Use the vertex function to calculate where on the screen each vertex should "
"end up."
msgstr "頂点関数を使用して、各頂点が画面のどこに出現するかを計算します。"

msgid ""
"The most important variable in the vertex function is ``VERTEX``. Initially, "
"it specifies the vertex coordinates in your model, but you also write to it "
"to determine where to actually draw those vertices. ``VERTEX`` is a ``vec2`` "
"that is initially presented in local-space (i.e. not relative to the camera, "
"viewport, or parent nodes)."
msgstr ""
"頂点関数の最も重要な変数は ``VERTEX`` です。最初はモデルの頂点座標を指定しま"
"すが、実際にそれらの頂点を描画する場所を決定するために書き込むこともできま"
"す。\\ ``VERTEX`` は、ローカル空間で最初に表示される ``vec2`` です(つまり、カ"
"メラ、ビューポート、または親ノードに関連しません)。"

msgid "You can offset the vertices by directly adding to ``VERTEX``."
msgstr "``VERTEX`` に直接追加することにより、頂点をオフセットできます。"

#, fuzzy
msgid ""
"Combined with the ``TIME`` built-in variable, this can be used for basic "
"animation."
msgstr ""
"``TIME`` 組み込み変数と組み合わせて、これを単純なアニメーションに使用できま"
"す。"

msgid "Conclusion"
msgstr "結論"

msgid ""
"At their core, shaders do what you have seen so far, they compute ``VERTEX`` "
"and ``COLOR``. It is up to you to dream up more complex mathematical "
"strategies for assigning values to those variables."
msgstr ""
"コアでは、シェーダーはこれまで見てきたことを実行し、\\ ``VERTEX`` と "
"``COLOR`` を計算します。これらの変数に値を割り当てるためのより複雑な数学的戦"
"略を考え出すのはあなた次第です。"

msgid ""
"For inspiration, take a look at some of the more advanced shader tutorials, "
"and look at other sites like `Shadertoy <https://www.shadertoy.com/results?"
"query=&sort=popular&from=10&num=4>`_ and `The Book of Shaders <https://"
"thebookofshaders.com>`_."
msgstr ""
"インスピレーションを得るには、\\ `Shadertoy <https://www.shadertoy.com/"
"results?query=&sort=popular&from=10&num=4>`_ や `The Book of Shaders "
"<https://thebookofshaders.com>`_などのより高度なシェーダーチュートリアルをい"
"くつか見てください。"

msgid "Translation status"
msgstr "翻訳ステータス"
