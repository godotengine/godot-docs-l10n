# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#, fuzzy
msgid "Using RigidBody"
msgstr "RigidBody2Dを使用する"

msgid "What is a rigid body?"
msgstr "リジッド ボディとは何ですか？"

msgid ""
"A rigid body is one that is directly controlled by the physics engine in "
"order to simulate the behavior of physical objects. In order to define the "
"shape of the body, it must have one or more :ref:`Shape <class_Shape>` "
"objects assigned. Note that setting the position of these shapes will affect "
"the body's center of mass."
msgstr ""
"リジッド ボディは、物理オブジェクトの動作をシミュレートするために物理エンジン"
"によって直接制御されるものです。ボディの形状を定義するには、1つ以上の :ref:"
"`Shape <class_Shape>` オブジェクトが割り当てられている必要があります。これら"
"の形状の位置を設定すると、ボディの重心に影響することに注意してください。"

msgid "How to control a rigid body"
msgstr "リジッド ボディを制御する方法"

#, fuzzy
msgid ""
"A rigid body's behavior can be altered by setting its properties, such as "
"mass and weight. A physics material needs to be added to the rigid body to "
"adjust its friction and bounce, and set if it's absorbent and/or rough. "
"These properties can be set in the Inspector or via code. See :ref:"
"`RigidBody <class_RigidBody>` and :ref:`PhysicsMaterial "
"<class_PhysicsMaterial>` for the full list of properties and their effects."
msgstr ""
"リジッドボディの動作は、摩擦、質量、反発などのプロパティを設定することで変更"
"できます。これらのプロパティは、インスペクタまたはコードを介して設定できま"
"す。プロパティとその効果の完全なリストについては、 :ref:`RigidBody "
"<class_RigidBody>` を参照してください。"

msgid ""
"There are several ways to control a rigid body's movement, depending on your "
"desired application."
msgstr ""
"目的のアプリケーションに応じて、リジットボディの動きを制御する方法がいくつか"
"あります。"

msgid ""
"If you only need to place a rigid body once, for example to set its initial "
"location, you can use the methods provided by the :ref:`Spatial "
"<class_Spatial>` node, such as ``set_global_transform()`` or ``look_at()``. "
"However, these methods cannot be called every frame or the physics engine "
"will not be able to correctly simulate the body's state. As an example, "
"consider a rigid body that you want to rotate so that it points towards "
"another object. A common mistake when implementing this kind of behavior is "
"to use ``look_at()`` every frame, which breaks the physics simulation. "
"Below, we'll demonstrate how to implement this correctly."
msgstr ""
"リジッド ボディを1回だけ配置する必要がある場合、たとえば最初の位置を設定する"
"場合は、\\ ``set_global_transform()`` または ``look_at()`` などの :ref:"
"`Spatial <class_Spatial>` ノードで提供されるメソッドを使用できます。ただし、"
"これらのメソッドをフレームごとに呼び出してはいけません。もし呼び出すと、物理"
"エンジンは体の状態を正しくシミュレートできなくなります。たとえば、別のオブ"
"ジェクトを向くように回転させるリジッド ボディを考えてみましょう。この種の動作"
"を実装する際のよくある間違いは、物理シミュレーションを破壊する ``look_at()`` "
"をすべてのフレームで使用してしまうことです。以下に、これを正しく実装する方法"
"を示します。"

msgid ""
"The fact that you can't use ``set_global_transform()`` or ``look_at()`` "
"methods doesn't mean that you can't have full control of a rigid body. "
"Instead, you can control it by using the ``_integrate_forces()`` callback. "
"In this method, you can add *forces*, apply *impulses*, or set the "
"*velocity* in order to achieve any movement you desire."
msgstr ""
"``set_global_transform()`` または ``look_at()`` メソッドを使用できないという"
"事実は、リジットボディを完全に制御できないという意味ではありません。代わり"
"に、\\ ``_integrate_forces()`` コールバックを使用して制御できます。この方法で"
"は、 *forces* を追加したり、\\ *impulses* を適用したり、\\ *velocity* を設定"
"して、希望する動きを実現したりできます。"

msgid "The \"look at\" method"
msgstr "\"look at\"メソッド"

msgid ""
"As described above, using the Spatial node's ``look_at()`` method can't be "
"used each frame to follow a target. Here is a custom ``look_at()`` method "
"that will work reliably with rigid bodies:"
msgstr ""
"上で説明したように、Spatialノードの ``look_at()`` メソッドを使用して、各フ"
"レームをターゲットに追従させることはできません。以下は、リジットボディで確実"
"に動作するカスタム ``look_at()`` メソッドです:"

msgid ""
"This method uses the rigid body's ``set_angular_velocity()`` method to "
"rotate the body. It first calculates the difference between the current and "
"desired angle and then adds the velocity needed to rotate by that amount in "
"one frame's time."
msgstr ""
"このメソッドは、リジットボディの ``set_angular_velocity()`` メソッドを使用し"
"て体を回転させます。最初に現在の角度と目的の角度の差を計算し、次に1フレームの"
"時間内にその量だけ回転するのに必要な速度を追加します。"

msgid ""
"This script will not work with rigid bodies in *character mode* because "
"then, the body's rotation is locked. In that case, you would have to rotate "
"the attached mesh node instead using the standard Spatial methods."
msgstr ""
"このスクリプトは、ボディの回転がロックされているため、\\ *character mode* の"
"リジッドボディでは動作しません。その場合、標準のSpatialメソッドを使用する代わ"
"りに、アタッチされたメッシュノードを回転する必要があります。"

msgid "Translation status"
msgstr "翻訳ステータス"
