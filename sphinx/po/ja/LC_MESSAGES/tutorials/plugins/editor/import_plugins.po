# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Import plugins"
msgstr "プラグインのインポート"

msgid ""
"This tutorial assumes you already know how to make generic plugins. If in "
"doubt, refer to the :ref:`doc_making_plugins` page. This also assumes you "
"are acquainted with Godot's import system."
msgstr ""
"このチュートリアルでは、汎用プラグインの作成方法を理解していることを前提とし"
"ています。よく理解していない場合は、\\ :ref:`doc_making_plugins`\\ ページを参"
"照してください。また、Godotのインポートシステムに精通していることを前提として"
"います。"

msgid "Introduction"
msgstr "はじめに"

msgid ""
"An import plugin is a special type of editor tool that allows custom "
"resources to be imported by Godot and be treated as first-class resources. "
"The editor itself comes bundled with a lot of import plugins to handle the "
"common resources like PNG images, Collada and glTF models, Ogg Vorbis "
"sounds, and many more."
msgstr ""
"インポートプラグインは、カスタムリソースをGodotによってインポートし、ファース"
"トクラスのリソースとして扱うことができる特別なタイプのエディタツールです。エ"
"ディタ自体には、PNG画像、ColladaおよびglTFモデル、Ogg Vorbisサウンドなどの一"
"般的なリソースを処理するための多くのインポートプラグインがバンドルされていま"
"す。"

#, fuzzy
msgid ""
"This tutorial shows how to create an import plugin to load a custom text "
"file as a material resource. This text file will contain three numeric "
"values separated by comma, which represents the three channels of a color, "
"and the resulting color will be used as the albedo (main color) of the "
"imported material. In this example it contains the pure blue color (zero "
"red, zero green, and full blue):"
msgstr ""
"このチュートリアルでは、単純なインポートプラグインを作成して、カスタムテキス"
"トファイルをマテリアルリソースとしてロードする方法を示します。このテキスト"
"ファイルには、色の3つのチャネルを表すコンマで区切られた3つの数値が含まれ、結"
"果の色はインポートされたマテリアルのアルベド(メインカラー)として使用されま"
"す。この例では、純粋な青の色(赤がゼロ、緑がゼロ、青がフル)が含まれます:"

msgid "Configuration"
msgstr "構成"

msgid ""
"First we need a generic plugin that will handle the initialization and "
"destruction of our import plugin. Let's add the ``plugin.cfg`` file first:"
msgstr ""
"まず、インポートプラグインの初期化と破棄を処理する汎用プラグインが必要です。"
"最初に ``plugin.cfg`` ファイルを追加してみましょう:"

msgid ""
"Then we need the ``material_import.gd`` file to add and remove the import "
"plugin when needed:"
msgstr ""
"次に、必要に応じてインポート プラグインを追加および削除する "
"``material_import.gd`` ファイルが必要です:"

msgid ""
"When this plugin is activated, it will create a new instance of the import "
"plugin (which we'll soon make) and add it to the editor using the :ref:"
"`add_import_plugin() <class_EditorPlugin_method_add_import_plugin>` method. "
"We store a reference to it in a class member ``import_plugin`` so we can "
"refer to it later when removing it. The :ref:`remove_import_plugin() "
"<class_EditorPlugin_method_remove_import_plugin>` method is called when the "
"plugin is deactivated to clean up the memory and let the editor know the "
"import plugin isn't available anymore."
msgstr ""
"このプラグインがアクティブになると、インポートプラグインの新しいインスタンス"
"(間もなく作成します)が作成され、\\ :ref:`add_import_plugin() "
"<class_EditorPlugin_method_add_import_plugin_plugin>` メソッドを使用してエ"
"ディタに追加されます。クラスメンバー ``import_plugin`` に参照を保存し、後で削"
"除するときに参照できるようにします。\\ :ref:`remove_import_plugin() "
"<class_EditorPlugin_method_remove_import_plugin>` メソッドは、メモリをクリー"
"ンアップするためにプラグインが非アクティブ化されたときに呼び出され、インポー"
"トプラグインが利用できなくなったことをエディタに知らせます。"

msgid ""
"Note that the import plugin is a reference type, so it doesn't need to be "
"explicitly released from memory with the ``free()`` function. It will be "
"released automatically by the engine when it goes out of scope."
msgstr ""
"インポートプラグインは参照型なので、 ``free()`` 関数を使用してメモリから明示"
"的に解放する必要はありません。スコープ外になると、エンジンによって自動的に解"
"放されます。"

msgid "The EditorImportPlugin class"
msgstr "エディタインポートプラグイン クラス"

msgid ""
"The main character of the show is the :ref:`EditorImportPlugin class "
"<class_EditorImportPlugin>`. It is responsible for implementing the methods "
"that are called by Godot when it needs to know how to deal with files."
msgstr ""
"ショーの主役は :ref:`EditorImportPluginクラス <class_EditorImportPlugin>` で"
"す。ファイルの処理方法を知る必要がある場合にGodotによって呼び出されるメソッド"
"の実装を担当します。"

msgid "Let's begin to code our plugin, one method at time:"
msgstr "プラグインのコーディングを始めましょう:"

#, fuzzy
msgid ""
"The first method is the :ref:"
"`_get_importer_name()<class_EditorImportPlugin_private_method__get_importer_name>`. "
"This is a unique name for your plugin that is used by Godot to know which "
"import was used in a certain file. When the files needs to be reimported, "
"the editor will know which plugin to call."
msgstr ""
"最初のメソッドは :ref:`get_importer_name() "
"<class_EditorImportPlugin_method_get_importer_name>` です。これは、特定のファ"
"イルでどのインポートが使用されたかを知るためにGodotによって使用されるプラグイ"
"ンの一意の名前です。ファイルを再インポートする必要がある場合、エディタは呼び"
"出すプラグインを認識します。"

#, fuzzy
msgid ""
"The :ref:"
"`_get_visible_name()<class_EditorImportPlugin_private_method__get_visible_name>` "
"method is responsible for returning the name of the type it imports and it "
"will be shown to the user in the Import dock."
msgstr ""
":ref:`get_visible_name() <class_EditorImportPlugin_method_get_visible_name>` "
"メソッドは、インポートする型の名前を返す役割を果たし、インポートドックでユー"
"ザーに表示されます。"

msgid ""
"You should choose this name as a continuation to \"Import as\", e.g. "
"*\"Import as Silly Material\"*. You can name it whatever you want but we "
"recommend a descriptive name for your plugin."
msgstr ""
"この名前は、「名前を付けてインポート」の続きとして選択する必要があります。 例"
"えば、 \\ *「愚かな素材としてインポート」*\\ 。 好きな名前を付けることができ"
"ますが、プラグインにはわかりやすい名前を付けることをお勧めします。"

#, fuzzy
msgid ""
"Godot's import system detects file types by their extension. In the :ref:"
"`_get_recognized_extensions()<class_EditorImportPlugin_private_method__get_recognized_extensions>` "
"method you return an array of strings to represent each extension that this "
"plugin can understand. If an extension is recognized by more than one "
"plugin, the user can select which one to use when importing the files."
msgstr ""
"Godotのインポートシステムは、拡張子によってファイルタイプを検出します。\\ :"
"ref:`get_recognized_extensions() "
"<class_EditorImportPlugin_method_get_recognized_extensions>` メソッドでは、こ"
"のプラグインが理解できる各拡張機能を表す文字列の配列を返します。拡張子が複数"
"のプラグインによって認識される場合、ユーザーはファイルをインポートするときに"
"使用するプラグインを選択できます。"

msgid ""
"Common extensions like ``.json`` and ``.txt`` might be used by many plugins. "
"Also, there could be files in the project that are just data for the game "
"and should not be imported. You have to be careful when importing to "
"validate the data. Never expect the file to be well-formed."
msgstr ""
"``.json`` や ``.txt`` などの一般的な拡張機能は、多くのプラグインで使用される"
"場合があります。また、プロジェクト内には、ゲームのデータにすぎず、インポート"
"してはならないファイルが存在する可能性もあります。データを検証するには、イン"
"ポート時に注意が必要です。ファイルが整形式であることを期待しないでください。"

msgid ""
"The imported files are saved in the ``.import`` folder at the project's "
"root. Their extension should match the type of resource you are importing, "
"but since Godot can't tell what you'll use (because there might be multiple "
"valid extensions for the same resource), you need to declare what will be "
"used in the import."
msgstr ""
"インポートされたファイルは、プロジェクトのルートにある ``.import`` フォルダに"
"保存されます。それらの拡張子は、インポートするリソースの種類と一致する必要が"
"ありますが、Godotは何を使用するのかを知ることができないため(同じリソースに対"
"して複数の有効な拡張機能が存在する可能性があるため)、インポートで使用される内"
"容を宣言する必要があります。"

msgid ""
"Since we're importing a Material, we'll use the special extension for such "
"resource types. If you are importing a scene, you can use ``scn``. Generic "
"resources can use the ``res`` extension. However, this is not enforced in "
"any way by the engine."
msgstr ""
"マテリアルを読み込むので、このようなリソースタイプには特別な拡張子を使用しま"
"す。シーンをインポートする場合は、``scn`` を使うことができます。汎用リソース"
"は ``res`` 拡張子を使用できます。ただし、これはエンジンによって強制されませ"
"ん。"

msgid ""
"The imported resource has a specific type, so the editor can know which "
"property slot it belongs to. This allows drag and drop from the FileSystem "
"dock to a property in the Inspector."
msgstr ""
"インポートされたリソースには特定のタイプがあるため、エディタはリソースがどの"
"プロパティスロットに属しているかを知ることができます。これにより、 「ファイル"
"システム」 ドックから 「インスペクタ」 のプロパティーにドラッグ&ドロップでき"
"ます。"

#, fuzzy
msgid ""
"In our case it's a :ref:`class_StandardMaterial3D`, which can be applied to "
"3D objects."
msgstr ""
"この例では、3Dオブジェクトに適用できる\\ :ref:`class_SpatialMaterial`\\ で"
"す。"

msgid ""
"If you need to import different types from the same extension, you have to "
"create multiple import plugins. You can abstract the import code on another "
"file to avoid duplication in this regard."
msgstr ""
"同じ拡張子から異なるタイプをインポートする必要がある場合は、複数のインポート"
"プラグインを作成する必要があります。インポートコードを別のファイルに抽象化し"
"て、重複を避けることができます。"

msgid "Options and presets"
msgstr "オプションとプリセット"

msgid ""
"Your plugin can provide different options to allow the user to control how "
"the resource will be imported. If a set of selected options is common, you "
"can also create different presets to make it easier for the user. The "
"following image shows how the options will appear in the editor:"
msgstr ""
"プラグインは、ユーザーがリソースのインポート方法を制御できるように、さまざま"
"なオプションを提供できます。選択したオプションのセットが一般的な場合は、異な"
"るプリセットを作成して、ユーザーが簡単に使用できるようにすることもできます。"
"次の図は、エディタでオプションがどのように表示されるかを示しています:"

msgid ""
"Since there might be many presets and they are identified with a number, "
"it's a good practice to use an enum so you can refer to them using names."
msgstr ""
"プリセットが多く、数値で識別される可能性があるため、名前を使用して参照できる"
"ように列挙型を使用することをお知めします。"

msgid ""
"Now that the enum is defined, let's keep looking at the methods of an import "
"plugin:"
msgstr ""
"列挙型が定義されたので、インポート プラグインのメソッドを見てみましょう:"

#, fuzzy
msgid ""
"The :ref:`_get_preset_count() "
"<class_EditorImportPlugin_private_method__get_preset_count>` method returns "
"the amount of presets that this plugins defines. We only have one preset "
"now, but we can make this method future-proof by returning the size of our "
"``Presets`` enumeration."
msgstr ""
":ref:`get_preset_count() <class_EditorImportPlugin_method_get_preset_count>` "
"メソッドは、このプラグインが定義するプリセットの量を返します。現在、プリセッ"
"トは1つしかありませんが、\\ ``Presets`` 列挙のサイズを返すことで、このメソッ"
"ドを将来に備えて作成できます。"

#, fuzzy
msgid ""
"Here we have the :ref:`_get_preset_name() "
"<class_EditorImportPlugin_private_method__get_preset_name>` method, which "
"gives names to the presets as they will be presented to the user, so be sure "
"to use short and clear names."
msgstr ""
"ここに、\\ :ref:`get_preset_name() "
"<class_EditorImportPlugin_method_get_preset_name>` メソッドがあります。これ"
"は、ユーザーに表示されるプリセットに名前を付けるため、必ず短く明確な名前を使"
"用してください。"

msgid ""
"We can use the ``match`` statement here to make the code more structured. "
"This way it's easy to add new presets in the future. We use the catch all "
"pattern to return something too. Although Godot won't ask for presets beyond "
"the preset count you defined, it's always better to be on the safe side."
msgstr ""
"ここで ``match`` ステートメントを使用して、コードをより構造化できます。 これ"
"により、将来的に新しいプリセットを簡単に追加できます。catch allも何かを返す時"
"に使います。Godotでは、定義したプリセット数を超えるプリセットは要求されません"
"が、常に安全側にあることをお勧めします。"

msgid ""
"If you have only one preset you could simply return its name directly, but "
"if you do this you have to be careful when you add more presets."
msgstr ""
"プリセットが1つしかない場合は、名前を直接返すだけですが、これを行う場合は、プ"
"リセットを追加するときに注意する必要があります。"

#, fuzzy
msgid ""
"This is the method which defines the available options. :ref:"
"`_get_import_options() "
"<class_EditorImportPlugin_private_method__get_import_options>` returns an "
"array of dictionaries, and each dictionary contains a few keys that are "
"checked to customize the option as its shown to the user. The following "
"table shows the possible keys:"
msgstr ""
"これは、使用可能なオプションを定義する方法です。\\ :ref:"
"`get_import_options() <class_EditorImportPlugin_method_get_import_options>` "
"はDictionaryの配列を返し、各Dictionaryにはユーザーに表示されるオプションをカ"
"スタマイズするためにチェックされるいくつかのキーが含まれます。次の表は、可能"
"なキーを示しています:"

msgid "Key"
msgstr "キー"

msgid "Type"
msgstr "タイプ(型)"

msgid "Description"
msgstr "説明"

msgid "``name``"
msgstr "``name``"

msgid "String"
msgstr "文字列"

msgid ""
"The name of the option. When showed, underscores become spaces and first "
"letters are capitalized."
msgstr ""
"オプションの名前。表示すると、アンダースコアはスペースになり、最初の文字は大"
"文字になります。"

msgid "``default_value``"
msgstr "``default_value``"

msgid "Any"
msgstr "任意"

msgid "The default value of the option for this preset."
msgstr "このプリセットのオプションの既定値。"

msgid "``property_hint``"
msgstr "``property_hint``"

msgid "Enum value"
msgstr "列挙値"

msgid ""
"One of the :ref:`PropertyHint <enum_@GlobalScope_PropertyHint>` values to "
"use as hint."
msgstr ""
"ヒントとして使用する :ref:`PropertyHint <enum_@GlobalScope_PropertyHint>` 値"
"の1つ。"

msgid "``hint_string``"
msgstr "``hint_string``"

msgid ""
"The hint text of the property. The same as you'd add in the ``export`` "
"statement in GDScript."
msgstr ""
"プロパティのヒントテキスト。GDScriptの ``export`` ステートメントに追加するの"
"と同じです。"

msgid "``usage``"
msgstr "``usage``"

msgid ""
"One of the :ref:`PropertyUsageFlags <enum_@GlobalScope_PropertyUsageFlags>` "
"values to define the usage."
msgstr ""
"使用法を定義する :ref:`PropertyUsageFlags "
"<enum_@GlobalScope_PropertyUsageFlags>` 値の1つ。"

msgid ""
"The ``name`` and ``default_value`` keys are **mandatory**, the rest are "
"optional."
msgstr ""
"``name`` キーと ``default_value`` キーは\\ **必須**\\ で、残りは省略可能で"
"す。"

#, fuzzy
msgid ""
"Note that the ``_get_import_options`` method receives the preset number, so "
"you can configure the options for each different preset (especially the "
"default value). In this example we use the ``match`` statement, but if you "
"have lots of options and the presets only change the value you may want to "
"create the array of options first and then change it based on the preset."
msgstr ""
"`` get_import_options`` メソッドはプリセット番号を受け取るので、異なるプリ"
"セット(特にデフォルト値)ごとにオプションを設定できることに注意してください。"
"この例では ``match`` ステートメントを使用しますが、多くのオプションがあり、プ"
"リセットが値のみを変更する場合は、最初にオプションの配列を作成してから、プリ"
"セットに基づいて変更することができます。"

#, fuzzy
msgid ""
"The ``_get_import_options`` method is called even if you don't define "
"presets (by making ``_get_preset_count`` return zero). You have to return an "
"array even it's empty, otherwise you can get errors."
msgstr ""
"``get_import_options`` メソッドは、プリセットを定義しない場合でも呼び出されま"
"す( ``get_preset_count`` を0にして返す)。空であっても配列を返さなければなら"
"ず、さもないとエラーが発生します。"

#, fuzzy
msgid ""
"For the :ref:`_get_option_visibility() "
"<class_EditorImportPlugin_private_method__get_option_visibility>` method, we "
"simply return ``true`` because all of our options (i.e. the single one we "
"defined) are visible all the time."
msgstr ""
":ref:`get_option_visibility() "
"<class_EditorImportPlugin_method_get_option_visibility>` メソッドの場合、すべ"
"てのオプション(つまり、定義した単一のオプション)が常に表示されるため、単に "
"``true`` を返します。"

msgid ""
"If you need to make certain option visible only if another is set with a "
"certain value, you can add the logic in this method."
msgstr ""
"特定のオプションを表示する必要がある場合は、別のオプションが特定の値で設定さ"
"れている場合にのみ、このメソッドにロジックを追加できます。"

msgid "The ``import`` method"
msgstr "``import`` メソッド"

#, fuzzy
msgid ""
"The heavy part of the process, responsible for converting the files into "
"resources, is covered by the :ref:`_import() "
"<class_EditorImportPlugin_private_method__import>` method. Our sample code "
"is a bit long, so let's split in a few parts:"
msgstr ""
"ファイルのリソースへの変換を担当するプロセスの重い部分は、\\ :ref:`import() "
"<class_EditorImportPlugin_method_import>` メソッドでカバーされます。サンプル"
"コードは少し長いので、いくつかの部分に分けてみましょう:"

#, fuzzy
msgid ""
"The first part of our import method opens and reads the source file. We use "
"the :ref:`FileAccess <class_FileAccess>` class to do that, passing the "
"``source_file`` parameter which is provided by the editor."
msgstr ""
"インポートメソッドの最初の部分は、ソースファイルを開いて読み取ります。\\ :"
"ref:`File <class_File>` クラスを使用してこれを行い、エディタが提供する "
"``source_file`` パラメーターを渡します。"

msgid ""
"If there's an error when opening the file, we return it to let the editor "
"know that the import wasn't successful."
msgstr ""
"ファイルを開くときにエラーが発生した場合は、それを返して、インポートが失敗し"
"たことをエディタに知らせます。"

msgid ""
"This code takes the line of the file it read before and splits it in pieces "
"that are separated by a comma. If there are more or less than the three "
"values, it considers the file invalid and reports an error."
msgstr ""
"このコードは、前に読み込んだファイルの行を取得し、コンマで区切られた断片に分"
"割します。 3つよりも多いまたは少ない場合、ファイルは無効であると見なされ、エ"
"ラーが報告されます。"

msgid ""
"Then it creates a new :ref:`Color <class_Color>` variable and sets its "
"values according to the input file. If the ``use_red_anyway`` option is "
"enabled, then it sets the color as a pure red instead."
msgstr ""
"次に、新しい :ref:`Color <class_Color>` 変数を作成し、入力ファイルに従ってそ"
"の値を設定します。\\ ``use_red_anyway`` オプションが有効な場合、代わりに色を"
"純粋な赤に設定します。"

#, fuzzy
msgid ""
"This part makes a new :ref:`StandardMaterial3D <class_StandardMaterial3D>` "
"that is the imported resource. We create a new instance of it and then set "
"its albedo color as the value we got before."
msgstr ""
"この部分は、インポートされたリソースである新しい :ref:`SpatialMaterial "
"<class_SpatialMaterial>` を作成します。その新しいインスタンスを作成し、そのア"
"ルベド色を以前に取得した値として設定します。"

#, fuzzy
msgid ""
"This is the last part and quite an important one, because here we save the "
"made resource to the disk. The path of the saved file is generated and "
"informed by the editor via the ``save_path`` parameter. Note that this comes "
"**without** the extension, so we add it using :ref:`string formatting "
"<doc_gdscript_printf>`. For this we call the ``_get_save_extension`` method "
"that we defined earlier, so we can be sure that they won't get out of sync."
msgstr ""
"ここで作成したリソースをディスクに保存するため、これは最後の部分であり、非常"
"に重要な部分です。保存されたファイルのパスが生成され、\\ ``save_path`` パラ"
"メーターを介してエディタによって通知されます。これは拡張子なしで来るた"
"め、\\ :ref:`string formating <doc_gdscript_printf>` を使用して追加することに"
"注意してください。このために、以前に定義した ``get_save_extension`` メソッド"
"を呼び出すので、それらが同期しなくなることはありません。"

msgid ""
"We also return the result from the :ref:`ResourceSaver.save() "
"<class_ResourceSaver_method_save>` method, so if there's an error in this "
"step, the editor will know about it."
msgstr ""
"また、\\ :ref:`ResourceSaver.save() <class_ResourceSaver_method_save>` メソッ"
"ドから結果を返すため、このステップでエラーが発生した場合、エディタはそれを認"
"識します。"

msgid "Platform variants and generated files"
msgstr "プラットフォームバリアントと生成されたファイル"

msgid ""
"You may have noticed that our plugin ignored two arguments of the ``import`` "
"method. Those are *return arguments* (hence the ``r`` at the beginning of "
"their name), which means that the editor will read from them after calling "
"your import method. Both of them are arrays that you can fill with "
"information."
msgstr ""
"お気付きかもしれませんが、このプラグインは ``import`` メソッドの2つの引数を無"
"視しています。これらは\\ *戻り引数*\\ (したがって、名前の先頭に ``r`` があり"
"ます)で、これはエディタがimportメソッドを呼び出した後にこれらの引数から読み込"
"むことを意味します。どちらも情報を格納できる配列です。"

msgid ""
"The ``r_platform_variants`` argument is used if you need to import the "
"resource differently depending on the target platform. While it's called "
"*platform* variants, it is based on the presence of :ref:`feature tags "
"<doc_feature_tags>`, so even the same platform can have multiple variants "
"depending on the setup."
msgstr ""
"ターゲットプラットフォームに応じて異なる方法でリソースをインポートする必要が"
"ある場合、\\ ``r_platform_variants`` 引数が使用されます。\\ *platform* バリア"
"ントと呼ばれますが、\\ :ref:`feature tags <doc_feature_tags>` の存在に基づい"
"ているため、同じプラットフォームでも設定に応じて複数のバリアントを使用できま"
"す。"

msgid ""
"To import a platform variant, you need to save it with the feature tag "
"before the extension, and then push the tag to the ``r_platform_variants`` "
"array so the editor can know that you did."
msgstr ""
"プラットフォームバリアントをインポートするには、拡張機能の前に機能タグを付け"
"て保存してから、タグを ``r_platform_variants`` 配列にプッシュして、エディタが"
"それを認識できるようにする必要があります。"

msgid ""
"For example, let's say we save a different material for a mobile platform. "
"We would need to do something like the following:"
msgstr ""
"たとえば、モバイルプラットフォーム用に別のマテリアルを保存したとします。次の"
"ような処理を行う必要があります:"

msgid ""
"The ``r_gen_files`` argument is meant for extra files that are generated "
"during your import process and need to be kept. The editor will look at it "
"to understand the dependencies and make sure the extra file is not "
"inadvertently deleted."
msgstr ""
"``r_gen_files`` 引数は、インポートプロセス中に生成され、保持する必要がある追"
"加のファイル用です。 エディタはこれを見て依存関係を理解し、余分なファイルが"
"誤って削除されないようにします。"

msgid ""
"This is also an array and should be filled with full paths of the files you "
"save. As an example, let's create another material for the next pass and "
"save it in a different file:"
msgstr ""
"これは配列でもあるので、保存するファイルの完全なパスで埋められます。たとえ"
"ば、次のパス用に別のマテリアルを作成し、別のファイルに保存してみましょう:"

msgid "Trying the plugin"
msgstr "プラグインを試す"

msgid ""
"This has been theoretical, but now that the import plugin is done, let's "
"test it. Make sure you created the sample file (with the contents described "
"in the introduction section) and save it as ``test.mtxt``. Then activate the "
"plugin in the Project Settings."
msgstr ""
"これは理論的なものですが、インポートプラグインが完了したので、テストしてみま"
"しょう。(紹介セクションで説明した内容を含む)サンプルファイルを作成し、\\ "
"``test.mtxt`` として保存してください。次に、プロジェクト設定でプラグインを有"
"効にします。"

msgid ""
"If everything goes well, the import plugin is added to the editor and the "
"file system is scanned, making the custom resource appear on the FileSystem "
"dock. If you select it and focus the Import dock, you can see the only "
"option to select there."
msgstr ""
"すべてがうまくいけば、インポートプラグインがエディタに追加され、ファイルシス"
"テムがスキャンされ、カスタムリソースがファイルシステムドックに表示されます。"
"選択して[インポート]ドックにフォーカスを合わせると、選択する唯一のオプション"
"が表示されます。"

#, fuzzy
msgid ""
"Create a MeshInstance3D node in the scene, and for its Mesh property set up "
"a new SphereMesh. Unfold the Material section in the Inspector and then drag "
"the file from the FileSystem dock to the material property. The object will "
"update in the viewport with the blue color of the imported material."
msgstr ""
"シーンにMeshInstanceノードを作成し、そのMeshプロパティに新しいSphereMeshを設"
"定します。インスペクタでMaterialセクションを展開し、ファイルシステムドックか"
"らMaterialプロパティにファイルをドラッグします。オブジェクトは、インポートさ"
"れたマテリアルの青色でビューポートで更新されます。"

msgid ""
"Go to Import dock, enable the \"Use Red Anyway\" option, and click on "
"\"Reimport\". This will update the imported material and should "
"automatically update the view showing the red color instead."
msgstr ""
"[インポートドック]に移動し、\"Use Red Anyway\"オプションを有効にし、[再イン"
"ポート]をクリックします。これにより、読み込まれたマテリアルが更新され、代わり"
"に赤い色を示すビューが自動的に更新されます。"

msgid ""
"And that's it! Your first import plugin is done! Now get creative and make "
"plugins for your own beloved formats. This can be quite useful to write your "
"data in a custom format and then use it in Godot as if they were native "
"resources. This shows how the import system is powerful and extendable."
msgstr ""
"以上です!最初のインポートプラグインが完了しました。自分の好きなフォーマットの"
"プラグインを作ってみましょう。これは、カスタム・フォーマットでデータを作成"
"し、それをあたかもネイティブ・リソースであるかのようにGodotで使用する場合に非"
"常に便利です。これは、インポート・システムがいかに強力で拡張可能であるかを示"
"しています。"

msgid "Translation status"
msgstr "翻訳ステータス"
