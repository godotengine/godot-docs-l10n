# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Making plugins"
msgstr "プラグインの作成"

msgid "About plugins"
msgstr "プラグインについて"

msgid ""
"A plugin is a great way to extend the editor with useful tools. It can be "
"made entirely with GDScript and standard scenes, without even reloading the "
"editor. Unlike modules, you don't need to create C++ code nor recompile the "
"engine. While this makes plugins less powerful, there are still many things "
"you can do with them. Note that a plugin is similar to any scene you can "
"already make, except it is created using a script to add editor "
"functionality."
msgstr ""
"プラグインは、便利なツールを使用してエディタを拡張する優れた方法です。エディ"
"タをリロードしなくても、GDScriptと標準シーンで完全に作成できます。モジュール"
"とは異なり、C++コードを作成したり、エンジンを再コンパイルしたりする必要はあり"
"ません。これによりプラグインのパワフルさが低下しますが、プラグインでできるこ"
"とはまだたくさんあります。プラグインは、エディタ機能を追加するスクリプトを使"
"用して作成されることを除いて、すでに作成できるシーンに似ていることに注意して"
"ください。"

#, fuzzy
msgid ""
"This tutorial will guide you through the creation of two plugins so you can "
"understand how they work and be able to develop your own. The first is a "
"custom node that you can add to any scene in the project, and the other is a "
"custom dock added to the editor."
msgstr ""
"このチュートリアルでは、2つの単純なプラグインを作成する手順を説明します。プラ"
"グインの動作を理解し、独自のプラグインを開発できるようになります。1つはプロ"
"ジェクトの任意のシーンに追加できるカスタムノードで、もう1つはエディタに追加さ"
"れるカスタムドックです。"

msgid "Creating a plugin"
msgstr "プラグインの作成"

msgid ""
"Before starting, create a new empty project wherever you want. This will "
"serve as a base to develop and test the plugins."
msgstr ""
"開始する前に、必要な場所に新しい空のプロジェクトを作成します。これは、プラグ"
"インを開発およびテストするためのベースとして機能します。"

msgid ""
"The first thing you need for the editor to identify a new plugin is to "
"create two files: a ``plugin.cfg`` for configuration and a tool script with "
"the functionality. Plugins have a standard path like ``addons/plugin_name`` "
"inside the project folder. Godot provides a dialog for generating those "
"files and placing them where they need to be."
msgstr ""
"エディタが新しいプラグインを識別するために最初に必要なことは、設定用の "
"``plugin.cfg`` と機能を備えたツールスクリプトの2つのファイルを作成することで"
"す。 プラグインには、プロジェクトフォルダ内に ``addons/plugin_name`` のような"
"標準パスがあります。Godotは、これらのファイルを生成し、必要な場所に配置するた"
"めのダイアログを提供します。"

#, fuzzy
msgid ""
"In the main toolbar, click the ``Project`` dropdown. Then click ``Project "
"Settings...``. Go to the ``Plugins`` tab and then click on the ``Create New "
"Plugin`` button in the top-right."
msgstr ""
"メインツールバーで、[プロジェクト]ドロップダウンをクリックします。 次に、[プ"
"ロジェクト設定...]をクリックします。[プラグイン]タブに移動し、右上の[作成]ボ"
"タンをクリックします。"

msgid "You will see the dialog appear, like so:"
msgstr "次のようなダイアログが表示されます:"

msgid ""
"The placeholder text in each field describes how it affects the plugin's "
"creation of the files and the config file's values."
msgstr ""
"各フィールドのプレースホルダーテキストは、プラグインによるファイルの作成と構"
"成ファイルの値にどのように影響するかを説明しています。"

#, fuzzy
msgid "To continue with the example, use the following values:"
msgstr "例を続行するには、次の値を使用します:"

msgid ""
"Unchecking the ``Activate now?`` option in C# is always required because, "
"like every other C# script, the EditorPlugin script needs to be compiled "
"which requires building the project. After building the project the plugin "
"can be enabled in the ``Plugins`` tab of ``Project Settings``."
msgstr ""

msgid "You should end up with a directory structure like this:"
msgstr "次のようなディレクトリ構造になるはずです:"

#, fuzzy
msgid ""
"``plugin.cfg`` is an INI file with metadata about your plugin. The name and "
"description help people understand what it does. Your name helps you get "
"properly credited for your work. The version number helps others know if "
"they have an outdated version; if you are unsure on how to come up with the "
"version number, check out `Semantic Versioning <https://semver.org/>`_. The "
"main script file will instruct Godot what your plugin does in the editor "
"once it is active."
msgstr ""
"``plugin.cfg``は、プラグインに関するメタデータを持つシンプルなINIファイルで"
"す。名前と説明は、人々の理解を助けるものです。 あなたの名前はあなたがあなたの"
"仕事に対して適切に認められるのに役立ちます。 バージョン番号は、他の人が古い"
"バージョンであるかどうかを知るのに役立ちます。 バージョン番号を見つける方法が"
"わからない場合は、\\ `Semantic Versioning <https://semver.org/>`_ を確認して"
"ください。 メインスクリプトファイルは、プラグインがアクティブになると、プラグ"
"インがエディタで行うことをGodotに指示します。"

msgid "The script file"
msgstr "スクリプトファイル"

#, fuzzy
msgid ""
"Upon creation of the plugin, the dialog will automatically open the "
"EditorPlugin script for you. The script has two requirements that you cannot "
"change: it must be a ``@tool`` script, or else it will not load properly in "
"the editor, and it must inherit from :ref:`class_EditorPlugin`."
msgstr ""
"プラグインの作成時に、ダイアログが自動的にEditorPluginスクリプトを開きます。"
"スクリプトには、変更できない2つの要件があります: まず ``tool`` スクリプトであ"
"る必要があります。そうでない場合、エディタに適切にロードされされません。次"
"に :ref:`class_EditorPlugin` を継承する必要があります。"

#, fuzzy
msgid ""
"In addition to the EditorPlugin script, any other GDScript that your plugin "
"uses must *also* be a tool. Any GDScript without ``@tool`` imported into the "
"editor will act like an empty file!"
msgstr ""
"EditorPluginスクリプトに加えて、プラグインが使用する他のGDScriptは、\\ "
"*tool* である必要があります。 エディタにインポートされた ``tool`` のない"
"GDScriptは、空のファイルのようにふるまいます！"

#, fuzzy
msgid ""
"It's important to deal with initialization and clean-up of resources. A good "
"practice is to use the virtual function :ref:`_enter_tree() "
"<class_Node_private_method__enter_tree>` to initialize your plugin and :ref:"
"`_exit_tree() <class_Node_private_method__exit_tree>` to clean it up. "
"Thankfully, the dialog generates these callbacks for you. Your script should "
"look something like this:"
msgstr ""
"リソースの初期化とクリーンアップに対処することが重要です。 仮想関数 :ref:"
"`_enter_tree() <class_Node_method__enter_tree>` を使用してプラグインを初期化"
"し、\\ :ref:`_exit_tree() <class_Node_method__exit_tree>` を使用してクリーン"
"アップすることをお勧めします。ありがたいことに、ダイアログはこれらのコール"
"バックを生成します。 スクリプトは次のようになります:"

msgid "This is a good template to use when creating new plugins."
msgstr ""
"これは、新しいプラグインを作成するときに使用するのに適したテンプレートです。"

msgid "A custom node"
msgstr "カスタム ノード"

msgid ""
"Sometimes you want a certain behavior in many nodes, such as a custom scene "
"or control that can be reused. Instancing is helpful in a lot of cases, but "
"sometimes it can be cumbersome, especially if you're using it in many "
"projects. A good solution to this is to make a plugin that adds a node with "
"a custom behavior."
msgstr ""
"再利用可能なカスタムシーンやコントロールなど、多くのノードで特定の動作が必要"
"な場合があります。 インスタンス化は多くの場合に役立ちますが、多くのプロジェク"
"トでインスタンス化を使用している場合は特に、面倒な場合があります。 これに対す"
"る適切な解決策は、カスタムの動作を持つノードを追加するプラグインを作成するこ"
"とです。"

#, fuzzy
msgid ""
"Nodes added via an EditorPlugin are \"CustomType\" nodes. While they work "
"with any scripting language, they have fewer features than :ref:`the Script "
"Class system <doc_gdscript_basics_class_name>`. If you are writing GDScript "
"or NativeScript, we recommend using Script Classes instead."
msgstr ""
"EditorPluginを介して追加されたノードは \"CustomType\" ノードです。 どのスクリ"
"プト言語でも動作しますが、\\ :ref:`スクリプトクラスシステム "
"<doc_scripting_continued_class_name>` よりも機能が少なくなります。\\ GDScript"
"またはNativeScriptを作成している場合は、そちらを代わりに使用することをお勧め"
"します。"

#, fuzzy
msgid ""
"To create a new node type, you can use the function :ref:`add_custom_type() "
"<class_EditorPlugin_method_add_custom_type>` from the :ref:"
"`class_EditorPlugin` class. This function can add new types to the editor "
"(nodes or resources). However, before you can create the type, you need a "
"script that will act as the logic for the type. While that script doesn't "
"have to use the ``@tool`` annotation, it can be added so the script runs in "
"the editor."
msgstr ""
"新しいノードタイプを作成するには、\\ :ref:`class_EditorPlugin` クラスの関数 :"
"ref:`add_custom_type() <class_EditorPlugin_method_add_custom_type>` を使用で"
"きます。この関数は、新しいタイプのエディタ(ノードまたはリソース)を追加できま"
"す。ただし、タイプを作成する前に、タイプのロジックとして機能するスクリプトが"
"必要です。このスクリプトは ``tool`` キーワードを使用する必要はありませんが、"
"スクリプトをエディタで実行させるためにそれを追加できます。"

#, fuzzy
msgid ""
"For this tutorial, we'll create a button that prints a message when clicked. "
"For that, we'll need a script that extends from :ref:`class_Button`. It "
"could also extend :ref:`class_BaseButton` if you prefer:"
msgstr ""
"このチュートリアルでは、クリックされたときにメッセージを印刷する簡単なボタン"
"を作成します。そのためには、\\ :ref:`class_Button` から拡張する簡単なスクリプ"
"トが必要です。必要に応じて :ref:`class_BaseButton` を拡張することもできます:"

#, fuzzy
msgid ""
"That's it for our basic button. You can save this as ``my_button.gd`` inside "
"the plugin folder. You'll also need a 16×16 icon to show in the scene tree. "
"If you don't have one, you can grab the default one from the engine and save "
"it in your `addons/my_custom_node` folder as `icon.png`, or use the default "
"Godot logo (`preload(\"res://icon.svg\")`)."
msgstr ""
"基本的なボタンはこれで終わりです。これをプラグインフォルダ内に ``my_button."
"gd`` として保存できます。シーンツリーに表示するには、16×16アイコンも必要で"
"す。持っていない場合は、デフォルトのものをエンジンから取得して、\\ `addons/"
"my_custom_node` フォルダに `icon.png` として保存するか、デフォルトのGodotロゴ"
"(`preload(\"res://icon.png\")`)を使用します。 必要に応じて、SVGアイコンを使用"
"することもできます。"

msgid ""
"SVG images that are used as custom node icons should have the **Editor > "
"Scale With Editor Scale** and **Editor > Convert Icons With Editor Theme** :"
"ref:`import options <doc_importing_images_editor_import_options>` enabled. "
"This allows icons to follow the editor's scale and theming settings if the "
"icons are designed with the same color palette as Godot's own icons."
msgstr ""

msgid ""
"Now, we need to add it as a custom type so it shows on the **Create New "
"Node** dialog. For that, change the ``custom_node.gd`` script to the "
"following:"
msgstr ""
"次に、\\ **Nodeを新規作成 ** ダイアログに表示されるように、カスタムタイプとし"
"て追加する必要があります。そのためには、\\ ``custom_node.gd`` スクリプトを次"
"のように変更します:"

msgid ""
"With that done, the plugin should already be available in the plugin list in "
"the **Project Settings**, so activate it as explained in `Checking the "
"results`_."
msgstr ""
"これが完了すると、プラグインは **プロジェクト設定** のプラグインリストですで"
"に使用可能になっているはずなので、\\ `Checking the results`_ で説明されている"
"ようにアクティブにします。"

msgid "Then try it out by adding your new node:"
msgstr "次に、新しいノードを追加して試してください:"

msgid ""
"When you add the node, you can see that it already has the script you "
"created attached to it. Set a text to the button, save and run the scene. "
"When you click the button, you can see some text in the console:"
msgstr ""
"ノードを追加すると、作成したスクリプトが既に接続されていることがわかります。 "
"ボタンにテキストを設定し、シーンを保存して実行します。 ボタンをクリックする"
"と、コンソールにテキストが表示されます:"

msgid "A custom dock"
msgstr "カスタムドック"

msgid ""
"Sometimes, you need to extend the editor and add tools that are always "
"available. An easy way to do it is to add a new dock with a plugin. Docks "
"are just scenes based on Control, so they are created in a way similar to "
"usual GUI scenes."
msgstr ""
"場合によっては、エディタを拡張し、常に使用可能なツールを追加する必要がありま"
"す。簡単な方法は、新しいドックにプラグインを追加することです。ドックはコント"
"ロールに基づいた単なるシーンであるため、通常のGUIシーンと同様の方法で作成され"
"ます。"

msgid ""
"Creating a custom dock is done just like a custom node. Create a new "
"``plugin.cfg`` file in the ``addons/my_custom_dock`` folder, then add the "
"following content to it:"
msgstr ""
"カスタムドックの作成は、カスタムノードのように行われます。\\ ``addons/"
"my_custom_dock`` フォルダに新しい ``plugin.cfg`` ファイルを作成し、次のコンテ"
"ンツを追加します:"

msgid ""
"Then create the script ``custom_dock.gd`` in the same folder. Fill it with "
"the :ref:`template we've seen before <doc_making_plugins_template_code>` to "
"get a good start."
msgstr ""
"に、同じフォルダにスクリプト ``custom_dock.gd`` を作成します。良いスタートを"
"切るために、\\ :ref:`前に見たテンプレート <doc_making_plugins_template_code> "
"` を入力してください。"

msgid ""
"Since we're trying to add a new custom dock, we need to create the contents "
"of the dock. This is nothing more than a standard Godot scene: just create a "
"new scene in the editor then edit it."
msgstr ""
"新しいカスタムドックを追加しようとしているので、ドックのコンテンツを作成する"
"必要があります。これは、標準のGodotシーンに他なりません。エディタで新しいシー"
"ンを作成し、編集するだけです。"

msgid ""
"For an editor dock, the root node **must** be a :ref:`Control "
"<class_Control>` or one of its child classes. For this tutorial, you can "
"create a single button. The name of the root node will also be the name that "
"appears on the dock tab, so be sure to give it a short and descriptive name. "
"Also, don't forget to add some text to your button."
msgstr ""
"エディタドックの場合、ルートノードは **必ず** :ref:`Control <class_Control>` "
"またはその子クラスでなければなりません。このチュートリアルでは、1つのボタンを"
"作成できます。ルートノードの名前は、ドックタブに表示される名前でもあるため、"
"必ず短くわかりやすい名前を付けてください。また、ボタンにテキストを追加するこ"
"とを忘れないでください。"

msgid ""
"Save this scene as ``my_dock.tscn``. Now, we need to grab the scene we "
"created then add it as a dock in the editor. For this, you can rely on the "
"function :ref:`add_control_to_dock() "
"<class_EditorPlugin_method_add_control_to_dock>` from the :ref:`EditorPlugin "
"<class_EditorPlugin>` class."
msgstr ""
"このシーンを ``my_dock.tscn`` として保存します。次に、作成したシーンを取得"
"し、エディタでドックとして追加する必要があります。このために、\\ :ref:"
"`EditorPlugin <class_EditorPlugin>` クラスの関数 :ref:`add_control_to_dock() "
"<class_EditorPlugin_method_add_control_to_dock>` を使用できます。"

msgid ""
"You need to select a dock position and define the control to add (which is "
"the scene you just created). Don't forget to **remove the dock** when the "
"plugin is deactivated. The script could look like this:"
msgstr ""
"ドックの位置を選択し、追加するコントロール(作成したばかりのシーン)を定義する"
"必要があります。プラグインが非アクティブになったら、\\ **ドックを削除する** "
"ことを忘れないでください。 スクリプトは次のようになります:"

msgid ""
"Note that, while the dock will initially appear at its specified position, "
"the user can freely change its position and save the resulting layout."
msgstr ""
"ドックは指定された位置に最初に表示されますが、ユーザーは自由に位置を変更し、"
"結果のレイアウトを保存できることに注意してください。"

msgid "Checking the results"
msgstr "結果の確認"

#, fuzzy
msgid ""
"It's now time to check the results of your work. Open the **Project "
"Settings** and click on the **Plugins** tab. Your plugin should be the only "
"one on the list."
msgstr ""
"ここで、作業の結果を確認します。\\ **プロジェクト設定** を開き、\\ **プラグイ"
"ン** タブをクリックします。プラグインはリストにある唯一のものでなければなりま"
"せん。 表示されていない場合は、右上隅の[**アップデート**]ボタンをクリックしま"
"す。"

#, fuzzy
msgid ""
"You can see the plugin is not enabled. Click the **Enable** checkbox to "
"activate the plugin. The dock should become visible before you even close "
"the settings window. You should now have a custom dock:"
msgstr ""
"**ステータス** 列でプラグインが非アクティブであることを確認できます。ステータ"
"スをクリックして[**Active**]を選択します。設定ウィンドウを閉じる前に、ドック"
"が表示されるはずです。これで、カスタムドックができました:"

msgid "Going beyond"
msgstr "今後の展開"

msgid ""
"Now that you've learned how to make basic plugins, you can extend the editor "
"in several ways. Lots of functionality can be added to the editor with "
"GDScript; it is a powerful way to create specialized editors without having "
"to delve into C++ modules."
msgstr ""
"基本的なプラグインの作成方法を学習したので、エディタをいくつかの方法で拡張で"
"きます。GDScriptを使用して、多くの機能をエディタに追加できます。これは、C++モ"
"ジュールを詳しく掘り下げることなく、専用のエディタを作成するための強力な方法"
"です。"

msgid ""
"You can make your own plugins to help yourself and share them in the `Asset "
"Library <https://godotengine.org/asset-library/>`_ so that people can "
"benefit from your work."
msgstr ""
"自分でプラグインを作成して自分自身を助け、\\ `Asset Library <https://"
"godotengine.org/asset-library/>`_ で共有して、人々があなたの仕事から利益を得"
"られるようにすることができます。"

#, fuzzy
msgid "Registering autoloads/singletons in plugins"
msgstr "登録とログイン"

msgid ""
"It is possible for editor plugins to automatically register :ref:`autoloads "
"<doc_singletons_autoload>` when the plugin is enabled. This also includes "
"unregistering the autoload when the plugin is disabled."
msgstr ""

msgid ""
"This makes setting up plugins faster for users, as they no longer have to "
"manually add autoloads to their project settings if your editor plugin "
"requires the use of an autoload."
msgstr ""

#, fuzzy
msgid "Use the following code to register a singleton from an editor plugin:"
msgstr ""
"次のコマンドを使用して、生成されたエクスポートテンプレートを削除できます:"

msgid "Translation status"
msgstr "翻訳ステータス"
