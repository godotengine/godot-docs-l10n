# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "VR starter tutorial part 2"
msgstr "VRスターターチュートリアルパート2"

msgid "Introduction"
msgstr "はじめに"

msgid ""
"In this part of the VR starter tutorial series, we will be adding a number "
"of special :ref:`RigidBody <class_RigidBody>`-based nodes that can be used "
"in VR."
msgstr ""
"VRスターターチュートリアルシリーズのこのパートでは、VRで使用できる特別な :"
"ref:`RigidBody <class_RigidBody>` ベースのノードをいくつか追加します。"

msgid ""
"This continues from where we left on in the last tutorial part, where we "
"just finished getting the VR controllers working and defined a custom class "
"called ``VR_Interactable_Rigidbody``."
msgstr ""
"これは、チュートリアルパート１の最後におこなったところから続きます。そこで"
"は、VRコントローラーを動作させ、\\ ``VR_Interactable_Rigidbody`` というカスタ"
"ムクラスを定義しました。"

#, fuzzy
msgid ""
"You can find the finished project on the `OpenVR GitHub repository <https://"
"github.com/GodotVR/godot_openvr_fps>`__."
msgstr ""
"完成したプロジェクトは、\\ ``OpenVR GitHub リポジトリ <https://github.com/"
"GodotVR/godot_openvr_fps>`_ で見つけることができます。"

msgid "Adding destroyable targets"
msgstr "破壊可能なターゲットを追加する"

msgid ""
"Before we make any of the special :ref:`RigidBody <class_RigidBody>`-based "
"nodes, we need something for them to do. Let's make a simple sphere target "
"that will break into a bunch of pieces when destroyed."
msgstr ""
"特別な :ref:`RigidBody <class_RigidBody>` ベースのノードを作成する前に、それ"
"らを実行するために色々と必要です。破壊されたときに多数のピースに分割される単"
"純な球体ターゲットを作成しましょう。"

msgid ""
"Open up ``Sphere_Target.tscn``, which is in the ``Scenes`` folder. The scene "
"is fairly simple, with just a :ref:`StaticBody <class_StaticBody>` with a "
"sphere shaped :ref:`CollisionShape <class_CollisionShape>`, a :ref:"
"`MeshInstance <class_MeshInstance>` node displaying a sphere mesh, and an :"
"ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node."
msgstr ""
"``Scenes`` フォルダにある ``Sphere_Target.tscn`` を開きます。 シーンはかなり"
"シンプルで、球形の :ref:`CollisionShape <class_CollisionShape>` を備えた :"
"ref:`StaticBody <class_StaticBody>`\\ 、球メッシュを表示する :ref:"
"`MeshInstance <class_MeshInstance>` ノード、および :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` ノードのみです。"

msgid ""
"The special :ref:`RigidBody <class_RigidBody>` nodes will handle damaging "
"the sphere, which is why we are using a :ref:`StaticBody <class_StaticBody>` "
"node instead of something like an :ref:`Area <class_Area>` or :ref:"
"`RigidBody <class_RigidBody>` node. Outside of that, there isn't really a "
"lot to talk about, so let's move straight into writing the code."
msgstr ""
"特別な :ref:`RigidBody <class_RigidBody>` ノードは球体のダメージを処理しま"
"す。そのため、\\ :ref:`Area <class_Area>` または :ref:`RigidBody "
"<class_RigidBody>` ノードのようなものの代わりに :ref:`StaticBody "
"<class_StaticBody>` ノードを使用しています。 それ以外のことについては、あまり"
"話すことはありませんので、コードの記述にまっすぐ進みましょう。"

msgid ""
"Select the ``Sphere_Target_Root`` node and make a new script called "
"``Sphere_Target.gd``. Add the following code:"
msgstr ""
"``Sphere_Target_Root`` ノードを選択し、\\ ``Sphere_Target.gd`` という新しいス"
"クリプトを作成します。次のコードを追加します:"

msgid "Let's go over how this script works."
msgstr "このスクリプトの仕組みを見ていきましょう。"

msgid "Explaining the Sphere Target code"
msgstr "Sphere Targetコードの説明"

#, fuzzy
msgid "First, let's go through all the class variables in the script:"
msgstr "最初に、スクリプト内のすべてのクラス変数を見てみましょう:"

msgid ""
"``destroyed``: A variable to track whether the sphere target has been "
"destroyed."
msgstr "``destroyed``: 球体ターゲットが破壊されたかどうかを追跡する変数。"

msgid ""
"``destroyed_timer``: A variable to track how long the sphere target has been "
"destroyed."
msgstr "``destroyed_timer``: 球体ターゲットが破壊された時間を追跡する変数。"

msgid ""
"``DESTROY_WAIT_TIME``: A constant to define the length of time the target "
"can be destroyed for before it frees/deletes itself."
msgstr ""
"``DESTROY_WAIT_TIME``: ターゲットがそれ自体を解放/削除する前に破棄できる時間"
"の長さを定義する定数。"

msgid ""
"``health``: A variable to store the amount of health the sphere target has."
msgstr "``health``: 球体ターゲットが持つ体力(HP)の量を保存する変数。"

msgid ""
"``RIGID_BODY_TARGET``: A constant to hold the scene of the destroyed sphere "
"target."
msgstr ""
"``RIGID_BODY_TARGET``: 破壊された球体ターゲットのシーンを保持する定数。"

msgid ""
"Feel free to check out the ``RIGID_BODY_TARGET`` scene. It is just a bunch "
"of :ref:`RigidBody <class_RigidBody>` nodes and a broken sphere model."
msgstr ""
"``RIGID_BODY_TARGET`` シーンをチェックしてください。それは :ref:`RigidBody "
"<class_RigidBody>` ノードの束と壊れた球体モデルです。"

msgid ""
"We'll be instancing this scene so when the target is destroyed, it looks "
"like it broke into a bunch of pieces."
msgstr ""
"このシーンをインスタンス化するので、ターゲットが破壊されると、多数のピースに"
"壊れたように見えます。"

msgid "``_ready`` function step-by-step explanation"
msgstr "``_ready`` 関数のステップごとの説明"

#, fuzzy
msgid ""
"All the ``_ready`` function does is that it stops the ``_physics_process`` "
"from being called by calling ``set_physics_process`` and passing ``false``. "
"The reason we do this is because all the code in ``_physics_process`` is for "
"destroying this node when enough time has passed, which we only want to do "
"when the target has been destroyed."
msgstr ""
"``_ready`` 関数は、\\ ``set_physics_process`` を呼び出して ``false`` を渡すこ"
"とで ``_physics_process`` の呼び出しを停止します。これを行う理由は、\\ ``_ "
"physics_process`` のすべてのコードが、十分な時間が経過したときにこのノードを"
"破棄するためであり、ターゲットが破棄された場合にのみ行うためです。"

msgid "``_physics_process`` function step-by-step explanation"
msgstr "``_physics_process`` 関数のステップごとの説明"

msgid ""
"First this function adds time, ``delta``, to the ``destroyed_timer`` "
"variable. It then checks to see if ``destroyed_timer`` is greater than or "
"equal to ``DESTROY_WAIT_TIME``. If ``destroyed_timer`` is greater than or "
"equal to ``DESTROY_WAIT_TIME``, then the sphere target frees/deletes itself "
"by calling the ``queue_free`` function."
msgstr ""
"最初に、この関数は ``delta`` を ``destroyed_timer`` 変数に加算します。次"
"に、\\ ``destroyed_timer`` が ``DESTROY_WAIT_TIME`` 以上であるかどうかを確認"
"します。\\ ``destroyed_timer`` が ``DESTROY_WAIT_TIME`` 以上の場合、球体ター"
"ゲットは ``queue_free`` 関数を呼び出すことで自身を解放/削除します。"

msgid "``damage`` function step-by-step explanation"
msgstr "``damage`` 関数の詳細な説明"

msgid ""
"The ``damage`` function will be called by the special :ref:`RigidBody "
"<class_RigidBody>` nodes, which will pass the amount of damage done to the "
"target, which is a function argument variable called ``damage``. The "
"``damage`` variable will hold the amount of damage the special :ref:"
"`RigidBody <class_RigidBody>` node did to the sphere target."
msgstr ""
"``damage`` 関数は、特別な :ref:`RigidBody <class_RigidBody>` ノードによって呼"
"び出され、ターゲットに加えられたダメージの量を ``damage`` と呼ばれる関数の引"
"数変数として渡します。\\ ``damage`` 変数は、特別な :ref:`RigidBody "
"<class_RigidBody>` ノードが球体ターゲットに与えたダメージの量を保持します。"

msgid ""
"First this function checks to make sure the target is not already destroyed "
"by checking if the ``destroyed`` variable is equal to ``true``. If "
"``destroyed`` is equal to ``true``, then the function calls ``return`` so "
"none of the other code is called. This is just a safety check so that if two "
"things damage the target at exactly the same time, the target cannot be "
"destroyed twice."
msgstr ""
"最初に、この関数は ``destroyed`` 変数が ``true`` に等しいかどうかをチェックす"
"ることにより、ターゲットが既に破棄されていないことを確認します。\\ "
"``destroyed`` が ``true`` に等しい場合、関数は ``return`` を呼び出すため、他"
"のコードは呼び出されません。これは単なる安全チェックであるため、2つのものが"
"まったく同時にターゲットにダメージを与えた場合でも、ターゲットを2回破壊するこ"
"とはできません。"

msgid ""
"Next the function removes the amount of damage taken, ``damage``, from the "
"target's health, ``health``. If then checks to see if ``health`` is equal to "
"zero or less, meaning that the target has just been destroyed."
msgstr ""
"次に、この関数は、ダメージの量 ``damage`` をターゲットの体力 ``health`` から"
"減らします。次に、\\ ``health`` がゼロ以下であるかどうか、つまりターゲットが"
"破壊されたことを確認します。"

msgid ""
"If the target has just been destroyed, then we disable the :ref:"
"`CollisionShape <class_CollisionShape>` by setting it's ``disabled`` "
"property to ``true``. We then make the ``Sphere_Target`` :ref:`MeshInstance "
"<class_MeshInstance>` invisible by setting the ``visible`` property to "
"``false``. We do this so the target can no longer effect the physics world "
"and so the non-broken target mesh is not visible."
msgstr ""
"ターゲットが破壊されたばかりの場合は、\\ ``disabled`` プロパティを ``true`` "
"に設定して :ref:`CollisionShape <class_CollisionShape>` を無効にします。次"
"に、\\ ``visible`` プロパティを ``false`` に設定して、\\ ``Sphere_Target`` :"
"ref:`MeshInstance <class_MeshInstance>` を非表示にします。これにより、ター"
"ゲットが物理世界に影響を与えなくなり、破損していないターゲットメッシュは表示"
"されなくなります。"

msgid ""
"After this the function then instances the ``RIGID_BODY_TARGET`` scene and "
"adds it as a child of the target. It then sets the ``global_transform`` of "
"the newly instanced scene, called ``clone``, to the ``global_transform`` of "
"the non-broken target. This makes it where the broken target starts at the "
"same position as the non-broken target with the same rotation and scale."
msgstr ""
"この後、関数は ``RIGID_BODY_TARGET`` シーンをインスタンス化し、それをターゲッ"
"トの子として追加します。次に、\\ ``clone`` と呼ばれる新しくインスタンス化され"
"たシーンの ``global_transform`` を、破損していないターゲットの "
"``global_transform`` に設定します。これにより、破損したターゲットは、破損して"
"いないターゲットと同じ位置から、同じ回転とスケールで開始します。"

msgid ""
"Then the function sets the ``destroyed`` variable to ``true`` so the target "
"knows it has been destroyed and calls the ``set_physics_process`` function "
"and passes ``true``. This will start executing the code in "
"``_physics_process`` so that after ``DESTROY_WAIT_TIME`` seconds have "
"passed, the sphere target will free/destroy itself."
msgstr ""
"次に、関数は ``destroyed`` 変数を ``true`` に設定するため、ターゲットはそれが"
"破棄されたことを認識し、\\ ``set_physics_process`` 関数を呼び出して ``true`` "
"を渡します。これは ``_physics_process`` のコードの実行を開始し、\\ "
"``DESTROY_WAIT_TIME`` 秒が経過した後、球体ターゲットはそれ自身を解放/破棄しま"
"す。"

msgid ""
"The function then gets the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node and calls the ``play`` function so it "
"plays its sound."
msgstr ""
"次に、関数は :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` ノードを"
"取得し、\\ ``play`` 関数を呼び出してサウンドを再生します。"

msgid ""
"Finally, the ``remove_sphere`` function is called in ``Game.gd``. To get "
"``Game.gd``, the code uses the scene tree and works its way from the root of "
"the scene tree to the root of the ``Game.tscn`` scene."
msgstr ""
"最後に、\\ ``remove_sphere`` 関数は ``Game.gd`` で呼び出されます。\\ ``Game."
"gd`` を取得するために、コードはシーンツリーを使用し、シーンツリーのルートか"
"ら ``Game.tscn`` シーンのルートに移動します。"

msgid "Adding the ``remove_sphere`` function to ``Game.gd``"
msgstr "``remove_sphere`` 関数を ``Game.gd`` に追加する"

msgid ""
"You may have noticed we are calling a function in ``Game.gd``, called "
"``remove_sphere``, that we have not defined yet. Open up ``Game.gd`` and add "
"the following additional class variables:"
msgstr ""
"まだ定義していない ``remove_sphere`` と呼ばれる ``Game.gd`` の関数を呼び出し"
"ていることに気づいたかもしれません。\\ ``Game.gd`` を開き、次の追加のクラス変"
"数を追加します:"

msgid ""
"``spheres_left``: The amount of sphere targets left in the world. In the "
"provided ``Game`` scene, there are ``10`` spheres, so that is the initial "
"value."
msgstr ""
"``spheres_left``: 世界に残っている球体ターゲットの量。提供された ``Game`` "
"シーンには、\\ ``10`` の球体があるため、これが初期値です。"

msgid ""
"``sphere_ui``: A reference to the sphere UI. We will use this later in the "
"tutorial to display the amount of spheres left in the world."
msgstr ""
"``sphere_ui``: 球体UIへの参照。チュートリアルの後半でこれを使用して、世界に"
"残っている球の量を表示します。"

msgid ""
"With these variables defined, we can now add the ``remove_sphere`` function. "
"Add the following code to ``Game.gd``:"
msgstr ""
"これらの変数を定義したら、\\ ``remove_sphere`` 関数を追加できます。次のコード"
"を ``Game.gd`` に追加します:"

msgid "Let's go through what this function does real quick:"
msgstr "この関数が実際に何をするのかを見てみましょう:"

msgid ""
"First, it removes one from the ``spheres_left`` variable. It then checks to "
"see if the ``sphere_ui`` variable is not equal to ``null``, and if it is not "
"equal to ``null`` it calls the ``update_ui`` function on ``sphere_ui``, "
"passing in the number of spheres as an argument to the function."
msgstr ""
"まず、\\ ``spheres_left`` 変数から1つ削除します。次に、\\ ``sphere_ui`` 変数"
"が ``null`` と等しくないかどうかを確認し、\\ ``null`` と等しくない場合は、\\ "
"``sphere_ui`` の ``update_ui`` 関数を、球体の数を引数として渡して呼び出しま"
"す。"

msgid "We will add the code for ``sphere_ui`` later in this tutorial!"
msgstr "このチュートリアルの後半で ``sphere_ui`` のコードを追加します！"

msgid ""
"Now the ``Sphere_Target`` is ready to be used, but we don't have any way to "
"destroy it. Let's fix that by adding some special :ref:`RigidBody "
"<class_RigidBody>`-based nodes that can damage the targets."
msgstr ""
"これで ``Sphere_Target`` を使用する準備ができましたが、それを破壊する方法はあ"
"りません。ターゲットを損傷させる事が可能な特別な :ref:`RigidBody "
"<class_RigidBody>` ベースのノードを追加して、これを修正しましょう。"

msgid "Adding a pistol"
msgstr "ピストルを追加する"

msgid ""
"Let's add a pistol as the first interactable :ref:`RigidBody "
"<class_RigidBody>` node. Open up ``Pistol.tscn``, which you can find in the "
"``Scenes`` folder."
msgstr ""
"最初の対話可能な :ref:`RigidBody <class_RigidBody>` ノードとしてピストルを追"
"加しましょう。\\ ``Scenes`` フォルダにある ``Pistol.tscn`` を開きます。"

msgid ""
"Let's quickly go over a few things of note in ``Pistol.tscn`` real quick "
"before we add the code."
msgstr ""
"コードを追加する前に ``Pistol.tscn`` のいくつかの注意事項を簡単に確認しましょ"
"う。"

msgid ""
"All of the nodes in ``Pistol.tscn`` expect the root node are rotated. This "
"is so the pistol is in the correct rotation relative to the VR controller "
"when it is picked up. The root node is a :ref:`RigidBody <class_RigidBody>` "
"node, which we need because we're going to use the "
"``VR_Interactable_Rigidbody`` class we created in the last part of this "
"tutorial series."
msgstr ""
"``Pistol.tscn`` のすべてのノードは、ルートノードが回転することを期待していま"
"す。これは、ピストルがピックアップされるときにVRコントローラーに対して正しい"
"回転になるようにするためです。ルートノードは :ref:`RigidBody "
"<class_RigidBody>` ノードです。このチュートリアルシリーズの最後のパートで作成"
"する ``VR_Interactable_Rigidbody`` クラスを使用するため、これが必要です。"

msgid ""
"There is a :ref:`MeshInstance <class_MeshInstance>` node called "
"``Pistol_Flash``, which is a simple mesh that we will be using to simulate "
"the muzzle flash on the end of the pistol's barrel. A :ref:`MeshInstance "
"<class_MeshInstance>` node called ``LaserSight`` is used to as a guide for "
"aiming the pistol, and it follows the direction of the :ref:`Raycast "
"<class_Raycast>` node, called ``Raycast``, that the pistol uses to detect if "
"its 'bullet' hit something. Finally, there is an :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node at the end of the pistol that we will use "
"to play the sound of the pistol firing."
msgstr ""
"``Pistol_Flash`` という名前の :ref:`MeshInstance <class_MeshInstance>` ノード"
"があります。これは、ピストルの銃身の端にある銃口フラッシュをシミュレートする"
"ために使用する単純なメッシュです。\\ ``LaserSight`` という :ref:"
"`MeshInstance <class_MeshInstance>` ノードは、ピストルを狙うためのガイドとし"
"て使用され、ピストルが「弾丸」が何かに当たったかどうかを検出するために使用す"
"る ``Raycast``と呼ばれる :ref:`Raycast <class_Raycast>` ノードの方向に従いま"
"す。最後に、ピストルの発射音を再生するために使用する :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` ノードがピストルの最後にあ"
"ります。"

msgid ""
"Feel free to look at the other parts of the scene if you want. Most of the "
"scene is fairly straightforward, with the major changes mentioned above. "
"Select the :ref:`RigidBody <class_RigidBody>` node called ``Pistol`` and "
"make a new script called ``Pistol.gd``. Add the following code:"
msgstr ""
"必要に応じて、シーンの他の部分を見てください。シーンのほとんどはかなり簡単"
"で、上記の大きな変更があります。\\ ``Pistol`` という :ref:`RigidBody "
"<class_RigidBody>` ノードを選択し、\\ ``Pistol.gd`` という新しいスクリプトを"
"作成します。次のコードを追加します:"

msgid "Explaining the pistol code"
msgstr "ピストルのコードの説明"

msgid ""
"First, notice how instead of ``extends RigidBody``, we instead have "
"``extends VR_Interactable_Rigidbody``. This makes it where the pistol script "
"extends the ``VR_Interactable_Rigidbody`` class so the VR controllers know "
"this object can be interacted with and that the functions defined in "
"``VR_Interactable_Rigidbody`` can be called when this object is held by a VR "
"controller."
msgstr ""
"まず、\\ ``extends RigidBody`` の代わりに、\\ ``extends "
"VR_Interactable_Rigidbody`` を使用することに注意してください。これにより、ピ"
"ストルスクリプトが ``VR_Interactable_Rigidbody`` クラスを拡張し、VRコントロー"
"ラーがこのオブジェクトとやり取りできることと、このオブジェクトがVRコントロー"
"ラーによって保持されているときに ``VR_Interactable_Rigidbody`` で定義された関"
"数を呼び出すことができるようになります。"

msgid "Next, let's look at the class variables:"
msgstr "次に、クラス変数を見てみましょう:"

msgid ""
"``flash_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that is used to simulate muzzle flash on the "
"pistol."
msgstr ""
"``flash_mesh``: ピストルの銃口フラッシュをシミュレートするために使用される :"
"ref:`MeshInstance <class_MeshInstance>` ノードを保持する変数。"

msgid ""
"``FLASH_TIME``: A constant to define how long the muzzle flash will be "
"visible. This will also define how fast the pistol can fire."
msgstr ""
"``FLASH_TIME``: 銃口フラッシュが見える時間を定義する定数。これは、ピストルが"
"発射できる速さも定義します。"

msgid ""
"``flash_timer``: A variable to hold the amount of time the muzzle flash has "
"been visible for."
msgstr "``flash_timer``: 銃口のフラッシュが見える時間を保持する変数。"

msgid ""
"``laser_sight_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that acts as the pistol's 'laser sight'."
msgstr ""
"``laser_sight_mesh``: ピストルの「レーザーサイト」として機能する :ref:"
"`MeshInstance <class_MeshInstance>` ノードを保持する変数。"

msgid ""
"``pistol_fire_sound``: A variable to hold the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node used for the pistol's firing sound."
msgstr ""
"``pistol_fire_sound``: ピストルの発射音に使用される :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` ノードを保持する変数。"

msgid ""
"``raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` node that "
"is used for calculating the bullet's position and normal when the pistol is "
"fired."
msgstr ""
"``raycast``: ピストルが発射されたときの弾丸の位置と法線の計算に使用される :"
"ref:`Raycast <class_Raycast>` ノードを保持する変数。"

msgid ""
"``BULLET_DAMAGE``: A constant to define the amount of damage a single bullet "
"from the pistol does."
msgstr ""
"``BULLET_DAMAGE``: ピストルからの1つの弾丸が与えるダメージの量を定義する定"
"数。"

msgid ""
"``COLLISION_FORCE``: A constant that defines the amount of force that is "
"applied to :ref:`RigidBody <class_RigidBody>` nodes when the pistol's bullet "
"collides."
msgstr ""
"``COLLISION_FORCE``: ピストルの弾丸が衝突したときに :ref:`RigidBody "
"<class_RigidBody>` ノードに適用される力の量を定義する定数。"

msgid ""
"This function gets the nodes and assigns them to their proper variables. For "
"the ``flash_mesh`` and ``laser_sight_mesh`` nodes, both have their "
"``visible`` property set to ``false`` so they are not visible initially."
msgstr ""
"この関数はノードを取得し、適切な変数に割り当てます。\\ ``flash_mesh`` および "
"``laser_sight_mesh`` ノードでは、両方とも ``visible`` プロパティが ``false`` "
"に設定されているため、最初は表示されません。"

msgid ""
"The ``_physics_process`` function first checks to see if the pistol's muzzle "
"flash is visible by checking if ``flash_timer`` is more than zero. If "
"``flash_timer`` is more than zero, then we remove time, ``delta`` from it. "
"Next we check if the ``flash_timer`` variable is zero or less now that we "
"removed ``delta`` from it. If it is, then the pistol muzzle flash timer just "
"finished and so we need to make ``flash_mesh`` invisible by setting it's "
"``visible`` property to ``false``."
msgstr ""
"``_physics_process`` 関数は、最初に ``flash_timer`` が0より大きいかどうかを"
"チェックすることで、ピストルの銃口フラッシュが見えるかどうかを確認します。\\ "
"``flash_timer`` が0より大きい場合、その時間から ``delta`` を減らします。次"
"に、\\ ``delta`` 分を減らしたので、\\ ``flash_timer`` 変数がゼロ以下かどうか"
"を確認します。そうである場合、ピストル銃口フラッシュタイマーはちょうど終了し"
"たので、\\ ``visible`` プロパティを ``false`` に設定して、\\ ``flash_mesh`` "
"を非表示にする必要があります。"

msgid "``interact`` function step-by-step explanation"
msgstr "``interact`` 関数のステップごとの説明"

msgid ""
"The interact function first checks to see if the pistol's muzzle flash is "
"invisible by checking to see if ``flash_timer`` is less than or equal to "
"zero. We do this so we can limit the rate of fire of the pistol to the "
"length of time the muzzle flash is visible, which is a simple solution for "
"limiting how fast the player can fire."
msgstr ""
"interact関数は、最初に ``flash_timer`` がゼロ以下であるかどうかを確認すること"
"で、ピストルの銃口フラッシュが見えないかどうかを確認します。これを行うこと"
"で、ピストルの発射速度を銃口フラッシュが見える時間の長さに制限できます。これ"
"は、プレイヤーが連続的に発射できる速さを制限するための簡単な解決策です。"

msgid ""
"If ``flash_timer`` is zero or less, we then set ``flash_timer`` to "
"``FLASH_TIME`` so there is a delay before the pistol can fire again. After "
"that we set ``flash_mesh.visible`` to ``true`` so the muzzle flash at the "
"end of the pistol is visible while ``flash_timer`` is more than zero."
msgstr ""
"``flash_timer`` がゼロ以下の場合、\\ ``flash_timer`` を ``FLASH_TIME`` に設定"
"して、ピストルが再び発砲できるようになるまでに遅延が生じるようにします。その"
"後、\\ ``flash_mesh.visible`` を ``true`` に設定して、\\ ``flash_timer`` がゼ"
"ロよりも大きいときにピストルの端の銃口フラッシュが見えるようにします。"

msgid ""
"Next we call the ``force_raycast_update`` function on the :ref:`Raycast "
"<class_Raycast>` node in ``raycast`` so that it gets the latest collision "
"info from the physics world. We then check if the ``raycast`` hit something "
"by checking if the ``is_colliding`` function is equal to ``true``."
msgstr ""
"次に、物理世界から最新の衝突情報を取得できるように、\\ ``raycast`` の :ref:"
"`Raycast <class_Raycast>` ノードで ``force_raycast_update`` 関数を呼び出しま"
"す。次に、\\ ``is_colliding`` 関数が ``true`` に等しいかどうかを確認すること"
"で、\\ ``raycast`` が何かにヒットするかどうかを確認します。"

msgid ""
"If the ``raycast`` hit something, then we get the :ref:`PhysicsBody "
"<class_PhysicsBody>` it collided with through the ``get_collider`` function. "
"We assign the hit :ref:`PhysicsBody <class_PhysicsBody>` to a variable "
"called ``body``."
msgstr ""
"``Raycast`` が何かに当たった場合、\\ ``get_collider`` 関数を介して衝突した :"
"ref:`PhysicsBody <class_PhysicsBody>` を取得します。ヒットした :ref:"
"`PhysicsBody <class_PhysicsBody>` を ``body`` という変数に割り当てます。"

msgid ""
"We then get the direction of the :ref:`Raycast <class_Raycast>` by getting "
"it's positive ``Z`` directional axis from the :ref:`Basis <class_Basis>` on "
"the ``raycast`` node's ``global_transform``. This will give us the direction "
"the raycast is pointing on the Z axis, which is the same direction as the "
"blue arrow on the :ref:`Spatial <class_Spatial>` gizmo when ``Local space "
"mode`` is enabled in the Godot editor. We store this direction in a variable "
"called ``direction_vector``."
msgstr ""
"次に、\\ ``raycast`` ノードの ``global_transform`` の :ref:`Basis "
"<class_Basis>` から正の ``Z`` 方向軸を取得することにより、\\ :ref:`Raycast "
"<class_Raycast>` の方向を取得します。 これにより、レイキャストがZ軸を指す方向"
"がわかります。これは、Godotエディタで ``ローカル空間モード`` が有効になってい"
"る場合、\\ :ref:`Spatial <class_Spatial>` ギズモの青い矢印が示す方向と同じで"
"す。この方向を ``direction_vector`` と呼ばれる変数に保存します。"

msgid ""
"Next we get the distance from the :ref:`Raycast <class_Raycast>` origin to "
"the :ref:`Raycast <class_Raycast>` collision point by getting the distance "
"from the global position, ``global_transform.origin`` of the ``raycast`` "
"node to the collision point of the :ref:`Raycast <class_Raycast>`, ``raycast."
"get_collision_point``, using the ``distance_to`` function. This will give us "
"the distance the :ref:`Raycast <class_Raycast>` traveled before it collided, "
"which we store in a variable called ``raycast_distance``."
msgstr ""
"次に、\\ ``distance_to`` 関数を使用して、\\ ``raycast`` ノードのグローバル位"
"置 ``global_transform.origin`` から :ref:`Raycast <class_Raycast>` の衝突点ま"
"での距離、\\ ``raycast.get_collision_point`` を取得することにより、\\ :ref:"
"`Raycast <class_Raycast>` の原点から :ref:`Raycast <class_Raycast>` の衝突点"
"までの距離を取得します。これにより、\\ :ref:`Raycast <class_Raycast>` が衝突"
"する前に移動した距離がわかり、\\ ``raycast_distance`` という変数に格納されま"
"す。"

msgid ""
"Then the code checks if the :ref:`PhysicsBody <class_PhysicsBody>`, "
"``body``, has a function/method called ``damage`` using the ``has_method`` "
"function. If the :ref:`PhysicsBody <class_PhysicsBody>` has a function/"
"method called ``damage``, then we call the ``damage`` function and pass "
"``BULLET_DAMAGE`` so it takes damage from the bullet colliding into it."
msgstr ""
"次に、コードは :ref:`PhysicsBody <class_PhysicsBody>` である ``body`` が "
"``has_method`` 関数を使用して ``damage`` という関数/メソッドを持っているかど"
"うかをチェックします。\\ :ref:`PhysicsBody <class_PhysicsBody>` に "
"``damage`` という関数/メソッドがある場合、\\ ``damage`` 関数を呼び出し、\\ "
"``BULLET_DAMAGE`` を渡して、衝突する弾丸からのダメージを受けます 。"

msgid ""
"Regardless of whether the :ref:`PhysicsBody <class_PhysicsBody>` has a "
"``damage`` function, we then check to see if ``body`` is a :ref:`RigidBody "
"<class_RigidBody>`-based node. If ``body`` is a :ref:`RigidBody "
"<class_RigidBody>`-based node, then we want to push it when the bullet "
"collides."
msgstr ""
":ref:`PhysicsBody <class_PhysicsBody>` に ``damage`` 関数があるかどうかに関係"
"なく、\\ ``body`` が :ref:`RigidBody <class_RigidBody>` ベースのノードである"
"かどうかを確認します。\\ ``body`` が :ref:`RigidBody <class_RigidBody>` ベー"
"スのノードである場合、弾丸が衝突したときに押し出します。"

msgid ""
"To calculate the amount of force applied, we simply take ``COLLISION_FORCE`` "
"and divide it by ``raycast_distance``, then we multiply the whole thing by "
"``body.mass``. We store this calculation in a variable called "
"``collision_force``. This will make collisions over a shorter distance apply "
"move force than those over longer distances, giving a *slightly* more "
"realistic collision response."
msgstr ""
"適用される力の量を計算するには、単に ``COLLISION_FORCE`` を取得し、それを "
"``raycast_distance`` で割ってから、全体に ``body.mass`` を掛けます。この計算"
"を ``collision_force`` と呼ばれる変数に保存します。これは、より短い距離での衝"
"突に、より長い距離での衝突よりも多くの移動力を適用し、\\ *心もち*\\ 現実的な"
"衝突応答を提供します。"

msgid ""
"We then push the :ref:`RigidBody <class_RigidBody>` using the "
"``apply_impulse`` function, where the position is a zero Vector3 so the "
"force is applied from the center, and the collision force is the "
"``collision_force`` variable we calculated."
msgstr ""
"次に、\\ ``apply_impulse`` 関数を使用して :ref:`RigidBody <class_RigidBody>` "
"を押し出します。位置はゼロVector3であるため、中心から力が適用され、衝突力は計"
"算した ``collision_force`` 変数になります。"

msgid ""
"Regardless of whether the ``raycast`` variable hit something or not, we then "
"play the pistol shot sound by calling the ``play`` function on the "
"``pistol_fire_sound`` variable."
msgstr ""
"``raycast`` 変数が何かに当たったかどうかに関係なく、\\ ``pistol_fire_sound`` "
"変数で ``play`` 関数を呼び出して ``pistol_fire_sound`` を再生します。"

msgid ""
"Finally, we check to see if the pistol is being held by a VR controller by "
"checking to see if the ``controller`` variable is not equal to ``null``. If "
"it is not equal to ``null``, we then set the ``rumble`` property of the VR "
"controller to ``0.25``, so there is a slight rumble when the pistol fires."
msgstr ""
"最後に、\\ ``controller`` 変数が ``null`` と等しくないかどうかを確認すること"
"で、ピストルがVRコントローラーに保持されているかどうかを確認します。\\ "
"``null`` と等しくない場合は、VRコントローラーの ``rumble`` プロパティを "
"``0.25`` に設定します。そのため、ピストルが発射されるときにわずかな振動が発生"
"します。"

msgid "``picked_up`` function step-by-step explanation"
msgstr "``picked_up`` 関数のステップごとの説明"

msgid ""
"This function simply makes the ``laser_sight_mesh`` :ref:`MeshInstance "
"<class_MeshInstance>` visible by setting the ``visible`` property to "
"``true``."
msgstr ""
"この関数は、単に ``visible`` プロパティを ``true`` に設定することで "
"``laser_sight_mesh`` :ref:`MeshInstance <class_MeshInstance>` を可視にしま"
"す。"

msgid "``dropped`` function step-by-step explanation"
msgstr "``dropped`` 関数のステップごとの説明"

msgid ""
"This function simply makes the ``laser_sight_mesh`` :ref:`MeshInstance "
"<class_MeshInstance>` invisible by setting the ``visible`` property to "
"``false``."
msgstr ""
"この関数は、単に ``visible`` プロパティを ``false`` に設定することで "
"``laser_sight_mesh`` :ref:`MeshInstance <class_MeshInstance>` を非表示にしま"
"す。"

msgid "Pistol finished"
msgstr "ピストル完成"

msgid ""
"That is all we need to do to have working pistols in the project! Go ahead "
"and run the project. If you climb up the stairs and grab the pistols, you "
"can fire them at the sphere targets in the scene using the trigger button on "
"the VR controller! If you fire at the targets long enough, they will break "
"into pieces."
msgstr ""
"プロジェクトで動作するピストルを使うために必要なことはこれだけです！ 先に進"
"み、プロジェクトを実行しましょう。階段を上ってピストルをつかむと、VRコント"
"ローラーのトリガーボタンを使用して、シーンの球体ターゲットにそれらを発射でき"
"ます！ ターゲットを十分に長く打ち続けた場合、それらはバラバラになります。"

msgid "Adding a shotgun"
msgstr "ショットガンを追加する"

msgid "Next let's add a shotgun to the VR project."
msgstr "次に、VRプロジェクトにショットガンを追加しましょう。"

msgid ""
"Adding a special shotgun :ref:`RigidBody <class_RigidBody>` should be fairly "
"straightforward, as almost everything with the shotgun is the same as the "
"pistol."
msgstr ""
"ショットガンのほとんどすべてがピストルと同じであるため、特別なショットガン :"
"ref:`RigidBody <class_RigidBody>` を追加するのはかなり簡単です。"

msgid ""
"Open up ``Shotgun.tscn``, which you can find in the ``Scenes`` folder and "
"take a look at the scene. Almost everything is the same as in ``Pistol."
"tscn``. The only thing that is different, beyond name changes, is that "
"instead of a single :ref:`Raycast <class_Raycast>`, there are five :ref:"
"`Raycast <class_Raycast>` nodes. This is because a shotgun generally fires "
"in a cone shape, so we are going to emulate that effect by having several :"
"ref:`Raycast <class_Raycast>` nodes that will rotate randomly in a cone "
"shape when the shotgun fires."
msgstr ""
"``Scenes`` フォルダにある ``Shotgun.tscn`` を開き、シーンを確認します。ほとん"
"どすべてが ``Pistol.tscn`` と同じです。唯一の違いは、名前の変更以外に、単一"
"の :ref:`Raycast <class_Raycast>` の代わりに、5つの :ref:`Raycast "
"<class_Raycast>` ノードがあることです。これは、ショットガンが通常コーン形状で"
"発砲するため、ショットガンが発砲するとコーン形状でランダムに回転する複数の :"
"ref:`Raycast <class_Raycast>` ノードを使用して、その効果をエミュレートするた"
"めです。"

msgid ""
"Outside of that, everything is more or less the same as ``Pistol.tscn``."
msgstr "それ以外は、すべてが ``Pistol.tscn`` とほぼ同じです。"

msgid ""
"Let's write the code for the shotgun. Select the :ref:`RigidBody "
"<class_RigidBody>` node called ``Shotgun`` and make a new script called "
"``Shotgun.gd``. Add the following code:"
msgstr ""
"ショットガンのコードを書きましょう。\\ ``Shotgun`` という :ref:`RigidBody "
"<class_RigidBody>` ノードを選択し、\\ ``Shotgun.gd`` という新しいスクリプトを"
"作成します。次のコードを追加します:"

msgid ""
"The majority of this code is exactly the same as the code for the pistol "
"with just a few *minor* changes that are primarily just different names. Due "
"to how similar these scripts are, let's just focus on the changes."
msgstr ""
"このコードの大部分はピストルのコードとまったく同じであり、主に名前が異なるだ"
"けの\\ *わずかな*\\ 変更があります。 これらのスクリプトは類似しているため、変"
"更点のみに注目しましょう。"

msgid "Explaining the shotgun code"
msgstr "ショットガンのコードの説明"

msgid ""
"Like with the pistol, the shotgun extends ``VR_Interactable_Rigidbody`` so "
"the VR controllers know that this object can be interacted with and what "
"functions are available."
msgstr ""
"ピストルと同様に、ショットガンは ``VR_Interactable_Rigidbody`` を拡張するた"
"め、VRコントローラーは、このオブジェクトとやり取りできること、および使用可能"
"な機能を認識します。"

msgid "There is only one new class variable:"
msgstr "新しいクラス変数は1つだけです:"

msgid ""
"``raycasts``: A variable to hold the node that has all of the :ref:`Raycast "
"<class_Raycast>` nodes as its children."
msgstr ""
"``raycasts``: すべての :ref:`Raycast <class_Raycast>` ノードを子として持つ"
"ノードを保持する変数。"

msgid ""
"The new class variable replaces the ``raycast`` variable from ``Pistol.gd``, "
"because with the shotgun we need to process multiple :ref:`Raycast "
"<class_Raycast>` nodes instead of just one. All of the other class variables "
"are the same as ``Pistol.gd`` and function the same way, some just are "
"renamed to be non-pistol specific."
msgstr ""
"新しいクラス変数は ``Pistol.gd`` の ``raycast`` 変数を置き換えます。ショット"
"ガンでは、1つではなく複数の :ref:`Raycast <class_Raycast>` ノードを処理する必"
"要があるためです。他のすべてのクラス変数は ``Pistol.gd`` と同じであり、同じよ"
"うに機能します。一部は、ピストル固有ではないように名前が変更されます。"

msgid ""
"The interact function first checks to see if the shotgun's muzzle flash is "
"invisible by checking to see if ``flash_timer`` is less than or equal to "
"zero. We do this so we can limit the rate of fire of the shotgun to the "
"length of time the muzzle flash is visible, which is a simple solution for "
"limiting how fast the player can fire."
msgstr ""
"interact(相互作用)関数は、最初に ``flash_timer`` がゼロ以下であるかどうかを確"
"認することにより、ショットガンの銃口フラッシュが見えないかどうかを確認しま"
"す。これにより、ショットガンの発射速度を銃口フラッシュが見える時間で制限でき"
"ます。これは、プレイヤーが連続発射できる速さを制限する簡単な解決策です。"

msgid ""
"If ``flash_timer`` is zero or less, we then set ``flash_timer`` to "
"``FLASH_TIME`` so there is a delay before the shotgun can fire again. After "
"that we set ``flash_mesh.visible`` to ``true`` so the muzzle flash at the "
"end of the shotgun is visible while ``flash_timer`` is more than zero."
msgstr ""
"``flash_timer`` がゼロ以下の場合、\\ ``flash_timer`` を ``FLASH_TIME`` に設定"
"し、ショットガンが再び発砲できるようになるまでに遅延が生じるようにします。そ"
"の後、\\ ``flash_mesh.visible`` を ``true`` に設定します。これにより、\\ "
"``flash_timer`` がゼロよりも大きい間、ショットガンの端の銃口フラッシュが見え"
"るようになります。"

msgid ""
"Next we go through each of the child nodes of the ``raycasts`` variable "
"using a for loop. This way the code will go through each of the :ref:"
"`Raycast <class_Raycast>` nodes that are children of the ``raycasts`` "
"variable."
msgstr ""
"次に、forループを使用して ``raycasts`` 変数の各子ノードを調べます。これによっ"
"て、コードは ``raycasts`` 変数の子である :ref:`Raycast <class_Raycast>` ノー"
"ドのそれぞれを処理します。"

msgid ""
"For each node, we check to see if ``raycast`` is *not* a :ref:`Raycast "
"<class_Raycast>` node. If the node is not a :ref:`Raycast <class_Raycast>` "
"node, we simply use ``continue`` to skip it."
msgstr ""
"各ノードについて、\\ ``raycast`` が :ref:`Raycast <class_Raycast>` ノードでは"
"ないかどうかを確認します。ノードが :ref:`Raycast <class_Raycast>` ノードでな"
"い場合は、単に ``continue`` を使用してスキップします。"

msgid ""
"Next we rotate the ``raycast`` node randomly around a small ``10`` degrees "
"cone by settings the ``rotation_degrees`` variable of the ``raycast`` to a "
"Vector3 where the X and Z axis are a random number from ``-10`` to ``10``. "
"This random number is selected using the ``rand_range`` function."
msgstr ""
"次に、\\ ``raycast`` の ``rotation_degrees`` 変数をVector3に設定して、\\ "
"``10`` 度の小さな円錐の周りに ``raycast`` ノードをランダムに回転させます。Xお"
"よびZ軸は ``-10`` 〜 ``10`` の乱数です。この乱数は ``rand_range`` 関数を使用"
"して選択します。"

msgid ""
"Then we call the ``force_raycast_update`` function on the :ref:`Raycast "
"<class_Raycast>` node in ``raycast`` so that it gets the latest collision "
"info from the physics world. We then check if the ``raycast`` hit something "
"by checking if the ``is_colliding`` function is equal to ``true``."
msgstr ""
"次に、物理世界から最新の衝突情報を取得するために、\\ ``raycast`` の :ref:"
"`Raycast <class_Raycast>` ノードで ``force_raycast_update`` 関数を呼び出しま"
"す。次に、\\ ``is_colliding`` 関数が ``true`` に等しいかどうかを確認すること"
"で、\\ ``raycast`` が何かにヒットするかどうかを確認します。"

msgid ""
"The rest of the code is exactly the same, but this process is repeated for "
"each :ref:`Raycast <class_Raycast>` node that is a child of the ``raycasts`` "
"variable."
msgstr ""
"残りのコードはまったく同じですが、このプロセスは ``raycasts`` 変数の子である"
"各 :ref:`Raycast <class_Raycast>` ノードに対して繰り返されます。"

msgid ""
"We then get the direction of the raycast by getting it's positive ``Z`` "
"directional axis from the :ref:`Basis <class_Basis>` on the ``raycast`` "
"node's ``global_transform``. This will give us the direction the raycast is "
"pointing on the Z axis, which is the same direction as the blue arrow on "
"the :ref:`Spatial <class_Spatial>` gizmo when ``Local space mode`` is "
"enabled in the Godot editor. We store this direction in a variable called "
"``direction_vector``."
msgstr ""
"次に、\\ ``raycast`` ノードの ``global_transform`` 上の :ref:`Basis "
"<class_Basis>` から正の ``Z`` 方向軸を取得することで、raycastの方向を取得しま"
"す。これにより、raycastがZ軸を指す方向がわかります。これは、Godotエディタで "
"``ローカル空間モード`` が有効になっている場合に、\\ :ref:`Spatial "
"<class_Spatial>` ギズモの青い矢印が示す方向と同じです 。この方向を "
"``direction_vector`` と呼ばれる変数に保存します。"

msgid ""
"Next we get the distance from the raycast origin to the raycast collision "
"point by getting the distance from the global position, ``global_transform."
"origin`` of the ``raycast`` node to the collision point of the raycast, "
"``raycast.get_collision_point``, using the ``distance_to`` function. This "
"will give us the distance the :ref:`Raycast <class_Raycast>` traveled before "
"it collided, which we store in a variable called ``raycast_distance``."
msgstr ""
"次に、\\ ``distance_to`` 関数を使用して、\\ ``raycast`` ノードのグローバル位"
"置である ``global_transform.origin`` からレイキャストの衝突点 ``raycast."
"get_collision_point`` までの距離を取得することにより、レイキャストの原点から"
"レイキャスト衝突点までの距離を取得します。 これにより、衝突する前に :ref:"
"`Raycast <class_Raycast>` が移動した距離が得られ、\\ `` raycast_distance`` と"
"いう変数に格納されます。"

msgid ""
"Once all of the :ref:`Raycast <class_Raycast>`\\s in the ``raycast`` "
"variable have been iterated over, we then play the shotgun shot sound by "
"calling the ``play`` function on the ``shotgun_fire_sound`` variable."
msgstr ""
"``raycast`` 変数内のすべての :ref: Raycast <class_Raycast>` が繰り返される"
"と、\\ ``shotgun_fire_sound`` 変数の ``play`` 関数を呼び出して、ショットガン"
"の発砲音を再生します。"

msgid ""
"Finally, we check to see if the shotgun is being held by a VR controller by "
"checking to see if the ``controller`` variable is not equal to ``null``. If "
"it is not equal to ``null``, we then set the ``rumble`` property of the VR "
"controller to ``0.25``, so there is a slight rumble when the shotgun fires."
msgstr ""
"最後に、\\ ``controller`` 変数が ``null`` と等しくないかどうかを確認すること"
"により、ショットガンがVRコントローラーに保持されているかどうかを確認しま"
"す。\\ ``null`` と等しくない場合、VRコントローラーの ``rumble`` プロパティを "
"``0.25`` に設定します。そのため、ショットガンの発砲時にわずかな振動が発生しま"
"す。"

msgid "Shotgun finished"
msgstr "ショットガン完成"

msgid ""
"Everything else is exactly the same as the pistol, with at most just some "
"simple name changes."
msgstr ""
"せいぜいいくつかの単純な名前の変更があるだけで、他のすべてはピストルとまった"
"く同じです。"

msgid ""
"Now the shotgun is finished! You can find the shotgun in the sample scene by "
"looking around the back of one of the walls (not in the building though!)."
msgstr ""
"これでショットガンが完成しました！サンプルシーンでショットガンを見つけるに"
"は、壁の1つ(建物ではなく！)の後ろを見てください。"

msgid "Adding a bomb"
msgstr "爆弾を追加する"

msgid ""
"Okay, let's add a different special :ref:`RigidBody <class_RigidBody>`. "
"Instead of adding something that shoots, let's add something we can throw - "
"a bomb!"
msgstr ""
"さて、別の特別な :ref:`RigidBody <class_RigidBody>` を追加しましょう。撃つも"
"のを追加する代わりに、投げることができるもの - 爆弾を追加しましょう！"

msgid "Open up ``Bomb.tscn``, which is in the ``Scenes`` folder."
msgstr "``Scenes`` フォルダにある ``Bomb.tscn`` を開きます。"

msgid ""
"The root node is a :ref:`RigidBody <class_RigidBody>` node that we'll be "
"extending to use ``VR_Interactable_Rigidbody``, which has a :ref:"
"`CollisionShape <class_CollisionShape>` like the other special :ref:"
"`RigidBody <class_RigidBody>` nodes we've made so far. Likewise, there is a :"
"ref:`MeshInstance <class_MeshInstance>` called ``Bomb`` that is used to "
"display the mesh for the bomb."
msgstr ""
"ルートノードは ``VR_Interactable_Rigidbody`` を使用するように拡張する :ref:"
"`RigidBody <class_RigidBody>` ノードです。これには、これまでに作成した他の特"
"別な :ref:`RigidBody <class_RigidBody>` ノードと同様の :ref:`CollisionShape "
"<class_CollisionShape>` があります。同様に、爆弾のメッシュを表示するために使"
"用される ``Bomb`` と呼ばれる :ref:`MeshInstance <class_MeshInstance>` があり"
"ます。"

msgid ""
"Then we have an :ref:`Area <class_Area>` node simply called ``Area`` that "
"has a large :ref:`CollisionShape <class_CollisionShape>` as its child. We'll "
"use this :ref:`Area <class_Area>` node to effect anything within it when the "
"bomb explodes. Essentially, this :ref:`Area <class_Area>` node will be the "
"blast radius for the bomb."
msgstr ""
"次に、単に ``Area`` と呼ばれる :ref:`Area <class_Area>` ノードがあり、その"
"ノードには大きな :ref:`CollisionShape <class_CollisionShape>` が子としてあり"
"ます。この :ref:`Area <class_Area>` ノードを使用して、爆弾が爆発したときにそ"
"の中にあるものに影響を与えます。基本的に、この :ref:`Area <class_Area>` ノー"
"ドは爆弾の爆発半径になります。"

msgid ""
"There is also a couple :ref:`Particles <class_Particles>` nodes. One of the :"
"ref:`Particles <class_Particles>` nodes are for the smoke coming out of the "
"bomb's fuse, while another is for the explosion. You can take a look at the :"
"ref:`ParticlesMaterial <class_ParticlesMaterial>` resources, which define "
"how the particles work, if you want. We will not be covering how the "
"particles work in this tutorial due to it being outside of the scope of this "
"tutorial."
msgstr ""
"いくつかの :ref:`Particles <class_Particles>` ノードもあります。\\ :ref:"
"`Particles <class_Particles>` ノードの1つは爆弾のヒューズから出る煙用で、もう"
"1つは爆発用です。必要に応じて、パーティクルの動作を定義する :ref:"
"`ParticlesMaterial <class_ParticlesMaterial>` リソースを確認できます。この"
"チュートリアルの範囲外であるため、このチュートリアルではパーティクルがどのよ"
"うに機能するかについてはカバーしません。"

msgid ""
"There is one thing with the :ref:`Particles <class_Particles>` nodes that we "
"need to make note of. If you select the ``Explosion_Particles`` node, you'll "
"find that its ``lifetime`` property is set to ``0.75`` and that the ``one "
"shot`` checkbox is enabled. This means that the particles will only play "
"once, and the particles will last for ``0.75`` seconds. We'll need to know "
"this so we can time the removal of the bomb with the end of the explosion :"
"ref:`Particles <class_Particles>`."
msgstr ""
":ref:`Particles <class_Particles>` ノードには、注意する必要があるものが1つあ"
"ります。\\ ``Explosion_Particles`` ノードを選択すると、\\ ``lifetime`` プロパ"
"ティが ``0.75`` に設定され、\\ ``one shot`` チェックボックスが有効になってい"
"ることがわかります。つまり、パーティクルは1回だけ再生され、パーティクルは "
"``0.75`` 秒間続きます。これを知っておくことで、爆発 :ref:`Particles "
"<class_Particles>` の終了時に爆弾の除去のタイミングを計ることができます。"

msgid ""
"Let's write the code for the bomb. Select the ``Bomb`` :ref:`RigidBody "
"<class_RigidBody>` node and make a new script called ``Bomb.gd``. Add the "
"following code:"
msgstr ""
"爆弾のコードを書きましょう。\\ ``Bomb`` :ref:`RigidBody <class_RigidBody>` "
"ノードを選択し、\\ ``Bomb.gd`` という新しいスクリプトを作成します。次のコード"
"を追加します:"

msgid "Explaining the bomb code"
msgstr "爆弾のコードの説明"

msgid ""
"Like with the other special :ref:`RigidBody <class_RigidBody>` nodes, the "
"bomb extends ``VR_Interactable_Rigidbody`` so the VR controllers know this "
"object can be interacted with and that the functions defined defined in "
"``VR_Interactable_Rigidbody`` can be called when this object is held by a VR "
"controller."
msgstr ""
"他の特別な :ref:`RigidBody <class_RigidBody>` ノードと同様に、爆弾は "
"``VR_Interactable_Rigidbody`` を拡張するため、VRコントローラーはこのオブジェ"
"クトが対話可能であり、\\ ``VR_Interactable_Rigidbody`` で定義された関数がこの"
"オブジェクトをVRコントローラーで保持しているときに呼び出すことができることを"
"認識します。"

msgid ""
"``bomb_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that is used for the non-exploded bomb."
msgstr ""
"``bomb_mesh``: 爆発しない爆弾に使用される :ref:`MeshInstance "
"<class_MeshInstance>` ノードを保持する変数。"

msgid ""
"``FUSE_TIME``: A constant to define how long the fuse will 'burn' before the "
"bomb explodes"
msgstr ""
"``FUSE_TIME``: 爆弾が爆発する前にヒューズが「燃える」時間を定義する定数"

msgid ""
"``fuse_timer``: A variable to hold the length of time that has passed since "
"the bomb's fuse has started to burn."
msgstr ""
"``fuse_timer``: 爆弾のヒューズが燃え始めてから経過した時間の長さを保持する変"
"数。"

msgid ""
"``explosion_area``: A variable to hold the :ref:`Area <class_Area>` node "
"used to detect objects within the bomb's explosion."
msgstr ""
"``explosion_area``: 爆弾の爆発内のオブジェクトを検出するために使用される :"
"ref:`Area <class_Area>` ノードを保持する変数。"

msgid ""
"``EXPLOSION_DAMAGE``: A constant to define how much damage is applied with "
"the bomb explodes."
msgstr ""
"``EXPLOSION_DAMAGE``: 爆弾の爆発でどの程度のダメージが適用されるかを定義する"
"定数。"

msgid ""
"``EXPLOSION_TIME``: A constant to define how long the bomb will last in the "
"scene after it explodes. This value should be the same as the ``lifetime`` "
"property of the explosion :ref:`Particles <class_Particles>` node."
msgstr ""
"``EXPLOSION_TIME``: 爆弾が爆発した後、シーン内で爆弾が持続する時間を定義する"
"定数。この値は、爆発 :ref:`Particles <class_Particles>` ノードの "
"``lifetime`` プロパティと同じでなければなりません。"

msgid ""
"``explosion_timer`` A variable to hold the length of time that has passed "
"since the bomb exploded."
msgstr ""
"``explosion_timer``: 爆弾が爆発してから経過した時間の長さを保持する変数。"

msgid "``exploded``: A variable to hold whether the bomb has exploded or not."
msgstr "``exploded``: 爆弾が爆発したかどうかを保持する変数。"

msgid ""
"``COLLISION_FORCE``: A constant that defines the amount of force that is "
"applied to :ref:`RigidBody <class_RigidBody>` nodes when the bomb explodes."
msgstr ""
"``COLLISION_FORCE``: 爆弾が爆発したときに :ref:`RigidBody <class_RigidBody>` "
"ノードに適用される力の量を定義する定数。"

msgid ""
"``fuse_particles``: A variable to hold a reference to the :ref:`Particles "
"<class_Particles>` node used for the bomb's fuse."
msgstr ""
"``fuse_particles``: 爆弾のヒューズに使用される :ref:`Particles "
"<class_Particles>` ノードへの参照を保持する変数。"

msgid ""
"``explosion_particles``: A variable to hold a reference to the :ref:"
"`Particles <class_Particles>` node used for the bomb's explosion."
msgstr ""
"``explosion_particles``: 爆弾の爆発に使用される :ref:`Particles "
"<class_Particles>` ノードへの参照を保持する変数。"

msgid ""
"``explosion_sound``: A variable to hold a reference to the :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node used for the "
"explosion sound."
msgstr ""
"``explosion_sound``: 爆発音に使用される :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` ノードへの参照を保持する変数。"

msgid ""
"The ``_ready`` function first gets all of the nodes from the bomb scene and "
"assigns them to their respective class variables for later use."
msgstr ""
"``_ready`` 関数は最初に爆弾シーンからすべてのノードを取得し、後で使用するため"
"にそれぞれのクラス変数に割り当てます。"

msgid ""
"Then we call ``set_physics_process`` and pass ``false`` so "
"``_physics_process`` is not executed. We do this because the code in "
"``_physics_process`` will start burning the fuse and exploding the bomb, "
"which we only want to do when the user interacts with the bomb. If we did "
"not disable ``_physics_process``, the bomb's fuse would start before the "
"user has a chance to get to the bomb."
msgstr ""
"それから ``set_physics_process`` を呼び出して ``false`` を渡すので "
"``_physics_process`` は実行されません。これを行う理由は、\\ "
"``_physics_process`` のコードがヒューズの燃焼と爆弾の爆発を開始するためです。"
"これは、ユーザーが爆弾と対話するときにのみ行いたい事です。\\ "
"``_physics_process`` を無効にしないと、ユーザーが爆弾に到達する前に爆弾の"
"ヒューズが起動します。"

msgid ""
"The ``_physics_process`` function first checks to see if ``fuse_timer`` is "
"less than ``FUSE_TIME``. If it is, then the bomb's fuse is still burning."
msgstr ""
"``_physics_process`` 関数はまず ``fuse_timer`` が ``FUSE_TIME`` よりも小さい"
"かどうかを確認します。もしそうなら、爆弾のヒューズはまだ燃えています。"

msgid ""
"If the bomb's fuse is still burning, we then add time, ``delta``, to the "
"``fuse_timer`` variable. We then check to see if ``fuse_timer`` is more than "
"or equal to ``FUSE_TIME`` now that we have added ``delta`` to it. If "
"``fuse_timer`` is more than or equal to ``FUSE_TIME``, then the fuse has "
"just finished and we need to explode the bomb."
msgstr ""
"爆弾のヒューズがまだ燃えている場合は、時間 ``delta`` を ``fuse_timer`` 変数に"
"追加します。次に、\\ ``delta`` を追加したので、\\ ``fuse_timer`` が "
"``FUSE_TIME`` 以上であるかどうかを確認します。\\ ``fuse_timer`` が "
"``FUSE_TIME`` 以上の場合、ヒューズはちょうど燃え終わったので、爆弾を爆発させ"
"る必要があります。"

msgid ""
"To explode the bomb, we first stop emitting particles for the fuse by "
"setting ``emitting`` to ``false`` on ``fuse_particles``. We then tell the "
"explosion :ref:`Particles <class_Particles>` node, ``explosion_particles``, "
"to emit all of its particle in a single shot by setting ``one_shot`` to "
"``true``. After that, we set ``emitting`` to ``true`` on "
"``explosion_particles`` so it looks like the bomb has exploded. To help make "
"it look like the bomb exploded, we hide the bomb :ref:`MeshInstance "
"<class_MeshInstance>` node by setting ``bomb_mesh.visible`` to ``false``."
msgstr ""
"爆弾を爆発させるには、まず ``fuse_particles`` で ``emitting`` を ``false`` に"
"設定して、ヒューズのパーティクルの放出を停止します。それから、爆発 :ref:"
"`Particles <class_Particles>` ノード ``explosion_particles`` の ``one_shot`` "
"を ``true`` に設定することで、単一ショットですべてのパーティクルを放出するよ"
"うに指示します。その後、\\ ``explosion_particles`` で ``emission`` を "
"``true`` に設定し、爆弾が爆発したようすを見せます。爆弾が爆発したように見せる"
"ために、\\ ``bomb_mesh.visible`` を ``false`` に設定して、爆弾 :ref:"
"`MeshInstance <class_MeshInstance>` ノードは非表示にします。"

msgid ""
"To keep the bomb from colliding with other objects in the physics world, we "
"set the ``collision_layer`` and ``collision_mask`` properties of the bomb to "
"``0``. We also change the :ref:`RigidBody <class_RigidBody>` mode to "
"``MODE_STATIC`` so the bomb :ref:`RigidBody <class_RigidBody>` does not move."
msgstr ""
"爆弾が物理世界の他のオブジェクトと衝突しないように、爆弾の "
"``collision_layer`` および ``collision_mask`` プロパティを ``0`` に設定しま"
"す。また、\\ :ref:`RigidBody <class_RigidBody>` モードを ``MODE_STATIC`` に変"
"更して、爆弾 :ref:`RigidBody <class_RigidBody>` が移動しないようにします。"

msgid ""
"Then we need to get all of the :ref:`PhysicsBody <class_PhysicsBody>` nodes "
"within the ``explosion_area`` node. To do this, we use the "
"``get_overlapping_bodies`` in a for loop. The ``get_overlapping_bodies`` "
"function will return an array of :ref:`PhysicsBody <class_PhysicsBody>` "
"nodes within the :ref:`Area <class_Area>` node, which is exactly what we are "
"looking for."
msgstr ""
"次に、\\ ``explosion_area`` ノード内のすべての :ref:`PhysicsBody "
"<class_PhysicsBody>` ノードを取得する必要があります。これを行うには、forルー"
"プで ``get_overlapping_bodies`` を使用します。\\ ``get_overlapping_bodies`` "
"関数は :ref:`Area <class_Area>` ノード内の :ref:`PhysicsBody "
"<class_PhysicsBody>` ノードの配列を返します。これはまさに探しているものです。"

msgid ""
"For each :ref:`PhysicsBody <class_PhysicsBody>` node, which we store in a "
"variable called ``body``, we check to see if it is equal to ``self``. We do "
"this so the bomb does not accidentally explode itself, as the "
"``explosion_area`` could potentially detect the ``Bomb`` :ref:`RigidBody "
"<class_RigidBody>` as a PhysicsBody within the explosion area."
msgstr ""
"``body`` と呼ばれる変数に格納する各 :ref:`PhysicsBody <class_PhysicsBody>` "
"ノードについて、それが ``self`` と等しいかどうかを確認します。これは、\\ "
"``explosion_area`` が ``Bomb`` :ref:`RigidBody <class_RigidBody>` 自体を爆発"
"領域内のPhysicsBodyとして検出する可能性があるため、爆弾が誤って爆発しないよう"
"にするためです。"

msgid ""
"If the :ref:`PhysicsBody <class_PhysicsBody>` node, ``body``, is not the "
"bomb, then we first check to see if the :ref:`PhysicsBody "
"<class_PhysicsBody>` node has a function called ``damage``. If the :ref:"
"`PhysicsBody <class_PhysicsBody>` node has a function called ``damage``, we "
"call it and pass ``EXPLOSION_DAMAGE`` to it so it takes damage from the "
"explosion."
msgstr ""
":ref:`PhysicsBody <class_PhysicsBody>` ノード ``body`` が爆弾でない場合、ま"
"ず :ref:`PhysicsBody <class_PhysicsBody>` ノードに ``damage`` という関数があ"
"るかどうかを確認します。\\ :ref:`PhysicsBody <class_PhysicsBody>` ノードに "
"``damage`` という関数がある場合、それを呼び出して ``EXPLOSION_DAMAGE`` を渡"
"し、爆発によるダメージを受けます。"

msgid ""
"Next we check to see if the :ref:`PhysicsBody <class_PhysicsBody>` node is "
"a :ref:`RigidBody <class_RigidBody>`. If ``body`` is a :ref:`RigidBody "
"<class_RigidBody>`, we want to move it when the bomb explodes."
msgstr ""
"次に、\\ :ref:`PhysicsBody <class_PhysicsBody>` ノードが :ref:`RigidBody "
"<class_RigidBody>` であるかどうかを確認します。\\ ``body`` が :ref:"
"`RigidBody <class_RigidBody>` の場合、爆弾が爆発したときに移動します。"

msgid ""
"To move the :ref:`RigidBody <class_RigidBody>` node when the bomb explodes, "
"we first need to calculate the direction from the bomb to the :ref:"
"`RigidBody <class_RigidBody>` node. To do this we subtract the global "
"position of the bomb, ``global_transform.origin`` from the global position "
"of the :ref:`RigidBody <class_RigidBody>`. This will give us a :ref:`Vector3 "
"<class_Vector3>` that points from the bomb to the :ref:`RigidBody "
"<class_RigidBody>` node. We store this :ref:`Vector3 <class_Vector3>` in a "
"variable called ``direction_vector``."
msgstr ""
"爆弾が爆発したときに :ref:`RigidBody <class_RigidBody>` ノードを移動するに"
"は、まず爆弾から :ref:`RigidBody <class_RigidBody>` ノードへの方向を計算する"
"必要があります。これを行うには、爆弾のグローバル位置 ``global_transform."
"origin`` を :ref:`RigidBody <class_RigidBody>` のグローバル位置から減算しま"
"す。これにより、爆弾から :ref:`RigidBody <class_RigidBody>` ノードを指す :"
"ref:`Vector3 <class_Vector3>` が得られます。これを :ref:`Vector3 "
"<class_Vector3>` を ``direction_vector`` という変数に保存します。"

msgid ""
"We then calculate the distance the :ref:`RigidBody <class_RigidBody>` is "
"from the bomb by using the ``length`` function on ``direction_vector``. We "
"store the distance in a variable called ``bomb_distance``."
msgstr ""
"次に、\\ ``direction_vector`` の ``length`` 関数を使用して、\\ :ref:"
"`RigidBody <class_RigidBody>` が爆弾からの距離を計算します。距離を "
"``bomb_distance`` と呼ばれる変数に保存します。"

msgid ""
"We then calculate the amount of force the bomb will be applied to the :ref:"
"`RigidBody <class_RigidBody>` node when the bomb explodes by dividing "
"``COLLISION_FORCE`` by ``bomb_distance``, and multiplying that by "
"``collision_force``. This will make it so if the :ref:`RigidBody "
"<class_RigidBody>` node is closer to the bomb, it will be pushed farther."
msgstr ""
"次に、\\ ``COLLISION_FORCE`` を ``bomb_distance`` で割って "
"``collision_force`` を掛けることで、爆弾が爆発したときに爆弾が :ref:"
"`RigidBody <class_RigidBody>` ノードに適用される力の量を計算します。これによ"
"り、\\ :ref:`RigidBody <class_RigidBody>` ノードが爆弾により近い場合、より遠"
"くに押し出されます。"

msgid ""
"Finally, we push the :ref:`RigidBody <class_RigidBody>` node using the "
"``apply_impulse`` function, with a :ref:`Vector3 <class_Vector3>` position "
"of zero and ``collision_force`` multiplied by ``direction_vector."
"normalized`` as the force. This will send the :ref:`RigidBody "
"<class_RigidBody>` node flying when the bomb explodes."
msgstr ""
"最後に、\\ ``apply_impulse`` 関数を使用して :ref:`RigidBody "
"<class_RigidBody>` ノードを押し出します。\\ ``Vector3`` の位置をゼロにし、\\ "
"``collision_force`` に ``direction_vector.normalized`` を力として掛けます。こ"
"れにより、爆弾が爆発したときに ``RigidBody`` ノードが飛んで行きます。"

msgid ""
"After we have looped through all of the :ref:`PhysicsBody "
"<class_PhysicsBody>` nodes within the ``explosion_area``, we set the "
"``exploded`` variable to ``true`` so the code knows the bomb exploded and "
"call ``play`` on ``explosion_sound`` so the sound of an explosion is played."
msgstr ""
"``explosion_area`` 内のすべての :ref:`PhysicsBody <class_PhysicsBody>` ノード"
"をループした後、\\ ``exploded`` 変数を ``true`` に設定し、コードが爆弾を認識"
"して呼び出す``explosion_sound`` で ``play`` を実行すると、爆発の音が再生され"
"ます。"

msgid ""
"Alright, the next section of code starts by first checking if ``exploded`` "
"is equal to ``true``."
msgstr ""
"さて、コードの次のセクションは、まず ``exploded`` が ``true`` に等しいかどう"
"かをチェックすることから始まります。"

msgid ""
"If ``exploded`` is equal to ``true``, then that means the bomb is waiting "
"for the explosion particles to finish before it frees/destroys itself. We "
"add time, ``delta``, to ``explosion_timer`` so we can track how long it has "
"been since the bomb has exploded."
msgstr ""
"``exploded`` が ``true`` に等しい場合、爆弾は爆発パーティクルが終了するのを"
"待ってから、それ自体を解放/破棄します。爆弾が爆発してからの時間を追跡できるよ"
"うに、\\ ``explosion_timer`` に時間 ``delta`` を加算します。"

msgid ""
"If ``explosion_timer`` is greater than or equal to ``EXPLOSION_TIME`` after "
"we added ``delta``, then the explosion timer just finished."
msgstr ""
"``delta`` を追加した後に ``explosion_timer`` が ``EXPLOSION_TIME`` 以上である"
"場合は、ちょうど爆発タイマーが終了しています。"

msgid ""
"If the explosion timer just finished, we set ``explosion_area.monitoring`` "
"to ``false``. The reason we do this is because there was a bug that would "
"print an error when you freed/deleted an :ref:`Area <class_Area>` node when "
"the ``monitoring`` property was true. To make sure this doesn't happen, we "
"simply set ``monitoring`` to false on ``explosion_area``."
msgstr ""
"爆発タイマーがちょうど終了した場合、\\ ``explosion_area.monitoring`` を "
"``false`` に設定します。これを行う理由は、\\ ``monitoring`` プロパティがtrue"
"のときに :ref:`Area <class_Area>` ノードを解放または削除したときにエラーを出"
"力するバグがあったためです。これが起こらないようにするには、\\ "
"``explosion_area`` で ``monitoring`` をfalseに設定するだけです。"

msgid ""
"Next we check to see if the bomb is being held by a VR controller by "
"checking to see if the ``controller`` variable is not equal to ``null``. If "
"the bomb is being held by a VR controller, we set the ``held_object`` "
"property of the VR controller, ``controller``, to ``null``. Because the VR "
"controller is no longer holding anything, we make the VR controller's hand "
"mesh visible by setting ``controller.hand_mesh.visible`` to ``true``. Then "
"we check to see if the VR controller grab mode is ``RAYCAST``, and if it is "
"we set ``controller.grab_raycast.visible`` to ``true`` so the 'laser sight' "
"for the grab raycast is visible."
msgstr ""
"次に、\\ ``controller`` 変数が ``null`` と等しくないかどうかを確認することに"
"より、爆弾がVRコントローラーによって保持されているかどうかを確認します。爆弾"
"がVRコントローラーによって保持されている場合、VRコントローラーの "
"``held_object`` プロパティ ``controller`` を ``null`` に設定します。VRコント"
"ローラーはもはや何も保持していないため、\\ ``controller.hand_mesh.visible`` "
"を ``true`` に設定することで、VRコントローラーのハンドメッシュを表示します。"
"次に、VRコントローラーのグラブモードが ``RAYCAST`` であるかどうかを確認"
"し、\\ ``controller.grab_raycast.visible`` を ``true`` に設定して、grab "
"raycastの ``レーザーサイト`` を可視化します。"

msgid ""
"Finally, regardless if the bomb is being held by a VR controller or not, we "
"call ``queue_free`` so the bomb scene is freed/removed from the scene."
msgstr ""
"最後に、爆弾がVRコントローラーに保持されているかどうかに関係なく、\\ "
"``queue_free`` を呼び出して、爆弾のシーンをシーンから解放/削除します。"

msgid ""
"First the ``interact`` function calls ``set_physics_process`` and passes "
"``true`` so the code in ``_physics_process`` starts executing. This will "
"start the bomb's fuse and eventually lead to the bomb exploding."
msgstr ""
"最初に ``interact`` 関数が ``set_physics_process`` を呼び出して ``true`` を渡"
"すので、\\ ``_physics_process`` のコードが実行を開始します。これは爆弾の"
"ヒューズを開始し、最終的に爆弾の爆発につながります。"

msgid ""
"Finally, we start the fuse particles by setting ``fuse_particles.visible`` "
"to ``true``."
msgstr ""
"最後に、\\ ``fuse_particles.visible`` を ``true`` に設定して、ヒューズパー"
"ティクルを開始します。"

msgid "Bomb finished"
msgstr "爆弾完成"

msgid ""
"Now the bomb is ready to go! You can find the bombs in the orange building."
msgstr ""
"これで爆弾の準備ができました！オレンジ色の建物で爆弾を見つけることができま"
"す。"

msgid ""
"Because of how we are calculating the VR controller's velocity, it is "
"easiest to throw the bombs using a thrusting-like motion instead of a more "
"natural throwing-like motion. The smooth curve of a throwing-like motion is "
"harder to track with the code we are using for calculating the velocity of "
"the VR controllers, so it does not always work correctly and can lead "
"inaccurately calculated velocities."
msgstr ""
"VRコントローラーの速度の計算方法により、より自然な投げのような動きの代わり"
"に、突きのような動きを使用して爆弾を投げるのが最も簡単です。 VRコントローラー"
"の速度を計算するために使用しているコードでは、投げのような動きの滑らかな曲線"
"を追跡するのが難しいため、常に正しく動作するとは限らず、不正確に計算された速"
"度につながる可能性があります。"

msgid "Adding a sword"
msgstr "剣を追加する"

msgid ""
"Let's add one last special :ref:`RigidBody <class_RigidBody>`-based node "
"that can destroy targets. Let's add a sword so we can slice through the "
"targets!"
msgstr ""
"最後に、ターゲットを破壊できる :ref:`RigidBody <class_RigidBody>` ベースの特"
"別なノードを1つ追加しましょう。ターゲットをスライスできるように、剣を追加しま"
"しょう！"

msgid "Open up ``Sword.tscn``, which you can find in the ``Scenes`` folder."
msgstr "``Scenes`` フォルダにある ``Sword.tscn`` を開きます。"

msgid ""
"There is not a whole lot going on here. All of the child nodes of the root "
"``Sword`` :ref:`RigidBody <class_RigidBody>` node are rotated to they are "
"positioned correctly when the VR controller picks them up, there is a :ref:"
"`MeshInstance <class_MeshInstance>` node for displaying the sword, and there "
"is an :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node that holds "
"a sound for the sword colliding with something."
msgstr ""
"ここではあまり多くのことはありません。ルート ``Sword`` のすべての子ノード :"
"ref:`RigidBody <class_RigidBody>` ノードは、VRコントローラーがそれらを選択し"
"たときに正しく配置されるように回転し、\\ :ref:`MeshInstance "
"<class_MeshInstance>` があります剣を表示するためのノード、および何かと衝突す"
"る剣の音を保持する :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` "
"ノードがあります。"

msgid ""
"There is one thing that is slightly different though. There is a :ref:"
"`KinematicBody <class_KinematicBody>` node called ``Damage_Body``. If you "
"take a look at it, you'll find that it is not on any collision layers, and "
"is instead only on a single collision mask. This is so the :ref:"
"`KinematicBody <class_KinematicBody>` will not effect other :ref:"
"`PhysicsBody <class_PhysicsBody>` nodes in the scene, but it will still be "
"effected by :ref:`PhysicsBody <class_PhysicsBody>` nodes."
msgstr ""
"ただし、少し異なる点が1つあります。\\ ``Damage_Body`` と呼ばれる :ref:"
"`KinematicBody <class_KinematicBody>` ノードがあります。見てみると、コリジョ"
"ンレイヤー上ではなく、単一のコリジョンマスク上にあることがわかります。これ"
"は、\\ :ref:`KinematicBody <class_KinematicBody>` がシーン内の他の :ref:"
"`PhysicsBody <class_PhysicsBody>` ノードに影響を与えることはありません"
"が、\\ :ref:`PhysicsBody <class_PhysicsBody>` ノードの影響は引き続き受けま"
"す。"

msgid ""
"We are going to use the ``Damage_Body`` :ref:`KinematicBody "
"<class_KinematicBody>` node to detect the collision point and normal when "
"the sword collides with something in the scene."
msgstr ""
"``Damage_Body`` :ref:`KinematicBody <class_KinematicBody>` ノードを使用して、"
"剣がシーン内の何かと衝突したときの衝突点と法線を検出します。"

#, fuzzy
msgid ""
"While this is perhaps not the best way of getting the collision information "
"from a performance point of view, it does give us a lot of information we "
"can use for post-processing! Using a :ref:`KinematicBody "
"<class_KinematicBody>` this way means we can detect exactly where the sword "
"collided with other :ref:`PhysicsBody <class_PhysicsBody>` nodes."
msgstr ""
"これはおそらくパフォーマンスの観点から衝突情報を取得する最良の方法ではありま"
"せんが、後処理に使用できる多くの情報を提供します！この方法で :ref:"
"`KinematicBody <class_KinematicBody>` を使用すると、剣が他の :ref:"
"`PhysicsBody <class_PhysicsBody>` ノードと衝突した場所を正確に検出できます。"

msgid ""
"That is really the only thing note worthy about the sword scene. Select the "
"``Sword`` :ref:`RigidBody <class_RigidBody>` node and make a new script "
"called ``Sword.gd``. Add the following code:"
msgstr ""
"それは本当に剣のシーンについてふさわしい唯一の注意事項です。\\ ``Sword`` :"
"ref:`RigidBody <class_RigidBody>` ノードを選択し、\\ ``Sword.gd`` という新し"
"いスクリプトを作成します。次のコードを追加します:"

msgid "Let's go over how this script works!"
msgstr "このスクリプトの仕組みを見ていきましょう！"

msgid "Explaining the sword code"
msgstr "剣のコードの説明"

msgid ""
"Like with the other special :ref:`RigidBody <class_RigidBody>` nodes, the "
"sword extends ``VR_Interactable_Rigidbody`` so the VR controllers know this "
"object can be interacted with and that the functions defined defined in "
"``VR_Interactable_Rigidbody`` can be called when this object is held by a VR "
"controller."
msgstr ""
"他の特別な :ref:`RigidBody <class_RigidBody>` ノードと同様に、剣は "
"``VR_Interactable_Rigidbody`` を拡張するため、VRコントローラーはこのオブジェ"
"クトが対話可能であり、\\ ``VR_Interactable_Rigidbody`` で定義された関数がこの"
"オブジェクトがVRコントローラーに保持されているときに呼び出せることを認識しま"
"す。"

#, fuzzy
msgid ""
"``SWORD_DAMAGE``: A constant to define the amount of damage the sword does. "
"This damage is applied to every object in the sword on every "
"``_physics_process`` call"
msgstr ""
"``SWORD_DAMAGE``: 剣が与えるダメージの量を定義する定数。このダメージは、すべ"
"ての ``_physics_process`` 呼び出しで剣のすべてのオブジェクトに適用されます"

msgid ""
"``COLLISION_FORCE``: A constant that defines the amount of force applied to :"
"ref:`RigidBody <class_RigidBody>` nodes when the sword collides with a :ref:"
"`PhysicsBody <class_PhysicsBody>`."
msgstr ""
"``COLLISION_FORCE``: 剣が :ref:`PhysicsBody <class_PhysicsBody>` と衝突したと"
"きに :ref:`RigidBody <class_RigidBody>` ノードに適用される力の量を定義する定"
"数。"

msgid ""
"``damage_body``: A variable to hold the :ref:`KinematicBody "
"<class_KinematicBody>` node used to detect whether the sword is stabbing a :"
"ref:`PhysicsBody <class_PhysicsBody>` node or not."
msgstr ""
"``damage_body``: 剣が :ref:`PhysicsBody <class_PhysicsBody>` ノードを突き刺し"
"ているかどうかを検出するために使用される :ref:`KinematicBody "
"<class_KinematicBody>` ノードを保持する変数。"

msgid ""
"``sword_noise``: A variable to hold the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node used to play a sound when the sword "
"collides with something."
msgstr ""
"``sword_noise``: 剣が何かと衝突したときにサウンドを再生するために使用される :"
"ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` ノードを保持する変数。"

msgid ""
"All we are doing in the ``_ready`` function is getting the ``Damage_Body`` :"
"ref:`KinematicBody <class_KinematicBody>` node and assigning it to "
"``damage_body``. Because we do not want the sword to detect a collision with "
"the root :ref:`RigidBody <class_RigidBody>` node of the sword, we call "
"``add_collision_exception_with`` on ``damage_body`` and pass ``self`` so the "
"sword will not be detected."
msgstr ""
"``_ready`` 関数で行っているのは、\\ ``Damage_Body`` :ref:`KinematicBody "
"<class_KinematicBody>` ノードを取得し、それを ``damage_body`` に割り当てるこ"
"とです。剣が剣のルート :ref:`RigidBody <class_RigidBody>` ノードとの衝突を検"
"出しないようにするため、\\ ``damage_body`` で "
"``add_collision_exception_with`` を呼び出して ``self`` を渡します。これで剣は"
"検出されません。"

msgid ""
"Finally, we get the :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` "
"node for the sword collision sound and apply it to the ``sword_noise`` "
"variable."
msgstr ""
"最後に、剣衝突音の :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` "
"ノードを取得し、それを ``sword_noise`` 変数に適用します。"

msgid ""
"First we need to determine whether the sword is colliding with something or "
"not. To do this, we use the ``move_and_collide`` function of the "
"``damage_body`` node. Unlike how ``move_and_collide`` is normally used, we "
"are not passing a velocity and instead are passing an empty :ref:`Vector3 "
"<class_Vector3>`. Because we do not want the ``damage_body`` node to move, "
"we set the ``test_only`` argument (the fourth argument) as ``true`` so the :"
"ref:`KinematicBody <class_KinematicBody>` generates collision info without "
"actually causing any collisions within the collision world."
msgstr ""
"まず、剣が何かと衝突しているかどうかを判断する必要があります。これを行うに"
"は、\\ ``damage_body`` ノードの ``move_and_collide`` 関数を使用します。\\ "
"``move_and_collide`` の通常の使用方法とは異なり、速度を渡すのではなく、空の :"
"ref:`Vector3 <class_Vector3>` を渡します。\\ ``damage_body`` ノードを移動させ"
"たくないので、\\ ``test_only`` 引数(4番目の引数)を ``true`` に設定して、\\ :"
"ref:`KinematicBody <class_KinematicBody>` が実際に衝突ワールド内で衝突を引き"
"起こすことなく衝突情報を生成するようにします。"

msgid ""
"The ``move_and_collide`` function will return a :ref:`KinematicCollision "
"<class_KinematicCollision>` class that has all of the information we need "
"for detecting collisions on the sword. We assign the return value of "
"``move_and_collide`` to a variable called ``collision_results``."
msgstr ""
"``move_and_collide`` 関数は、剣の衝突を検出するために必要なすべての情報を含"
"む :ref:`KinematicCollision <class_KinematicCollision>` クラスを返します。\\ "
"``move_and_collide`` の戻り値を ``collision_results`` という変数に割り当てま"
"す。"

msgid ""
"Next we check to see if ``collision_results`` is not equal to ``null``. If "
"``collision_results`` is not equal to ``null``, then we know that the sword "
"has collided with something."
msgstr ""
"次に、\\ ``collision_results`` が ``null`` と等しくないかどうかを確認しま"
"す。\\ ``collision_results`` が ``null`` と等しくない場合、剣が何かと衝突して"
"いることがわかります。"

msgid ""
"We then check to see if the :ref:`PhysicsBody <class_PhysicsBody>` the sword "
"collided with has a function/method called ``damage`` using the "
"``has_method`` function. If the :ref:`PhysicsBody <class_PhysicsBody>` has a "
"function called ``damage_body``, we call it and pass the amount of damage "
"the sword does, ``SWORD_DAMAGE``, to it."
msgstr ""
"次に、剣が衝突した :ref:`PhysicsBody <class_PhysicsBody>` が ``has_method`` "
"関数を使用して ``damage`` という関数/メソッドを持っているかどうかを確認しま"
"す。\\ :ref:`PhysicsBody <class_PhysicsBody>` に ``damage_body`` という関数が"
"ある場合、それを呼び出して、剣が与えるダメージ量 ``SWORD_DAMAGE`` を渡しま"
"す。"

msgid ""
"Next we check to see if the :ref:`PhysicsBody <class_PhysicsBody>` the sword "
"collided with is a :ref:`RigidBody <class_RigidBody>`. If what the sword "
"collided with is a :ref:`RigidBody <class_RigidBody>` node, we then check to "
"see if the sword is being held by a VR controller or not by checking to see "
"if ``controller`` is equal to ``null``."
msgstr ""
"次に、剣が衝突した :ref:`PhysicsBody <class_PhysicsBody>` が :ref:`RigidBody "
"<class_RigidBody>` であるかどうかを確認します。剣が衝突したものが :ref:"
"`RigidBody <class_RigidBody>` ノードである場合、\\ ``controller`` が "
"``null`` に等しいかどうかを確認することで、剣がVRコントローラーに保持されてい"
"るかどうかを確認します。"

msgid ""
"If the sword is not being held by a VR controller, ``controller`` is equal "
"to ``null``, then we move the :ref:`RigidBody <class_RigidBody>` node the "
"sword collided with using the ``apply_impulse`` function. For the "
"``position`` of the ``apply_impulse`` function, we use "
"``collision_position`` variable stored within the :ref:`KinematicCollision "
"<class_KinematicCollision>` class in ``collision_results``. For the "
"``velocity`` of the ``apply_impulse`` function, we use the "
"``collision_normal`` multiplied by the ``linear_velocity`` of the sword's :"
"ref:`RigidBody <class_RigidBody>` node multiplied by ``COLLISION_FORCE``."
msgstr ""
"剣がVRコントローラーによって保持されていない場合、\\ ``controller`` は "
"``null`` に等しいため、剣が ``apply_impulse`` 関数を使用して衝突した :ref:"
"`RigidBody <class_RigidBody>` ノードを移動します。\\ ``apply_impulse`` 関数"
"の ``position`` には、\\ ``collision_results`` の :ref:`KinematicCollision "
"<class_KinematicCollision>` クラス内に格納されている ``collision_position`` "
"変数を使用します。\\ ``apply_impulse`` 関数の速度については、\\ "
"``collision_normal`` に剣の :ref:`RigidBody <class_RigidBody>` ノードの "
"``linear_velocity`` と ``COLLISION_FORCE`` を掛けた値を使用します。"

msgid ""
"If the sword is being held by a VR controller, ``controller`` is not equal "
"to ``null``, then we move the :ref:`RigidBody <class_RigidBody>` node the "
"sword collided with using the ``apply_impulse`` function. For the "
"``position`` of the ``apply_impulse`` function, we use "
"``collision_position`` variable stored within the :ref:`KinematicCollision "
"<class_KinematicCollision>` class in ``collision_results``. For the "
"``velocity`` of the ``apply_impulse`` function, we use the "
"``collision_normal`` multiplied by the VR controller's velocity multiplied "
"by ``COLLISION_FORCE``."
msgstr ""
"剣がVRコントローラーによって保持されている場合、つまり\\ ``controller`` が "
"``null`` と等しくない場合、剣が　 ``apply_impulse`` 関数を使用して衝突した :"
"ref:`RigidBody <class_RigidBody>` ノードを移動します`。\\ ``apply_impulse`` "
"関数の ``position`` には、\\ ``collision_results`` の :ref:"
"`KinematicCollision <class_KinematicCollision>` クラス内に格納されている "
"``collision_position`` 変数を使用します。\\ ``apply_impulse`` 関数の "
"``velocity`` には、\\ ``collision_normal`` にVRコントローラーの速度を掛け、さ"
"らに\\ ``COLLISION_FORCE`` を掛けます。"

msgid ""
"Finally, regardless of whether the :ref:`PhysicsBody <class_PhysicsBody>` is "
"a :ref:`RigidBody <class_RigidBody>` or not, we play the sound of the sword "
"colliding with something by calling ``play`` on ``sword_noise``."
msgstr ""
"最後に、\\ :ref:`PhysicsBody <class_PhysicsBody>` が :ref:`RigidBody "
"<class_RigidBody>` であるかどうかに関係なく、\\ ``sword_noise`` で ``play`` "
"を呼び出すことで、何かと衝突する剣の音を再生します。"

msgid "Sword finished"
msgstr "完成した剣"

msgid ""
"With that done, you can now slice through the targets! You can find the "
"sword in the corner in between the shotgun and the pistol."
msgstr ""
"これで、ターゲットをスライスできます！ショットガンとピストルの間の隅にある剣"
"を見つけることができます。"

msgid "Updating the target UI"
msgstr "ターゲットUIの更新"

msgid "Let's update the UI as the sphere targets are destroyed."
msgstr "球体ターゲットが破壊されるとUIを更新しましょう。"

msgid ""
"Open up ``Main_VR_GUI.tscn``, which you can find in the ``Scenes`` folder. "
"Feel free to look at how the scene is setup if you want, but in an effort to "
"keep this tutorial from becoming too long, we will not be covering the scene "
"setup in this tutorial."
msgstr ""
"``Scenes``フォルダにある ``Main_VR_GUI.tscn`` を開きます。必要に応じてシーン"
"のセットアップ方法を自由に確認してください。ただし、このチュートリアルが長く"
"なりすぎないように、このチュートリアルではシーンのセットアップについては説明"
"しません。"

msgid ""
"Expand the ``GUI`` :ref:`Viewport <class_Viewport>` node and then select the "
"``Base_Control`` node. Add a new script called ``Base_Control.gd``, and add "
"the following:"
msgstr ""
"``GUI`` :ref:`Viewport <class_Viewport>` ノードを展開し、 ``Base_Control`` "
"ノードを選択します。\\ ``Base_Control.gd`` という新しいスクリプトを追加し、次"
"を追加します:"

msgid "Let's go over how this script works real quick."
msgstr "このスクリプトが実際にどのようにすばやく機能するかを見ていきましょう。"

msgid ""
"First, in ``_ready``, we get the :ref:`Label <class_Label>` that shows how "
"many spheres are left and assign it to the ``sphere_count_label`` class "
"variable. Next, we get ``Game.gd`` by using ``get_tree().root`` and assign "
"``sphere_ui`` to this script."
msgstr ""
"まず、\\ ``_ ready`` で、残りの球の数を示す :ref:`Label <class_Label>` を取得"
"し、それを ``sphere_count_label`` クラス変数に割り当てます。次に、 \\ "
"``get_tree().root`` を使用して ``Game.gd`` を取得し、\\ ``sphere_ui`` をこの"
"スクリプトに割り当てます。"

msgid ""
"In ``update_ui``, we change the sphere :ref:`Label <class_Label>`'s text. If "
"there is at least one sphere remaining, we change the text to show how many "
"spheres are still left in the world. If there are no more spheres remaining, "
"we change the text and congratulate the player."
msgstr ""
"``update_ui`` では、球体 :ref:`Label <class_Label>` のテキストを変更します。"
"少なくとも1つの球体が残っている場合は、テキストを変更して、まだ世界に残ってい"
"る球体の数を表示します。球が残っていない場合は、テキストを変更してプレイヤー"
"を祝福します。"

msgid "Adding the final special RigidBody"
msgstr "最後の特別なRigidBodyの追加"

msgid ""
"Finally, before we finish this tutorial, let's add a way to reset the game "
"while in VR."
msgstr ""
"最後に、このチュートリアルを完了する前に、VRでゲームをリセットする方法を追加"
"しましょう。"

msgid ""
"Open up ``Reset_Box.tscn``, which you will find in ``Scenes``. Select the "
"``Reset_Box`` :ref:`RigidBody <class_RigidBody>` node and make a new script "
"called ``Reset_Box.gd``. Add the following code:"
msgstr ""
"``Scenes`` にある ``Reset_Box.tscn`` を開きます。\\ ``Reset_Box`` :ref:"
"`RigidBody <class_RigidBody>` ノードを選択し ``Reset_Box.gd`` という新しいス"
"クリプトを作成します。次のコードを追加します:"

msgid "Let's quickly go over how this script works."
msgstr "このスクリプトがどのように機能するかを簡単に見てみましょう。"

msgid "Explaining the reset box code"
msgstr "リセットボックスのコードの説明"

msgid ""
"Like with the other special :ref:`RigidBody <class_RigidBody>`-based objects "
"we've created, the reset box extends ``VR_Interactable_Rigidbody``."
msgstr ""
"作成した他の特別な :ref:`RigidBody <class_RigidBody>` ベースのオブジェクトと"
"同様に、リセットボックスは ``VR_Interactable_Rigidbody`` を拡張します。"

msgid ""
"The ``start_transform`` class variable will store the global transform of "
"the reset box when the game starts, the ``reset_timer`` class variable will "
"hold the length of time that has passed since the reset box's position has "
"moved, the ``RESET_TIME`` constant defines the length of time the reset box "
"has to wait before being reset, and the ``RESET_MIN_DISTANCE`` constant "
"defines how far the reset box has to be away from it's initial position "
"before the reset timer starts."
msgstr ""
"``start_transform`` クラス変数は、ゲームの開始時にリセットボックスのグローバ"
"ル変換を格納します。\\ ``reset_timer`` クラス変数は、リセットボックスの位置が"
"移動してから経過した時間の長さを保持します。\\ ``RESET_TIME`` 定数は、リセッ"
"トボックスがリセットされるまで待機する時間の長さを定義し、\\ "
"``RESET_MIN_DISTANCE`` 定数は、リセットタイマーが開始する前にリセットボックス"
"が初期位置からどれだけ離れている必要があるかを定義します。"

msgid ""
"In the ``_ready`` function all we are doing is storing the "
"``global_transform`` of the reset position when the scene starts. This is so "
"we can reset the position, rotation, and scale of the reset box object to "
"this initial transform when enough time has passed."
msgstr ""
"``_ready`` 関数では、シーンの開始時にリセット位置の ``global_transform`` を保"
"存するだけです。これは、十分な時間が経過したときに、リセットボックスオブジェ"
"クトの位置、回転、スケールをこの初期transformにリセットできるようにするためで"
"す。"

msgid ""
"In the ``_physics_process`` function, the code checks to see if the reset "
"box's initial position to the reset box's current position is farther than "
"``RESET_MIN_DISTANCE``. If it is farther, then it starts adding time, "
"``delta``, to ``reset_timer``. Once ``reset_timer`` is more than or equal to "
"``RESET_TIME``, we reset the ``global_transform`` to the ``start_transform`` "
"so the reset box is back in its initial position. We then set "
"``reset_timer`` to ``0``."
msgstr ""
"``_physics_process`` 関数では、コードはリセットボックスの現在位置に対するリ"
"セットボックスの初期位置が ``RESET_MIN_DISTANCE`` よりも遠いかどうかを確認し"
"ます。さらに遠い場合は、\\ ``reset_timer`` に時間 ``delta`` を加算し始めま"
"す。\\ ``reset_timer`` が ``RESET_TIME`` 以上になると、\\ "
"``global_transform`` を ``start_transform`` にリセットし、リセットボックスが"
"初期位置に戻るようにします。次に、\\ ``reset_timer`` を ``0`` に設定します。"

msgid ""
"The ``interact`` function simply reloads the ``Game.tscn`` scene using "
"``get_tree().change_scene``. This will reload the game scene, resetting "
"everything."
msgstr ""
"``interact`` 関数は、単に ``get_tree().change_scene`` を使用して ``Game."
"tscn`` シーンをリロードします。これにより、ゲームシーンがリロードされ、すべて"
"がリセットされます。"

msgid ""
"Finally, the ``dropped`` function resets the ``global_transform`` to the "
"initial transform in ``start_transform`` so the reset box has its initial "
"position/rotation. Then ``reset_timer`` is set to ``0`` so the timer is "
"reset."
msgstr ""
"最後に、\\ ``dropped`` 関数は ``global_transform`` を ``start_transform`` の"
"初期変換にリセットするので、リセットボックスは初期位置/回転を保持します。次"
"に、\\ ``reset_timer`` が ``0`` に設定され、タイマーがリセットされます。"

msgid "Reset box finished"
msgstr "リセット ボックスが完了しました"

msgid ""
"With that done, when you grab and interact with the reset box, the entire "
"scene will reset/restart and you can destroy all the targets again!"
msgstr ""
"これが完了したら、リセットボックスをつかんで操作すると、シーン全体がリセット/"
"再起動され、すべてのターゲットを再び破壊できます！"

msgid ""
"Resetting the scene abruptly without any sort of transition can lead to "
"discomfort in VR."
msgstr ""
"なんらかの移行をせずにシーンを突然リセットすると、VRに不快感が生じる可能性が"
"あります。"

msgid "Final notes"
msgstr "最終ノート"

msgid "Whew! That was a lot of work."
msgstr "ふう！これは大変な仕事でした。"

msgid ""
"Now you have a fully working VR project with multiple different types of "
"special :ref:`RigidBody <class_RigidBody>`-based nodes that can be used and "
"extended. Hopefully this will help serve as an introduction to making fully-"
"featured VR games in Godot! The code and concepts detailed in this tutorial "
"can be expanded on to make puzzle games, action games, story-based games, "
"and more!"
msgstr ""
"これで、複数の異なるタイプの特別な :ref:`RigidBody <class_RigidBody>` ベース"
"のノードが使用および拡張できる、完全に機能するVRプロジェクトができました。こ"
"れがGodotでフル機能のVRゲームを作成するための入門書として役立つことを願ってい"
"ます！このチュートリアルで詳しく説明するコードと概念を拡張して、パズルゲー"
"ム、アクションゲーム、ストーリーベースのゲームなどを作成できます！"

#, fuzzy
msgid ""
"You can download the finished project for this tutorial series on the "
"`OpenVR GitHub repository <https://github.com/GodotVR/godot_openvr_fps>`__, "
"under the releases tab!"
msgstr ""
"このチュートリアルシリーズの完成したプロジェクトは、リリースタブの下の "
"`OpenVR GitHubリポジトリ <https://github.com/GodotVR/godot_openvr_fps>`_から"
"ダウンロードできます！"

msgid "Translation status"
msgstr "翻訳ステータス"
