# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "VR starter tutorial part 1"
msgstr "VRスターターチュートリアルパート1"

msgid "Introduction"
msgstr "はじめに"

msgid ""
"This tutorial will show you how to make a beginner VR game project in Godot."
msgstr ""
"このチュートリアルでは、Godotで初心者向けのVRゲームプロジェクトを作成する方法"
"を説明します。"

msgid ""
"Keep in mind, **one of the most important things when making VR content is "
"getting the scale of your assets correct**! It can take lots of practice and "
"iterations to get this right, but there are a few things you can do to make "
"it easier:"
msgstr ""
"**VRコンテンツを作成する際に最も重要なことの1つは、アセットの規模を正確にする"
"ことです** ！ これを正しく行うには多くの練習と反復が必要になりますが、簡単に"
"するためにできることがいくつかあります:"

msgid ""
"In VR, 1 unit is typically considered 1 meter. If you design your assets "
"around that standard, you can save yourself a lot of headache."
msgstr ""
"VRでは、1単位は通常1メートルと見なされます。 その標準を中心に据えてアセットを"
"設計すれば、頭痛の種を大幅に減らすことができます。"

msgid ""
"In your 3D modeling program, see if there is a way to measure and use real "
"world distances. In Blender, you can use the MeasureIt add-on; in Maya, you "
"can use the Measure Tool."
msgstr ""
"3Dモデリングプログラムで、現実世界の距離を測定して使用する方法があるかどうか"
"を確認します。 Blenderでは、MeasureItアドオンを使用できます。 Mayaでは、測定"
"ツールを使用できます。"

#, fuzzy
msgid ""
"You can make rough models using a tool like `Google Blocks <https://vr."
"google.com/blocks/>`__, and then refine in another 3D modelling program."
msgstr ""
"`Google Blocks <https://vr.google.com/blocks/>`_ のようなツールを使用して大ま"
"かなモデルを作成し、別の3Dモデリングプログラムで改良できます。"

msgid ""
"Test often, as the assets can look dramatically different in VR than on a "
"flat screen!"
msgstr ""
"アセットは、VRとフラットスクリーンで劇的に異なって見える可能性があるので、頻"
"繁にテストしてください！"

msgid "Throughout the course of this tutorial, we will cover:"
msgstr "このチュートリアルでは、次のことを説明します:"

msgid "How to tell Godot to run in VR."
msgstr "VRで実行するようにGodotに伝える方法。"

msgid ""
"How to make a teleportation locomotion system that uses the VR controllers."
msgstr "VRコントローラを使用するテレポーテーション移動システムの作成方法。"

msgid ""
"How to make a artificial movement locomotion system that uses the VR "
"controllers."
msgstr "VRコントローラを使用した人工的な運動移動システムの作り方。"

msgid ""
"How to create a :ref:`RigidBody <class_RigidBody>`-based system that allows "
"for picking up, dropping, and throwing RigidBody nodes using the VR "
"controllers."
msgstr ""
"VR コントローラを使用してRigidBodyノードをピックアップ、ドロップ、およびス"
"ローできる :ref:`RigidBody <class_RigidBody>` ベースのシステムを作成する方"
"法。"

msgid "How to create simple destroyable target."
msgstr "単純な破壊可能なターゲットを作成する方法。"

msgid ""
"How to create some special :ref:`RigidBody <class_RigidBody>`-based objects "
"that can destroy the targets."
msgstr ""
"ターゲットを破壊できる特別な :ref:`RigidBody <class_RigidBody>` ベースのオブ"
"ジェクトを作成する方法 。"

#, fuzzy
msgid ""
"While this tutorial can be completed by beginners, it is highly advised to "
"complete :ref:`doc_your_first_2d_game`, if you are new to Godot and/or game "
"development."
msgstr ""
"このチュートリアルは初心者でも完了することができますが、Godotやゲーム開発に慣"
"れていない場合は、\\ :ref:`doc_your_first_game` を完了することを強くお勧めし"
"ます。"

msgid ""
"**Some experience with making 3D games is required** before going through "
"this tutorial series. This tutorial assumes you have experience with the "
"Godot editor, GDScript, and basic 3D game development. A OpenVR-ready "
"headset and two OpenVR-ready controllers are required."
msgstr ""
"**このチュートリアルシリーズを読む前に、3Dゲームを作成した経験が必要です"
"**\\ 。このチュートリアルでは、Godotエディタ、GDScript、および基本的な3Dゲー"
"ム開発の経験があることを前提としています。OpenVR対応ヘッドセットと2つのOpenVR"
"対応コントローラーが必要です。"

msgid ""
"This tutorial was written and tested using a Windows Mixed Reality headset "
"and controllers. This project has also been tested on the HTC Vive. Code "
"adjustments may be required for other VR Headsets, such as the Oculus Rift."
msgstr ""
"このチュートリアルは、Windows Mixed Realityヘッドセットとコントローラーを使用"
"して作成およびテストされています。 このプロジェクトはHTC Viveでもテストされて"
"います。 Oculus Riftなどの他のVRヘッドセットでは、コードの調整が必要になる場"
"合があります。"

#, fuzzy
msgid ""
"The Godot project for this tutorial is found on the `OpenVR GitHub "
"repository <https://github.com/GodotVR/godot_openvr_fps>`__. The starter "
"assets for this tutorial can be found in the releases section on the GitHub "
"repository. The starter assets contain some 3D models, sounds, scripts, and "
"scenes that are configured for this tutorial."
msgstr ""
"このチュートリアルのGodotプロジェクトは、\\ `OpenVR GitHubリポジトリ "
"<https://github.com/GodotVR/godot_openvr_fps>`_ にあります。 このチュートリア"
"ルのスターターアセットは、GitHubリポジトリのリリースセクションにあります。 ス"
"ターターアセットには、このチュートリアル用に設定された3Dモデル、サウンド、ス"
"クリプト、シーンが含まれています。"

msgid "**Credits for the assets provided**:"
msgstr "**提供されたアセットのクレジット**:"

#, fuzzy
msgid ""
"The sky panorama was created by `CGTuts <https://cgi.tutsplus.com/articles/"
"freebie-8-awesome-ocean-hdris--cg-5684>`__."
msgstr ""
"空のパノラマは、\\ `CGTuts <https://cgi.tutsplus.com/articles/freebie-8-"
"awesome-ocean-hdris--cg-5684>`_ によって作成されました。"

msgid "The font used is Titillium-Regular"
msgstr "使用しているフォントはTitillium-Regular"

msgid "The font is licensed under the SIL Open Font License, Version 1.1"
msgstr "このフォントは SIL Open Font License, Version 1.1 でライセンスされます"

#, fuzzy
msgid ""
"The audio used are from several different sources, all downloaded from the "
"Sonniss #GameAudioGDC Bundle (`License PDF <https://sonniss.com/gdc-bundle-"
"license/>`__)"
msgstr ""
"使用しているオーディオはいくつかの異なるソースからのもので、すべて Sonniss "
"#GameAudioGDC Bundle からダウンロードされます(`ライセンスPDF <https://"
"sonniss.com/gdc-bundle-license/>`_)"

msgid ""
"The folders where the audio files are stored have the same name as folders "
"in the Sonniss audio bundle."
msgstr ""
"オーディオファイルが保存されているフォルダの名前は、Sonniss audio bundle の"
"フォルダと同じです。"

#, fuzzy
msgid ""
"The OpenVR addon was created by `Bastiaan Olij <https://github.com/"
"BastiaanOlij>`__ and is released under the MIT license. It can be found both "
"on the `Godot Asset Library <https://godotengine.org/asset-library/"
"asset/150>`__ and on `GitHub <https://github.com/GodotVR/godot-openvr-"
"asset>`__. *3rd party code and libraries used in the OpenVR addon may be "
"under a different license.*"
msgstr ""
"OpenVRアドオンは `Bastiaan Olij <https://github.com/BastiaanOlij>`_ によって"
"作成され、MITライセンスの下でリリースされています。\\ `Godot Asset Library "
"<https://godotengine.org/asset-library/asset/150>`_ と `GitHub <https://"
"github.com/GodotVR/godot-openvr-asset>`_ の両方にあります。\\ *OpenVRアドオン"
"で使用されるサードパーティのコードとライブラリは、異なるライセンスの下にある"
"場合があります。*"

#, fuzzy
msgid ""
"The initial project, 3D models, and scripts were created by `TwistedTwigleg "
"<https://github.com/TwistedTwigleg>`__ and is released under the MIT license."
msgstr ""
"最初のプロジェクト、3Dモデル、およびスクリプトは、\\ `TwistedTwigleg "
"<https://github.com/TwistedTwigleg>`_ によって作成され、MITライセンスの下でリ"
"リースされています。"

#, fuzzy
msgid ""
"You can find the finished project on the `OpenVR GitHub repository <https://"
"github.com/GodotVR/godot_openvr_fps>`__."
msgstr ""
"完成したプロジェクトは、\\ ``OpenVR GitHub リポジトリ <https://github.com/"
"GodotVR/godot_openvr_fps>`_ で見つけることができます。"

msgid "Getting everything ready"
msgstr "すべてを準備する"

#, fuzzy
msgid ""
"If you have not already, go to the `OpenVR GitHub repository <https://github."
"com/GodotVR/godot_openvr_fps/releases/>`__ and download the \"Starter "
"Assets\" file from the releases. Once you have the starter assets "
"downloaded, open up the project in Godot."
msgstr ""
"まだ行っていない場合は、\\ `OpenVR GitHubリポジトリ <https://github.com/"
"GodotVR/godot_openvr_fps>`_ にアクセスし、releasesから \"Starter Assets\" "
"ファイルをダウンロードします。 スターターアセットをダウンロードしたら、Godot"
"でプロジェクトを開きます。"

msgid ""
"The starter assets are not required to use the scripts provided in this "
"tutorial. The starter assets include several premade scenes and scripts that "
"will be used throughout the tutorial."
msgstr ""
"このチュートリアルで提供されるスクリプトを使用するために、スターターアセット"
"は必要ありません。 スターターアセットには、チュートリアル全体で使用されるいく"
"つかの作成済みのシーンとスクリプトが含まれています。"

msgid ""
"When the project is first loaded, the Game.tscn scene will be opened. This "
"will be the main scene used for the tutorial. It includes several nodes and "
"scenes already placed throughout the scene, some background music, and "
"several GUI-related :ref:`MeshInstance <class_MeshInstance>` nodes."
msgstr ""
"プロジェクトが最初にロードされると、Game.tscnシーンが開きます。 これがチュー"
"トリアルで使用されるメインシーンになります。 シーン全体にすでに配置されている"
"いくつかのノードとシーン、いくつかのバックグラウンドミュージック、およびいく"
"つかのGUI関連の :ref:`MeshInstance <class_MeshInstance>` ノードが含まれていま"
"す。"

msgid ""
"The GUI-related :ref:`MeshInstance <class_MeshInstance>` nodes already have "
"scripts attached to them. These scripts will set the texture of a :ref:"
"`Viewport <class_Viewport>` node to the albedo texture of the material of "
"the :ref:`MeshInstance <class_MeshInstance>` node. This is used to display "
"text within the VR project. Feel free to take a look at the script, ``GUI."
"gd``, if you want. We will not be going over how to to use :ref:`Viewport "
"<class_Viewport>` nodes for displaying UI on :ref:`MeshInstance "
"<class_MeshInstance>` nodes in this tutorial ."
msgstr ""
"GUI関連の :ref:`MeshInstance <class_MeshInstance>` ノードには既にスクリプトが"
"アタッチされています。 これらのスクリプトは、\\ :ref:`Viewport "
"<class_Viewport>` ノードのテクスチャを :ref:`MeshInstance "
"<class_MeshInstance>` ノードのマテリアルのアルベドテクスチャに設定します。こ"
"れは、VRプロジェクト内のテキストを表示するために使用されます。 必要に応じて、"
"スクリプト ``GUI.gd`` をご覧ください。このチュートリアルでは、\\ :ref:"
"`MeshInstance <class_MeshInstance>` ノードでUIを表示するために :ref:"
"`Viewport <class_Viewport>` ノードを使用する方法については説明しません。"

msgid ""
"If you are interested in how to use :ref:`Viewport <class_Viewport>` nodes "
"for displaying UI on :ref:`MeshInstance <class_MeshInstance>` nodes, see "
"the :ref:`doc_viewport_as_texture` tutorial. It covers how to use a :ref:"
"`Viewport <class_Viewport>` as a render texture, along with how to apply "
"that texture onto a :ref:`MeshInstance <class_MeshInstance>` node."
msgstr ""
":ref:`MeshInstance <class_MeshInstance>` ノードでUIを表示するために :ref:"
"`Viewport <class_Viewport>` ノードを使用する方法に興味がある場合は、\\ :ref:"
"`doc_viewport_as_texture` チュートリアルを参照してください。\\ :ref:"
"`Viewport <class_Viewport>` をレンダリングテクスチャとして使用する方法と、そ"
"のテクスチャを :ref:`MeshInstance <class_MeshInstance>` ノードに適用する方法"
"について説明します。"

msgid ""
"Before we jump into the tutorial, let's take a moment to talk about how the "
"nodes used for VR work."
msgstr ""
"チュートリアルに進む前に、VRに使用されるノードがどのように機能するかについて"
"少し話をしましょう。"

msgid ""
"The :ref:`ARVROrigin <class_ARVROrigin>` node is the center point of the VR "
"tracking system. The position of the :ref:`ARVROrigin <class_ARVROrigin>` is "
"the position the VR system considers the 'center' point on the floor. The :"
"ref:`ARVROrigin <class_ARVROrigin>` has a `world scale` property that "
"effects the size of the user within the VR scene. For this tutorial, it is "
"set to `1.4`, as the world was originally just a tad to big. As mentioned "
"earlier, keeping the scale relatively consistent is important in VR."
msgstr ""
":ref:`ARVROrigin <class_ARVROrigin>` ノードは、VRトラッキングシステムの中心点"
"です。\\ :ref:`ARVROrigin <class_ARVROrigin>` の位置は、VRシステムが床の「中"
"心」点と見なす位置です。\\ :ref:`ARVROrigin <class_ARVROrigin>`　には、VRシー"
"ン内のユーザーのサイズに影響を与える `world scale` プロパティがあります。 こ"
"のチュートリアルでは、世界はもともと大きなものだったため、\\ `1.4` に設定され"
"ています。 前述したように、VRではスケールを比較的一定に保つことが重要です。"

msgid ""
"The :ref:`ARVRCamera <class_ARVRCamera>` is the player's headset and view "
"into the scene. The :ref:`ARVRCamera <class_ARVRCamera>` is offset on the Y "
"axis by the VR user's height, which will be important later when we add "
"teleportation locomotoin. If the VR system supports room tracking, then the :"
"ref:`ARVRCamera <class_ARVRCamera>` will move as the player moves. This "
"means that the :ref:`ARVRCamera <class_ARVRCamera>` is not guaranteed to be "
"in the same position as the :ref:`ARVROrigin <class_ARVROrigin>` node."
msgstr ""
":ref:`ARVRCamera <class_ARVRCamera>` は、プレイヤーのヘッドセットであり、シー"
"ンを表示します。\\ :ref:`ARVRCamera <class_ARVRCamera>` は、VRユーザーの高さ"
"によってY軸上でオフセットされます。これは、テレポート移動を追加するときに重要"
"になります。 VRシステムが部屋のトラッキングをサポートしている場合、プレイヤー"
"が移動すると :ref:`ARVRCamera <class_ARVRCamera>` も移動します。これは、\\ :"
"ref:`ARVRCamera <class_ARVRCamera>` が :ref:`ARVROrigin <class_ARVROrigin>` "
"ノードと同じ位置にあることが保証されていないことを意味します。"

msgid ""
"The :ref:`ARVRController <class_ARVRController>` node represents a VR "
"controller. The :ref:`ARVRController <class_ARVRController>` will follow the "
"position and rotation of the VR controller relative to the :ref:`ARVROrigin "
"<class_ARVROrigin>` node. All of the input for the VR controllers happens "
"through the :ref:`ARVRController <class_ARVRController>` node. An :ref:"
"`ARVRController <class_ARVRController>` node with an ``ID`` of ``1`` "
"represents the left VR controller, while an :ref:`ARVRController "
"<class_ARVRController>` controller with an ``ID`` of ``2`` represents the "
"right VR controller."
msgstr ""
":ref:`ARVRController <class_ARVRController>` ノードはVRコントローラーを表しま"
"す。\\ :ref:`ARVRController <class_ARVRController>` は、\\ :ref:`ARVROrigin "
"<class_ARVROrigin>` ノードに対するVRコントローラーの位置と回転に従います。 VR"
"コントローラーへのすべての入力は、\\ :ref:`ARVRController "
"<class_ARVRController>` ノードを介して行われます。\\ ``1`` の ``ID`` を持つ :"
"ref:`ARVRController <class_ARVRController>` ノードは左のVRコントローラーを表"
"し、\\ ``2`` の ``ID`` を持つ :ref:`ARVRController <class_ARVRController>` コ"
"ントローラーは右のVRコントローラーを表します。"

#, fuzzy
msgid "To summarize:"
msgstr "要約すると:"

msgid ""
"The :ref:`ARVROrigin <class_ARVROrigin>` node is the center of the VR "
"tracking system and is positioned on the floor."
msgstr ""
":ref:`ARVROrigin <class_ARVROrigin>` ノードはVRトラッキングシステムの中心であ"
"り、床に配置されています。"

msgid ""
"The :ref:`ARVRCamera <class_ARVRCamera>` is the player's VR headset and view "
"into the scene."
msgstr ""
":ref:`ARVRCamera <class_ARVRCamera>` は、プレイヤーのVRヘッドセットであり、"
"シーンを見ることができます。"

msgid ""
"The :ref:`ARVRCamera <class_ARVRCamera>` node is offset on the Y axis by the "
"user's height."
msgstr ""
":ref:`ARVRCamera <class_ARVRCamera>` ノードは、ユーザの高さによってY軸上でオ"
"フセットされます。"

msgid ""
"If the VR system supports room tracking, then the :ref:`ARVRCamera "
"<class_ARVRCamera>` node may be offset on the X and Z axes as the player "
"moves."
msgstr ""
"VR システムがルームトラッキングをサポートしている場合、\\ :ref:`ARVRCamera "
"<class_ARVRCamera>` ノードはプレイヤーの移動に合わせてX軸とZ軸でオフセットさ"
"れる可能性があります。"

msgid ""
"The :ref:`ARVRController <class_ARVRController>` nodes represent the VR "
"controllers and handle all of the input from the VR controllers."
msgstr ""
":ref:`ARVRController <class_ARVRController>` ノードは VR コントローラーを表"
"し、VR コントローラーからの入力をすべて処理します。"

msgid "Starting VR"
msgstr "VRの開始"

msgid ""
"Now that we have gone over the VR nodes, let's start working on the project. "
"While in ``Game.tscn``, select the ``Game`` node and make a new script "
"called ``Game.gd``. In the ``Game.gd`` file, add the following code:"
msgstr ""
"VRノードを確認したので、プロジェクトの作業を始めましょう。\\ ``Game.tscn`` "
"で ``Game`` ノードを選択し、\\ ``Game.gd`` という新しいスクリプトを作成しま"
"す。\\ ``Game.gd`` ファイルに次のコードを追加します:"

msgid "Let's go over what this code does."
msgstr "このコードの機能について説明します。"

msgid ""
"In the ``_ready`` function, we first get the OpenVR VR interface using the "
"``find_interface`` function in the :ref:`ARVRServer <class_ARVRServer>` and "
"assign it to a variable called `VR`. If the :ref:`ARVRServer "
"<class_ARVRServer>` finds an interface with the name OpenVR, it will return "
"it, otherwise it will return ``null``."
msgstr ""
"``_ready`` 関数では、最初に :ref:`ARVRServer <class_ARVRServer>` の "
"``find_interface`` 関数を使用してOpenVR VRインターフェースを取得し、それを "
"`VR` という変数に割り当てます。\\ :ref:`ARVRServer <class_ARVRServer>` が"
"OpenVRという名前のインターフェイスを見つけると、それを返します。それ以外の場"
"合は ``null`` を返します。"

#, fuzzy
msgid ""
"The OpenVR VR interface is not included with Godot by default. You will need "
"to download the OpenVR asset from the `Asset Library <https://godotengine."
"org/asset-library/asset/150>`__ or `GitHub <https://github.com/GodotVR/godot-"
"openvr-asset>`__."
msgstr ""
"OpenVR VRインターフェイスは、デフォルトではGodotに含まれていません。\\ "
"`Asset Library <https://godotengine.org/asset-library/asset/150>`_ または "
"`GitHub <https://github.com/GodotVR/godot-openvr-asset>`_ からOpenVRアセット"
"をダウンロードする必要があります。"

msgid ""
"The code then combines two conditionals, one to check if the `VR` variable "
"is NOT null (``if VR``) and another calls the initialize function, which "
"returns a boolean based on whether the OpenVR interface was able to "
"initialize or not. If both of these conditionals return true, then we can "
"turn the main Godot :ref:`Viewport <class_Viewport>` into an ARVR viewport."
msgstr ""
"次に、コードは2つの条件を組み合わせます。1つは `VR` 変数がnullではない (``if "
"VR``) かどうかをチェックし、もう1つはOpenVRインターフェイスが初期化できたかど"
"うかに基づいてブール値を返す初期化関数を呼び出します 。 これらの条件の両方が"
"trueを返す場合、メインのGodot :ref:`Viewport <class_Viewport>` をARVRビュー"
"ポートに変換できます。"

#, fuzzy
msgid ""
"If the VR interface initialized successfully, we then get the root :ref:"
"`Viewport <class_Viewport>` and set the `arvr` property to ``true``. This "
"will tell Godot to use the initialized ARVR interface to drive the :ref:"
"`Viewport <class_Viewport>` display."
msgstr ""
"VRインターフェイスが正常に初期化された場合、ルート :ref:`Viewport "
"<class_Viewport>` を取得し、\\ `arvr` プロパティを ``true`` に設定します。 こ"
"れにより、初期化されたARVRインターフェイスを使用して :ref:`Viewport "
"<class_Viewport>` ディスプレイを扱うようにGodotに指示します。\\ ``arvr`` プロ"
"パティを ``true`` に設定した後、\\ `` hdr`` プロパティを ``false`` に設定しま"
"す。これは、ほとんどのVRヘッドセットが現在HDRレンダリングをサポートしていない"
"ためです。"

msgid ""
"Finally, we disable VSync so the Frames Per Second (FPS) is not capped by "
"the computer monitor. After this we tell Godot to render at ``90`` frames "
"per second, which is the standard for most VR headsets. Without disabling "
"VSync, the normal computer monitor may limit the frame rate of the VR "
"headset to the frame rate of the computer monitor."
msgstr ""
"最後に、VSyncを無効にして、1秒あたりのフレーム数(FPS)がコンピューターモニター"
"によって制限されないようにします。 この後、ほとんどのVRヘッドセットの標準であ"
"る ``90`` フレーム/秒でレンダリングするようにGodotに指示します。 VSyncを無効"
"にしないと、通常のコンピューターモニターはVRヘッドセットのフレームレートをコ"
"ンピューターモニターのフレームレートに制限する場合があります。"

msgid ""
"In the project settings, under the ``Physics->Common`` tab, the physics FPS "
"has been set to ``90``. This makes the physics engine run at the same frame "
"rate as the VR display, which makes physics reactions look smoother when in "
"VR."
msgstr ""
"プロジェクト設定の ``Physics->Common`` タブで、物理FPSが ``90`` に設定されて"
"います。 これにより、物理エンジンがVRディスプレイと同じフレームレートで実行さ"
"れ、VRでの物理反応がより滑らかに見えます。"

msgid ""
"That is all we need to do for Godot to launch OpenVR within the project! Go "
"ahead and give it a try if you want. Assuming everything works, you will be "
"able to look around the world. If you have a VR headset with room tracking, "
"then you will be able to move around the scene within the limits of the room "
"tracking."
msgstr ""
"Godotがプロジェクト内でOpenVRを起動するために必要なことはこれだけです！ 必要"
"に応じて試してみてください。 すべてが機能すると仮定すると、世界中を見ることが"
"できるようになります。 ルームトラッキングを備えたVRヘッドセットをお持ちの場合"
"は、ルームトラッキングの制限内でシーン内を移動できます。"

msgid "Creating the controllers"
msgstr "コントローラーの作成"

#, fuzzy
msgid ""
"Right now all that the VR user can do is stand around, which isn't really "
"what we are going for unless we are working on a VR film. Lets write the "
"code for the VR controllers. We are going to write all the code for the VR "
"controllers in one go, so the code is rather long. That said, once we are "
"finished you will be able to teleport around the scene, artificially move "
"using the touchpad/joystick on the VR controller, and be able to pick up, "
"drop, and throw :ref:`RigidBody <class_RigidBody>`-based nodes."
msgstr ""
"今、VRユーザーができることは立ち回ることだけですが、これはVR映画に取り組んで"
"いない限り、これは実際の目的ではありません。VRコントローラーのコードを記述し"
"ましょう。VRコントローラー用のすべてのコードを一度に作成するため、コードはか"
"なり長くなります。しかし、それが終われば、シーンの周りをテレポートし、VRコン"
"トローラのタッチパッド/ジョイスティックを使って人工的に動き、\\ :ref:"
"`RigidBody <class_RigidBody>` ベースのノードを拾い、捨て、投げることができる"
"ようになります。"

msgid ""
"First we need to open the scene used for the VR controllers. "
"``Left_Controller.tscn`` or ``Right_Controller.tscn``. Let's briefly go over "
"how the scene is setup."
msgstr ""
"最初に、VRコントローラーに使用するシーンを開く必要があります。\\ "
"``Left_Controller.tscn`` または ``Right_Controller.tscn``。ではシーンのセット"
"アップ方法について簡単に説明します。"

msgid "How the VR controller scene is setup"
msgstr "VRコントローラーシーンの設定方法"

msgid ""
"In both scenes the root node is a ARVRController node. The only difference "
"is that the ``Left_Controller`` scene has the ``Controller Id`` property set "
"to ``1`` while the ``Right_Controller`` has the ``Controller Id`` property "
"set to ``2``."
msgstr ""
"どちらのシーンでもルート ノードはARVRControllerノードです。唯一の違いは、"
"``Left_Controller`` シーンの ``Controller Id`` プロパティが ``1`` に設定され"
"ているのに対し、\\ ``Right_Controller`` プロパティには ``2`` が設定されている"
"点です。"

msgid ""
"The :ref:`ARVRServer <class_ARVRServer>` attempts to use these two IDs for "
"the left and right VR controllers. For VR systems that support more than 2 "
"controllers/tracked-objects, these IDs may need adjusting."
msgstr ""
":ref:`ARVRServer <class_ARVRServer>` は、左右のVRコントローラーにこれら2つの"
"IDを使用しようとします。3つ以上のコントローラー/追跡オブジェクトをサポートす"
"るVRシステムの場合、これらのIDの調整が必要になる場合があります。"

msgid ""
"Next is the ``Hand`` :ref:`MeshInstance <class_MeshInstance>` node. This "
"node is used to display the hand mesh that will be used when the VR "
"controller is not holding onto a :ref:`RigidBody <class_RigidBody>` node. "
"The hand in the ``Left_Controller`` scene is a left hand, while the hand on "
"the ``Right_Controller`` scene is a right hand."
msgstr ""
"次は ``Hand`` :ref:`MeshInstance <class_MeshInstance>` ノードです。このノード"
"は、VRコントローラーが :ref: RigidBody <class_RigidBody>` ノードを保持してい"
"ないときに使用されるハンドメッシュを表示するために使用されます。\\ "
"``Left_Controller`` シーンの手は左手で、\\ ``Right_Controller`` シーンの手は"
"右手です。"

msgid ""
"The node named ``Raycast`` is a :ref:`Raycast <class_Raycast>` node that is "
"used for aiming where to teleport to when the VR controller is teleporting. "
"The length of the :ref:`Raycast <class_Raycast>` is set to ``-16`` on the Y "
"axis and is rotated so that it points out of the pointer finger of the hand. "
"The ``Raycast`` node has a single child node, ``Mesh``, that is a :ref:"
"`MeshInstance <class_MeshInstance>`. This is used for visually showing where "
"the teleportation :ref:`Raycast <class_Raycast>` is aiming."
msgstr ""
"``Raycast`` という名前のノードは :ref:`Raycast <class_Raycast>` ノードで、VR"
"コントローラーがテレポートするときにテレポートする場所を狙うために使用されま"
"す。\\ :ref:`Raycast <class_Raycast>` の長さはY軸で ``-16`` に設定され、手の"
"ポインターの指の外側を指すように回転します。\\ ``Raycast`` ノードには、単一の"
"子ノード ``Mesh`` があります。これは :ref:`MeshInstance "
"<class_MeshInstance>` です。これは、テレポート :ref:`Raycast "
"<class_Raycast>` が狙っている場所を視覚的に示すために使用されます。"

msgid ""
"The node named ``Area`` is a :ref:`Area <class_Area>` node will be used for "
"grabbing :ref:`RigidBody <class_RigidBody>`-based nodes when the VR "
"controller grab mode is set to ``AREA``. The ``Area`` node has a single "
"child node, ``CollisionShape``, that defines a sphere :ref:`CollisionShape "
"<class_CollisionShape>`. When the VR controller is not holding any objects "
"and the grab button is pressed, the first :ref:`RigidBody <class_RigidBody>`-"
"based node within the ``Area`` node will be picked up."
msgstr ""
"``Area`` という名前のノードは、\\ :ref:`Area <class_Area>` ノードで、VRコント"
"ローラーのグラブモードが ``AREA`` に設定されている場合、\\ :ref:`RigidBody "
"<class_RigidBody>` ベースのノードを取得するために使用されます。\\ ``Area`` "
"ノードには、球体 :ref:`CollisionShape <class_CollisionShape>` を定義する単一"
"の子ノード ``CollisionShape`` があります。VRコントローラーがオブジェクトを保"
"持していない状態でグラブボタンを押すと、\\ ``Area`` ノード内の最初の :ref:"
"`RigidBody <class_RigidBody>` ベースのノードが選択されます。"

msgid ""
"Next is a :ref:`Position3D <class_Position3D>` node called ``Grab_Pos``. "
"This is used to define the position that grabbed :ref:`RigidBody "
"<class_RigidBody>` nodes will follow then they are held by the VR controller."
msgstr ""
"次は ``Grab_Pos`` と呼ばれる :ref:`Position3D <class_Position3D>` ノードで"
"す。これは、\\ :ref:`RigidBody <class_RigidBody>` ノードを取得し、VRコント"
"ローラーによって保持される位置を定義するために使用されます。"

msgid ""
"A large :ref:`Area <class_Area>` node called ``Sleep_Area`` is used to "
"disable sleeping for any RigidBody nodes within its :ref:`CollisionShape "
"<class_CollisionShape>`, simple called ``CollisionShape``. This is needed "
"because if a :ref:`RigidBody <class_RigidBody>` node falls asleep, then the "
"VR controller will be unable to grab it. By using ``Sleep_Area``, we can "
"write code that makes any :ref:`RigidBody <class_RigidBody>` node within it "
"not able to sleep, therefore allowing the VR controller to grab it."
msgstr ""
"``Sleep_Area`` という名前の大きな :ref:`Area <class_Area>` ノードは、\\ :ref:"
"`CollisionShape <class_CollisionShape>` 内のRigidBodyノードのスリープを無効に"
"するために使用されます。これは、\\ :ref:`RigidBody <class_RigidBody>` ノード"
"がスリープ状態になると、VRコントローラーがそれを取得できなくなるためです。\\ "
"``Sleep_Area`` を使用することで、ノード内のすべての :ref:`RigidBody "
"<class_RigidBody>` ノードがスリープできないようにし、VRコントローラーがそれを"
"取得できるようにするコードを記述できます。"

msgid ""
"An :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node called "
"``AudioStreamPlayer3D`` has a sound loaded that we will use when an object "
"has been picked up, dropped or thrown by the VR controller. While this is "
"not necessary for the functionality of the VR controller, it makes grabbing "
"and dropping objects feel more natural."
msgstr ""
"``AudioStreamPlayer3D`` と呼ばれる :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` ノードには、オブジェクトがVRコントローラーによっ"
"てピックアップ、ドロップ、またはスローされたときに使用するサウンドがロードさ"
"れています。これはVRコントローラーの機能には必要ありませんが、オブジェクトを"
"つかんだり落としたりすることがより自然に感じられます。"

msgid ""
"Finally, the last nodes are the ``Grab_Cast`` node and it's only child node, "
"``Mesh``. The ``Grab_Cast`` node will be used for grabbing :ref:`RigidBody "
"<class_RigidBody>`-based nodes when the VR controller grab mode is set to "
"``RAYCAST``. This will allow the VR controller to grab objects that are just "
"slightly out of reach using a Raycast. The ``Mesh`` node is used for "
"visually showing where the teleportation :ref:`Raycast <class_Raycast>` is "
"aiming."
msgstr ""
"最後に、最後のノードは ``Grab_Cast`` ノードと唯一の子ノードである ``Mesh`` で"
"す。\\ ``Grab_Cast`` ノードは、VRコントローラーのグラブモードが ``RAYCAST`` "
"に設定されている場合、\\ :ref:`RigidBody <class_RigidBody>` ベースのノードを"
"取得するために使用されます。これにより、VRコントローラーは、レイキャストを使"
"用してわずかに手の届かないオブジェクトを取得できます。\\ ``Mesh`` ノードは、"
"テレポート :ref:`Raycast <class_Raycast>` の照準を視覚的に示すために使用され"
"ます。"

msgid ""
"That is a quick overview of how the VR controller scenes are setup, and how "
"we will be using the nodes to provide the functionality for them. Now that "
"we have looked at the VR controller scene, let's write the code that will "
"drive them."
msgstr ""
"VR コントローラーシーンの設定方法と、ノードを使用してそれらの機能を提供する方"
"法の概要を簡単に説明します。VR コントローラーのシーンを見てきたので、それらを"
"駆動するコードを記述しましょう。"

msgid "The code for the VR controllers"
msgstr "VRコントローラーのコード"

msgid ""
"Select the root node of the scene, either ``Right_Controller`` or "
"``Left_Controller``, and make a new script called ``VR_Controller.gd``. Both "
"scenes will be using the same script, so it doesn't matter which you use "
"first. With ``VR_Controller.gd`` opened, add the following code:"
msgstr ""
"シーンのルートノードである ``Right_Controller`` または ``Left_Controller`` を"
"選択し、\\ ``VR_Controller.gd`` という新しいスクリプトを作成します。両方の"
"シーンで同じスクリプトが使用されるため、どちらを最初に使用してもかまいませ"
"ん。\\ ``VR_Controller.gd`` を開いた状態で、次のコードを追加します:"

msgid ""
"You can copy and paste the code from this page directly into the script "
"editor."
msgstr ""
"このページからコードをコピーして、スクリプト エディタに直接貼り付けることがで"
"きます。"

#, fuzzy
msgid ""
"If you do this, all the code copied will be using spaces instead of tabs."
msgstr ""
"この操作を行うと、コピーされたコードはすべてタブの代わりにスペースを使用しま"
"す。"

msgid ""
"To convert the spaces to tabs in the script editor, click the ``Edit`` menu "
"and select ``Convert Indent To Tabs``. This will convert all the spaces into "
"tabs. You can select ``Convert Indent To Spaces`` to convert tabs back into "
"spaces."
msgstr ""
"スクリプトエディタでスペースをタブに変換するには、[編集]メニューをクリック"
"し、[インデントをタブに変換]を選択します。これにより、すべてのスペースがタブ"
"に変換されます。タブをスペースに戻すには、[インデントをスペースに変換]を選択"
"します。"

msgid ""
"This is quite a bit of code to go through. Let's go through what the code "
"does step-by-step."
msgstr ""
"これはかなりの量のコードです。コードがステップごとに行うことを見ていきましょ"
"う。"

msgid "Explaining the VR controller code"
msgstr "VRコントローラーコードの説明"

#, fuzzy
msgid "First, let's go through all the class variables in the script:"
msgstr "最初に、スクリプト内のすべてのクラス変数を見てみましょう:"

msgid ""
"``controller_velocity``: A variable to hold a rough approximation of the VR "
"controller's velocity."
msgstr ""
"``controller_velocity``: VRコントローラーの速度の大まかな近似値を保持する変"
"数。"

msgid ""
"``prior_controller_position``: A variable to hold the VR controller's last "
"position in 3D space."
msgstr ""
"``prior_controller_position``: 3D空間でVRコントローラーの最後の位置を保持する"
"変数。"

msgid ""
"``prior_controller_velocities``: An Array to hold the last 30 calculated VR "
"controller velocities. This is used to smooth the velocity calculations over "
"time."
msgstr ""
"``prior_controller_velocities``: 最後に計算された30個のVRコントローラー速度を"
"保持する配列。これは、時間の経過とともに速度計算を滑らかにするために使用され"
"ます。"

msgid ""
"``held_object``: A variable to hold a reference to the object the VR "
"controller is holding. If the VR controller is not holding any objects, this "
"variable will be ``null``."
msgstr ""
"``held_object``: VRコントローラーが保持しているオブジェクトへの参照を保持する"
"変数。VRコントローラーがオブジェクトを保持していない場合、この変数は "
"``null`` になります。"

msgid ""
"``held_object_data``: A dictionary to hold data for the :ref:`RigidBody "
"<class_RigidBody>` node being held by the VR controller. This is used to "
"reset the :ref:`RigidBody <class_RigidBody>`'s data when it is no longer "
"held."
msgstr ""
"``held_object_data``: VRコントローラーによって保持されている :ref:`RigidBody "
"<class_RigidBody>` ノードのデータを保持するdictionary。これは、\\ :ref:"
"`RigidBody <class_RigidBody>` のデータが保持されなくなったときにリセットする"
"ために使用されます。"

msgid ""
"``grab_area``: A variable to hold the :ref:`Area <class_Area>` node used to "
"grab objects with the VR controller."
msgstr ""
"``grab_area``: VRコントローラーでオブジェクトを取得するために使用される :ref:"
"`Area <class_Area>` ノードを保持する変数。"

msgid ""
"``grab_raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` node "
"used to grab objects with the VR controller."
msgstr ""
"``grab_raycast``: VRコントローラーでオブジェクトを取得するために使用される :"
"ref:`Raycast <class_Raycast>` ノードを保持する変数。"

msgid ""
"``grab_mode``: A variable to define the grab mode the VR controller is "
"using. There are only two modes for grabbing objects in this tutorial, "
"``AREA`` and ``RAYCAST``."
msgstr ""
"``grab_mode``: VRコントローラーが使用しているグラブモードを定義する変数。この"
"チュートリアルでオブジェクトを取得するモードは、\\ ``AREA`` と ``RAYCAST`` の"
"2つだけです。"

msgid ""
"``grab_pos_node``: A variable to hold the node that will be used to update "
"the position and rotation of held objects."
msgstr ""
"``grab_pos_node``: 保持されたオブジェクトの位置と回転を更新するために使用され"
"るノードを保持する変数。"

msgid ""
"``hand_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node that contains the hand mesh for the VR "
"controller. This mesh will be shown when the VR controller is not holding "
"anything."
msgstr ""
"``hand_mesh``: VRコントローラーのハンドメッシュを含む :ref:`MeshInstance "
"<class_MeshInstance>` ノードを保持する変数。このメッシュは、VRコントローラー"
"が何も保持していないときに表示されます。"

msgid ""
"``hand_pickup_drop_sound``: A variable to hold the :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` node that contains the pickup/drop sound."
msgstr ""
"``hand_pickup_drop_sound``: ピックアップ/ドロップサウンドを含む :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` ノードを保持する変数。"

msgid ""
"``teleport_pos``: A variable to hold the position the player will be "
"teleported to when the VR controller teleports the player."
msgstr ""
"``teleport_pos``: VRコントローラーがプレイヤーをテレポートするときにプレイ"
"ヤーがテレポートされる位置を保持する変数。"

msgid ""
"``teleport_mesh``: A variable to hold the :ref:`MeshInstance "
"<class_MeshInstance>` node used to show where the player is teleporting to."
msgstr ""
"``teleport_mesh``: プレイヤーのテレポート先を示すために使用される :ref:"
"`MeshInstance <class_MeshInstance>` ノードを保持する変数。"

msgid ""
"``teleport_button_down``: A variable used to track whether the controller's "
"teleport button is held down. This will be used to detect if this VR "
"controller is trying to teleport the player."
msgstr ""
"``teleport_button_down``: コントローラーのテレポートボタンが押されているかど"
"うかを追跡するために使用される変数。これは、このVRコントローラーがプレイヤー"
"をテレポートしようとしているかどうかを検出するために使用されます。"

msgid ""
"``teleport_raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` "
"node used to calculate the teleport position. This node also has a :ref:"
"`MeshInstance <class_MeshInstance>` that acts as a 'laser sight' for aiming."
msgstr ""
"``teleport_raycast``: テレポート位置の計算に使用される :ref:`Raycast "
"<class_Raycast>` ノードを保持する変数。このノードには、照準の「レーザーサイ"
"ト」 として機能する :ref:`MeshInstance <class_MeshInstance>` もあります。"

msgid ""
"``CONTROLLER_DEADZONE``: A constant to define the deadzone for both the "
"trackpad and the joystick on the VR controller. See the note below for more "
"information."
msgstr ""
"``CONTROLLER_DEADZONE``: トラックパッドとVRコントローラーのジョイスティックの"
"両方のデッドゾーンを定義する定数。詳細については、以下の注を参照してくださ"
"い。"

msgid ""
"``MOVEMENT_SPEED``: A constant to define the speed the player moves at when "
"using the trackpad/joystick to move artificially."
msgstr ""
"``MOVEMENT_SPEED``: トラックパッド/ジョイスティックを使用して人為的に移動する"
"ときにプレイヤーが移動する速度を定義する定数。"

msgid ""
"``CONTROLLER_RUMBLE_FADE_SPEED``: A constant to define how fast the VR "
"controller rumble fades."
msgstr ""
"``CONTROLLER_RUMBLE_FADE_SPEED``: VRコントローラーのランブルフェードの速度を"
"定義する定数。"

msgid ""
"``directional_movement``: A variable to hold whether this VR controller is "
"moving the player using the touchpad/joystick."
msgstr ""
"``directional_movement``: このVRコントローラーがタッチパッド/ジョイスティック"
"を使用してプレイヤーを動かしているかどうかを保持する変数。"

msgid ""
"You can find a great article explaining all about how to handle touchpad/"
"joystick dead zones `here <https://web.archive.org/web/20191208161810/http://"
"www.third-helix.com/2013/04/12/doing-thumbstick-dead-zones-right.html>`__."
msgstr ""
"ジョイパッド / コントローラーのデッドゾーンの処理方法について、すべてを説明す"
"る素晴らしい記事が\\ `ここにあります <https://web.archive.org/"
"web/20191208161810/http://www.third-helix.com/2013/04/12/doing-thumbstick-"
"dead-zones-right.html>`_ (英語)。"

msgid ""
"We are using a translated version of the scaled radial dead zone code "
"provided in that article for the VR controller's joystick/touchpad. The "
"article is a great read, and I highly suggest giving it a look!"
msgstr ""
"VRコントローラーのジョイスティック/タッチパッド用にその記事で提供されているス"
"ケーリングされた放射状デッドゾーンコードの翻訳バージョンを使用しています。こ"
"の記事は素晴らしい読み物です。ぜひご覧ください！"

msgid ""
"That is quite a few class variables. Most of them are used to hold "
"references to nodes we will need throughout the code. Next let's start "
"looking at the functions, starting with the ``_ready`` function."
msgstr ""
"これはかなりの数のクラス変数です。それらのほとんどは、コード全体で必要なノー"
"ドへの参照を保持するために使用されます。次に ``_ready`` 関数から始めて、関数"
"を見てみましょう。"

msgid "``_ready`` function step-by-step explanation"
msgstr "``_ready`` 関数のステップごとの説明"

msgid ""
"First we tell Godot to silence the warnings about not using the values "
"returned by the ``connect`` function. We will not need the returned values "
"for this tutorial."
msgstr ""
"まず、 ``connect`` 関数によって返された値を使用しないことに関する警告を黙らせ"
"るようにGodotに指示します。このチュートリアルでは戻り値は必要ありません。"

msgid ""
"Next we get the :ref:`Raycast <class_Raycast>` node we are going to use for "
"determining the position for teleporting and assign it to the "
"``teleport_raycast`` variable. We then get the :ref:`MeshInstance "
"<class_MeshInstance>` node that we will use to show where the player will be "
"teleporting to. The node we are using for teleporting is a child of the "
"``Game`` scene. We do this so the teleport mesh node is not effected by "
"changes in the VR controller, and so the teleport mesh can be used by both "
"VR controllers."
msgstr ""
"次に、テレポートの位置を決定するために使用する :ref:`Raycast "
"<class_Raycast>` ノードを取得し、それを ``teleport_raycast`` 変数に割り当てま"
"す。次に、プレイヤーがテレポートする場所を示すために使用する :ref:"
"`MeshInstance <class_MeshInstance>` ノードを取得します。テレポートに使用して"
"いるノードは、\\ ``Game`` シーンの子です。これにより、テレポートメッシュノー"
"ドがVRコントローラーの変更の影響を受けなくなり、テレポートメッシュを両方のVR"
"コントローラーで使用できるようになります。"

msgid ""
"Then the ``teleport_button_down`` variable is set to false, ``teleport_mesh."
"visible`` is set to ``false``, and ``teleport_raycast.visible`` is set to "
"``false``. This sets up the variables for teleporting the player into their "
"initial, not teleporting the player, state."
msgstr ""
"次に、\\ ``teleport_button_down`` 変数がfalseに設定され、\\ ``teleport_mesh."
"visible`` と ``teleport_raycast.visible`` が共に ``false`` に設定されます。こ"
"れは、プレイヤーをテレポートするのではなく、初期状態にプレイヤーをテレポート"
"するための変数を設定します。"

msgid ""
"The code then gets the ``grab_area`` node, the ``grab_raycast`` node, and "
"the ``grab_pos_node`` node and assigns them all to their respective "
"variables for use later."
msgstr ""
"次に、コードは ``grab_area`` ノード、\\ ``grab_raycast`` ノード、および "
"``grab_pos_node`` ノードを取得し、それらをすべて後で使用するためにそれぞれの"
"変数に割り当てます。"

msgid ""
"Next the ``grab_mode`` is set to ``AREA`` so the VR controller will attempt "
"to grab objects using the :ref:`Area <class_Area>` node defined in "
"``grab_area`` when the VR controller's grab/grip button is pressed. We also "
"set the ``grab_raycast`` node's ``visible`` property to ``false`` so the "
"'laser sight' child node of ``grab_raycast`` is not visible."
msgstr ""
"次に ``grab_mode`` が ``AREA`` に設定されているため、VRコントローラーのグラ"
"ブ/グリップボタンが押されると、VRコントローラーは ``grab_area`` で定義され"
"た :ref:`Area <class_Area>` ノードを使用してオブジェクトをつかもうとします。"
"また、\\ ``grab_raycast`` ノードの ``visible`` プロパティを ``false`` に設定"
"して、\\ ``grab_raycast`` の ``laser sight`` 子ノードが表示されないようにしま"
"す。"

msgid ""
"After that we connect the ``body_entered`` and ``body_exited`` signals from "
"the ``Sleep_Area`` node in the VR controller to the ``sleep_area_entered`` "
"and ``sleep_area_exited`` functions. The ``sleep_area_entered`` and "
"``sleep_area_exited`` functions will be used to make :ref:`RigidBody "
"<class_RigidBody>` nodes unable to sleep when nearby the VR controller."
msgstr ""
"その後、VRコントローラーの ``Sleep_Area`` ノードからの ``body_entered`` およ"
"び ``body_exited`` シグナルを ``sleep_area_entered`` および "
"``sleep_area_exited`` 関数に接続します。\\ ``sleep_area_entered`` および "
"``sleep_area_exited`` 関数は、VRコントローラーの近くでスリープすることができ"
"ない :ref:`RigidBody <class_RigidBody>` ノードを作成するために使用されます。"

msgid ""
"Then the ``hand_mesh`` and ``hand_pickup_drop_sound`` nodes are gotten and "
"assigned them to their respective variables for use later."
msgstr ""
"次に、\\ ``hand_mesh`` および ``hand_pickup_drop_sound`` ノードが取得され、後"
"で使用するためにそれぞれの変数に割り当てられます。"

msgid ""
"Finally, the ``button_pressed`` and ``button_release`` signals in the :ref:"
"`ARVRController <class_ARVRController>` node, which the VR controller "
"extends, are connected to the ``button_pressed`` and ``button_released`` "
"functions respectively. This means that when a button on the VR controller "
"is pressed or released, the ``button_pressed`` or ``button_released`` "
"functions defined in this script will be called."
msgstr ""
"最後に、VRコントローラーが拡張する :ref:`ARVRController "
"<class_ARVRController>` ノードの ``button_pressed`` および "
"``button_release`` シグナルは 、それぞれ ``button_pressed`` および "
"``button_released`` 関数に接続されます。つまり、VRコントローラーのボタンが押"
"されたり離されたりすると、このスクリプトで定義されている ``button_pressed`` "
"または ``button_released`` 関数が呼び出されます。"

msgid "``_physics_process`` function step-by-step explanation"
msgstr "``_physics_process`` 関数のステップごとの説明"

msgid ""
"First we check to see if the ``rumble`` variable is more than zero. If the "
"``rumble`` variable, which is a property of the :ref:`ARVRController "
"<class_ARVRController>` node, is more than zero then the VR controller "
"rumbles."
msgstr ""
"まず、\\ ``rumble`` 変数がゼロ以上かどうかを確認します。\\ :ref:"
"`ARVRController <class_ARVRController>` ノードのプロパティである ``rumble`` "
"変数がゼロより大きい場合、VRコントローラーが鳴ります。"

msgid ""
"If the ``rumble`` variable is more than zero, then we reduce the rumble by "
"``CONTROLLER_RUMBLE_FADE_SPEED`` every second by subtracting "
"``CONTROLLER_RUMBLE_FADE_SPEED`` multiplied by delta. There is then a ``if`` "
"condition to check if ``rumble`` is less than zero, which sets ``rumble`` to "
"zero if its value is less than zero."
msgstr ""
"``rumble`` 変数がゼロより大きい場合、 ``CONTROLLER_RUMBLE_FADE_SPEED`` にデル"
"タを掛けることにより、毎秒 ``CONTROLLER_RUMBLE_FADE_SPEED`` によってrumbleを"
"減らします。次に、\\ ``rumble`` がゼロ未満かどうかをチェックする ``if`` 条件"
"式があり、その値がゼロ未満の場合に ``rumble`` をゼロに設定します。"

msgid ""
"This small section of code is all we need for reducing the VR controller's "
"rumble. Now when we set ``rumble`` to a value, this code will automatically "
"make it fade over time."
msgstr ""
"この小さなコードのセクションは、VRコントローラーの振動を減らすために必要なす"
"べてです。 ``rumble``に値を設定すると、このコードは時間とともに自動的にフェー"
"ドします。"

msgid ""
"The first section of code checks to see if the ``teleport_button_down`` "
"variable is equal to ``true``, which means this VR controller is trying to "
"teleport."
msgstr ""
"コードの最初のセクションでは、\\ ``teleport_button_down`` 変数が ``true`` に"
"等しいかどうかを確認します。これは、このVRコントローラーがテレポートしようと"
"していることを意味します。"

msgid ""
"If ``teleport_button_down`` is equal to ``true``, we force the "
"``teleport_raycast`` :ref:`Raycast <class_Raycast>` node to update using the "
"``force_raycast_update`` function. The ``force_raycast_update`` function "
"will update the properties within the :ref:`Raycast <class_Raycast>` node "
"with the latest version of the physics world."
msgstr ""
"``teleport_button_down`` が ``true`` に等しい場合、\\ "
"``force_raycast_update`` 関数を使用して ``teleport_raycast`` :ref:`Raycast "
"<class_Raycast>` ノードを強制的に更新します。\\ ``force_raycast_update`` 関数"
"は、\\ :ref:`Raycast <class_Raycast>` ノード内のプロパティを物理世界の最新"
"バージョンで更新します。"

msgid ""
"The code then checks to see if the ``teleport_raycast`` collided with "
"anything by checking of the ``is_colliding`` function in "
"``teleport_raycast`` is true. If the :ref:`Raycast <class_Raycast>` collided "
"with something, we then check to see if the :ref:`PhysicsBody "
"<class_PhysicsBody>` the raycast collided with is a :ref:`StaticBody "
"<class_StaticBody>` or not. We then check to see if the collision normal "
"vector returned by the raycast is greater than or equal to ``0.85`` on the Y "
"axis."
msgstr ""
"次に、コードは ``teleport_raycast`` の ``is_colliding`` 関数をチェックするこ"
"とにより、\\ ``teleport_raycast`` が何かと衝突したかどうかを確認します。\\ :"
"ref:`Raycast <class_Raycast>` が何かと衝突した場合、レイキャストが衝突した :"
"ref:`PhysicsBody <class_PhysicsBody>` が :ref:`StaticBody "
"<class_StaticBody>` かどうかを確認します。次に、レイキャストによって返された"
"コリジョン法線ベクトルがY軸の `` 0.85`` 以上であるかどうかを確認します。"

msgid ""
"We do this because we do not want the user to be able to teleport onto "
"RigidBody nodes and we only want the player to be able to teleport on floor-"
"like surfaces."
msgstr ""
"これは、ユーザーがRigidBodyノードにテレポートできないようにし、床のような表面"
"にプレイヤーがテレポートできるようにするためです。"

msgid ""
"If all these conditions are met, then we assign the ``teleport_pos`` "
"variable to the ``get_collision_point`` function in ``teleport_raycast``. "
"This will assign ``teleport_pos`` to the position the raycast collided at in "
"world space. We then move the ``teleport_mesh`` to the world position stored "
"in ``teleport_pos``."
msgstr ""
"これらすべての条件が満たされている場合、\\ ``teleport_raycast`` の "
"``get_collision_point`` 関数に ``teleport_pos`` 変数を割り当てます。これは、"
"レイスペースがワールド空間で衝突した位置に ``teleport_pos`` を割り当てます。"
"それから ``teleport_mesh`` を ``teleport_pos`` に保存されているワールド位置に"
"移動します。"

msgid ""
"This section of code will get the position the player is aiming at with the "
"teleportation raycast and update the teleportation mesh, giving a visual "
"update on where the user will be teleporting to when the release the "
"teleport button."
msgstr ""
"コードのこのセクションは、プレイヤーがテレポートレイキャストで狙っている位置"
"を取得し、テレポートメッシュを更新し、テレポートボタンを離したときにユーザー"
"がテレポートする場所を視覚的に更新します。"

msgid ""
"The next section of code first checks to see if the VR controller is active "
"through the ``get_is_active`` function, which is defined by :ref:"
"`ARVRController <class_ARVRController>`. If the VR controller is active, "
"then it calls the ``_physics_process_update_controller_velocity`` function."
msgstr ""
"コードの次のセクションでは、最初に、\\ :ref:`ARVRController "
"<class_ARVRController>` で定義される ``get_is_active`` 関数を介してVRコント"
"ローラーがアクティブかどうかを確認します。VRコントローラーがアクティブな場"
"合、\\ ``_ physics_process_update_controller_velocity`` 関数を呼び出します。"

msgid ""
"The ``_physics_process_update_controller_velocity`` function will calculate "
"the VR controller's velocity through changes in position. It is not perfect, "
"but this process gets a rough idea of the velocity of the VR controller, "
"which is fine for the purposes of this tutorial."
msgstr ""
"``_physics_process_update_controller_velocity`` 関数は、位置の変化を通してVR"
"コントローラーの速度を計算します。それは完全ではありませんが、このプロセスは"
"VRコントローラーの速度の大まかな概念を取得します。これは、このチュートリアル"
"の目的には適しています。"

msgid ""
"The next section of code checks to see if the VR controller is holding an "
"object by checking to see if the ``held_object`` variable is not equal to "
"``null``."
msgstr ""
"コードの次のセクションでは、\\ ``held_object`` 変数が ``null`` と等しくないか"
"どうかを確認して、VRコントローラーがオブジェクトを保持しているかどうかを確認"
"します。"

msgid ""
"If the VR controller is holding an object, we first store it's scale in a "
"temporary variable called ``held_scale``. We then set the "
"``global_transform`` of the held object to the ``global_transform`` of the "
"``held_object`` node. This will make the held object have the same position, "
"rotation, and scale of the ``grab_pos_node`` node in world space."
msgstr ""
"VRコントローラーがオブジェクトを保持している場合、最初に ``held_scale`` と呼"
"ばれる一時変数にそのスケールを保存します。次に、保持されたオブジェクトの "
"``global_transform`` を ``held_object`` ノードの ``global_transform`` に設定"
"します。これにより、保持されたオブジェクトは、ワールド空間の "
"``grab_pos_node`` ノードと同じ位置、回転、スケールになります。"

msgid ""
"However, because we do not want the held object to change in scale when it "
"is grabbed, we need to set the ``scale`` property of the ``held_object`` "
"node back to ``held_scale``."
msgstr ""
"ただし、保持されたオブジェクトが取得されたときにスケールが変更されないように"
"するには、\\ ``held_object`` ノードの ``scale`` プロパティを ``held_scale`` "
"に戻す必要があります。"

msgid ""
"This section of code will keep the held object in the same position and "
"rotation as the VR controller, keeping it synced with the VR controller."
msgstr ""
"コードのこのセクションは、保持されたオブジェクトをVRコントローラーと同じ位置"
"と回転に保ち、VRコントローラーとの同期を維持します。"

#, fuzzy
msgid ""
"Finally, the last section of code simply calls the "
"``_physics_process_directional_movement`` function. This function contains "
"all the code for moving the player when the touchpad/joystick on the VR "
"controller moves."
msgstr ""
"最後に、コードの最後のセクションでは、単に "
"``_physics_process_directional_movement`` 関数を呼び出します。この関数には、"
"VRコントローラーのタッチパッド/ジョイスティックが移動したときにプレイヤーを移"
"動するためのすべてのコードが含まれています。"

msgid ""
"``_physics_process_update_controller_velocity`` function step-by-step "
"explanation"
msgstr ""
"``_physics_process_update_controller_velocity`` 関数のステップごとの説明"

msgid ""
"First this function resets the ``controller_velocity`` variable to zero :ref:"
"`Vector3 <class_Vector3>`."
msgstr ""
"最初に、この関数は ``controller_velocity``　変数をゼロにリセットします :ref:"
"`Vector3 <class_Vector3>`\\ 。"

msgid ""
"Then we check to see if there are any stored/cached VR controller velocities "
"saved in the ``prior_controller_velocities`` array. We do this by checking "
"to see if the ``size()`` function returns a value greater than ``0``. If "
"there are cached velocities within ``prior_controller_velocities``, then we "
"iterate through each of the stored velocities using a ``for`` loop."
msgstr ""
"次に、\\ ``prior_controller_velocities`` 配列に保存/キャッシュされたVRコント"
"ローラーの速度が保存されているかどうかを確認します。\\ ``size()`` 関数が "
"``0`` より大きい値を返すかどうかを確認することでこれを行います。\\ "
"``prior_controller_velocities`` 内にキャッシュされた速度がある場合、\\ "
"``for`` ループを使用して、保存されている各速度を反復処理します。"

msgid ""
"For each of the cached velocities, we simply add its value to "
"``controller_velocity``. Once the code has gone through all of the cached "
"velocities in ``prior_controller_velocities``, we divide "
"``controller_velocity`` by the size of the ``prior_controller_velocities`` "
"array, which will give us the combined velocity value. This helps take the "
"previous velocities into account, making the direction of the controller's "
"velocity more accurate."
msgstr ""
"キャッシュされた速度のそれぞれについて、その値を ``controller_velocity`` に加"
"算するだけです。コードが ``prior_controller_velocities`` のキャッシュされたす"
"べての速度を通過したら、\\ ``controller_velocity`` を "
"``prior_controller_velocities`` 配列のサイズで除算します。これにより、合成さ"
"れた速度値が得られます。これにより、以前の速度が考慮され、コントローラーの速"
"度の方向がより正確になります。"

msgid ""
"Next we calculate the change in position the VR controller has taken since "
"the last ``_physics_process`` function call. We do this by subtracting "
"``prior_controller_position`` from the global position of the VR controller, "
"``global_transform.origin``. This will give us a :ref:`Vector3 "
"<class_Vector3>` that points from the position in "
"``prior_controller_position`` to the current position of the VR controller, "
"which we store in a variable called ``relative_controller_position``."
msgstr ""
"次に、最後の ``_physics_process`` 関数呼び出し以降にVRコントローラーが取った"
"位置の変化を計算します。これを行うには、VRコントローラーのグローバル位置 "
"``global_transform.origin`` から ``prior_controller_position`` を減算します。"
"これにより、\\ ``prior_controller_position`` の位置からVRコントローラーの現在"
"の位置を指す :ref:`Vector3 <class_Vector3>` が得られ、これを "
"``relative_controller_position`` という変数に保存します。"

msgid ""
"Next we add the change in position to ``controller_velocity`` so the latest "
"change in position is taken into account in the velocity calculation. We "
"then add ``relative_controller_position`` to ``prior_controller_velocities`` "
"so it can be taken into account on the next calculation of the VR "
"controller's velocity."
msgstr ""
"次に、位置の変更を ``controller_velocity`` に加算して、位置の最新の変更が速度"
"計算で考慮されるようにします。次に、\\ ``relative_controller_position`` を "
"``prior_controller_velocities`` に加算して、次回のVRコントローラーの速度計算"
"で考慮できるようにします。"

msgid ""
"Then ``prior_controller_position`` is updated with the global position of "
"the VR controller, ``global_transform.origin``. We then divide "
"``controller_velocity`` by ``delta`` so the velocity is higher, giving "
"results like those we expect, while still being relative to the amount of "
"time that has passed. It is not a perfect solution, but the results look "
"decent most of the time and for the purposes of this tutorial, it is good "
"enough."
msgstr ""
"次に、\\ ``prior_controller_position`` がVRコントローラーのグローバル位置 "
"``global_transform.origin`` で更新されます。次に、\\ ``controller_velocity`` "
"を ``delta`` で除算し、速度を上げて、期待通りの結果をもたらしますが、経過時間"
"との相対的な関係を維持します。これは完全な解決策ではありませんが、ほとんどの"
"場合、結果は適切に見えます。このチュートリアルの目的には十分です。"

msgid ""
"Finally, the function checks to see if the ``prior_controller_velocities`` "
"has more than ``30`` velocities cached by checking if the ``size()`` "
"function returns a value greater than ``30``. If there are more than ``30`` "
"cached velocities stored in ``prior_controller_velocities``, then we simply "
"remove the oldest cached velocity by calling the ``remove`` function and "
"passing in a index position of ``0``."
msgstr ""
"最後に、関数は、\\ ``size()`` 関数が ``30`` より大きい値を返すかどうかを"
"チェックすることにより、\\ ``prior_controller_velocities`` が ``30`` を超える"
"速度をキャッシュしているかどうかを確認します。\\ "
"``prior_controller_velocities`` に ``30`` を超えるキャッシュ速度が保存されて"
"いる場合、\\ ``remove`` 関数を呼び出してインデックス位置 ``0`` を渡すことで、"
"最も古いキャッシュ速度を削除します。"

msgid ""
"What this function ultimately does is that it gets a rough idea of the VR "
"controller's velocity by calculating the VR controller's relative changes in "
"position over the last thirty ``_physics_process`` calls. While this is not "
"perfect, it gives a decent idea of how fast the VR controller is moving in "
"3D space."
msgstr ""
"この関数が最終的に行うことは、最後の30回の ``_physics_process`` 呼び出しでの"
"VRコントローラーの相対的な位置の変化を計算することにより、VRコントローラーの"
"速度の大まかなアイデアを得るということです。これは完全ではありませんが、VRコ"
"ントローラーが3D空間でどれだけ速く動いているかについての適切なアイデアを提供"
"します。"

msgid ""
"``_physics_process_directional_movement`` function step-by-step explanation"
msgstr "``_physics_process_directional_movement`` 関数のステップごとの説明"

msgid ""
"First this function gets the axes for the trackpad and the joystick and "
"assigns them to :ref:`Vector2 <class_Vector2>` variables called "
"``trackpad_vector`` and ``joystick_vector`` respectively."
msgstr ""
"最初に、この関数はトラックパッドとジョイスティックの軸を取得し、それらをそれ"
"ぞれ ``trackpad_vector`` および ``joystick_vector`` と呼ばれる :ref:`Vector2 "
"<class_Vector2>` 変数に割り当てます。"

msgid ""
"You may need to remap the joystick and/or touchpad index values depending on "
"your VR headset and controller. The inputs in this tutorial are the index "
"values of a Windows Mixed Reality headset."
msgstr ""
"VRヘッドセットとコントローラーによっては、ジョイスティックやタッチパッドのイ"
"ンデックス値の再マッピングが必要になる場合があります。このチュートリアルの入"
"力は、Windows Mixed Realityヘッドセットのインデックス値です。"

msgid ""
"Then ``trackpad_vector`` and ``joystick_vector`` have their deadzones "
"account for. The code for this is detailed in the article below, with slight "
"changes as the code is converted from C# to GDScript."
msgstr ""
"次に、\\ ``trackpad_vector`` と ``joystick_vector`` のデッドゾーンを考慮しま"
"す。このコードは以下の記事で詳しく説明されていますが、コードがC#からGDScript"
"に変換されたので若干の変更が加えられています。"

msgid ""
"Once the ``trackpad_vector`` and ``joystick_vector`` variables have had "
"their deadzones account for, the code then gets the forward and right "
"direction vectors relative to the global transform of the :ref:`ARVRCamera "
"<class_ARVRCamera>`. What this does is that it gives us vectors that point "
"forward and right relative to the rotation of the user camera, the :ref:"
"`ARVRCamera <class_ARVRCamera>`, in world space. These vectors point in the "
"same direction of the blue and red arrows when you select an object in the "
"Godot editor with the ``local space mode`` button enabled. The forward "
"direction vector is stored in a variable called ``forward_direction``, while "
"the right direction vector is stored in a variable called "
"``right_direction``."
msgstr ""
"``trackpad_vector`` 変数と ``joystick_vector`` 変数のデッドゾーンが考慮される"
"と、コードは :ref:`ARVRCamera <class_ARVRCamera>` のグローバルトランスフォー"
"ムに関連する順方向および右方向のベクトルを取得します。これが行うことは、ワー"
"ルド空間でユーザーカメラ :ref:`ARVRCamera <class_ARVRCamera>` の回転に対して"
"前方および右側を指すベクトルを提供することです。これらのベクトルは、\\ ``ロー"
"カル空間モード`` ボタンを有効にしてGodotエディタでオブジェクトを選択すると、"
"青と赤の矢印の同じ方向を指します。順方向ベクトルは ``forward_direction`` と呼"
"ばれる変数に保存され、右方向ベクトルは ``right_direction`` と呼ばれる変数に保"
"存されます。"

msgid ""
"Next the code adds the ``trackpad_vector`` and ``joystick_vector`` variables "
"together and normalizes the results using the ``normalized`` function. This "
"gives us the combined movement direction of both input devices, so we can "
"use a single :ref:`Vector2 <class_Vector2>` for moving the user. We assign "
"the combined direction to a variable called ``movement_vector``."
msgstr ""
"次に、コードは ``trackpad_vector`` 変数と ``joystick_vector`` 変数を一緒に加"
"算し、\\ ``normalized`` 関数を使用して結果を正規化します。これにより、両方の"
"入力デバイスの移動方向が結合されるため、ユーザーを移動するために単一の :ref:"
"`Vector2 <class_Vector2>` を使用できます。合成された方向を "
"``movement_vector`` と呼ばれる変数に割り当てます。"

msgid ""
"Then we calculate the distance the user will move forward, relative to the "
"forward direction stored in ``forward_direction``. To calculate this, we "
"multiply ``forward_direction`` by ``movement_vector.x``, ``delta``, and "
"``MOVEMENT_SPEED``. This will give us the distance the user will move "
"forward when the trackpad/joystick is pushed forward or backwards. We assign "
"this to a variable called ``movement_forward``."
msgstr ""
"次に、\\ ``forward_direction`` に保存されている前方方向を基準にして、ユーザー"
"が前方に移動する距離を計算します。これを計算するために、\\ "
"``forward_direction`` に ``movement_vector.x``\\ 、\\ ``delta``\\ 、\\ "
"``MOVEMENT_SPEED`` を掛けます。これにより、トラックパッド/ジョイスティックを"
"前方または後方に押したときにユーザーが前(後)に移動する距離がわかります。これ"
"を ``movement_forward`` という変数に割り当てます。"

msgid ""
"We do a similar calculation for the distance the user will move right, "
"relative to the right direction stored in ``right_direction``. To calculate "
"the distance the user will move right, we multiply ``right_direction`` by "
"``movement_vector.y``, ``delta``, and ``MOVEMENT_SPEED``. This will give us "
"the distance the user will move right when the trackpad/joystick is pushed "
"right or left. We assign this to a variable called ``movement_right``."
msgstr ""
"``right_direction`` に保存されている右の方向を基準にして、ユーザーが右に移動"
"する距離についても同様の計算を行います。ユーザーが右に移動する距離を計算する"
"には、\\ ``right_direction`` に ``movement_vector.y``\\ 、\\ "
"``delta``\\ 、\\ ``MOVEMENT_SPEED`` を乗算します。これにより、トラックパッド/"
"ジョイスティックを右または左に押したときにユーザーが(左)右に移動する距離がわ"
"かります。これを ``movement_right`` という変数に割り当てます。"

msgid ""
"Next we remove any movement on the ``Y`` axis of ``movement_forward`` and "
"``movement_right`` by assigning their ``Y`` values to ``0``. We do this so "
"the user cannot fly/fall simply by moving the trackpad or joystick. Without "
"doing this, the player could fly in the direction they are facing."
msgstr ""
"次に、\\ ``movement_forward`` と ``movement_right`` の ``Y`` 軸上の動きを、そ"
"れらの ``Y`` 値を ``0`` に割り当てることで削除します。これは、ユーザーがト"
"ラックパッドまたはジョイスティックを動かすだけで飛行/落下できないようにするた"
"めです。これを行わないと、プレイヤーは向いている方向に飛ぶことができます。"

msgid ""
"Finally, we check to see if the ``length`` function on ``movement_right`` or "
"``movement_forward`` is greater than ``0``. If it is, then we need to move "
"the user. To move the user, we perform a global translation to the :ref:"
"`ARVROrigin <class_ARVROrigin>` node using ``get_parent().global_translate`` "
"and pass in the ``movement_right`` variable with the ``movement_forward`` "
"variable added to it. This will move the player in the direction the "
"trackpad/joystick is pointing, relative to the rotation of the VR headset. "
"We also set the ``directional_movement`` variable to ``true`` so the code "
"knows this VR controller is moving the player."
msgstr ""
"最後に、\\ ``movement_right`` または ``movement_forward`` の ``length`` 関数"
"が ``0`` より大きいかどうかを確認します。そうである場合、ユーザーを移動する必"
"要があります。ユーザーを移動するには、\\ ``get_parent().global_translate`` を"
"使用して :ref:`ARVROrigin <class_ARVROrigin> ノードへのグローバル変換を実行"
"し、\\ ``movement_forward`` 変数を加算した ``movement_right`` 変数を渡しま"
"す。これにより、VRヘッドセットの回転に対して、トラックパッド/ジョイスティック"
"が指している方向にプレイヤーが移動します。また、\\ ``directional_movement`` "
"変数を ``true`` に設定して、このVRコントローラーがプレイヤーを動かしているこ"
"とをコードが認識できるようにします。"

msgid ""
"If the ``length`` function on ``movement_right`` or ``movement_forward`` is "
"less than or equal to ``0``, then we simply set the ``directional_movement`` "
"variable to ``false`` so the code knows this VR controller is not moving the "
"player."
msgstr ""
"``movement_right`` または ``movement_forward`` の ``length`` 関数が ``0`` 以"
"下の場合、\\ ``directional_movement`` 変数を ``false`` に設定するだけで、コー"
"ドはこのVRコントローラーがプレイヤーを動かしていないことを認識します。"

msgid ""
"What this function ultimately does is takes the input from the VR "
"controller's trackpad and joystick and moves the player in the direction the "
"player is pushing them. Movement is relative to the rotation of the VR "
"headset, so if the player pushes forward and turns their head to the left, "
"they will move to the left."
msgstr ""
"この関数が最終的に行うことは、VRコントローラーのトラックパッドとジョイス"
"ティックから入力を受け取り、プレイヤーが押している方向にプレイヤーを移動させ"
"ることです。動きはVRヘッドセットの回転に関連するため、プレイヤーが前方に押し"
"て頭を左に回すと、左に動きます。"

msgid "``button_pressed`` function step-by-step explanation"
msgstr "``button_pressed`` 関数のステップごとの説明"

msgid ""
"This function checks to see if the VR button that was just pressed is equal "
"to one of the VR buttons used in this project. The ``button_index`` variable "
"is passed in by the ``button_pressed`` signal in :ref:`ARVRController "
"<class_ARVRController>`, which we connected in the ``_ready`` function."
msgstr ""
"この関数は、押されたばかりのVRボタンがこのプロジェクトで使用されているVRボタ"
"ンのいずれかと等しいかどうかを確認します。\\ ``button_index`` 変数は、\\ "
"``_ready`` 関数で接続した :ref:`ARVRController <class_ARVRController>` の "
"``button_pressed`` シグナルによって渡されます。"

msgid ""
"There are only three buttons we are looking for in this project: the trigger "
"button, the grab/grip button, and the menu button."
msgstr ""
"このプロジェクトで探しているボタンは、トリガーボタン、グラブ/グリップボタン、"
"メニューボタンの3つだけです。"

msgid ""
"You may need to remap these button index values depending on your VR headset "
"and controller. The inputs in this tutorial are the index values of a "
"Windows Mixed Reality headset."
msgstr ""
"VRヘッドセットとコントローラーによっては、これらのボタンインデックス値を再"
"マッピングする必要がある場合があります。このチュートリアルの入力は、Windows "
"Mixed Realityヘッドセットのインデックス値です。"

msgid ""
"First we check if the ``button_index`` is equal to ``15``, which should map "
"to the trigger button on the VR controller. If the button pressed is the "
"trigger button, then the ``_on_button_pressed_trigger`` function is called."
msgstr ""
"最初に、\\ ``button_index`` が ``15`` に等しいかどうかを確認します。これはVR"
"コントローラーのトリガーボタンにマップする必要があります。押されたボタンがト"
"リガーボタンである場合、\\ ``_on_button_pressed_trigger`` 関数が呼び出されま"
"す。"

msgid ""
"If the ``button_index`` is equal to ``2``, then the grab button was just "
"pressed. If the button pressed is the grab button, the "
"``_on_button_pressed_grab`` function is called."
msgstr ""
"``button_index`` が ``2`` に等しい場合、グラブボタンが押されたばかりです。押"
"されたボタンがグラブボタンの場合、\\ ``_on_button_pressed_grab`` 関数が呼び出"
"されます。"

msgid ""
"Finally, if the ``button_index`` is equal to ``1``, then the menu button was "
"just pressed. If the button pressed is the menu button, the "
"``_on_button_pressed_menu`` function is called."
msgstr ""
"最後に、\\ ``button_index`` が ``1`` に等しい場合、メニューボタンが押されたば"
"かりです。押されたボタンがメニューボタンの場合、\\ "
"``_on_button_pressed_menu`` 関数が呼び出されます。"

msgid "``_on_button_pressed_trigger`` function step-by-step explanation"
msgstr "``_on_button_pressed_trigger`` 関数のステップごとの説明"

msgid ""
"First this function checks to see if the VR controller is not holding by "
"checking if ``held_object`` is equal to ``null``. If the VR controller is "
"not holding anything, then we assume that the trigger press on the VR "
"controller was for teleporting. We then make sure that ``teleport_mesh."
"visible`` is equal to ``false``. We use this to tell if the other VR "
"controller is trying to teleport or not, as ``teleport_mesh`` will be "
"visible if the other VR controller is teleporting."
msgstr ""
"最初に、この関数は ``held_object`` が ``null`` に等しいかどうかを確認すること"
"により、VRコントローラーが何かを保持していないかどうかを確認します。 VRコント"
"ローラーが何も保持していない場合、VRコントローラーのトリガープレスはテレポー"
"ト用であると想定します。次に、\\ ``teleport_mesh.visible`` が ``false`` に等"
"しいことを確認します。これを使用して、他のVRコントローラーがテレポートしよう"
"としているかどうかを確認します。他のVRコントローラーがテレポートしている場合"
"は ``teleport_mesh`` が表示されるためです。"

msgid ""
"If ``teleport_mesh.visible`` is equal to ``false``, then we can teleport "
"with this VR controller. We set the ``teleport_button_down`` variable to "
"``true``, set ``teleport_mesh.visible`` to true, and set ``teleport_raycast."
"visible`` to ``true``. This will tell the code in ``_physics_process`` that "
"this VR controller is going to teleport, it will make the ``teleport_mesh`` "
"visible so the user knows where the are teleporting to, and will make "
"``teleport_raycast`` visible to the player has a 'laser sight' they can use "
"to aim the teleportation pos."
msgstr ""
"``teleport_mesh.visible`` が ``false`` に等しい場合、このVRコントローラーでテ"
"レポートできます。\\ ``teleport_button_down`` 変数を ``true`` に設定し、\\ "
"``teleport_mesh.visible`` および ``teleport_raycast.visible`` を共に ``true``"
"に設定します。これにより、\\ ``_physics_process`` のコードにこのVRコントロー"
"ラーがテレポートすることを通知し、\\ ``teleport_mesh`` を表示して、ユーザーが"
"テレポートする場所を認識させ、 ``teleport_raycast`` を表示して、プレイヤーが"
"テレポート位置を狙うために使用できる「レーザーサイト」を表示します。"

#, fuzzy
msgid ""
"If ``held_object`` is not equal to ``null``, then the VR controller is "
"holding something. We then check to see if the object that is being held, "
"``held_object``, extends a class called ``VR_Interactable_Rigidbody``. We "
"have not made ``VR_Interactable_Rigidbody`` yet, but "
"``VR_Interactable_Rigidbody`` will be a custom class we will use on all of "
"the special/custom :ref:`RigidBody <class_RigidBody>`-based nodes in the "
"project."
msgstr ""
"``held_object`` が ``null`` と等しくない場合、VRコントローラーは何かを保持し"
"ています。次に、保持されているオブジェクト ``held_object`` が "
"``VR_Interactable_Rigidbody`` というクラスを拡張しているかどうかを確認しま"
"す。まだ ``VR_Interactable_Rigidbody`` を作成していませんが、\\ "
"``VR_Interactable_Rigidbody`` は、プロジェクトのすべての special/custom :ref:"
"`RigidBody <class_RigidBody>` ベースのノードで使用するカスタムクラスになりま"
"す。"

msgid ""
"Don't worry, we will cover ``VR_Interactable_Rigidbody`` after this section!"
msgstr ""
"ご心配なく。\\ ``VR_Interactable_Rigidbody`` については、このセクションの後で"
"取りあげます！"

msgid ""
"If the ``held_object`` extends ``VR_Interactable_Rigidbody``, then we call "
"the ``interact`` function, so the held object can do whatever it is supposed "
"to do when the trigger is pressed and the object is held by the VR "
"controller."
msgstr ""
"``held_object`` が ``VR_Interactable_Rigidbody`` から拡張される場合、\\ "
"``interact`` 関数を呼び出すため、トリガーが押され、オブジェクトがVRコントロー"
"ラーによって保持されているときに、その保持されたオブジェクトが行うべきことを"
"実行できます。"

msgid "``_on_button_pressed_grab`` function step-by-step explanation"
msgstr "``_on_button_pressed_grab`` 関数のステップごとの説明"

msgid ""
"First this function checks to see if ``teleport_button_down`` is equal to "
"``true``. If it is, then it calls ``return``. We do this because we do not "
"want the user to be able to pick up objects while teleporting."
msgstr ""
"最初に、この関数は ``teleport_button_down`` が ``true`` に等しいかどうかを確"
"認します。もしそうなら、それは ``return`` を呼び出します。これは、ユーザーが"
"テレポート中にオブジェクトを取得できないようにするためです。"

msgid ""
"Then we check to see if the VR controller is currently not holding anything "
"by checking if ``held_object`` is equal to ``null``. If the VR controller is "
"not holding anything, then the ``_pickup_rigidbody`` function is called. If "
"the VR controller is holding something, ``held_object`` is not equal to "
"``null``, then the ``_throw_rigidbody`` function is called."
msgstr ""
"次に、\\ ``held_object`` が ``null`` に等しいかどうかを確認することにより、VR"
"コントローラーが現在何も保持していないかどうかを確認します。 VRコントローラー"
"が何も保持していない場合、\\ ``_pickup_rigidbody`` 関数が呼び出されます。VRコ"
"ントローラーが何かを保持している場合、\\ ``held_object`` が ``null`` と等しく"
"ない場合、\\ ``_throw_rigidbody`` 関数が呼び出されます。"

msgid ""
"Finally, the pick-up/drop sound is played by calling the ``play`` function "
"on ``hand_pickup_drop_sound``."
msgstr ""
"最後に、ピックアップ/ドロップサウンドは、\\ ``hand_pickup_drop_sound`` の "
"``play`` 関数を呼び出すことで再生されます。"

msgid "``_pickup_rigidbody`` function step-by-step explanation"
msgstr "``_pickup_rigidbody`` 関数のステップごとの説明"

msgid ""
"First the function makes a variable called ``rigid_body``, which we'll be "
"using to store the :ref:`RigidBody <class_RigidBody>` that the VR controller "
"is going to pick up, assuming there is a RigidBody to pick up."
msgstr ""
"最初に、関数は ``rigid_body`` と呼ばれる変数を作成します。これは、ピックアッ"
"プするRigidBodyがあると仮定して、VRコントローラーがピックアップする :ref:"
"`RigidBody <class_RigidBody>` を格納するために使用します。"

msgid ""
"Then the function checks to see if the ``grab_mode`` variable is equal to "
"``AREA``. If it is, then it gets all of the :ref:`PhysicsBody "
"<class_PhysicsBody>` nodes within the ``grab_area`` using the "
"``get_overlapping_bodies`` functions. This function will return an array of :"
"ref:`PhysicsBody <class_PhysicsBody>` nodes. We assign the array of :ref:"
"`PhysicsBody <class_PhysicsBody>` to a new variable called ``bodies``."
msgstr ""
"次に、関数は ``grab_mode`` 変数が ``AREA`` と等しいかどうかを確認します。そう"
"である場合、\\ ``get_overlapping_bodies`` 関数を使用して、\\ ``grab_area`` 内"
"のすべての :ref:`PhysicsBody <class_PhysicsBody>` ノードを取得します。この関"
"数は :ref:`PhysicsBody <class_PhysicsBody>` ノードの配列を返します。\\ :ref:"
"`PhysicsBody <class_PhysicsBody>` の配列を ``bodies`` と呼ばれる新しい変数に"
"割り当てます。"

msgid ""
"We then check to see if the length of the ``bodies`` variable is more than "
"``0``. If it is, we go through each of the :ref:`PhysicsBody "
"<class_PhysicsBody>` nodes in ``bodies`` using a for loop."
msgstr ""
"次に、\\ ``bodies`` 変数の長さが ``0`` を超えているかどうかを確認します。そう"
"である場合、forループを使用して ``body`` の :ref:`PhysicsBody "
"<class_PhysicsBody>` ノードのそれぞれを調べます。"

msgid ""
"For each :ref:`PhysicsBody <class_PhysicsBody>` node, we check if it is, or "
"extends, a :ref:`RigidBody <class_RigidBody>` node using ``if body is "
"RigidBody``, which will return ``true`` if the :ref:`PhysicsBody "
"<class_PhysicsBody>` node is or extends the :ref:`RigidBody "
"<class_RigidBody>` node. If the object is a :ref:`RigidBody "
"<class_RigidBody>`, then we check to make sure there is not a variable/"
"constant called ``NO_PICKUP`` defined in the body. We do this because if you "
"want to have :ref:`RigidBody <class_RigidBody>` nodes that cannot be picked "
"up, all you have to do is define a constant/variable called ``NO_PICKUP`` "
"and the VR controller will be unable to pick it up. If the :ref:`RigidBody "
"<class_RigidBody>` node does not have a variable/constant defined with the "
"name ``NO_PICKUP``, then we assign the ``rigid_body`` variable to the :ref:"
"`RigidBody <class_RigidBody>` node and break the for loop."
msgstr ""
"各 :ref:`PhysicsBody <class_PhysicsBody>` ノードにごとに、\\ ``if body is "
"RigidBody`` を使用して :ref:`RigidBody <class_RigidBody>` ノードもしくは、そ"
"れを拡張したものかを確認し、\\ :ref:`PhysicsBody <class_PhysicsBody>` ノード"
"が :ref` RigidBody <class_RigidBody> ` ノードもしくは、それを拡張したものの場"
"合は ``true`` を返します。オブジェクトが :ref:`RigidBody <class_RigidBody>` "
"の場合、ボディに ``NO_PICKUP`` という変数/定数が定義されていないことを確認し"
"ます。これは、ピックアップできない :ref:`RigidBody <class_RigidBody>` ノード"
"が必要な場合、\\ ``NO_PICKUP`` という定数/変数を定義するだけで、VRコントロー"
"ラーがそれを拾えなくなります。\\ :ref:`RigidBody <class_RigidBody>` ノードに "
"``NO_PICKUP`` という名前で定義された変数/定数がない場合、\\ ``refid_body`` 変"
"数を :ref:`RigidBody <class_RigidBody>` ノードに割り当て、forループを中断しま"
"す。"

msgid ""
"What this section of code does is goes through all of the physics bodies "
"within the ``grab_area`` and grabs the first :ref:`RigidBody "
"<class_RigidBody>` node that does not have a variable/constant named "
"``NO_PICKUP`` and assigns it to the ``rigid_body`` variable so we can do "
"some additional post processing later in this function."
msgstr ""
"コードのこのセクションは、\\ ``grab_area`` 内のすべてのphysicsボディを通過"
"し、\\ ``NO_PICKUP`` という名前の変数/定数を持たない最初の :ref:`RigidBody "
"<class_RigidBody>` ノードを取得します。それを ``rigid_body`` 変数に割り当てる"
"ので、この関数の後半で追加の後処理を行うことができます。"

msgid ""
"If the ``grab_mode`` variable is not equal to ``AREA``, we then check to see "
"if it is equal to ``RAYCAST`` instead. If it is equal to ``RAYCAST``, we "
"force the ``grab_raycast`` node to update using the ``force_raycast_update`` "
"function. The ``force_raycast_update`` function will update the :ref:"
"`Raycast <class_Raycast>` with the latest changes in the physics world. We "
"then check to see if the ``grab_raycast`` node collided with something using "
"the ``is_colliding`` function, which will return true if the :ref:`Raycast "
"<class_Raycast>` hit something."
msgstr ""
"``grab_mode`` 変数が ``AREA`` と等しくない場合、代わりに ``RAYCAST`` と等しい"
"かどうかを確認します。\\ ``RAYCAST`` と等しい場合、\\ "
"``force_raycast_update`` 関数を使用して ``grab_raycast`` ノードを強制的に更新"
"します。\\ ``force_raycast_update`` 関数は、物理世界の最新の変更内容で :ref:"
"`Raycast <class_Raycast>` を更新します。次に、 \\ ``is_colliding`` 関数を使用"
"して ``grab_raycast`` ノードが何かと衝突したかどうかを確認します。これ"
"は、\\ :ref:`Raycast <class_Raycast>` が何かにヒットした場合にtrueを返しま"
"す。"

msgid ""
"If the ``grab_raycast`` hit something, we get the :ref:`PhysicsBody "
"<class_PhysicsBody>` node hit using the ``get_collider`` function. The code "
"then checks to see if the node hit is a :ref:`RigidBody <class_RigidBody>` "
"node using ``if body is RigidBody``, which will return ``true`` if the :ref:"
"`PhysicsBody <class_PhysicsBody>` node is or extends the :ref:`RigidBody "
"<class_RigidBody>` node. Then the code checks to see if the :ref:`RigidBody "
"<class_RigidBody>` node does not have a variable named ``NO_PICKUP``, and if "
"it does not, then it assigns the :ref:`RigidBody <class_RigidBody>` node to "
"the ``rigid_body`` variable."
msgstr ""
"``grab_raycast`` が何かにヒットした場合、\\ ``get_collider`` 関数を使用して :"
"ref:`PhysicsBody <class_PhysicsBody>` ノードにヒットします。次にコードは、"
"ノードヒットが :ref:`PhysicsBody <class_PhysicsBody>` の場合に ``if body is "
"RigidBody`` を使用して、\\ :ref:`PhysicsBody <class_PhysicsBody>` ノードが :"
"ref:`RigidBody <class_RigidBody>` ノード、もしくはそれを拡張したノードの場合"
"に ``true`` を返します。次に、コードは :ref:`RigidBody <class_RigidBody>` "
"ノードに ``NO_PICKUP`` という名前の変数がないかどうかを確認し、ない場合は "
"``rigid_body`` 変数に :ref:`RigidBody <class_RigidBody>` ノードを割り当てま"
"す。"

msgid ""
"What this section of code does is sends the ``grab_raycast`` :ref:`Raycast "
"<class_Raycast>` node out and checks if it collided with a :ref:`RigidBody "
"<class_RigidBody>` node that does not have a variable/constant named "
"``NO_PICKUP``. If it collided with a RigidBody without ``NO_PICKUP``, it "
"assigns the node to the ``rigid_body`` variable so we can do some additional "
"post processing later in this function."
msgstr ""
"コードのこのセクションが行っていることは、\\ ``grab_raycast`` :ref:`Raycast "
"<class_Raycast>` ノードを送信し、\\ ``NO_PICKUP`` という名前の変数/定数を持っ"
"ていない :ref:`RigidBody <class_RigidBody>` ノードと衝突したかどうかをチェッ"
"クすることです。\\ `` NO_PICKUP`` なしのRigidBodyと衝突した場合、そのノード"
"を ``rigid_body`` 変数に割り当てるため、この関数で後から追加の後処理を行うこ"
"とができます。"

msgid ""
"The final section of code first checks to see if ``rigid_body`` is not equal "
"to ``null``. If ``rigid_body`` is not equal to ``null``, then the VR "
"controller found a :ref:`RigidBody <class_RigidBody>`-based node that can be "
"picked up."
msgstr ""
"コードの最後のセクションでは、最初に ``rigid_body`` が ``null`` と等しくない"
"かどうかを確認します。\\ ``rigid_body`` が ``null`` に等しくない場合、VRコン"
"トローラーは :ref:`RigidBody <class_RigidBody>` ベースのノードを検出できま"
"す。"

msgid ""
"If there is a VR controller to pickup, we assign ``held_object`` to the :ref:"
"`RigidBody <class_RigidBody>` node stored in ``rigid_body``. We then store "
"the :ref:`RigidBody <class_RigidBody>` node's ``mode``, ``collision_layer``, "
"and ``collision_mask`` in ``held_object_data`` using ``mode``, ``layer``, "
"and ``mask`` as keys for the respective values. This is so we can reapply "
"them later when the object is dropped by the VR controller."
msgstr ""
"ピックアップするVRコントローラーがある場合は、\\ ``rigid_body`` に保存されて"
"いる :ref:`RigidBody <class_RigidBody>` ノードに ``held_object`` を割り当てま"
"す。次に、\\ ``mode``\\ 、\\ ``layer``\\ 、および ``mask`` をそれぞれの値の"
"キーとして使用して、\\ RigidBody <class_RigidBody>`` ノードの "
"``mode``\\ 、\\ ``collision_layer``\\ 、および ``collision_mask`` を "
"``held_object_data`` に保存します。これは、後でオブジェクトがVRコントローラー"
"によってドロップされたときにそれらを再適用できるようにするためです。"

msgid ""
"We then set the :ref:`RigidBody <class_RigidBody>`'s mode to "
"``MODE_STATIC``, it's ``collision_layer`` to zero, and it's "
"``collision_mask`` to zero. This will make it where the held :ref:`RigidBody "
"<class_RigidBody>` cannot interact with other objects in the physics world "
"when held by the VR controller."
msgstr ""
"次に、\\ :ref:`RigidBody <class_RigidBody>` のmodeを ``MODE_STATIC`` に設定し"
"ます。これは ``collision_layer`` をゼロに設定し、\\ ``collision_mask`` もゼロ"
"に設定します。これにより、保持されている :ref:`RigidBody <class_RigidBody>` "
"がVRコントローラーで保持されている場合、物理世界の他のオブジェクトと対話でき"
"なくなります。"

msgid ""
"Next the ``hand_mesh`` :ref:`MeshInstance <class_MeshInstance>` is made "
"invisible by setting the ``visible`` property to ``false``. This is so the "
"hand does not get in the way of the held object. Likewise, the "
"``grab_raycast`` 'laser sight' is made invisible by setting the ``visible`` "
"property to ``false``."
msgstr ""
"次に、\\ ``visible`` プロパティを ``false`` に設定することにより、\\ "
"``hand_mesh`` :ref:`MeshInstance <class_MeshInstance>` を非表示にします。これ"
"は、手がホールドされたオブジェクトの邪魔にならないようにするためです。同様"
"に、\\ ``grab_raycast``「レーザーサイト」は、\\ ``visible`` プロパティを "
"``false`` に設定することで非表示になります。"

msgid ""
"Then the code checks to see if the held object extends a class called "
"``VR_Interactable_Rigidbody``. If it does, then sets a variable called "
"``controller`` on ``held_object`` to ``self``, and calls the ``picked_up`` "
"function on ``held_object``. While we haven't made "
"``VR_Interactable_Rigidbody`` just yet, what this will do is set tell the "
"``VR_Interactable_Rigidbody`` class that it is being held by a VR "
"controller, where the a reference to the controller is stored in the "
"``controller`` variable, through calling the ``picked_up`` function."
msgstr ""
"次に、コードは、保持されているオブジェクトが ``VR_Interactable_Rigidbody`` と"
"いうクラスを拡張しているかどうかを確認します。その場合、\\ ``held_object`` "
"の ``controller`` という変数を ``self`` に設定し、\\ ``held_object`` の "
"``picked_up`` 関数を呼び出します。まだ ``VR_Interactable_Rigidbody`` を作成し"
"ていませんが、これが行うことは、\\ ``picked_up`` 関数を呼び出すことで、\\ "
"``controller`` 変数に保存されているVRコントローラーによってコントローラーへの"
"参照が 保持されていることを ``VR_Interactable_Rigidbody`` クラスに伝えること"
"です。"

msgid ""
"The code should make more sense after completing part 2 of this tutorial "
"series, where we will actually be using ``VR_Interactable_Rigidbody``."
msgstr ""
"このチュートリアルシリーズのパート2を完了した後、コードはより意味のあるものに"
"なるはずです。そこでは実際に ``VR_Interactable_Rigidbody`` を使用します。"

msgid ""
"What this section of code does is that if a :ref:`RigidBody "
"<class_RigidBody>` was found using the grab :ref:`Area <class_Area>` or :ref:"
"`Raycast <class_Raycast>`, it sets it up so that it can be carried by the VR "
"controller."
msgstr ""
"コードのこのセクションは、もしも gurb :ref:`Area <class_Area>` または :ref:"
"`Raycast <class_Raycast>` を使用して :ref:`RigidBody <class_RigidBody>` を検"
"出した場合、VRコントローラーでそれを運べるようにセットアップします。"

msgid "``_throw_rigidbody`` function step-by-step explanation"
msgstr "``_throw_rigidbody`` 関数のステップごとの説明"

msgid ""
"First the function checks to see if the VR controller is not holding any "
"object by checking if the ``held_object`` variable is equal to ``null``. If "
"it is, then it simply calls ``return`` so nothing happens. While this "
"shouldn't be possible, the ``_throw_rigidbody`` function should only be "
"called if an object is held, this check helps ensure that if something "
"strange happens, this function will react as expected."
msgstr ""
"最初に、関数は ``held_object`` 変数が ``null`` に等しいかどうかを確認すること"
"により、VRコントローラーがオブジェクトを保持していないかどうかを確認します。"
"そうである場合は、単に ``return`` を呼び出すため、何も起こりません。必ず、オ"
"ブジェクトが保持されている場合にのみ ``_throw_rigidbody`` 関数を呼び出す必要"
"があります。このチェックは、奇妙なことが発生した場合に、この関数が期待どおり"
"に反応することを保証します。"

msgid ""
"After checking if the VR controller is holding an object, we assume it is "
"and set the stored :ref:`RigidBody <class_RigidBody>` data back to the held "
"object. We take the ``mode``, ``layer`` and ``mask`` data stored in the "
"``held_object_data`` dictionary and reapply it to the object in "
"``held_object``. This will set the :ref:`RigidBody <class_RigidBody>` back "
"to the state it was prior to being picked up."
msgstr ""
"VRコントローラーがオブジェクトを保持しているかどうかを確認した後、それを想定"
"し、保存された :ref:`RigidBody <class_RigidBody>` データを保持されたオブジェ"
"クトに戻します。\\ ``held_object_data`` dictionaryに保存されている "
"``mode``\\ 、\\ ``layer`` および ``mask`` データを取得し、それを "
"``held_object`` のオブジェクトに再適用します。これにより、\\ :ref:`RigidBody "
"<class_RigidBody>` がピックアップされる前の状態に戻ります。"

msgid ""
"Then we call ``apply_impulse`` on the ``held_object`` so that the :ref:"
"`RigidBody <class_RigidBody>` is thrown in the direction of the VR "
"controller's velocity, ``controller_velocity``."
msgstr ""
"次に、\\ ``held_object`` で ``apply_impulse`` を呼び出して、\\ :ref:"
"`RigidBody <class_RigidBody>` がVRコントローラーの速度 "
"``controller_velocity`` の方向にスローされるようにします。"

msgid ""
"We then check to see if the object held extends a class called "
"``VR_Interactable_Rigidbody``. If it does, then we call a function called "
"``dropped`` in ``held_object`` and set ``held_object.controller`` to "
"``null``. While we have not made ``VR_Interactable_Rigidbody`` yet, but what "
"this will do is call the ``droppped`` function so the :ref:`RigidBody "
"<class_RigidBody>` can do whatever it needs to do when dropped, and we set "
"the ``controller`` variable to ``null`` so that the :ref:`RigidBody "
"<class_RigidBody>` knows that it is not being held."
msgstr ""
"次に、保持されているオブジェクトが ``VR_Interactable_Rigidbody`` というクラス"
"を拡張しているかどうかを確認します。もしそうなら、 ``held_object`` の "
"``dropped`` と呼ばれる関数を呼び出し、\\ ``held_object.controller`` を "
"``null`` に設定します。まだ ``VR_Interactable_Rigidbody`` を作成していません"
"が、これは ``droppped`` 関数を呼び出すので、\\ :ref:`RigidBody "
"<class_RigidBody>` はドロップ時に必要なことを何でも行うことができ、\\ :ref:"
"`RigidBody <class_RigidBody>` が保持されていないことがわかるように、\\ "
"``controller`` 変数を ``null`` に設定します。"

msgid ""
"Regardless of whether ``held_object`` extends ``VR_Interactable_Rigidbody`` "
"or not, we then set ``held_object`` to ``null`` so the VR controller knows "
"it is no longer holding anything. Because the VR controller is no longer "
"holding anything, we make the ``hand_mesh`` visible by setting ``hand_mesh."
"visible`` to true."
msgstr ""
"``held_object`` が ``VR_Interactable_Rigidbody`` を拡張しているかどうかに関係"
"なく、\\ ``held_object`` を ``null`` に設定して、VRコントローラーがもう何も保"
"持していないことを認識します。 VRコントローラーはもう何も保持していないの"
"で、\\ ``hand_mesh.visible`` をtrueに設定することで ``hand_mesh`` を可視化し"
"ます。"

msgid ""
"Finally, if the ``grab_mode`` variable is set to ``RAYCAST``, we set "
"``grab_raycast.visible`` to ``true`` so the 'laser sight' for the :ref:"
"`Raycast <class_Raycast>` in ``grab_raycast`` is visible."
msgstr ""
"最後に、\\ ``grab_mode`` 変数が ``RAYCAST`` に設定されている場合、\\ "
"``grab_raycast.visible`` を ``true`` に設定するため、\\ ``grab_raycast`` の :"
"ref:`Raycast <class_Raycast>`\\ 「レーザーサイト」が表示されます。"

msgid "``_on_button_pressed_menu`` function step-by-step explanation"
msgstr "``_on_button_pressed_menu`` 関数のステップごとの説明"

msgid ""
"First this function checks to see if the ``grab_mode`` variable is equal to "
"``AREA``. If it is, then it sets ``grab_mode`` to ``RAYCAST``. It then "
"checks to see if the VR controller is not holding anything by checking to "
"see if ``held_object`` is equal to ``null``. If the VR controller is not "
"holding anything, then ``grab_raycast.visible`` is set to ``true`` so the "
"'laser sight' on the grab raycast is visible."
msgstr ""
"最初に、この関数は ``grab_mode`` 変数が ``AREA`` と等しいかどうかを確認しま"
"す。もしそうなら、それは ``grab_mode`` を ``RAYCAST`` に設定します。次に、\\ "
"``held_object`` が ``null`` に等しいかどうかを確認することにより、VRコント"
"ローラーが何も保持していないかどうかを確認します。 VRコントローラーが何も保持"
"していない場合は、\\ ``grab_raycast.visible`` が ``true`` に設定されるため、"
"grabレイキャストの「レーザーサイト」が表示されます。"

msgid ""
"If the ``grab_mode`` variable is not equal to ``AREA``, then it checks to "
"see if it is equal to ``RAYCAST``. If it is, then it sets the ``grab_mode`` "
"to ``AREA`` and sets ``grab_raycast.visible`` to ``false`` so the 'laser "
"sight' on the grab raycast is not visible."
msgstr ""
"``grab_mode`` 変数が ``AREA`` と等しくない場合、変数が ``RAYCAST`` と等しいか"
"どうかを確認します。そうである場合は、\\ ``grab_mode`` を ``AREA`` に設定"
"し、\\ ``grab_raycast.visible`` を ``false`` に設定して、grubレイキャストの"
"「レーザーサイト」が表示されないようにします。"

msgid ""
"This section of code simply changes how the VR controller will grab :ref:"
"`RigidBody <class_RigidBody>`-based nodes when the grab/grip button is "
"pressed. If ``grab_mode`` is set to ``AREA``, then the :ref:`Area "
"<class_Area>` node in ``grab_area`` will be used for detecting :ref:"
"`RigidBody <class_RigidBody>` nodes, while if ``grab_mode`` is set to "
"``RAYCAST`` the :ref:`Raycast <class_Raycast>` node in ``grab_raycast`` will "
"be used for detecting :ref:`RigidBody <class_RigidBody>` nodes."
msgstr ""
"コードのこのセクションは、グラブ/グリップボタンが押されたときにVRコントロー"
"ラーが :ref:`RigidBody <class_RigidBody>` ベースのノードを保持する方法を単に"
"変更します。\\ ``grab_mode`` が ``AREA`` に設定されている場合、\\ "
"``grab_area`` の :ref:`Area <class_Area>` ノードは :ref:`RigidBody "
"<class_RigidBody>` ノードの検出に使用されますが、\\ ``grab_mode`` が "
"``RAYCAST`` に設定されている場合、\\ ``grab_raycast`` の :ref:`Raycast "
"<class_Raycast>` ノードは :ref:`RigidBody <class_RigidBody>` ノードの検出に使"
"用されます。"

msgid "``button_released`` function step-by-step explanation"
msgstr "``button_released`` 関数のステップごとの説明"

msgid ""
"The only section of code in this function checks to see if the index of the "
"button that was just released, ``button_index``, is equal to ``15``, which "
"should map to the trigger button on the VR controller. The ``button_index`` "
"variable is passed in by the ``button_release`` signal in :ref:"
"`ARVRController <class_ARVRController>`, which we connected in the "
"``_ready`` function."
msgstr ""
"この関数のコードの唯一のセクションは、リリースされたばかりのボタンのインデッ"
"クス ``button_index`` が ``15`` に等しいかどうかを確認します。これはVRコント"
"ローラーのトリガーボタンにマップする必要があります。 ``button_index`` 変数"
"は、\\ :ref:`ARVRController <class_ARVRController>` の ``button_release`` シ"
"グナルによって渡されます。これは ``_ready`` 関数で接続しています。"

msgid ""
"If the trigger button was just released, then the "
"``_on_button_released_trigger`` function is called."
msgstr ""
"トリガーボタンがちょうど離されたときに、\\ ``_on_button_released_trigger`` 関"
"数が呼び出されます。"

msgid "``_on_button_released_trigger`` function step-by-step explanation"
msgstr "``_on_button_released_trigger`` 関数のステップごとの説明"

msgid ""
"The only section of code in this function first checks to see if the VR "
"controller is trying to teleport by checking if the ``teleport_button_down`` "
"variable is equal to ``true``."
msgstr ""
"この関数のコードの唯一のセクションは、最初に ``teleport_button_down`` 変数が "
"``true`` に等しいかどうかを確認することにより、VRコントローラーがテレポートし"
"ようとしているかどうかを確認します。"

msgid ""
"If the ``teleport_button_down`` variable is equal to ``true``, the code then "
"checks if there is a teleport position set and whether the teleport mesh is "
"visible. It does this by checking to see if ``teleport_pos`` is not equal to "
"``null`` and if ``teleport_mesh.visible`` is equal to ``true``."
msgstr ""
"``teleport_button_down`` 変数が ``true`` に等しい場合、コードはテレポート位置"
"が設定されているかどうか、テレポートメッシュが表示されているかどうかをチェッ"
"クします。これは、\\ ``teleport_pos`` が ``null`` と等しくないかどうか、およ"
"び ``teleport_mesh.visible`` が ``true`` と等しいかどうかを確認することで行い"
"ます。"

msgid ""
"If there is a teleport position set and the teleport mesh is visible, the "
"code then calculates the offset from the camera to the :ref:`ARVROrigin "
"<class_ARVROrigin>` node, which is assumed to be the parent node of the VR "
"controller. To calculate the offset, the global position (``global_transform."
"origin``) of the ``Player_Camera`` node has the global position of the :ref:"
"`ARVROrigin <class_ARVROrigin>` subtracted from it. This will result in a "
"vector that points from the :ref:`ARVROrigin <class_ARVROrigin>` to the :ref:"
"`ARVRCamera <class_ARVRCamera>`, which we store in a variable called "
"``camera_offset``."
msgstr ""
"テレポート位置セットがあり、テレポートメッシュが表示されている場合、コードは"
"カメラから :ref:`ARVROrigin <class_ARVROrigin>` ノードへのオフセットを計算し"
"ます。これはVRコントローラーの親ノードと見なされます。オフセットを計算するた"
"めに、\\ ``Player_Camera`` ノードのグローバル位置(``global_transform."
"origin``)から :ref:`ARVROrigin <class_ARVROrigin>` のグローバル位置が減算され"
"ます。これにより、\\ :ref:`ARVROrigin <class_ARVROrigin>` から :ref:"
"`ARVRCamera <class_ARVRCamera>` を指すベクトルが生成され、これを "
"``camera_offset`` という変数に格納します。"

msgid ""
"The reason we need to know the offset is because some VR headsets use room "
"tracking, where the player's camera can be offset from the :ref:`ARVROrigin "
"<class_ARVROrigin>` node. Because of this, when we teleport we want to keep "
"the offset created by room tracking so that when the player teleports, the "
"offset created by the room tracking is not applied. Without this, if you "
"moved in a room and then teleported, instead of appearing at the position "
"you wanted to teleport at, your position would be offset by the amount of "
"distance you have from the :ref:`ARVROrigin <class_ARVROrigin>` node."
msgstr ""
"オフセットを知る必要がある理由は、一部のVRヘッドセットはルームトラッキングを"
"使用しているためです。プレイヤーのカメラは :ref:`ARVROrigin "
"<class_ARVROrigin>` ノードからオフセットできます。このため、テレポートすると"
"き、ルームトラッキングによって作成されたオフセットを保持して、プレイヤーがテ"
"レポートするときに、ルームトラッキングによって作成されたオフセットが適用され"
"ないようにします。これがないと、部屋に移動してテレポートした場合、テレポート"
"したい位置に現れるのではなく、\\ :ref:`ARVROrigin <class_ARVROrigin>` ノード"
"からの距離によって位置がオフセットされます。"

msgid ""
"Now that we know the offset from the VR camera to the VR origin, we need to "
"remove the difference on the ``Y`` axis. We do this because we do not want "
"to offset based on the user's height. If we did not do this, when "
"teleporting the player's head would be level with the ground."
msgstr ""
"VRカメラからVR原点までのオフセットがわかったので、\\ ``Y`` 軸の違いを取り除く"
"必要があります。これは、ユーザーの身長に基づいてオフセットしたくないためで"
"す。これを行わなかった場合、プレイヤーの頭をテレポートするとき、地面と水平に"
"なります。"

msgid ""
"Then we can 'teleport' the player by setting the global position "
"(``global_transform.origin``) of the ARVROrigin node to the position stored "
"in ``teleport_pos`` with ``camera_offset`` subtracted from it. This will "
"teleport the player and remove the room tracking offset, so the user appears "
"exactly where they want when teleporting."
msgstr ""
"その後、ARVROriginノードのグローバル位置(``global_transform.origin``)を "
"``teleport_pos`` に格納された位置に設定し、そこから ``camera_offset`` を減算"
"することにより、プレイヤーを「'テレポート」できます。これにより、プレイヤーが"
"テレポートされ、ルームトラッキングオフセットが削除されるため、ユーザーはテレ"
"ポート時に希望する場所に正確に表示されます。"

msgid ""
"Finally, regardless of whether the VR controller teleported the user or not, "
"we reset the teleport related variables. ``teleport_button_down`` is set to "
"``false``, ``teleport_mesh.visible`` is set to ``false`` so the mesh is "
"invisible, ``teleport_raycast.visible`` is set to ``false``, and "
"``teleport_pos`` is set to ``null``."
msgstr ""
"最後に、VRコントローラーがユーザーをテレポートしたかどうかに関係なく、テレ"
"ポート関連の変数をリセットします。\\ ``teleport_button_down`` は ``false`` に"
"設定され、\\ ``teleport_mesh.visible`` は ``false`` に設定されているため、"
"メッシュは非表示になり、\\ ``teleport_raycast.visible`` は ``false`` に設定さ"
"れ、そして ``teleport_pos`` は ``null`` に設定されます。"

msgid "``sleep_area_entered`` function step-by-step explanation"
msgstr "``sleep_area_entered`` 関数のステップごとの説明"

msgid ""
"The only section of code in this function checks to see if the :ref:"
"`PhysicsBody <class_PhysicsBody>` node that entered the ``Sleep_Area`` node "
"has a variable called ``can_sleep``. If it does, then it sets the "
"``can_sleep`` variable to ``false`` and sets the ``sleeping`` variable to "
"``false``."
msgstr ""
"この関数のコードの唯一のセクションは、\\ ``Sleep_Area`` ノードに入った :ref:"
"`PhysicsBody <class_PhysicsBody>` ノードに ``can_sleep`` という変数があるかど"
"うかを確認します。存在する場合、\\ ``can_sleep`` 変数を ``false`` に設定"
"し、\\ ``sleeping`` 変数を ``false`` に設定します。"

msgid ""
"Without doing this, sleeping :ref:`PhysicsBody <class_PhysicsBody>` nodes "
"would not be able to be picked up by the VR controller, even if the VR "
"controller is at the same position as the :ref:`PhysicsBody "
"<class_PhysicsBody>` node. To work around this, we simply 'wake up' :ref:"
"`PhysicsBody <class_PhysicsBody>` nodes that are close to the VR controller."
msgstr ""
"これを行わないと、VRコントローラーが :ref:`PhysicsBody <class_PhysicsBody>` "
"ノードと同じ位置にある場合でも、\\ :ref:`PhysicsBody <class_PhysicsBody>` "
"ノードをVRコントローラーで取得することはできません。これを回避するには、VRコ"
"ントローラーの近くにある :ref:`PhysicsBody <class_PhysicsBody>` ノードを単に "
"「ウェイクアップ」します。"

msgid "``sleep_area_exited`` function step-by-step explanation"
msgstr "``sleep_area_exited`` 関数のステップごとの説明"

msgid ""
"The only section of code in this function checks to see if the :ref:"
"`PhysicsBody <class_PhysicsBody>` node that entered the ``Sleep_Area`` node "
"has a variable called ``can_sleep``. If it does, then it sets the "
"``can_sleep`` variable to ``true``."
msgstr ""
"この関数のコードの唯一のセクションは、\\ ``Sleep_Area`` ノードに入った :ref:"
"`PhysicsBody <class_PhysicsBody>` ノードに ``can_sleep`` という変数があるかど"
"うかを確認します。存在する場合、\\ ``can_sleep`` 変数を ``true`` に設定しま"
"す。"

msgid ""
"This allows :ref:`RigidBody <class_RigidBody>` nodes that leave the "
"``Sleep_Area`` to sleep again, saving performance."
msgstr ""
"これにより、\\ ``Sleep_Area`` から出る :ref:`RigidBody <class_RigidBody>` "
"ノードが再びスリープ状態になり、パフォーマンスが節約されます。"

msgid ""
"Okay, whew! That was a lot of code! Add the same script, ``VR_Controller."
"gd`` to the other VR controller scene so both VR controllers have the same "
"script."
msgstr ""
"わかりました、ふう！これは大量のコードでした！同じスクリプト ``VR_Controller."
"gd`` を他のVRコントローラーシーンに追加して、両方のVRコントローラーが同じスク"
"リプトを持つようにします。"

msgid ""
"Now we just need to do one thing before testing the project! Right now we "
"are referencing a class called ``VR_Interactable_Rigidbody``, but we have "
"not defined it yet. While we will not be using ``VR_Interactable_Rigidbody`` "
"in this tutorial, let's create it real quick so the project can be run."
msgstr ""
"あとは、プロジェクトをテストする前に1つのことを行うだけです！現在、\\ "
"``VR_Interactable_Rigidbody`` というクラスを参照していますが、まだ定義してい"
"ません。このチュートリアルでは ``VR_Interactable_Rigidbody`` を使用しません"
"が、プロジェクトを実行できるようにすばやく作成してみましょう。"

msgid "Creating a base class for interactable VR objects"
msgstr "対話可能なVRオブジェクトの基本クラスを作成する"

msgid ""
"With the ``Script`` tab still open, create a new GDScript called "
"``VR_Interactable_Rigidbody.gd``."
msgstr ""
"``Script`` タブを開いたまま、\\ ``VR_Interactable_Rigidbody.gd`` という新しい"
"GDScriptを作成します。"

msgid ""
"You can create GDScripts in the ``Script`` tab by pressing ``File -> New "
"Script...``."
msgstr ""
"[ファイル] -> [新規スクリプト...] を押すことで、\\ ``Script`` タブでGDScript"
"を作成できます。"

msgid ""
"Once you have ``VR_Interactable_Rigidbody.gd`` open, add the following code:"
msgstr "``VR_Interactable_Rigidbody.gd`` を開いたら、次のコードを追加します:"

msgid "Let's quickly go through what this script."
msgstr "このスクリプトを簡単に見ていきましょう。"

msgid ""
"First we start the script with ``class_name VR_Interactable_Rigidbody``. "
"What this does is that it tells Godot that this GDScript is a new class that "
"called ``VR_Interactable_Rigidbody``. This allows us to compare nodes "
"against the ``VR_Interactable_Rigidbody`` class in other script files "
"without having to load the script directly or do anything special. We can "
"compare the class just like all of the built-in Godot classes."
msgstr ""
"まず、\\ ``class_name VR_Interactable_Rigidbody`` でスクリプトを開始します。"
"これは、このGDScriptが ``VR_Interactable_Rigidbody`` と呼ばれる新しいクラスで"
"あることをGodotに伝えます。これにより、スクリプトを直接ロードしたり特別なこと"
"をしたりする必要もなしに、すべての組み込みGodotクラスと同様に、ノードを他のス"
"クリプトファイルの ``VR_Interactable_Rigidbody`` クラスと突き合せることができ"
"ます。"

msgid ""
"Next is a class variable called ``controller``. ``controller`` will be used "
"to hold a reference to the VR controller that is currently holding the "
"object. If a VR controller is not holding the object, then the "
"``controller`` variable will be ``null``. The reason we need to have a "
"reference to the VR controller is so held objects can access VR controller "
"specific data, like ``controller_velocity``."
msgstr ""
"次は ``controller`` と呼ばれるクラス変数です。\\ ``controller`` は、現在オブ"
"ジェクトを保持しているVRコントローラーへの参照を保持するために使用されます。"
"VRコントローラーがオブジェクトを保持していない場合、\\ ``controller`` 変数は "
"``null`` になります。 VRコントローラーへの参照が必要な理由は、保持されたオブ"
"ジェクトが ``controller_velocity`` のようなVRコントローラー固有のデータにアク"
"セスできるようにするためです。"

msgid ""
"Finally, we have four functions. The ``_ready`` function is defined by Godot "
"and all we do is simply have ``pass`` as there is nothing we need to do when "
"the object is added to the scene in ``VR_Interactable_Rigidbody``."
msgstr ""
"最後に、4つの関数があります。\\ ``_ready`` 関数はGodotによって定義され、オブ"
"ジェクトが ``VR_Interactable_Rigidbody`` のシーンに追加されたときに行うべきこ"
"とは何もないので、単に ``pass`` を持つだけです。"

msgid ""
"The ``interact`` function is a stub function that will be called when the "
"interact button on the VR controller, the trigger in this case, is pressed "
"while the object is held."
msgstr ""
"``interact`` 関数は、オブジェクトが保持されているときにVRコントローラーの対話"
"ボタン(この場合はトリガー)が押されたときに呼び出されるスタブ関数です。"

msgid ""
"A stub function is a function that is defined but does not have any code. "
"Stub functions are generally designed to be overwritten or extended. In this "
"project, we are using the stub functions so there is a consistent interface "
"across all interactable :ref:`RigidBody <class_RigidBody>` objects."
msgstr ""
"スタブ関数は、定義されているがコードを持たない関数です。スタブ関数は通常、上"
"書きまたは拡張されるように設計されています。このプロジェクトでは、スタブ関数"
"を使用しているため、すべての対話可能な :ref:`RigidBody <class_RigidBody>` オ"
"ブジェクト全体で一貫したインターフェイスがあります。"

msgid ""
"The ``picked_up`` and ``dropped`` functions are stub functions that will be "
"called when the object is picked up and dropped by the VR controller."
msgstr ""
"``picked_up`` および ``dropped`` 関数は、オブジェクトがVRコントローラーによっ"
"てピックアップおよびドロップされるときに呼び出されるスタブ関数です。"

msgid ""
"That is all we need to do for now! In the next part of this tutorial series, "
"we'll start making special interactable :ref:`RigidBody <class_RigidBody>` "
"objects."
msgstr ""
"今のところ私たちが行うべきことはそれだけです！このチュートリアルシリーズの次"
"のパートでは、相互作用可能な特別な :ref:`RigidBody <class_RigidBody>` オブ"
"ジェクトの作成を開始します。"

msgid ""
"Now that the base class is defined, the code in the VR controller should "
"work. Go ahead and try the game again, and you should find you can teleport "
"around by pressing the touch pad, and can grab and throw objects using the "
"grab/grip buttons."
msgstr ""
"基本クラスが定義されたので、VRコントローラーのコードが機能するはずです。先に"
"進み、もう一度ゲームを試してください。タッチパッドを押すとテレポートでき、グ"
"ラブ/グリップボタンを使用してオブジェクトをつかんで投げることができます。"

msgid ""
"Now, you may want to try moving using the trackpads and/or joysticks, but "
"**it may make you motion sick!**"
msgstr ""
"さて、トラックパッドやジョイスティックを使用して移動してみたくなるかもしれま"
"せんが、\\ **乗り物酔いになる場合があります！**"

msgid ""
"One of the main reasons this can make you feel motion sick is because your "
"vision tells you that you are moving, while your body is not moving. This "
"conflict of signals can make the body feel sick. Let's add a vignette shader "
"to help reduce motion sickness while moving in VR!"
msgstr ""
"この乗り物酔いを感じる主な理由の1つは、体は動いていないのに、視力は動いている"
"ことを伝えて来るからです。この信号の衝突により、気分が悪くなることがありま"
"す。 VRでの移動中の乗り物酔いを軽減するために、ビネットシェーダーを追加しま"
"しょう！"

msgid "Reducing motion sickness"
msgstr "乗り物酔いの軽減"

#, fuzzy
msgid ""
"There are plenty of ways to reduce motion sickness in VR, and there is no "
"one perfect way to reduce motion sickness. See `this page on the Oculus "
"Developer Center <https://developer.oculus.com/design/latest/concepts/bp-"
"locomotion/>`__ for more information on how to implement locomotion and "
"reducing motion sickness."
msgstr ""
"VRで乗り物酔いを減らす方法はたくさんありますが、乗り物酔いを減らす完璧な方法"
"はありません。移動と乗り物酔いの軽減を実装する方法の詳細については、\\ "
"``Oculus Developer Centerのこのページ <https://developer.oculus.com/design/"
"latest/concepts/bp-locomotion/>`_ を参照してください。"

msgid ""
"To help reduce motion sickness while moving, we are going to add a vignette "
"effect that will only be visible while the player moves."
msgstr ""
"移動中の乗り物酔いを軽減するために、プレイヤーが移動している間のみ表示される"
"ビネットエフェクトを追加します。"

#, fuzzy
msgid ""
"First, quickly switch back to ``Game.tscn``. Under the :ref:`ARVROrigin "
"<class_ARVROrigin>` node there is a child node called ``Movement_Vignette``. "
"This node is going to apply a simple vignette to the VR headset when the "
"player is moving using the VR controllers. This should help reduce motion "
"sickness."
msgstr ""
"まず、すぐに ``Game.tscn`` に切り替えます。\\ :ref:`ARVROrigin "
"<class_ARVROrigin>` ノードの下に、\\ ``Movement_Vignette`` という子ノードがあ"
"ります。このノードは、プレイヤーがVRコントローラーを使用して移動しているとき"
"に、単純なビネットをVRヘッドセットに適用します。これは乗り物酔いの軽減に役立"
"つはずです。"

#, fuzzy
msgid ""
"Open up ``Movement_Vignette.tscn``, which you can find in the ``Scenes`` "
"folder. The scene is just a :ref:`ColorRect <class_ColorRect>` node with a "
"custom shader. Feel free to look at the custom shader if you want, it is "
"just a slightly modified version of the vignette shader you can find in the "
"`Godot demo repository <https://github.com/godotengine/godot-demo-"
"projects>`__."
msgstr ""
"``Scenes`` フォルダにある ``Movement_Vignette.tscn`` を開きます。シーンは、カ"
"スタムシェーダーを備えた :ref:`ColorRect <class_ColorRect>` ノードです。必要"
"に応じて、カスタムシェーダーをご覧ください。これは、\\ `Godotデモリポジトリ "
"<https://github.com/godotengine/godot-demo-projects>`_ にあるビネットシェー"
"ダーのわずかに変更されたバージョンです。"

msgid ""
"Let's write the code that will make the vignette shader visible when the "
"player is moving. Select the ``Movement_Vignette`` node and create a new "
"script called ``Movement_Vignette.gd``. Add the following code:"
msgstr ""
"プレイヤーが動いているときにビネットシェーダーを表示するコードを記述しましょ"
"う。\\ ``Movement_Vignette`` ノードを選択し、\\ ``Movement_Vignette.gd`` とい"
"う名前の新しいスクリプトを作成します。次のコードを追加します:"

msgid ""
"Because this script is fairly brief, let's quickly go over what it does."
msgstr ""
"このスクリプトはかなり短いため、スクリプトの機能について簡単に説明します。"

msgid "Explaining the vignette code"
msgstr "ビネットのコードの説明"

msgid ""
"There are two class variables, ``controller_one`` and ``controller_two``. "
"These variables will hold references to the left and right VR controllers."
msgstr ""
"``controller_one`` と ``controller_two`` の2つのクラス変数があります。これら"
"の変数は、左右のVRコントローラーへの参照を保持します。"

msgid ""
"In the ``_ready`` function first waits for four frames using ``yield``. The "
"reason we are waiting four frames is because we want to ensure the VR "
"interface is ready and accessible."
msgstr ""
"``_ready`` 関数では、最初に ``yield`` を使用して4つのフレームを待ちます。 4つ"
"のフレームを待機している理由は、VRインターフェイスの準備ができており、アクセ"
"スできるようにするためです。"

msgid ""
"After waiting the primary VR interface is retrieved using ``ARVRServer."
"primary_interface``, which is assigned to a variable called ``interface``. "
"The code then checks to see if ``interface`` is equal to ``null``. If "
"``interface`` is equal to ``null``, then ``_process`` is disabled using "
"``set_process`` with a value of ``false``."
msgstr ""
"待機後、\\ ``ARVRServer.primary_interface`` を使用してプライマリVRインター"
"フェースが取得され、\\ ``interface`` という変数に割り当てられます。次に、コー"
"ドは ``interface`` が ``null`` と等しいかどうかを確認します。\\ "
"``interface`` が ``null`` に等しい場合、\\ ``_process`` は、値が ``false`` "
"の ``set_process`` を使用して無効にされます。"

msgid ""
"If ``interface`` is not ``null``, then we set the ``rect_size`` of the "
"vignette shader to the render size of the VR viewport so it takes up the "
"entire screen. We need to do this because different VR headsets have "
"different resolutions and aspect ratios, so we need to resize the node "
"accordingly. We also set the ``rect_position`` of the vignette shader to "
"zero so it is in the correct position relative to the screen."
msgstr ""
"``interface`` が ``null`` でない場合、ビネットシェーダーの ``rect_size`` をVR"
"ビューポートのレンダリングサイズに設定して、画面全体を占めるようにします。VR"
"ヘッドセットごとに解像度とアスペクト比が異なるため、これを行う必要がありま"
"す。したがって、それに応じてノードのサイズを変更する必要があります。 また、ビ"
"ネットシェーダーの ``rect_position`` をゼロに設定して、画面に対して正しい位置"
"に配置します。"

msgid ""
"The left and right VR controllers are then retrieved and assigned to "
"``controller_one`` and ``controller_two`` respectively. Finally, the "
"vignette shader is made invisible by default by setting it's ``visible`` "
"property to ``false``."
msgstr ""
"次に、左右のVRコントローラーが取得され、それぞれ ``controller_one`` と "
"``controller_two`` に割り当てられます。 最後に、ビネットシェーダーは、デフォ"
"ルトで ``visible`` プロパティを ``false`` に設定することで非表示になります。"

msgid ""
"In ``_process`` the code first checks if either ``controller_one`` or "
"``controller_two`` are equal to ``null``. If either node is equal to "
"``null``, then ``return`` is called so nothing happens."
msgstr ""
"``_process`` では、コードはまず ``controller_one`` または ``controller_two`` "
"が ``null`` と等しいかどうかをチェックします。いずれかのノードが ``null`` に"
"等しい場合は、\\ ``return`` が実行されるため、何も起こりません。"

msgid ""
"Then the code checks to see if either of the VR controllers are moving the "
"player using the touchpad/joystick by checking if ``directional_movement`` "
"is equal to ``true`` in ``controller_one`` or ``controller_two``. If either "
"of the VR controllers are moving the player, then the vignette shader makes "
"itself visible by setting it's ``visible`` property to ``true``. If neither "
"VR controller is moving the player, so ``directional_movement`` is ``false`` "
"in both VR controllers, than the vignette shader makes itself invisible by "
"setting it's ``visible`` property to ``false``."
msgstr ""
"次に、コードは、\\ ``controller_one`` または ``controller_two`` で "
"``directional_movement`` が ``true`` に等しいかどうかを確認することにより、VR"
"コントローラーのいずれかがタッチパッド/ジョイスティックを使用してプレイヤーを"
"動かしているかどうかを確認します。どちらかのVRコントローラーがプレイヤーを動"
"かしている場合、ビネットシェーダーは ``visible`` プロパティを ``true`` に設定"
"することで自身を可視にします。 どちらのVRコントローラーもプレイヤーを動かして"
"いないので、両方のVRコントローラーで ``directional_movement`` が ``false`` で"
"ある場合は、ビネットシェーダーは、その ``visible`` プロパティを ``false`` に"
"設定することで自身を非表示にします。"

msgid ""
"That is the whole script! Now that we have written the code, go ahead and "
"try moving around with the trackpad and/or joystick. You should find that it "
"is less motion sickness-inducing then before!"
msgstr ""
"これがスクリプトの全てです！ コードを作成したので、トラックパッドやジョイス"
"ティックで動いてみましょう。 以前よりも乗り物酔いが少ないことに気付くはずで"
"す！"

#, fuzzy
msgid ""
"As previously mentioned, there are plenty of ways to reduce motion sickness "
"in VR. Check out `this page on the Oculus Developer Center <https://"
"developer.oculus.com/design/latest/concepts/bp-locomotion/>`__ for more "
"information on how to implement locomotion and reducing motion sickness."
msgstr ""
"前述のように、VRで乗り物酔いを軽減する方法はたくさんあります。 移動を実装し、"
"乗り物酔いを軽減する方法の詳細については、\\ ``Oculus Developer Center "
"<https://developer.oculus.com/design/latest/concepts/bp-locomotion/>`_ の「こ"
"の件に関するページ」をご覧ください。"

msgid "Final notes"
msgstr "最終ノート"

msgid ""
"Now you have fully working VR controllers that can move around the "
"environment and interact with :ref:`RigidBody <class_RigidBody>`-based "
"objects. In the next part of this tutorial series, we will be creating some "
"special :ref:`RigidBody <class_RigidBody>`-based objects for the player to "
"use!"
msgstr ""
"これで、環境内を移動して :ref:`RigidBody <class_RigidBody>` ベースのオブジェ"
"クトとやり取りできる完全に機能するVRコントローラーが完成しました。このチュー"
"トリアルシリーズの次のパートでは、プレイヤーが使用する特別な :ref:`RigidBody "
"<class_RigidBody>` ベースのオブジェクトを作成します！"

msgid ""
"You can download the finished project for this tutorial series on the Godot "
"OpenVR GitHub repository, under the releases tab!"
msgstr ""
"このチュートリアルシリーズの完成したプロジェクトは、リリースタブの下のGodot "
"OpenVR GitHubリポジトリからダウンロードできます！"

msgid "Translation status"
msgstr "翻訳ステータス"
