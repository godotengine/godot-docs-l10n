# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 16:09+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom drawing in 2D"
msgstr "2Dカスタム描画"

msgid "Introduction"
msgstr "はじめに"

msgid ""
"Godot has nodes to draw sprites, polygons, particles, and all sorts of "
"stuff. For most cases, this is enough; but not always. Before crying in "
"fear, angst, and rage because a node to draw that specific *something* does "
"not exist... it would be good to know that it is possible to easily make any "
"2D node (be it :ref:`Control <class_Control>` or :ref:`Node2D "
"<class_Node2D>` based) draw custom commands. It is *really* easy to do it, "
"too."
msgstr ""
"Godotには、スプライト、ポリゴン、パーティクル、あらゆる種類のものを描画する"
"ノードがあります。ほとんどの場合、これで十分です。しかしそれがすべてではあり"
"ません。その特定の *何か* を描画するノードが存在しないため、恐怖、不安、怒り"
"で泣く前に...簡単に任意の2Dノード(\\ :ref:`Control <class_Control>` または :"
"ref:`Node2D <class_Node2D>` ベース)を作成できることを知っておくとよいでしょ"
"う。そして、作成したノードでカスタムコマンドを描画します。それも *本当に* 簡"
"単に行えます。"

#, fuzzy
msgid ""
"Custom drawing in a 2D node is *really* useful. Here are some use cases:"
msgstr ""
"ノードのカスタム描画は*非常に*便利です。次に、その理由の例をいくつか示します:"

#, fuzzy
msgid ""
"Drawing shapes or logic that existing nodes can't do, such as an image with "
"trails or a special animated polygon."
msgstr ""
"ノードによって処理されない図形またはロジックを描画する(例:円、軌跡のあるイ"
"メージ、特殊なアニメートされたポリゴンなどを描画するノードの作成など)。"

msgid ""
"Visualizations that are not that compatible with nodes, such as a tetris "
"board. (The tetris example uses a custom draw function to draw the blocks.)"
msgstr ""
"ノードと互換性のない視覚化、例えばテトリスボード等。 (テトリスの例では、カス"
"タム描画関数を使用してブロックを描画します。)"

#, fuzzy
msgid ""
"Drawing a large number of simple objects. Custom drawing avoids the overhead "
"of using a large number of nodes, possibly lowering memory usage and "
"improving performance."
msgstr ""
"多数の単純なオブジェクトの描画。カスタム描画により、ノードの使用によるオー"
"バーヘッドが回避されるため、メモリの所費を減らし、潜在的に高速化します。"

#, fuzzy
msgid ""
"Making a custom UI control. There are plenty of controls available, but when "
"you have unusual needs, you will likely need a custom control."
msgstr ""
"カスタムUIコントロールの作成。利用できるコントロールはたくさんありますが、新"
"しいカスタムコントロールを作るのも難しくはありません。"

msgid "Drawing"
msgstr "描画"

msgid ""
"Add a script to any :ref:`CanvasItem <class_CanvasItem>` derived node, like :"
"ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`. Then override "
"the ``_draw()`` function."
msgstr ""
":ref:`Control <class_Control>` や :ref:`Node2D <class_Node2D>` のような :ref:"
"`CanvasItem <class_CanvasItem>` から派生したノードにスクリプトを追加します。"
"次に ``_draw()`` 関数をオーバーライドします。"

msgid ""
"Draw commands are described in the :ref:`CanvasItem <class_CanvasItem>` "
"class reference. There are plenty of them."
msgstr ""
"描画のコマンドについては、 \\ :ref:`CanvasItem <class_CanvasItem>` クラスリ"
"ファレンスを参照してください。たくさんあります。"

msgid "Updating"
msgstr "描画の更新"

msgid ""
"The ``_draw()`` function is only called once, and then the draw commands are "
"cached and remembered, so further calls are unnecessary."
msgstr ""
"``_draw()`` 関数は一度だけ呼び出され、その後は描画コマンドがキャッシュされて"
"記憶されるため、それ以上の呼び出しは不要です。"

#, fuzzy
msgid ""
"If re-drawing is required because a state or something else changed, call :"
"ref:`CanvasItem.update() <class_CanvasItem_method_update>` in that same node "
"and a new ``_draw()`` call will happen."
msgstr ""
"状態やその他の変更が原因で再描画が必要な場合は、同じノードで :ref:"
"`CanvasItem.update() <class_CanvasItem_method_update>` を呼び出すだけで、新し"
"い ``_draw()`` の呼び出しが行われます。"

msgid ""
"Here is a little more complex example, a texture variable that will be "
"redrawn if modified:"
msgstr ""
"次に、もう少し複雑な例を示します。テクスチャ変数を変更すると再描画されます:"

msgid ""
"In some cases, it may be desired to draw every frame. For this, just call "
"``update()`` from the ``_process()`` callback, like this:"
msgstr ""
"場合によっては、すべてのフレームを描画することが望ましい場合があります。この"
"ためには、次のように ``_process()`` コールバックから ``update()`` を呼び出す"
"だけです:"

msgid "An example: drawing circular arcs"
msgstr "例:円弧の描画"

msgid ""
"We will now use the custom drawing functionality of the Godot Engine to draw "
"something that Godot doesn't provide functions for. As an example, Godot "
"provides a ``draw_circle()`` function that draws a whole circle. However, "
"what about drawing a portion of a circle? You will have to code a function "
"to perform this and draw it yourself."
msgstr ""
"次に、Godotエンジンのカスタム描画機能を使用して、Godotが機能を提供しないもの"
"を描画します。たとえば、Godotには円全体を描画する ``draw_circle()`` 関数が用"
"意されています。しかし、円の一部を描くのはどうでしょうか？自分でこれを実行し"
"て描画をするには、関数をコーディングする必要があります。"

msgid "Arc function"
msgstr "Arc関数"

msgid ""
"An arc is defined by its support circle parameters, that is, the center "
"position and the radius. The arc itself is then defined by the angle it "
"starts from and the angle at which it stops. These are the 4 arguments that "
"we have to provide to our drawing function. We'll also provide the color "
"value, so we can draw the arc in different colors if we wish."
msgstr ""
"円弧は、サポート円パラメーター、つまり中心位置と半径によって定義されます。円"
"弧自体は、開始角度と停止角度によって定義されます。これらは、描画関数に提供す"
"る必要がある4つの引数です。また、色の値も提供するため、必要に応じて異なる色で"
"弧を描くことができます。"

#, fuzzy
msgid ""
"Basically, drawing a shape on the screen requires it to be decomposed into a "
"certain number of points linked from one to the next. As you can imagine, "
"the more points your shape is made of, the smoother it will appear, but the "
"heavier it will also be in terms of processing cost. In general, if your "
"shape is huge (or in 3D, close to the camera), it will require more points "
"to be drawn without it being angular-looking. On the contrary, if your shape "
"is small (or in 3D, far from the camera), you may decrease its number of "
"points to save processing costs; this is known as *Level of Detail (LOD)*. "
"In our example, we will simply use a fixed number of points, no matter the "
"radius."
msgstr ""
"基本的に、画面上に図形を描画するには、図形を1つのポイントから次のポイントにリ"
"ンクする特定の数のポイントに分解する必要があります。想像できるように、シェイ"
"プのポイントが多いほど、より滑らかに表示されますが、処理コストの観点から見る"
"と重くなります。一般に、形状が巨大な場合(または3Dでカメラに近い場合)、角ばっ"
"た場所を作らないために描画するポイントを増やす必要があります。反対に、形状が"
"小さい場合(またはカメラから遠く離れた3Dの場合)、処理コストを節約するためにポ"
"イント数を減らすことができます。これは *Level of Detail(LoD)* として知られて"
"います。この例では、半径に関係なく、固定数のポイントを使用します。"

msgid ""
"Remember the number of points our shape has to be decomposed into? We fixed "
"this number in the ``nb_points`` variable to a value of ``32``. Then, we "
"initialize an empty ``PoolVector2Array``, which is simply an array of "
"``Vector2``\\ s."
msgstr ""
"形状を分解する必要があるポイントの数を覚えていますか？ ``nb_points`` 変数のこ"
"の数値を ``32`` の値に修正しました。次に、空の ``PoolVector2Array`` を初期化"
"します。これは、単に ``Vector2`` の配列です。"

msgid ""
"The next step consists of computing the actual positions of these 32 points "
"that compose an arc. This is done in the first for-loop: we iterate over the "
"number of points for which we want to compute the positions, plus one to "
"include the last point. We first determine the angle of each point, between "
"the starting and ending angles."
msgstr ""
"次のステップでは、円弧を構成する32個の点の実際の位置を計算します。これは最初"
"のforループで行われ、位置を計算したいポイントの数に最後のポイントを含めるため"
"に1を加えて繰り返します。最初に、開始角度と終了角度の間の各点の角度を決定しま"
"す。"

msgid ""
"The reason why each angle is decreased by 90° is that we will compute 2D "
"positions out of each angle using trigonometry (you know, cosine and sine "
"stuff...). However, to be simple, ``cos()`` and ``sin()`` use radians, not "
"degrees. The angle of 0° (0 radian) starts at 3 o'clock, although we want to "
"start counting at 12 o'clock. So we decrease each angle by 90° in order to "
"start counting from 12 o'clock."
msgstr ""
"各角度が90°減算される理由は、三角関数(コサインとサインなど)を使用して各角度か"
"ら2D位置を計算するためです。ただし、簡単にするために、\\ ``cos()`` および "
"``sin()`` は度ではなくラジアンを使用します。 0°(0ラジアン)の角度は3時から始ま"
"りますが、12時からカウントを開始します。したがって、12時からカウントを開始す"
"るために、各角度を90°ずつ減らします。"

msgid ""
"The actual position of a point located on a circle at angle ``angle`` (in "
"radians) is given by ``Vector2(cos(angle), sin(angle))``. Since ``cos()`` "
"and ``sin()`` return values between -1 and 1, the position is located on a "
"circle of radius 1. To have this position on our support circle, which has a "
"radius of ``radius``, we simply need to multiply the position by ``radius``. "
"Finally, we need to position our support circle at the ``center`` position, "
"which is performed by adding it to our ``Vector2`` value. Finally, we insert "
"the point in the ``PoolVector2Array`` which was previously defined."
msgstr ""
"角度 ``angle`` (ラジアン単位)の円上にある点の実際の位置は、\\ "
"``Vector2(cos(angle),sin(angle))`` で与えられます。\\ ``cos()`` および "
"``sin()`` は-1から1の間の値を返すため、点の位置は半径1の円上にあります。目標"
"の半径にするには、単に点の位置に ``radius`` を乗算するだけです。次に、サポー"
"トサークルを ``center`` の位置に配置する必要があります。これは ``Vector2`` の"
"値に``center`` を加算することで実行されます。最後に、以前に定義した "
"``PoolVector2Array`` にポイントを挿入します。"

msgid ""
"Now, we need to actually draw our points. As you can imagine, we will not "
"simply draw our 32 points: we need to draw everything that is between each "
"of them. We could have computed every point ourselves using the previous "
"method, and drew it one by one. But this is too complicated and inefficient "
"(except if explicitly needed), so we simply draw lines between each pair of "
"points. Unless the radius of our support circle is big, the length of each "
"line between a pair of points will never be long enough to see them. If that "
"were to happen, we would simply need to increase the number of points."
msgstr ""
"次に、実際にポイントを描画する必要があります。ご想像のとおり、単純に32ポイン"
"トを描画するのではなく、それぞれの間にあるすべてのものを描画する必要がありま"
"す。前の方法を使用してすべてのポイントを自分で計算し、それを1つずつ描画するこ"
"ともできます。しかし、これはあまりに複雑で非効率的であるため(明示的に必要な場"
"合を除く)、各ポイントのペア間に単純に線を引きます。サポート円の半径が大きくな"
"い限り、1組のポイント間の各線の長さは、それらが個々の直線として見えてしまう長"
"さになることはありません。もしもその場合は、ポイント数を増やすだけで済みま"
"す。"

msgid "Draw the arc on the screen"
msgstr "画面上に円弧を描画する"

msgid ""
"We now have a function that draws stuff on the screen; it is time to call it "
"inside the ``_draw()`` function:"
msgstr ""
"これで、画面上に物を描画する関数ができました。\\ ``_draw()`` 関数内で呼び出し"
"ます:"

msgid "Result:"
msgstr "結果:"

msgid "Arc polygon function"
msgstr "Arc polygon関数"

msgid ""
"We can take this a step further and not only write a function that draws the "
"plain portion of the disc defined by the arc, but also its shape. The method "
"is exactly the same as before, except that we draw a polygon instead of "
"lines:"
msgstr ""
"これをさらに一歩進めて、円弧で定義されたディスクのプレーン部分だけでなく、そ"
"の形状を描画する関数を作成することもできます。この処理は、線の代わりに多角形"
"を描くことを除いて、以前とまったく同じです:"

msgid "Dynamic custom drawing"
msgstr "動的カスタム描画"

msgid ""
"All right, we are now able to draw custom stuff on the screen. However, it "
"is static; let's make this shape turn around the center. The solution to do "
"this is simply to change the angle_from and angle_to values over time. For "
"our example, we will simply increment them by 50. This increment value has "
"to remain constant or else the rotation speed will change accordingly."
msgstr ""
"さて、私たちは今、画面上にカスタムのものを描画できるようになりました。ただ"
"し、動きません。そこで、この図形を中心で回してみましょう。これを行うための解"
"決策は、単にangle_fromとangle_toの値を経時的に変更させることです。この例で"
"は、単純に50ずつインクリメントします。このインクリメント値は一定のままにする"
"必要があります。そうしないと、それに応じて回転速度が変化します。"

msgid ""
"First, we have to make both angle_from and angle_to variables global at the "
"top of our script. Also note that you can store them in other nodes and "
"access them using ``get_node()``."
msgstr ""
"まず、スクリプトの先頭で、angle_from変数とangle_to変数の両方をグローバルにす"
"る必要があります。また、他のノードに保存し、\\ ``get_node()`` を使用してアク"
"セスすることもできます。"

msgid "We make these values change in the _process(delta) function."
msgstr "これらの値は_process(delta)関数で変更します。"

msgid ""
"We also increment our angle_from and angle_to values here. However, we must "
"not forget to ``wrap()`` the resulting values between 0 and 360°! That is, "
"if the angle is 361°, then it is actually 1°. If you don't wrap these "
"values, the script will work correctly, but the angle values will grow "
"bigger and bigger over time until they reach the maximum integer value Godot "
"can manage (``2^31 - 1``). When this happens, Godot may crash or produce "
"unexpected behavior."
msgstr ""
"ここではangle_fromとangle_to値をインクリメントします。ただし、0から360°の間に"
"結果の値を ``wrap()`` することを忘れてはなりません。つまり、角度が361°の場"
"合、実際には1°です。これらの値をラップしない場合、スクリプトは当面は正しく動"
"作しますが、Godot が管理できる最大整数値 (``2^31 - 1``)に達するまで、角度の値"
"は時間の経過と共に大きくなります。この現象を放置すると、Godotがクラッシュした"
"り、予期しない動作が発生する可能性があります。"

msgid ""
"Finally, we must not forget to call the ``update()`` function, which "
"automatically calls ``_draw()``. This way, you can control when you want to "
"refresh the frame."
msgstr ""
"最後に、自動的に ``_draw()`` を呼び出す ``update()`` 関数を呼び出すことを忘れ"
"てはなりません。これにより、フレームを更新するタイミングを制御できます。"

msgid ""
"Also, don't forget to modify the ``_draw()`` function to make use of these "
"variables:"
msgstr ""
"また、これらの変数を利用するために ``_draw()`` 関数を変更することを忘れないで"
"ください:"

msgid ""
"Let's run! It works, but the arc is rotating insanely fast! What's wrong?"
msgstr ""
"実行しましょう！動作はしますが、アークがものすごい速さで回転しています！何故"
"でしょうか？"

msgid ""
"The reason is that your GPU is actually displaying the frames as fast as it "
"can. We need to \"normalize\" the drawing by this speed; to achieve that, we "
"have to make use of the ``delta`` parameter of the ``_process()`` function. "
"``delta`` contains the time elapsed between the two last rendered frames. It "
"is generally small (about 0.0003 seconds, but this depends on your "
"hardware), so using ``delta`` to control your drawing ensures that your "
"program runs at the same speed on everybody's hardware."
msgstr ""
"その理由は、GPUが実際にできるだけ速くフレームを表示しているからです。この速度"
"で図面を「正規化」する必要があります。そのためには、\\ ``_process()`` 関数の "
"``delta`` パラメーターを利用する必要があります。\\ ``delta`` には、最後にレン"
"ダリングされた2つのフレーム間の経過時間が含まれます。通常は小さい(約0.0003秒"
"ですが、これはハードウェアによって異なります)ため、\\ ``delta`` を使用して描"
"画を制御すると、プログラムがすべてのハードウェアで同じ速度で実行されます。"

msgid ""
"In our case, we simply need to multiply our ``rotation_angle`` variable by "
"``delta`` in the ``_process()`` function. This way, our 2 angles will be "
"increased by a much smaller value, which directly depends on the rendering "
"speed."
msgstr ""
"この場合、単に ``_process()`` 関数で ``rotation_angle`` 変数に ``delta`` を乗"
"算するだけです。このように、2つの角度は、レンダリング速度に直接依存する非常に"
"小さな値で増加します。"

msgid "Let's run again! This time, the rotation displays fine!"
msgstr "もう一度実行しましょう！今度は、回転が正常に表示されます！"

#, fuzzy
msgid "Antialiased drawing"
msgstr "**アンチエイリアシング:**"

msgid ""
"Godot offers method parameters in :ref:"
"`draw_line<class_CanvasItem_method_draw_line>` to enable antialiasing, but "
"it doesn't work reliably in all situations (for instance, on mobile/web "
"platforms, or when HDR is enabled). There is also no ``antialiased`` "
"parameter available in :ref:"
"`draw_polygon<class_CanvasItem_method_draw_polygon>`."
msgstr ""

msgid ""
"As a workaround, install and use the `Antialiased Line2D add-on <https://"
"github.com/godot-extended-libraries/godot-antialiased-line2d>`__ (which also "
"supports antialiased Polygon2D drawing). Note that this add-on relies on "
"high-level nodes, rather than low-level ``_draw()`` functions."
msgstr ""

msgid "Tools"
msgstr "ツール"

#, fuzzy
msgid ""
"Drawing your own nodes might also be desired while running them in the "
"editor. This can be used as a preview or visualization of some feature or "
"behavior. See :ref:`doc_running_code_in_the_editor` for more information."
msgstr ""
"エディタでノードを実行しているときに独自のノードを描画して、いくつかの機能ま"
"たは動作のプレビューまたは視覚化として使用することもできます。"

msgid "Translation status"
msgstr "翻訳ステータス"
